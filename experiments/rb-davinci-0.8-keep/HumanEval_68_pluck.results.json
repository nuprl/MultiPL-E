{
  "language": "rb",
  "name": "HumanEval_68_pluck",
  "results": [
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.select(&:even?)\n  evens.size.zero? ? [] : [evens.min, arr.index(evens.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmphhfn_4dd\nStarted\n.\nFinished in 0.000447044 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2236.92 tests/s, 17895.33 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.find_index { |x| x.even? }.nil? ? [] : [arr.min, arr.find_index(arr.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpe2grmyae\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpe2grmyae.rb:34:in `test_pluck'\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n     33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n  => 34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     37:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n<[2, 1]> expected but was\n<[1, 0]>\n\ndiff:\n? [2, 1]\n?  1  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.009414086 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n106.22 tests/s, 212.45 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.min_by { |x| x.even? ? x : Float::INFINITY }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpaylqlwj1\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpaylqlwj1.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<2>\n\ndiff:\n? [2, 1]\n===============================================================================\n\nFinished in 0.007097525 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n140.89 tests/s, 140.89 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  raise 'Not Implemented'\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmptz91v6pn\nStarted\nE\n===============================================================================\nError: test_pluck(TestHumanEval): RuntimeError: Not Implemented\n/tmp/tmptz91v6pn.rb:27:in `pluck'\n/tmp/tmptz91v6pn.rb:33:in `call'\n/tmp/tmptz91v6pn.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n===============================================================================\n\nFinished in 0.001183371 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n845.04 tests/s, 0.00 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  min_even_value = nil\n  min_even_index = nil\n  arr.each_with_index do |n, i|\n    next if n.odd?\n    if min_even_value.nil? || n < min_even_value\n      min_even_value = n\n      min_even_index = i\n    end\n  end\n  min_even_value ? [min_even_value, min_even_index] : []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp5dxtdymx\nStarted\n.\nFinished in 0.000498349 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2006.63 tests/s, 16053.01 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n\treturn [] if arr.empty?\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfmqtbm3h.rb:29: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpfmqtbm3h.rb:41: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = arr.select { |x| x % 2 == 0 }\n  return [] if evens.empty?\n  [evens.min, arr.index(evens.min)]\nend\nputs pluck([5, 0, 3, 0, 4, 2])\nputs pluck([0, 1, 2, 3, 4, 5])\nputs pluck([1, 2, 3])\nputs pluck([4, 2, 3])\nputs pluck([])\nputs pluck([-1, -2, -3])\nputs pluck([2, 1, 3])\nputs pluck([1, 1, 1])\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "0\n1\n0\n0\n2\n1\n2\n1\n-2\n1\n2\n0\nLoaded suite /tmp/tmp59a6hede\nStarted\n.\nFinished in 0.000966391 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1034.78 tests/s, 8278.22 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  idx = arr.each_with_index.min_by{|e,i| [e&1, e, i]}.last\n  return [] if idx.nil?\n  [arr[idx], idx]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpxq2q4xbg\nStarted\nE\n===============================================================================\nError: test_pluck(TestHumanEval):\n  NoMethodError: undefined method `last' for nil:NilClass\n  \n    idx = arr.each_with_index.min_by{|e,i| [e&1, e, i]}.last\n                                                       ^^^^^\n/tmp/tmpxq2q4xbg.rb:27:in `pluck'\n/tmp/tmpxq2q4xbg.rb:37:in `call'\n/tmp/tmpxq2q4xbg.rb:37:in `test_pluck'\n     34:     candidate = method(:pluck)\n     35:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n  => 37:     assert_equal([], candidate.call([]))\n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     39:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     40:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n===============================================================================\n\nFinished in 0.00292154 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n342.29 tests/s, 684.57 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.length == 0\n    even = arr.select{|x| x.even?}\n    return [] if even.length == 0\n    return [even.min, arr.index(even.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpih83yof6\nStarted\n.\nFinished in 0.000498498 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2006.03 tests/s, 16048.21 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  even_arr = arr.select{|x| x % 2 == 0}\n  even_arr.empty? ? [] : [even_arr.min, arr.index(even_arr.min)]\nend\nputs \"expect [2, 1]: #{pluck([4,2,3])}\"\nputs \"expect [2, 1]: #{pluck([1,2,3])}\"\nputs \"expect []: #{pluck([])}\"\nputs \"expect [0, 1]: #{pluck([5, 0, 3, 0, 4, 2])}\"\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "expect [2, 1]: [2, 1]\nexpect [2, 1]: [2, 1]\nexpect []: []\nexpect [0, 1]: [0, 1]\nLoaded suite /tmp/tmprd3w2v9w\nStarted\n.\nFinished in 0.000508812 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1965.36 tests/s, 15722.90 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = []\n  arr.each_with_index { |n, i| evens << [n, i] if n.even? }\n  return [] if evens.empty?\n  evens.sort_by { |n, i| [n, i] }.first\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp0qpvs2_g\nStarted\n.\nFinished in 0.000495895 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2016.56 tests/s, 16132.45 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp2aulsn42\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp2aulsn42.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.007079618 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n141.25 tests/s, 141.25 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  even_values = []\n  even_values = arr.each_with_index.select{|value, index| value.even?}.sort_by{|value, index| value}\n  if even_values.empty?\n    []\n  else\n    even_values[0]\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp5safqsvj\nStarted\n.\nFinished in 0.000516803 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1934.97 tests/s, 15479.79 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  ans = []\n  arr.each_with_index do |x,i|\n    if x % 2 == 0\n      if ans.empty?\n        ans << [x,i]\n      else\n        if x < ans[0][0]\n          ans = [[x,i]]\n        elsif x == ans[0][0]\n          ans << [x,i]\n        end\n      end\n    end\n  end\n  ans.sort_by!{|x| x[1]}\n  ans.empty? ? [] : ans[0]\nend\np pluck([4,2,3]) == [2, 1]\np pluck([1,2,3]) == [2, 1]\np pluck([]) == []\np pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "true\ntrue\ntrue\ntrue\nLoaded suite /tmp/tmp9u2md33o\nStarted\n.\nFinished in 0.000563708 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1773.97 tests/s, 14191.74 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp2aulsn42\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp2aulsn42.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.007079618 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n141.25 tests/s, 141.25 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index.select{|v, i| v.even?}.min_by{|a| [a[0], a[1]]}\nend\np pluck([4,2,3]) == [2, 1]\np pluck([1,2,3]) == [2, 1]\np pluck([]) == []\np pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "true\ntrue\nfalse\ntrue\nLoaded suite /tmp/tmppo_202a6\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmppo_202a6.rb:39:in `test_pluck'\n     36:     candidate = method(:pluck)\n     37:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     38:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n  => 39:     assert_equal([], candidate.call([]))\n     40:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     41:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     42:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n<[]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.006845981 seconds.\n-------------------------------------------------------------------------------\n1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n146.07 tests/s, 438.21 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  smallest_index = 0\n  smallest_value = nil\n  (0...arr.length).each do |index|\n    value = arr[index]\n    next if value.odd?\n    if smallest_value.nil? || value < smallest_value\n      smallest_value = value\n      smallest_index = index\n    end\n  end\n  smallest_value.nil? ? [] : [smallest_value, smallest_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp2o0csmq8\nStarted\n.\nFinished in 0.000501181 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1995.29 tests/s, 15962.30 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  plucked = []\n  arr.each_with_index { |n, i| plucked = [n, i] if n.even? && (plucked.empty? || n < plucked[0]) }\n  plucked\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp0ea3shcl\nStarted\n.\nFinished in 0.000514629 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1943.15 tests/s, 15545.18 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    arr.select { |e| e % 2 == 0 }.sort.first\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpz0ta5_vy\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpz0ta5_vy.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<2>\n\ndiff:\n? [2, 1]\n===============================================================================\n\nFinished in 0.006771113 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n147.69 tests/s, 147.69 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = arr.select(&:even?)\n  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmps6i2yd36\nStarted\n.\nFinished in 0.000523427 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1910.49 tests/s, 15283.89 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp2aulsn42\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp2aulsn42.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.007079618 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n141.25 tests/s, 141.25 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    smallest = 2 ** 32\n    smallest_index = nil\n    arr.each_with_index do |val, i|\n        if val % 2 == 0 && val < smallest\n            smallest = val\n            smallest_index = i\n        end\n    end\n    smallest_index == nil ? [] : [smallest, smallest_index]\nend\nputs \"Expected: [2, 1], Actual: #{pluck([4,2,3])}\"\nputs \"Expected: [2, 1], Actual: #{pluck([1,2,3])}\"\nputs \"Expected: [], Actual: #{pluck([])}\"\nputs \"Expected: [0, 1], Actual: #{pluck([5, 0, 3, 0, 4, 2])}\"\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Expected: [2, 1], Actual: [2, 1]\nExpected: [2, 1], Actual: [2, 1]\nExpected: [], Actual: []\nExpected: [0, 1], Actual: [0, 1]\nLoaded suite /tmp/tmpit1p7tpy\nStarted\n.\nFinished in 0.000458092 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2182.97 tests/s, 17463.74 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.length < 1\n    ans = []\n    evens = []\n    for i in 0...arr.length\n        if arr[i] % 2 == 0\n            evens.push(arr[i])\n        end\n    end\n    if evens.length < 1\n        return []\n    end\n    evens.sort!\n    for i in 0...arr.length\n        if arr[i] == evens[0]\n            ans.push(arr[i])\n            ans.push(i)\n            return ans\n        end\n    end\nend\nputs pluck([4,2,3]) == [2, 1]\nputs pluck([1,2,3]) == [2, 1]\nputs pluck([]) == []\nputs pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\nputs pluck([1, 4, 6, 5, 7, 8, 4, 5, 4, 3, 2, 5, 6, 3, 2, 5, 7, 8, 4, 5, 7, 8, 4, 6, 7, 8, 6, 5, 7, 3, 2, 5, 7, 3, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2,\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpc6k0d59h.rb:52: syntax error, unexpected string literal, expecting `do' or '{' or '('\nrequire 'test/unit'\n        ^\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  small = nil\n  index = nil\n  arr.each_with_index do |num,i|\n    next if num % 2 != 0\n    if small.nil? || num < small\n      small = num\n      index = i\n    end\n  end\n  if small.nil?\n    []\n  else\n    [small,index]\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp7ki2xndb\nStarted\n.\nFinished in 0.000495783 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2017.01 tests/s, 16136.09 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = []\n  arr.each_with_index { |e, i| evens << [e, i] if e.even? }\n  evens.sort_by(&:first).first\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpxyvx4ct5\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpxyvx4ct5.rb:37:in `test_pluck'\n     34:     candidate = method(:pluck)\n     35:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n  => 37:     assert_equal([], candidate.call([]))\n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     39:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     40:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n<[]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.00687127 seconds.\n-------------------------------------------------------------------------------\n1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n145.53 tests/s, 436.60 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\nend\nputs \"Pluck: Given an array representing a branch of a tree that has non-negative integer nodes\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnv5q_ujc.rb:42: unterminated string meets end of file\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  even_indexes = []\n  arr.each_with_index { |v, i| even_indexes << i if v.even? }\n  return [] if even_indexes.empty?\n  res = even_indexes.map { |i| [arr[i], i] }.min_by { |v, i| v }\n  res\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpn1f9hhrl\nStarted\n.\nFinished in 0.000736041 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1358.62 tests/s, 10868.96 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  min = nil\n  min_index = nil\n  arr.each_with_index do |val, index|\n    if val.even?\n      if min == nil || val < min\n        min = val\n        min_index = index\n      end\n    end\n  end\n  return [] if min == nil\n  [min, min_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpqzybqchx\nStarted\n.\nFinished in 0.000465017 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2150.46 tests/s, 17203.67 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp2aulsn42\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp2aulsn42.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.007079618 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n141.25 tests/s, 141.25 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.empty?\n    even = arr.find_all{|x| x % 2 == 0}\n    return [] if even.empty?\n    idx = arr.index(even.min)\n    [even.min, idx]\nend\nputs \"Expected: [2, 1], Actual: #{pluck([4,2,3])}\"\nputs \"Expected: [2, 1], Actual: #{pluck([1,2,3])}\"\nputs \"Expected: [], Actual: #{pluck([])}\"\nputs \"Expected: [0, 1], Actual: #{pluck([5, 0, 3, 0, 4, 2])}\"\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Expected: [2, 1], Actual: [2, 1]\nExpected: [2, 1], Actual: [2, 1]\nExpected: [], Actual: []\nExpected: [0, 1], Actual: [0, 1]\nLoaded suite /tmp/tmpwi2f4qup\nStarted\n.\nFinished in 0.00045573 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2194.28 tests/s, 17554.25 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.map.with_index { |e, i| [e, i] if e.even? }.compact.min || []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpogw7atn1\nStarted\n.\nFinished in 0.000476343 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2099.33 tests/s, 16794.62 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  smallest = arr.map(&:to_i).select(&:even?).min\n  smallest.nil? ? [] : [smallest, arr.index(smallest.to_s)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpoctf4m9j\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpoctf4m9j.rb:35:in `test_pluck'\n     32: class TestHumanEval < Test::Unit::TestCase\n     33:   def test_pluck\n     34:     candidate = method(:pluck)\n  => 35:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     37:     assert_equal([], candidate.call([]))\n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[2, nil]>\n\ndiff:\n? [2, 1  ]\n?     nil \n?     ? \n===============================================================================\n\nFinished in 0.011020091 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n90.74 tests/s, 90.74 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |v, i|\n    return [v, i] if v.even?\n  end\n  []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpq7z51md2\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpq7z51md2.rb:36:in `test_pluck'\n     33: class TestHumanEval < Test::Unit::TestCase\n     34:   def test_pluck\n     35:     candidate = method(:pluck)\n  => 36:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     38:     assert_equal([], candidate.call([]))\n     39:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[4, 0]>\n\ndiff:\n? [2, 1]\n?  4  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.007469288 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n133.88 tests/s, 133.88 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.select { |node| node.even? }\n  return [] if evens.empty?\n  smallest = evens.min\n  [smallest, arr.index(smallest)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpsc04vpdg\nStarted\n.\nFinished in 0.000482406 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2072.94 tests/s, 16583.54 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = arr.select { |e| e.even? }\n  return [] if evens.empty?\n  evens.min.to_s\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmppyagcujx\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmppyagcujx.rb:36:in `test_pluck'\n     33: class TestHumanEval < Test::Unit::TestCase\n     34:   def test_pluck\n     35:     candidate = method(:pluck)\n  => 36:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     38:     assert_equal([], candidate.call([]))\n     39:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<\"2\">\n\ndiff:\n? [2, 1]\n? \" \"   \n? ? ????   \n===============================================================================\n\nFinished in 0.006893832 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n145.06 tests/s, 145.06 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = []\n  arr.each_with_index do |n,i|\n    evens << [n,i] if n.even?\n  end\n  evens.min_by { |a| a[0] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpmow25mg8\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpmow25mg8.rb:45:in `test_pluck'\n     42:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     43:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n     44:     assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n  => 45:     assert_equal([], candidate.call([7, 9, 7, 1]))\n     46:   end\n     47: end\n<[]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.006944381 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n144.00 tests/s, 1152.01 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  result = []\n  even_arr = arr.select { |e| e.even? }\n  return [] if even_arr.empty?\n  even_arr.sort!\n  small_even = even_arr[0]\n  result << small_even\n  result << arr.index(small_even)\n  result\nend\nputs \"Expected: [2, 1]\"\nputs \"Output: #{pluck([4,2,3])}\"\nputs \"Expected: [2, 1]\"\nputs \"Output: #{pluck([1,2,3])}\"\nputs \"Expected: []\"\nputs \"Output: #{pluck([])}\"\nputs \"Expected: [0, 1]\"\nputs \"Output: #{pluck([5, 0, 3, 0, 4, 2])}\"\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Expected: [2, 1]\nOutput: [2, 1]\nExpected: [2, 1]\nOutput: [2, 1]\nExpected: []\nOutput: []\nExpected: [0, 1]\nOutput: [0, 1]\nLoaded suite /tmp/tmplywu98cm\nStarted\n.\nFinished in 0.000491876 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2033.03 tests/s, 16264.26 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  even_nums = []\n  i = 0\n  while i < arr.length\n    if arr[i] % 2 == 0\n      even_nums << [arr[i], i]\n    end\n    i += 1\n  end\n  return [] if even_nums.empty?\n  result = even_nums[0]\n  i = 1\n  while i < even_nums.length\n    if even_nums[i][0] < result[0]\n      result = even_nums[i]\n    end\n    i += 1\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmplx7e6yc0\nStarted\n.\nFinished in 0.000499135 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2003.47 tests/s, 16027.73 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  e = arr.select { |e| e.even? }\n  return [] if e.empty?\n  e.sort!\n  e.unshift(arr.index(e.first))\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpu3nqq2a_\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpu3nqq2a_.rb:36:in `test_pluck'\n     33: class TestHumanEval < Test::Unit::TestCase\n     34:   def test_pluck\n     35:     candidate = method(:pluck)\n  => 36:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     38:     assert_equal([], candidate.call([]))\n     39:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[1, 2, 4]>\n\ndiff:\n? [   2, 1]\n?  1,    4 \n?  +++   ? \n===============================================================================\n\nFinished in 0.007151546 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n139.83 tests/s, 139.83 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  if arr.length == 0\n    return []\n  end\n  even = []\n  i = 0\n  while i < arr.length\n    if arr[i] % 2 == 0\n      even.push([arr[i], i])\n    end\n    i += 1\n  end\n  return [] if even.length == 0\n  even.sort! { |a, b| a[0] <=> b[0] }\n  even[0]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp8xrouxf6\nStarted\n.\nFinished in 0.000497704 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2009.23 tests/s, 16073.81 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp2aulsn42\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp2aulsn42.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.007079618 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n141.25 tests/s, 141.25 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  if arr.empty?\n    return []\n  end\n  even_count = 0\n  nodes = []\n  arr.each_with_index do |val, idx|\n    if val.even?\n      even_count += 1\n      nodes << [val, idx]\n    end\n  end\n  if even_count == 0\n    return []\n  end\n  nodes.sort_by { |val, idx| [val, idx] }.first\nend\nputs \"Problem 2: #{pluck([5, 0, 3, 0, 4, 2])}\"\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Problem 2: [0, 1]\nLoaded suite /tmp/tmpg28ailkn\nStarted\n.\nFinished in 0.000540166 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1851.28 tests/s, 14810.26 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = []\n  arr.each_with_index { |x, i| evens << [x, i] if x.even? }\n  evens.empty? ? [] : evens.min\nend\np pluck([4,2,3]) # [2, 1]\np pluck([1,2,3]) # [2, 1]\np pluck([]) # []\np pluck([5, 0, 3, 0, 4, 2]) # [0, 1]\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "[2, 1]\n[2, 1]\n[]\n[0, 1]\nLoaded suite /tmp/tmpe_haz954\nStarted\n.\nFinished in 0.000451924 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2212.76 tests/s, 17702.09 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.map.with_index{|v,i| [v,i] if v.even?}.compact.min_by{|x| x[0]} || []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpoph2rrb2\nStarted\n.\nFinished in 0.000463872 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2155.77 tests/s, 17246.14 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = []\n  arr.each_with_index { |v, i| evens << [v, i] if v.even? }\n  evens.min_by { |v, i| v } || []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpy2f4dka3\nStarted\n.\nFinished in 0.000471044 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2122.94 tests/s, 16983.55 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = arr.select { |e| e.even? }\n  return [] if evens.empty?\n  [evens.min, arr.index(evens.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp5q0mf7k8\nStarted\n.\nFinished in 0.000456867 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2188.82 tests/s, 17510.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    smallest = nil\n    smallest_i = nil\n    arr.each_with_index do |x,i|\n        if (x % 2 == 0)\n            if !smallest || x < smallest\n                smallest = x\n                smallest_i = i\n            end\n        end\n    end\n    return [] if smallest.nil?\n    [smallest, smallest_i]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpdf9ho_0q\nStarted\n.\nFinished in 0.00046466 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2152.11 tests/s, 17216.89 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.select(&:even?).min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpef11jvqn\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpef11jvqn.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<2>\n\ndiff:\n? [2, 1]\n===============================================================================\n\nFinished in 0.010255173 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n97.51 tests/s, 97.51 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    odd_arr = []\n    even_arr = []\n    arr.each_with_index do |el, idx|\n        el.even? ? even_arr << [el, idx] : odd_arr << [el, idx]\n    end\n    even_arr.sort[0] || []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpt0a6ebmz\nStarted\n.\nFinished in 0.000524729 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1905.75 tests/s, 15245.97 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.empty?\n    curr_min = -1;\n    idx = nil;\n    arr.each_with_index { |x, i|\n        next if x%2 == 1\n        if curr_min == -1\n            curr_min = x\n            idx = i\n        elsif x < curr_min\n            curr_min = x\n            idx = i\n        end\n    }\n    return [] if curr_min == -1\n    return [curr_min, idx]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprbq3rnt0\nStarted\n.\nFinished in 0.000440417 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2270.58 tests/s, 18164.60 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |e, i|\n    return [e, i] if e.even?\n  end\n  []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpdnoc5eq9\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpdnoc5eq9.rb:36:in `test_pluck'\n     33: class TestHumanEval < Test::Unit::TestCase\n     34:   def test_pluck\n     35:     candidate = method(:pluck)\n  => 36:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     38:     assert_equal([], candidate.call([]))\n     39:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[4, 0]>\n\ndiff:\n? [2, 1]\n?  4  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.007161917 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n139.63 tests/s, 139.63 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  idx, min = nil, nil\n  arr.each_with_index { |x, i| idx, min = i, x if x % 2 == 0 && (min.nil? || x < min) }\n  idx.nil? ? [] : [min, idx]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp89q2n2q9\nStarted\n.\nFinished in 0.000495957 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2016.30 tests/s, 16130.43 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.select { |x| x.even? }\n  return [] if evens.empty?\n  smallest = evens.min\n  index = arr.index(smallest)\n  [smallest, index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp6q647w77\nStarted\n.\nFinished in 0.000442842 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2258.14 tests/s, 18065.13 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  return [] if arr.all?{|n| n % 2 != 0}\n  evens = arr.select{|n| n % 2 == 0}\n  evens.uniq.sort!\n  inds = evens.map{|n| arr.index(n)}\n  [evens[0], inds[0]]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp716ez0_9\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp716ez0_9.rb:38:in `test_pluck'\n     35: class TestHumanEval < Test::Unit::TestCase\n     36:   def test_pluck\n     37:     candidate = method(:pluck)\n  => 38:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     39:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     40:     assert_equal([], candidate.call([]))\n     41:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[4, 0]>\n\ndiff:\n? [2, 1]\n?  4  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.008598148 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n116.30 tests/s, 116.30 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.min_by.with_index { |v, i| v.even? ? [v, i] : [Float::INFINITY, Float::INFINITY] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpucr5ta0f\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpucr5ta0f.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<2>\n\ndiff:\n? [2, 1]\n===============================================================================\n\nFinished in 0.00712403 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n140.37 tests/s, 140.37 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = arr.select(&:even?)\n  min = evens.min\n  [min, arr.index(min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpotnkdacu\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpotnkdacu.rb:43:in `test_pluck'\n     40:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     41:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n     42:     assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n  => 43:     assert_equal([], candidate.call([7, 9, 7, 1]))\n     44:   end\n     45: end\n<[]> expected but was\n<[nil, nil]>\n\ndiff:\n? [nil, nil]\n===============================================================================\n\nFinished in 0.006891751 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n145.10 tests/s, 1160.81 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  even_values = arr.select { |x| x.even? }\n  return [] if even_values.empty?\n  even_values.each_with_index.min.reverse\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmps77yq3at\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmps77yq3at.rb:35:in `test_pluck'\n     32: class TestHumanEval < Test::Unit::TestCase\n     33:   def test_pluck\n     34:     candidate = method(:pluck)\n  => 35:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     37:     assert_equal([], candidate.call([]))\n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[1, 2]>\n\ndiff:\n? [1, 2, 1]\n===============================================================================\n\nFinished in 0.010488803 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n95.34 tests/s, 95.34 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  min_value = nil\n  min_index = -1\n  arr.each_with_index do |value, index|\n    if value % 2 == 0\n      if min_value.nil? || value < min_value\n        min_value = value\n        min_index = index\n      end\n    end\n  end\n  if min_value.nil?\n    []\n  else\n    [min_value, min_index]\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp69ulcjkw\nStarted\n.\nFinished in 0.000459726 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2175.21 tests/s, 17401.67 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.length == 0\n    even = {}\n    arr.each_with_index { |a,i|\n        even[a] = i if a%2 == 0\n    }\n    return [] if even.length == 0\n    min = even.keys.min\n    return [min, even[min]]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmph4hygjd7\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmph4hygjd7.rb:43:in `test_pluck'\n     40:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     41:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     42:     assert_equal([], candidate.call([]))\n  => 43:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     44:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     45:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n     46:     assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n<[0, 1]> expected but was\n<[0, 3]>\n\ndiff:\n? [0, 1]\n?     3 \n?     ? \n===============================================================================\n\nFinished in 0.007508743 seconds.\n-------------------------------------------------------------------------------\n1 tests, 4 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n133.18 tests/s, 532.71 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp90kopeq4\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp90kopeq4.rb:32:in `test_pluck'\n     29: class TestHumanEval < Test::Unit::TestCase\n     30:   def test_pluck\n     31:     candidate = method(:pluck)\n  => 32:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     33:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     34:     assert_equal([], candidate.call([]))\n     35:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.011015318 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n90.78 tests/s, 90.78 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.sort_by.with_index { |x,i| [x.even? ? 0 : 1, x, i] }.find(&:even?)&.then { |x| [x, arr.index(x)] } || []\nend\np pluck([4,2,3])\np pluck([1,2,3])\np pluck([])\np pluck([5, 0, 3, 0, 4, 2])\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "[2, 1]\n[2, 1]\n[]\n[0, 1]\nLoaded suite /tmp/tmp5u_bufsr\nStarted\n.\nFinished in 0.000534799 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1869.86 tests/s, 14958.89 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    evens = arr.find_all { |n| n % 2 == 0 }\n    return [] if evens.empty?\n    small_even = evens.min\n    return [small_even, arr.index(small_even)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp3y6wefbu\nStarted\n.\nFinished in 0.000448651 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2228.90 tests/s, 17831.23 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  small = nil\n  ind = nil\n  arr.each_with_index do |e, i|\n    if e.even?\n      if small.nil?\n        small = e\n        ind = i\n      elsif e < small\n        small = e\n        ind = i\n      end\n    end\n  end\n  return [] if small.nil?\n  [small, ind]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp_k5grggv\nStarted\n.\nFinished in 0.000452355 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2210.65 tests/s, 17685.23 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |val,idx|\n    return [val,idx] if val % 2 == 0 && (arr.empty? || idx == arr.index(arr.min) && val == arr.min)\n  end\n  []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp577gq8kn\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp577gq8kn.rb:37:in `test_pluck'\n     34:   def test_pluck\n     35:     candidate = method(:pluck)\n     36:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n  => 37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     38:     assert_equal([], candidate.call([]))\n     39:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     40:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n<[2, 1]> expected but was\n<[]>\n\ndiff:\n? [2, 1]\n===============================================================================\n\nFinished in 0.006769563 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n147.72 tests/s, 295.44 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = arr.select { |x| x.even? }\n  return [] if evens.empty?\n  smallest = evens.min\n  index = arr.index(smallest)\n  [smallest, index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp3qyymyze\nStarted\n.\nFinished in 0.000429292 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2329.42 tests/s, 18635.33 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.select { |num| num % 2 == 0 }.sort\n  index = evens.index(evens.first)\n  if evens.empty?\n    []\n  else\n    [evens.first, index]\n  end\nend\np pluck([4,2,3])\np pluck([1,2,3])\np pluck([])\np pluck([5, 0, 3, 0, 4, 2])\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "[2, 0]\n[2, 0]\n[]\n[0, 0]\nLoaded suite /tmp/tmp6kg6inww\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp6kg6inww.rb:43:in `test_pluck'\n     40: class TestHumanEval < Test::Unit::TestCase\n     41:   def test_pluck\n     42:     candidate = method(:pluck)\n  => 43:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     44:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     45:     assert_equal([], candidate.call([]))\n     46:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[2, 0]>\n\ndiff:\n? [2, 1]\n?     0 \n?     ? \n===============================================================================\n\nFinished in 0.007369199 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n135.70 tests/s, 135.70 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.select { |e| e.even? }\n  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp6t5166ji\nStarted\n.\nFinished in 0.000549988 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1818.22 tests/s, 14545.77 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  # Convert to list of (val, idx) pairs.\n  pairs = arr.map.with_index { |val, idx| [val, idx] }\n  # Keep only even values.\n  evens = pairs.select { |val, idx| val.even? }\n  # Sort by value and by index.\n  evens.sort_by! { |val, idx| [val, idx] }\n  # Return first even value, or nil if no even values.\n  return evens.first\nend\nputs \"#{pluck([4,2,3])}\"\nputs \"#{pluck([1,2,3])}\"\nputs \"#{pluck([])}\"\nputs \"#{pluck([5, 0, 3, 0, 4, 2])}\"\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "[2, 1]\n[2, 1]\n\n[0, 1]\nLoaded suite /tmp/tmpn1a9yyqj\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpn1a9yyqj.rb:46:in `test_pluck'\n     43:     candidate = method(:pluck)\n     44:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     45:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n  => 46:     assert_equal([], candidate.call([]))\n     47:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     48:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     49:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n<[]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.006565553 seconds.\n-------------------------------------------------------------------------------\n1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n152.31 tests/s, 456.93 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    #puts \"pluck_1> arg = #{arr}\"\n    return [] if arr.nil? || arr.empty?\n    #puts \"pluck_2> arr = #{arr}\"\n    min_even_val = 2**40\n    min_even_val_idx = -1\n    arr.each_with_index do |item, idx|\n        #puts \"pluck_3> item = #{item}, idx = #{idx}\"\n        min_even_val, min_even_val_idx = item, idx if item % 2 == 0 && item < min_even_val\n    end\n    #puts \"pluck_4> min_even_val = #{min_even_val}, min_even_val_idx = #{min_even_val_idx}\"\n    return min_even_val_idx == -1 ? [] : [min_even_val, min_even_val_idx]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpjbcuh4ez\nStarted\n.\nFinished in 0.000436275 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2292.13 tests/s, 18337.06 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n\tputs(\"arr: #{arr}\")\n\treturn [] if(arr.length == 0)\n\tmin_even_val = nil\n\tmin_even_idx = -1\n\tfor i in 0...arr.length\n\t\tval = arr[i]\n\t\tif((val % 2) == 0)\n\t\t\tif(min_even_val == nil)\n\t\t\t\tmin_even_val = val\n\t\t\t\tmin_even_idx = i\n\t\t\telsif(val < min_even_val)\n\t\t\t\tmin_even_val = val\n\t\t\t\tmin_even_idx = i\n\t\t\tend\n\t\tend\n\tend\n\tif(min_even_val == nil)\n\t\t[]\n\telse\n\t\t[min_even_val, min_even_idx]\n\tend\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp0m8fi2kp\nStarted\narr: [4, 2, 3]\narr: [1, 2, 3]\narr: []\narr: [5, 0, 3, 0, 4, 2]\narr: [1, 2, 3, 0, 5, 3]\narr: [5, 4, 8, 4, 8]\narr: [7, 6, 7, 1]\narr: [7, 9, 7, 1]\n.\nFinished in 0.000876426 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1141.00 tests/s, 9127.98 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  min, min_ind = nil, nil\n  arr.each_with_index do |n, i|\n    if (n % 2).zero?\n      if min.nil? || n < min\n        min = n\n        min_ind = i\n      end\n    end\n  end\n  min.nil? ? [] : [min, min_ind]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpp5_jdl4x\nStarted\n.\nFinished in 0.000463374 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2158.08 tests/s, 17264.67 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.find_all { |node| node.even? }\n  return [] if evens.empty?\n  evens.min <=> evens.max\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp9crybf91\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp9crybf91.rb:35:in `test_pluck'\n     32: class TestHumanEval < Test::Unit::TestCase\n     33:   def test_pluck\n     34:     candidate = method(:pluck)\n  => 35:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     37:     assert_equal([], candidate.call([]))\n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<-1>\n\ndiff:\n? [2, 1]\n? -     \n? ????    -\n===============================================================================\n\nFinished in 0.006707331 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n149.09 tests/s, 149.09 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = arr.select { |n| n.even? }\n  return [] if evens.empty?\n  min = evens.min\n  return [min, arr.index(min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpj50ulomz\nStarted\n.\nFinished in 0.000443791 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2253.31 tests/s, 18026.50 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.nil? || arr.empty?\n  even_values = arr.select { |e| e.even? }\n  return [] if even_values.empty?\n  min_even_value = even_values.min\n  [min_even_value, arr.index(min_even_value)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpxvl922b1\nStarted\n.\nFinished in 0.00045906 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2178.36 tests/s, 17426.92 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    i, j = 0, -1\n    for k in (0...arr.length)\n        if (arr[k] % 2 == 0)\n            if (j == -1)\n                i, j = k, arr[k]\n            elsif (arr[k] < j)\n                i, j = k, arr[k]\n            end\n        end\n    end\n    j == -1 ? [] : [j, i]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp0pz4h200\nStarted\n.\nFinished in 0.000473804 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2110.58 tests/s, 16884.62 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.empty?\n    min = arr.min\n    return [] if min.odd?\n    min = arr.map { |e| e if e.even? }.compact.min\n    return [] if min.nil?\n    min_arr = arr.map.with_index { |e, i| [e, i] if e == min }.compact\n    return min_arr.min { |a, b| a[1] <=> b[1] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzv6mjbka\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpzv6mjbka.rb:40:in `test_pluck'\n     37:   def test_pluck\n     38:     candidate = method(:pluck)\n     39:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n  => 40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     41:     assert_equal([], candidate.call([]))\n     42:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     43:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n<[2, 1]> expected but was\n<[]>\n\ndiff:\n? [2, 1]\n===============================================================================\n\nFinished in 0.007042324 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n142.00 tests/s, 284.00 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n\tmin = arr.find { |x| x % 2 == 0 }\n\treturn [] if min.nil?\n\tres = []\n\tarr.each_with_index { |x, i| res = [x, i] if x == min }\n\tres\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpbjt7lvr9\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpbjt7lvr9.rb:37:in `test_pluck'\n     34: class TestHumanEval < Test::Unit::TestCase\n     35:   def test_pluck\n     36:     candidate = method(:pluck)\n  => 37:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     38:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     39:     assert_equal([], candidate.call([]))\n     40:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[4, 0]>\n\ndiff:\n? [2, 1]\n?  4  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.008468947 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n118.08 tests/s, 118.08 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.empty?\n    if evens = arr.select { |node| node.even? }\n        evens.sort!\n        arr.each_with_index do |node, i|\n            return [node, i] if node == evens[0]\n        end\n    end\n    []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpfms12xfy\nStarted\n.\nFinished in 0.00047586 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2101.46 tests/s, 16811.67 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  # no array, no even numbers\n  return [] if arr.length == 0\n  # iterate over the array and find the even numbers\n  even_numbers = []\n  arr.each_with_index do |num, index|\n    if num % 2 == 0\n      even_numbers << [num, index]\n    end\n  end\n  # select the even number with the smallest value\n  even_numbers.min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpkj3k8pan\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpkj3k8pan.rb:50:in `test_pluck'\n     47:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     48:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n     49:     assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n  => 50:     assert_equal([], candidate.call([7, 9, 7, 1]))\n     51:   end\n     52: end\n<[]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.006543523 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n152.82 tests/s, 1222.58 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    # map!\n    result = []\n    return result if arr.empty?\n    arr.map! { |e| e.even? ? e : -1 }\n    arr.sort!\n    arr.delete_if { |e| e == -1 }\n    return result if arr.empty?\n    smalest_value = arr[0]\n    index = arr.index(smalest_value)\n    result << smalest_value\n    result << index\n    result\nend\nputs pluck([4,2,3])\nputs pluck([1,2,3])\nputs pluck([])\nputs pluck([5, 0, 3, 0, 4, 2])\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "2\n0\n2\n0\n0\n0\nLoaded suite /tmp/tmpjcfainhn\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpjcfainhn.rb:48:in `test_pluck'\n     45: class TestHumanEval < Test::Unit::TestCase\n     46:   def test_pluck\n     47:     candidate = method(:pluck)\n  => 48:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     49:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     50:     assert_equal([], candidate.call([]))\n     51:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[2, 0]>\n\ndiff:\n? [2, 1]\n?     0 \n?     ? \n===============================================================================\n\nFinished in 0.007376126 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n135.57 tests/s, 135.57 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    # return [] if arr.empty?\n    # return [] if arr.select { |e| e.even? }.empty?\n    # return [arr.select { |e| e.even? }.min, arr.index(arr.select { |e| e.even? }.min)]\n    return [] if arr.empty?\n    return [] if arr.select { |e| e.even? }.empty?\n    return [arr.select { |e| e.even? }.min, arr.index(arr.select { |e| e.even? }.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpc3ahpd91\nStarted\n.\nFinished in 0.000457299 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2186.75 tests/s, 17494.02 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.empty?\n    even_arr = arr.select { |x| x.even? }\n    return [] if even_arr.empty?\n    even_arr.map.with_index { |x, idx| [x, idx] }.min_by { |x| x[0] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpi72kr92c\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpi72kr92c.rb:37:in `test_pluck'\n     34:   def test_pluck\n     35:     candidate = method(:pluck)\n     36:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n  => 37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     38:     assert_equal([], candidate.call([]))\n     39:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     40:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n<[2, 1]> expected but was\n<[2, 0]>\n\ndiff:\n? [2, 1]\n?     0 \n?     ? \n===============================================================================\n\nFinished in 0.007329434 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n136.44 tests/s, 272.87 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  min_even = nil\n  min_idx = -1\n  arr.each_with_index do |el, idx|\n    if el.even? && (min_even.nil? || el < min_even)\n      min_even = el\n      min_idx = idx\n    end\n  end\n  min_even.nil? ? [] : [min_even, min_idx]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpqb7wfpvi\nStarted\n.\nFinished in 0.000461981 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2164.59 tests/s, 17316.73 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    i, j = 0, arr.size-1\n    while i <= j\n        return [arr[i], i] if arr[i].even?\n        i += 1\n    end\n    [arr[i], i]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpx8z7xazf\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpx8z7xazf.rb:38:in `test_pluck'\n     35: class TestHumanEval < Test::Unit::TestCase\n     36:   def test_pluck\n     37:     candidate = method(:pluck)\n  => 38:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     39:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     40:     assert_equal([], candidate.call([]))\n     41:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[4, 0]>\n\ndiff:\n? [2, 1]\n?  4  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.006992061 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n143.02 tests/s, 143.02 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmph2e26i02\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmph2e26i02.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.006204714 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n161.17 tests/s, 161.17 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  # ...\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpfjs60pfm\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpfjs60pfm.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.006818644 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n146.66 tests/s, 146.66 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n\treturn [] if !arr || arr.length == 0\n\t\n\tsmallest_value = nil\n\tsmallest_index = nil\n\tfor i in 0...arr.length\n\t\tnext if arr[i] % 2 != 0\n\t\tif !smallest_value || arr[i] < smallest_value\n\t\t\tsmallest_value = arr[i]\n\t\t\tsmallest_index = i\n\t\tend\n\tend\n\treturn [] if !smallest_value\n\t[smallest_value, smallest_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpbnqzmsw9\nStarted\n.\nFinished in 0.000438736 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2279.28 tests/s, 18234.20 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  count = []\n  arr.each_with_index { |node, i|\n    if node.even?\n      count << [node, i]\n    end\n  }\n  count.min.nil? ? [] : count.min\nend\nputs \"Expected: [2, 1] -- Actual: #{pluck([4,2,3])}\"\nputs \"Expected: [2, 1] -- Actual: #{pluck([1,2,3])}\"\nputs \"Expected: [] -- Actual: #{pluck([])}\"\nputs \"Expected: [0, 1] -- Actual: #{pluck([5, 0, 3, 0, 4, 2])}\"\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Expected: [2, 1] -- Actual: [2, 1]\nExpected: [2, 1] -- Actual: [2, 1]\nExpected: [] -- Actual: []\nExpected: [0, 1] -- Actual: [0, 1]\nLoaded suite /tmp/tmplkm9yprm\nStarted\n.\nFinished in 0.000481071 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2078.70 tests/s, 16629.56 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  unless arr.empty?\n    evens = arr.each_with_index.select { |i, idx| i.even? }\n    evens.sort_by { |i, idx| [i, idx] }.first\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmptwym1n63\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmptwym1n63.rb:38:in `test_pluck'\n     35:     candidate = method(:pluck)\n     36:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n  => 38:     assert_equal([], candidate.call([]))\n     39:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     40:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     41:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n<[]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.006690113 seconds.\n-------------------------------------------------------------------------------\n1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n149.47 tests/s, 448.42 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  answer = []\n  min = 0xffff\n  min_i = 0xffff\n  arr.each_with_index do |n, i|\n    if n % 2 == 0\n      min = n if n < min\n      min_i = i if i < min_i\n    end\n  end\n  answer = [min, min_i] if min < 0xffff && min_i < 0xffff\n  answer\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmppb3yovdf\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmppb3yovdf.rb:43:in `test_pluck'\n     40: class TestHumanEval < Test::Unit::TestCase\n     41:   def test_pluck\n     42:     candidate = method(:pluck)\n  => 43:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     44:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     45:     assert_equal([], candidate.call([]))\n     46:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[2, 0]>\n\ndiff:\n? [2, 1]\n?     0 \n?     ? \n===============================================================================\n\nFinished in 0.007042285 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n142.00 tests/s, 142.00 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  min = arr.index do |e|\n    e.even?\n  end\n  return [] if min.nil?\n  [arr[min], min]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpujb061jo\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpujb061jo.rb:37:in `test_pluck'\n     34: class TestHumanEval < Test::Unit::TestCase\n     35:   def test_pluck\n     36:     candidate = method(:pluck)\n  => 37:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     38:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     39:     assert_equal([], candidate.call([]))\n     40:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[4, 0]>\n\ndiff:\n? [2, 1]\n?  4  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.00689163 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n145.10 tests/s, 145.10 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  curr_min = [1.0/0.0, 1.0/0.0]\n  arr.each_with_index do |x, i|\n    curr_min = [x, i] if x < curr_min[0] && x.even?\n  end\n  curr_min[0] == 1.0/0.0 ? [] : curr_min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpelybchjv\nStarted\n.\nFinished in 0.000473808 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2110.56 tests/s, 16884.48 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  smallest, smallest_index = nil, nil\n  arr.each_with_index do |e, i|\n    if e.even?\n      if smallest.nil? || e < smallest\n        smallest = e\n        smallest_index = i\n      end\n    end\n  end\n  return [] if smallest.nil?\n  [smallest, smallest_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp_bfdt98y\nStarted\n.\nFinished in 0.000434104 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2303.60 tests/s, 18428.76 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  even_values = arr.reject { |x| x.odd? }\n  return [] if even_values.empty?\n  min_value = even_values.min\n  min_index = arr.index(min_value)\n  [min_value, min_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp_53v_nj5\nStarted\n.\nFinished in 0.000471558 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2120.63 tests/s, 16965.04 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  num = nil\n  index = nil\n  arr.each_with_index do |num_comp, index_comp|\n    if num_comp % 2 == 0 && (num == nil || num_comp < num)\n      num = num_comp\n      index = index_comp\n    end\n  end\n  return [] if num == nil\n  [num, index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp_rk2soha\nStarted\n.\nFinished in 0.0004389 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2278.42 tests/s, 18227.39 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    h = {}\n    arr.each_with_index { |e, i| h[e] = i if e.even? }\n    return [] if h.size == 0\n    [h.keys.min, h[h.keys.min]]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpz8z6n3i3\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpz8z6n3i3.rb:39:in `test_pluck'\n     36:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     38:     assert_equal([], candidate.call([]))\n  => 39:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     40:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     41:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n     42:     assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n<[0, 1]> expected but was\n<[0, 3]>\n\ndiff:\n? [0, 1]\n?     3 \n?     ? \n===============================================================================\n\nFinished in 0.007088205 seconds.\n-------------------------------------------------------------------------------\n1 tests, 4 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n141.08 tests/s, 564.32 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.length == 0 || arr.length > 10000\n  evens = arr.select { |v| v.even? }\n  return [] if evens.length == 0\n  min_index = evens.map { |v| arr.index(v) }.min\n  [evens.min, min_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp_aptcpu4\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp_aptcpu4.rb:37:in `test_pluck'\n     34: class TestHumanEval < Test::Unit::TestCase\n     35:   def test_pluck\n     36:     candidate = method(:pluck)\n  => 37:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     38:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     39:     assert_equal([], candidate.call([]))\n     40:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[2, 0]>\n\ndiff:\n? [2, 1]\n?     0 \n?     ? \n===============================================================================\n\nFinished in 0.00746543 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n133.95 tests/s, 133.95 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  hash = {}\n  arr.each_with_index do |num, i|\n    if num.even?\n      hash[num] = i\n    end\n  end\n  return [] if hash.empty?\n  sorted = hash.sort\n  smallest = sorted[0][0]\n  index = sorted[0][1]\n  [smallest, index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpt_nmb1qg\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpt_nmb1qg.rb:47:in `test_pluck'\n     44:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     45:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     46:     assert_equal([], candidate.call([]))\n  => 47:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     48:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     49:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n     50:     assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n<[0, 1]> expected but was\n<[0, 3]>\n\ndiff:\n? [0, 1]\n?     3 \n?     ? \n===============================================================================\n\nFinished in 0.007297735 seconds.\n-------------------------------------------------------------------------------\n1 tests, 4 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n137.03 tests/s, 548.12 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = []\n  arr.each_with_index { |n, i| evens << [n, i] if n.even? }\n  evens.sort! { |a, b| a[0] <=> b[0] }\n  return [] if evens.empty?\n  evens[0]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpw16xs0k5\nStarted\n.\nFinished in 0.000431918 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2315.25 tests/s, 18522.03 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.empty?\n    arr = arr.sort\n    evens = arr.select { |el| el.even? }\n    evens.empty? ? [] : [evens[0], arr.index(evens[0])]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpnq5f197l\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpnq5f197l.rb:36:in `test_pluck'\n     33: class TestHumanEval < Test::Unit::TestCase\n     34:   def test_pluck\n     35:     candidate = method(:pluck)\n  => 36:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     38:     assert_equal([], candidate.call([]))\n     39:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[2, 0]>\n\ndiff:\n? [2, 1]\n?     0 \n?     ? \n===============================================================================\n\nFinished in 0.009404857 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n106.33 tests/s, 106.33 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  return [arr[0], 0] if arr.length == 1\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpl2zmihql.rb:30: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpl2zmihql.rb:42: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    even_array = arr.select{|e| e.even?}\n    if even_array.empty?\n        return []\n    else\n        return [even_array.min, arr.index(even_array.min)]\n    end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpeiokk_zg\nStarted\n.\nFinished in 0.000442481 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2259.98 tests/s, 18079.87 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    new_arr = []\n    if arr.all? { |num| num % 2 != 0 } || arr.length == 0\n        return []\n    else\n        arr.each_with_index do |num, idx|\n            if num % 2 == 0\n                new_arr << [num, idx]\n            end\n        end\n        return new_arr.sort[0]\n    end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpw_oalkex\nStarted\n.\nFinished in 0.00045728 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2186.84 tests/s, 17494.75 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  min = arr.min\n  return [] if !min.even?\n  arr.map.with_index { |e, i| [e, i] }.select { |e| e[0] == min }.first\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpjo41u6p2\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpjo41u6p2.rb:36:in `test_pluck'\n     33:   def test_pluck\n     34:     candidate = method(:pluck)\n     35:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n  => 36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     37:     assert_equal([], candidate.call([]))\n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     39:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n<[2, 1]> expected but was\n<[]>\n\ndiff:\n? [2, 1]\n===============================================================================\n\nFinished in 0.007705482 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n129.78 tests/s, 259.56 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    ev = arr.select{|x| x.even?}.sort\n    return [] if ev.empty?\n    [ev[0], arr.index(ev[0])]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprapeyfom\nStarted\n.\nFinished in 0.00044017 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2271.85 tests/s, 18174.80 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp90kopeq4\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp90kopeq4.rb:32:in `test_pluck'\n     29: class TestHumanEval < Test::Unit::TestCase\n     30:   def test_pluck\n     31:     candidate = method(:pluck)\n  => 32:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     33:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     34:     assert_equal([], candidate.call([]))\n     35:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.011015318 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n90.78 tests/s, 90.78 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.select { |n| n.even? }\n  return [] if evens.empty?\n  [evens.min, arr.index(evens.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp4lyo1gvb\nStarted\n.\nFinished in 0.000445182 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2246.27 tests/s, 17970.18 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp90kopeq4\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp90kopeq4.rb:32:in `test_pluck'\n     29: class TestHumanEval < Test::Unit::TestCase\n     30:   def test_pluck\n     31:     candidate = method(:pluck)\n  => 32:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     33:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     34:     assert_equal([], candidate.call([]))\n     35:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.011015318 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n90.78 tests/s, 90.78 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  even_idx = arr.each_with_index.min_by{|v, i| v.even? ? v : Float::INFINITY}\n  return [] if !even_idx\n  [even_idx[0], even_idx[1]]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp1lcwcp_o\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp1lcwcp_o.rb:42:in `test_pluck'\n     39:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     40:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n     41:     assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n  => 42:     assert_equal([], candidate.call([7, 9, 7, 1]))\n     43:   end\n     44: end\n<[]> expected but was\n<[7, 0]>\n\ndiff:\n? [7, 0]\n===============================================================================\n\nFinished in 0.007059951 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n141.64 tests/s, 1133.15 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = []\n  arr.each_with_index do |e, idx|\n    if e.even?\n      evens << [e, idx]\n    end\n  end\n  if evens.empty?\n    []\n  else\n    evens.sort! { |a, b| [a[0], a[1]] <=> [b[0], b[1]] }\n    evens[0]\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp79ah7bdx\nStarted\n.\nFinished in 0.000457161 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2187.41 tests/s, 17499.31 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp2aulsn42\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp2aulsn42.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.007079618 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n141.25 tests/s, 141.25 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |v,i|\n    return [v,i] if v.even?\n  end\n  []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpvhl4no8h\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpvhl4no8h.rb:36:in `test_pluck'\n     33: class TestHumanEval < Test::Unit::TestCase\n     34:   def test_pluck\n     35:     candidate = method(:pluck)\n  => 36:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     38:     assert_equal([], candidate.call([]))\n     39:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[4, 0]>\n\ndiff:\n? [2, 1]\n?  4  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.007349994 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n136.05 tests/s, 136.05 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  return arr.map{|i| i.even? ? i : nil}.compact.min\nend\n  \nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpksx6c2v5\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpksx6c2v5.rb:35:in `test_pluck'\n     32: class TestHumanEval < Test::Unit::TestCase\n     33:   def test_pluck\n     34:     candidate = method(:pluck)\n  => 35:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     37:     assert_equal([], candidate.call([]))\n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<2>\n\ndiff:\n? [2, 1]\n===============================================================================\n\nFinished in 0.006975274 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n143.36 tests/s, 143.36 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  res = []\n  min = nil\n  for i in 0...arr.length\n    if arr[i].even?\n      if min.nil?\n        min = arr[i]\n        res = [min, i]\n      elsif arr[i] < min\n        min = arr[i]\n        res = [min, i]\n      end\n    end\n  end\n  res\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp7vf97fpq\nStarted\n.\nFinished in 0.000502115 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1991.58 tests/s, 15932.61 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    min = nil\n    min_index = nil\n    even_count = 0\n    arr.each_with_index do |val, index|\n        if (val % 2 == 0)\n            even_count += 1\n            if (min.nil? || val < min)\n                min = val\n                min_index = index\n            end\n        end\n    end\n    if (even_count == 0)\n        return []\n    end\n    return [min, min_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp5qurff_u\nStarted\n.\nFinished in 0.000588247 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1699.97 tests/s, 13599.73 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    if !arr || arr.length == 0\n        return []\n    end\n    arr.each_with_index do |item, i|\n        if item % 2 == 0\n            return [item, i]\n        end\n    end\n    return []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpgom88mtv\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpgom88mtv.rb:41:in `test_pluck'\n     38: class TestHumanEval < Test::Unit::TestCase\n     39:   def test_pluck\n     40:     candidate = method(:pluck)\n  => 41:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     42:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     43:     assert_equal([], candidate.call([]))\n     44:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[4, 0]>\n\ndiff:\n? [2, 1]\n?  4  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.007204065 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n138.81 tests/s, 138.81 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  max = arr.size\n  i = 0\n  while (i < max) do\n    if (arr[i] % 2 == 0)\n      return [arr[i], i]\n    end\n    i += 1\n  end\n  return []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpc9q92p_i\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpc9q92p_i.rb:42:in `test_pluck'\n     39: class TestHumanEval < Test::Unit::TestCase\n     40:   def test_pluck\n     41:     candidate = method(:pluck)\n  => 42:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     43:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     44:     assert_equal([], candidate.call([]))\n     45:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[4, 0]>\n\ndiff:\n? [2, 1]\n?  4  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.007340819 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n136.22 tests/s, 136.22 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n\treturn [] if arr.empty?\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfmqtbm3h.rb:29: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpfmqtbm3h.rb:41: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.select(&:even?)\n  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmptm3ewy9l\nStarted\n.\nFinished in 0.000508806 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1965.39 tests/s, 15723.09 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = arr.select { |n| n.even? }\n  return [] if evens.empty?\n  min_val = evens.min\n  min_idx = arr.index(min_val)\n  [min_val, min_idx]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpx957_sip\nStarted\n.\nFinished in 0.000471477 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2120.99 tests/s, 16967.95 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n\t# Check for edge cases.\n\tif arr.length == 0\n\t\treturn []\n\tend\n\t\n\t# Create the list of even numbers, and the hash of index keys and numbers\n\t# Also keep track of the smallest number\n\teven_numbers = []\n\tindex_values = {}\n\tsmallest_number = nil\n\t\n\t# Loop through the array, and populate even_numbers and index_values\n\tfor i in 0..arr.length-1\n\t\tif arr[i] % 2 == 0\n\t\t\teven_numbers.push(arr[i])\n\t\t\tindex_values[arr[i]] = i\n\t\t\t\n\t\t\tif smallest_number == nil || arr[i] < smallest_number\n\t\t\t\tsmallest_number = arr[i]\n\t\t\tend\n\t\tend\n\tend\n\t\n\t# If there were no even numbers\n\tif even_numbers.length == 0\n\t\treturn []\n\tend\n\t\n\t# Get the smallest value, and its index from the dictionary\n\t# And return that as an array\n\treturn [smallest_number, index_values[smallest_number]]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpx67ap22e\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpx67ap22e.rb:66:in `test_pluck'\n     63:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     64:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     65:     assert_equal([], candidate.call([]))\n  => 66:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     67:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     68:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n     69:     assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n<[0, 1]> expected but was\n<[0, 3]>\n\ndiff:\n? [0, 1]\n?     3 \n?     ? \n===============================================================================\n\nFinished in 0.0071356 seconds.\n-------------------------------------------------------------------------------\n1 tests, 4 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n140.14 tests/s, 560.57 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    arr.each_with_index do |e,i|\n        if e % 2 == 0 && arr.first(i).select{|e| e % 2 == 0}.empty?\n            return [e,i]\n        end\n    end\n    []\nend\nputs 'Given an array representing a branch of a tree that has non-negative integer nodes\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdi0pg4ye.rb:35: syntax error, unexpected local variable or method, expecting end-of-input\nrequire 'test/unit'\n         ^~~~\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    values = []\n    arr.each_with_index { |x,i| values << [x,i] if x.even? }\n    values.min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpdw97ra49\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpdw97ra49.rb:37:in `test_pluck'\n     34:     candidate = method(:pluck)\n     35:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n  => 37:     assert_equal([], candidate.call([]))\n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     39:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     40:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n<[]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.006692681 seconds.\n-------------------------------------------------------------------------------\n1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n149.42 tests/s, 448.25 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  ary = arr.select{|i| i.even?}\n  ary.empty? ? [] : [ary.min, arr.index(ary.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpyqco1l0k\nStarted\n.\nFinished in 0.000432248 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2313.49 tests/s, 18507.89 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.empty?\n    smallest_index = nil\n    smallest_even = nil\n    arr.each_with_index do |node, index|\n        if node.even?\n            if smallest_even.nil?\n                smallest_even = node\n                smallest_index = index\n            elsif node < smallest_even\n                smallest_even = node\n                smallest_index = index\n            end\n        end\n    end\n    smallest_even.nil? ? [] : [smallest_even, smallest_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmph9j_rq82\nStarted\n.\nFinished in 0.00045827 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2182.12 tests/s, 17456.96 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = []\n  arr.each_with_index { |node, i| evens << [node, i] if node.even? }\n  return [] if evens.empty?\n  evens.sort { |a, b| a[0] <=> b[0] }[0]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmph1lsd57l\nStarted\n.\nFinished in 0.000691372 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1446.40 tests/s, 11571.19 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |val, idx|\n    return [val, idx] if val.even?\n  end\n  []\nend\nputs '##################### Pluck Branch #####################'\nputs 'Pluck'\nputs \"Input: [4,2,3]\\nOutput: #{pluck([4,2,3])}\"\nputs \"Input: [1,2,3]\\nOutput: #{pluck([1,2,3])}\"\nputs \"Input: []\\nOutput: #{pluck([])}\"\nputs \"Input: [5, 0, 3, 0, 4, 2]\\nOutput: #{pluck([5, 0, 3, 0, 4, 2])}\"\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "##################### Pluck Branch #####################\nPluck\nInput: [4,2,3]\nOutput: [4, 0]\nInput: [1,2,3]\nOutput: [2, 1]\nInput: []\nOutput: []\nInput: [5, 0, 3, 0, 4, 2]\nOutput: [0, 1]\nLoaded suite /tmp/tmpciww89z6\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpciww89z6.rb:42:in `test_pluck'\n     39: class TestHumanEval < Test::Unit::TestCase\n     40:   def test_pluck\n     41:     candidate = method(:pluck)\n  => 42:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     43:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     44:     assert_equal([], candidate.call([]))\n     45:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[4, 0]>\n\ndiff:\n? [2, 1]\n?  4  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.007971773 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n125.44 tests/s, 125.44 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  small = []\n  if arr.empty?\n    return []\n  else\n    arr.each_with_index do |number, index|\n      if number % 2 == 0 && number < arr[index + 1]\n        small = [number, index]\n      else\n        next\n      end\n    end\n  end\n  small\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp6_un14f1\nStarted\nE\n===============================================================================\nError: test_pluck(TestHumanEval): ArgumentError: comparison of Integer with nil failed\n/tmp/tmp6_un14f1.rb:32:in `<'\n/tmp/tmp6_un14f1.rb:32:in `block in pluck'\n/tmp/tmp6_un14f1.rb:31:in `each'\n/tmp/tmp6_un14f1.rb:31:in `each_with_index'\n/tmp/tmp6_un14f1.rb:31:in `pluck'\n/tmp/tmp6_un14f1.rb:48:in `call'\n/tmp/tmp6_un14f1.rb:48:in `test_pluck'\n     45:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     46:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     47:     assert_equal([], candidate.call([]))\n  => 48:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     49:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     50:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n     51:     assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n===============================================================================\n\nFinished in 0.001223363 seconds.\n-------------------------------------------------------------------------------\n1 tests, 3 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n817.42 tests/s, 2452.26 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.select(&:even?)\n  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmptm3ewy9l\nStarted\n.\nFinished in 0.000508806 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1965.39 tests/s, 15723.09 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    if arr.length==0\n        return []\n    end\n    a = []\n    for i in 0..arr.length-1\n        if arr[i]%2==0\n            a.push(arr[i])\n        end\n    end\n    if a.length==0\n        return []\n    end\n    smallest = a[0]\n    index = 0\n    for i in 0..a.length-1\n        if a[i]<smallest\n            smallest = a[i]\n            index = i\n        end\n    end\n    return [smallest,index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpa2y5i4et\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpa2y5i4et.rb:54:in `test_pluck'\n     51:   def test_pluck\n     52:     candidate = method(:pluck)\n     53:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n  => 54:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     55:     assert_equal([], candidate.call([]))\n     56:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     57:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n<[2, 1]> expected but was\n<[2, 0]>\n\ndiff:\n? [2, 1]\n?     0 \n?     ? \n===============================================================================\n\nFinished in 0.009154904 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n109.23 tests/s, 218.46 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjip4wnhy.rb:29: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpjip4wnhy.rb:41: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  small_even = -1\n  index = -1\n  arr.each_with_index do |num, i|\n    if num.even? && small_even == -1\n      small_even = num\n      index = i\n    elsif num.even? && num < small_even\n      small_even = num\n      index = i\n    end\n  end\n  small_even != -1 ? [small_even, index] : []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp8l_cy_42\nStarted\n.\nFinished in 0.000437547 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2285.47 tests/s, 18283.75 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.map.with_index do |e,i|\n    return [e,i] if e.even?\n  end\n  []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp4jhzw87u\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp4jhzw87u.rb:36:in `test_pluck'\n     33: class TestHumanEval < Test::Unit::TestCase\n     34:   def test_pluck\n     35:     candidate = method(:pluck)\n  => 36:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     38:     assert_equal([], candidate.call([]))\n     39:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[4, 0]>\n\ndiff:\n? [2, 1]\n?  4  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.0078141 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n127.97 tests/s, 127.97 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n\treturn [] if arr.empty? || arr.select{|n| n.even?}.empty?\n\t\n\tarr.select{|n| n.even?}.min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpj3ep2ksj\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpj3ep2ksj.rb:35:in `test_pluck'\n     32: class TestHumanEval < Test::Unit::TestCase\n     33:   def test_pluck\n     34:     candidate = method(:pluck)\n  => 35:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     37:     assert_equal([], candidate.call([]))\n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<2>\n\ndiff:\n? [2, 1]\n===============================================================================\n\nFinished in 0.007134337 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n140.17 tests/s, 140.17 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  raise ArgumentError, \"Argument is nil\" if arr.nil?\n  raise ArgumentError, \"Argument is empty\" if arr.empty?\n  evens = arr.select { |num| num.even? }\n  return [] if evens.empty?\n  evens.min == 0 ? [0, arr.index(0)] : [evens.min, arr.index(evens.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmptsntvta0\nStarted\nE\n===============================================================================\nError: test_pluck(TestHumanEval): ArgumentError: Argument is empty\n/tmp/tmptsntvta0.rb:28:in `pluck'\n/tmp/tmptsntvta0.rb:39:in `call'\n/tmp/tmptsntvta0.rb:39:in `test_pluck'\n     36:     candidate = method(:pluck)\n     37:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     38:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n  => 39:     assert_equal([], candidate.call([]))\n     40:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     41:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     42:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n===============================================================================\n\nFinished in 0.001183542 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n844.92 tests/s, 1689.84 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.length == 0\n  smallest_even = arr.min\n  smallest_even -= 1 if smallest_even.odd?\n  return [] if smallest_even < 0\n  smallest_even_index = nil\n  arr.each_with_index do |element, index|\n    if element == smallest_even\n      smallest_even_index = index\n      break\n    end\n  end\n  [smallest_even, smallest_even_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpn25hl6pb\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpn25hl6pb.rb:45:in `test_pluck'\n     42:   def test_pluck\n     43:     candidate = method(:pluck)\n     44:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n  => 45:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     46:     assert_equal([], candidate.call([]))\n     47:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     48:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n<[2, 1]> expected but was\n<[0, nil]>\n\ndiff:\n? [2, 1  ]\n?  0  nil \n?  ?  ? \n===============================================================================\n\nFinished in 0.007829644 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n127.72 tests/s, 255.44 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    if arr.nil? || arr.length == 0\n        []\n    else\n        vals = arr.select { |v| v % 2 == 0 }\n        # puts \"vals: #{vals}\"\n        if vals.length == 0\n            []\n        else\n            smallest = vals.min\n            # puts \"smallest: #{smallest}\"\n            idx = arr.index(smallest)\n            # puts \"idx: #{idx}\"\n            [smallest, idx]\n        end\n    end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp4h12eum0\nStarted\n.\nFinished in 0.000442525 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2259.76 tests/s, 18078.07 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  smallest, smallest_index = nil, nil\n  arr.each_with_index do |val, index|\n    if val.even?\n      if smallest.nil? || val < smallest\n        smallest = val\n        smallest_index = index\n      end\n    end\n  end\n  smallest.nil? ? [] : [smallest, smallest_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpblvj4oq8\nStarted\n.\nFinished in 0.00051567 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1939.22 tests/s, 15513.80 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.empty?\n    num = []\n    arr.each_with_index do |val, i|\n        num.push([val, i]) if val.even?\n    end\n    return [] if num.empty?\n    num.sort!\n    num[0]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp5_zc05oo\nStarted\n.\nFinished in 0.000500075 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1999.70 tests/s, 15997.60 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    if arr.empty?\n        return []\n    else\n        even_nums = arr.select { |num| num.even? }\n        if even_nums.empty?\n            return []\n        else\n            even_min = even_nums.min\n            return [even_min, arr.index(even_min)]\n        end\n    end\nend\nputs \"Pluck:\"\nputs pluck([1,2,3]) == [2, 1]\nputs pluck([4,2,3]) == [2, 1]\nputs pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\nputs pluck([]) == []\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Pluck:\ntrue\ntrue\ntrue\ntrue\nLoaded suite /tmp/tmpb82raoap\nStarted\n.\nFinished in 0.000477726 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2093.25 tests/s, 16746.00 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.length == 0\n  smallest_even = arr.min\n  smallest_even_index = 0\n  if smallest_even.even?\n    smallest_even_index = arr.index(smallest_even)\n  else\n    while smallest_even.odd?\n      arr.delete_at(arr.index(smallest_even))\n      smallest_even = arr.min\n    end\n    smallest_even_index = arr.index(smallest_even)\n  end\n  return [smallest_even, smallest_even_index]\nend\nputs \"Expected: [2, 1] -- Actual: #{pluck([4,2,3])}\"\nputs \"Expected: [2, 1] -- Actual: #{pluck([1,2,3])}\"\nputs \"Expected: [] -- Actual: #{pluck([])}\"\nputs \"Expected: [0, 1] -- Actual: #{pluck([5, 0, 3, 0, 4, 2])}\"\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Expected: [2, 1] -- Actual: [2, 1]\nExpected: [2, 1] -- Actual: [2, 0]\nExpected: [] -- Actual: []\nExpected: [0, 1] -- Actual: [0, 1]\nLoaded suite /tmp/tmp_65a03ry\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp_65a03ry.rb:50:in `test_pluck'\n     47:   def test_pluck\n     48:     candidate = method(:pluck)\n     49:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n  => 50:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     51:     assert_equal([], candidate.call([]))\n     52:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     53:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n<[2, 1]> expected but was\n<[2, 0]>\n\ndiff:\n? [2, 1]\n?     0 \n?     ? \n===============================================================================\n\nFinished in 0.00734453 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n136.16 tests/s, 272.31 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp2aulsn42\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp2aulsn42.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.007079618 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n141.25 tests/s, 141.25 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp2aulsn42\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp2aulsn42.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.007079618 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n141.25 tests/s, 141.25 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  min_value = nil\n  min_index = nil\n  arr.each_with_index do |val, idx|\n    next if val % 2 != 0\n    if min_value.nil? || val < min_value\n      min_value = val\n      min_index = idx\n    end\n  end\n  return [] if min_value.nil?\n  [min_value, min_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmphi9g916h\nStarted\n.\nFinished in 0.000508208 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1967.70 tests/s, 15741.59 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjip4wnhy.rb:29: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpjip4wnhy.rb:41: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n \nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpb0omulr2\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpb0omulr2.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.008112784 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n123.26 tests/s, 123.26 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  h = {}\n  arr.each_with_index do |i, index|\n    h[i] = index if i.even?\n  end\n  arr = h.sort_by{|k,v| k}.first\n  arr[0] == nil ? [] : arr\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpmnvr6stk\nStarted\nE\n===============================================================================\nError: test_pluck(TestHumanEval):\n  NoMethodError: undefined method `[]' for nil:NilClass\n  \n    arr[0] == nil ? [] : arr\n       ^^^\n/tmp/tmpmnvr6stk.rb:32:in `pluck'\n/tmp/tmpmnvr6stk.rb:40:in `call'\n/tmp/tmpmnvr6stk.rb:40:in `test_pluck'\n     37:     candidate = method(:pluck)\n     38:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     39:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n  => 40:     assert_equal([], candidate.call([]))\n     41:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     42:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     43:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n===============================================================================\n\nFinished in 0.002255894 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n443.28 tests/s, 886.57 assertions/s\n",
      "timestamp": 1659823492
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    smallest, index = [], []\n    for i in (0...arr.length)\n        if arr[i] % 2 == 0 && smallest.length == 0\n            smallest << arr[i]\n            index << i\n        elsif arr[i] % 2 == 0 && arr[i] < smallest[0]\n            smallest = []\n            index = []\n            smallest << arr[i]\n            index << i\n        elsif arr[i] % 2 == 0 && arr[i] == smallest[0]\n            smallest << arr[i]\n            index << i\n        end\n    end\n    smallest.length == 0 ? [] : [smallest[0], index[0]]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp_qz6_pr5\nStarted\n.\nFinished in 0.000514429 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1943.90 tests/s, 15551.22 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.empty?\n    return [] if arr.all?{|x| x % 2 != 0}\n    smallest_value = arr.min\n    smallest_index = 0\n    arr.each_with_index do |x,index|\n        if x == smallest_value\n            smallest_index = index\n            break\n        end\n    end\n    return [smallest_value, smallest_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpu1ya9zlo\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpu1ya9zlo.rb:44:in `test_pluck'\n     41:   def test_pluck\n     42:     candidate = method(:pluck)\n     43:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n  => 44:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     45:     assert_equal([], candidate.call([]))\n     46:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     47:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n<[2, 1]> expected but was\n<[1, 0]>\n\ndiff:\n? [2, 1]\n?  1  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.010995307 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n90.95 tests/s, 181.90 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    is_even_arr = arr.select { |x| x % 2 == 0}\n    if is_even_arr.length == 0\n        return []\n    end\n    min_val = is_even_arr.min\n    idx = arr.index(min_val)\n    return [min_val, idx]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpubnvrkvz\nStarted\n.\nFinished in 0.000511985 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1953.18 tests/s, 15625.46 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823492
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    h = Hash.new(0)\n    return [] if arr.empty?\n    min = arr.first\n    arr.each { |e| h[e] += 1 }\n    h.each do |k, v|\n        if k % 2 == 0 && k < min\n            min = k\n        end\n    end\n    return [min, arr.index(min)]\nend\nputs pluck([4,2,3])\nputs pluck([1,2,3])\nputs pluck([])\nputs pluck([5, 0, 3, 0, 4, 2])\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "2\n1\n1\n0\n0\n1\nLoaded suite /tmp/tmpaqmevaf9\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpaqmevaf9.rb:47:in `test_pluck'\n     44:   def test_pluck\n     45:     candidate = method(:pluck)\n     46:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n  => 47:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     48:     assert_equal([], candidate.call([]))\n     49:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     50:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n<[2, 1]> expected but was\n<[1, 0]>\n\ndiff:\n? [2, 1]\n?  1  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.006975305 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n143.36 tests/s, 286.73 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.select { |v| v.even? }\n  return [] if evens.empty?\n  evens.sort!\n  [evens.first, arr.index(evens.first)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpmuoshgfg\nStarted\n.\nFinished in 0.00046975 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2128.79 tests/s, 17030.34 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.nil? || arr.size == 0\n  lowest_even = arr.select{|val| val.even?}.min\n  if lowest_even.nil?\n    []\n  else\n    [lowest_even, arr.index(lowest_even)]\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp422018wu\nStarted\n.\nFinished in 0.000427671 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2338.25 tests/s, 18705.97 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  smallest_even = nil\n  smallest_even_idx = nil\n  arr.each_with_index do |n, idx|\n    next if n.odd?\n    smallest_even = n\n    smallest_even_idx = idx\n    break\n  end\n  return [] if smallest_even.nil?\n  arr.each_with_index do |n, idx|\n    next if n.odd?\n    if n < smallest_even\n      smallest_even = n\n      smallest_even_idx = idx\n    end\n  end\n  [smallest_even, smallest_even_idx]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmponabkqe1\nStarted\n.\nFinished in 0.000439321 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2276.24 tests/s, 18209.92 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  sorted = arr.sort\n  sorted.select!{|n| n.even?}\n  return [] if sorted.empty?\n  min = sorted.first\n  idx = arr.index(min)\n  return [min, idx]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpkoijlwyc\nStarted\n.\nFinished in 0.000429295 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2329.40 tests/s, 18635.20 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = []\n  arr.each_with_index do |val, i|\n    evens << [val, i] if val.even?\n  end\n  evens.min_by { |val, _| val }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmptbcqwnpo\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmptbcqwnpo.rb:39:in `test_pluck'\n     36:     candidate = method(:pluck)\n     37:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     38:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n  => 39:     assert_equal([], candidate.call([]))\n     40:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     41:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     42:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n<[]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.006188636 seconds.\n-------------------------------------------------------------------------------\n1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n161.59 tests/s, 484.76 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  smallest_even_idx = nil\n  smallest_even_value = nil\n  arr.each_with_index do |value, index|\n    next if value.odd?\n    if smallest_even_value.nil? || value < smallest_even_value\n      smallest_even_value = value\n      smallest_even_idx = index\n    end\n  end\n  return [] if smallest_even_value.nil?\n  [smallest_even_value, smallest_even_idx]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpgd169wte\nStarted\n.\nFinished in 0.00048946 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2043.07 tests/s, 16344.54 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  i = 0\n  even = []\n  while i < arr.length\n    if arr[i] % 2 == 0\n      even << [arr[i], i]\n    end\n    i += 1\n  end\n  return [] if even.empty?\n  even.sort! { |a, b| a[0] <=> b[0] }\n  even[0]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpptun8jaj\nStarted\n.\nFinished in 0.000460649 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2170.85 tests/s, 17366.80 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.select { |v| v.even? }\n  return [] if evens.empty?\n  evens.min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpqq1lz626\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpqq1lz626.rb:35:in `test_pluck'\n     32: class TestHumanEval < Test::Unit::TestCase\n     33:   def test_pluck\n     34:     candidate = method(:pluck)\n  => 35:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     37:     assert_equal([], candidate.call([]))\n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<2>\n\ndiff:\n? [2, 1]\n===============================================================================\n\nFinished in 0.007891602 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n126.72 tests/s, 126.72 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  num = arr.find { |x| x.even? }\n  return [] if num.nil?\n  num_idx = arr.index(num)\n  [num, num_idx]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpw458a5lg\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpw458a5lg.rb:36:in `test_pluck'\n     33: class TestHumanEval < Test::Unit::TestCase\n     34:   def test_pluck\n     35:     candidate = method(:pluck)\n  => 36:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     38:     assert_equal([], candidate.call([]))\n     39:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[4, 0]>\n\ndiff:\n? [2, 1]\n?  4  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.007447942 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n134.27 tests/s, 134.27 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  x, y = [], nil\n  arr.each_with_index do |n, i|\n    next if !n.even?\n    x[0] ||= n\n    if n < x[0]\n      x = [n, i]\n    end\n  end\n  x.size == 1 ? [] : x\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp9ghdr8il\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp9ghdr8il.rb:42:in `test_pluck'\n     39:   def test_pluck\n     40:     candidate = method(:pluck)\n     41:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n  => 42:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     43:     assert_equal([], candidate.call([]))\n     44:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     45:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n<[2, 1]> expected but was\n<[]>\n\ndiff:\n? [2, 1]\n===============================================================================\n\nFinished in 0.007144766 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n139.96 tests/s, 279.93 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  smallest = nil\n  index = -1\n  arr.each_with_index do |e,i|\n    next if e.odd?\n    if smallest.nil? || e < smallest\n      smallest = e\n      index = i\n    end\n  end\n  return [] if smallest.nil?\n  [smallest, index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpahj0oaoy\nStarted\n.\nFinished in 0.000460101 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2173.44 tests/s, 17387.49 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.length == 0\n  evens = []\n  arr.each_with_index { |e, i| evens << [e, i] if e % 2 == 0 }\n  return [] if evens.length == 0\n  evens.sort!\n  evens[0]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpa5zfvwye\nStarted\n.\nFinished in 0.00049568 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2017.43 tests/s, 16139.44 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  even_values = arr.select(&:even?)\n  return [] if even_values.empty?\n  min_value = even_values.min\n  [min_value, arr.index(min_value)]\nend\nputs \"Expected: [2, 1] -- Actual: #{pluck([4,2,3])}\"\nputs \"Expected: [2, 1] -- Actual: #{pluck([1,2,3])}\"\nputs \"Expected: [] -- Actual: #{pluck([])}\"\nputs \"Expected: [0, 1] -- Actual: #{pluck([5, 0, 3, 0, 4, 2])}\"\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Expected: [2, 1] -- Actual: [2, 1]\nExpected: [2, 1] -- Actual: [2, 1]\nExpected: [] -- Actual: []\nExpected: [0, 1] -- Actual: [0, 1]\nLoaded suite /tmp/tmpqxrjzn7k\nStarted\n.\nFinished in 0.000429082 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2330.56 tests/s, 18644.45 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.delete_if { |x| x.odd? }.min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpvak_oxhf\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpvak_oxhf.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<2>\n\ndiff:\n? [2, 1]\n===============================================================================\n\nFinished in 0.006917542 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n144.56 tests/s, 144.56 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    arr.each_with_index do |value, index|\n        if value % 2 == 0\n            return [value, index]\n        end\n    end\n    return []\nend\nputs pluck([4,2,3]) == [2, 1]\nputs pluck([1,2,3]) == [2, 1]\nputs pluck([]) == []\nputs pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\nputs pluck([1,3,5,7,9]) == []\nputs pluck([2,4,6,8,10]) == [2, 0]\nputs pluck([4,4,4,4,4]) == [4, 0]\nputs pluck([0,0,0,0,0]) == [0, 0]\nputs pluck([2,2,2,2,2]) == [2, 0]\nputs pluck([7,3,3,3,7]) == []\nputs pluck([8,6,4,6,8]) == [4, 2]\nputs pluck([2,1,1,1,2]) == [2, 0]\nputs pluck([2,2,2,2,1]) == [2, 0]\nputs pluck([2,2,2,2,3]) == [2, 0]\nputs pluck([3,3,3,3,3]) == []\nputs pluck([9,1,1,1,9]) == []\nputs pluck([4,4,4,4,1]) == [4, 0]\nputs pluck([4,4,4,4,3]) == [4, 0]\nputs pluck([4,4,4,4,5]) == [4, 0]\nputs pluck([5,5,5,5,5]) == []\nputs pluck([3,3,3,3,1]) == []\nputs pluck([3,3,3,3,2]) == []\nputs pluck([3,3,3,3,4]) == []\nputs pluck([2,2,2,2,\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp085qn0ui.rb:58: syntax error, unexpected string literal, expecting `do' or '{' or '('\nrequire 'test/unit'\n        ^\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.size==0\n    sm_even = nil\n    sm_even_idx = nil\n    arr.each_with_index do |e, i|\n        if sm_even==nil && e%2==0\n            sm_even = e\n            sm_even_idx = i\n        elsif sm_even!=nil && e%2==0 && e<sm_even\n            sm_even = e\n            sm_even_idx = i\n        end\n    end\n    return [] if sm_even==nil\n    [sm_even, sm_even_idx]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpyzy3rbzc\nStarted\n.\nFinished in 0.000502078 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1991.72 tests/s, 15933.78 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = arr.map.with_index{|v, i| [v, i] if v.even?}.compact\n  return [] if evens.empty?\n  evens.sort_by{|v, i| [v, i]}.first\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp6jwzxo1o\nStarted\n.\nFinished in 0.000495792 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2016.97 tests/s, 16135.80 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.select(&:even?)\n  return [] if evens.empty?\n  return [evens.min, arr.index(evens.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp2uk7og03\nStarted\n.\nFinished in 0.000429753 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2326.92 tests/s, 18615.34 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = arr.select(&:even?)\n  return [] if evens.empty?\n  res = evens.each_with_index.inject { |acc, val| val[0] < acc[0] ? val : acc }\n  [res[0], arr.index(res[0])]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpfw2vtxzd\nStarted\n.\nFinished in 0.000526386 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1899.75 tests/s, 15197.97 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  res = [0, -1]\n  arr.each_with_index { |x, idx|\n    if x % 2 == 0 && res[0] == 0\n      res = [x, idx]\n    elsif x % 2 == 0 && x < res[0]\n      res = [x, idx]\n    end\n  }\n  return [] if res[0] == 0\n  res\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpg0_kxwmm\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpg0_kxwmm.rb:46:in `test_pluck'\n     43:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     44:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     45:     assert_equal([], candidate.call([]))\n  => 46:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     47:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     48:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n     49:     assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n<[0, 1]> expected but was\n<[2, 5]>\n\ndiff:\n? [0, 1]\n?  2  5 \n?  ?  ? \n===============================================================================\n\nFinished in 0.007736767 seconds.\n-------------------------------------------------------------------------------\n1 tests, 4 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n129.25 tests/s, 517.01 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.select { |x| x.even? }\n  idx = arr.find_index(evens.min)\n  idx.nil? ? [] : [evens.min, idx]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp1fcn5da9\nStarted\n.\nFinished in 0.000472025 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2118.53 tests/s, 16948.25 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  arr.each_with_index.min_by{|x, idx| x.even? ? x : Float::INFINITY}.with_index(1)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpbcwbeohv\nStarted\nE\n===============================================================================\nError: test_pluck(TestHumanEval):\n  NoMethodError: undefined method `with_index' for [2, 1]:Array\n  \n    arr.each_with_index.min_by{|x, idx| x.even? ? x : Float::INFINITY}.with_index(1)\n                                                                      ^^^^^^^^^^^\n/tmp/tmpbcwbeohv.rb:28:in `pluck'\n/tmp/tmpbcwbeohv.rb:34:in `call'\n/tmp/tmpbcwbeohv.rb:34:in `test_pluck'\n     31: class TestHumanEval < Test::Unit::TestCase\n     32:   def test_pluck\n     33:     candidate = method(:pluck)\n  => 34:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     35:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     36:     assert_equal([], candidate.call([]))\n     37:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n===============================================================================\n\nFinished in 0.00865212 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n115.58 tests/s, 0.00 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  min = nil\n  idx = nil\n  arr.each_with_index do |val, i|\n    if val.even? && (min.nil? || val < min)\n      min = val\n      idx = i\n    end\n  end\n  return [min, idx] if idx\n  []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpbjhci9a6\nStarted\n.\nFinished in 0.000491627 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2034.06 tests/s, 16272.50 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  even_numbers = arr.select { |n| n.even? }\n  min_even = even_numbers.min\n  min_even ? [min_even, arr.index(min_even)] : []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmppydjykdt\nStarted\n.\nFinished in 0.000480234 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2082.32 tests/s, 16658.55 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = arr.each_with_index.select { |val, _| val.even? }\n  return [] if evens.empty?\n  evens.min_by { |val, i| [val, i] }.to_a\nend\nputs '###### pluck ######'\nputs pluck([4,2,3]) == [2, 1]\nputs pluck([1,2,3]) == [2, 1]\nputs pluck([]) == []\nputs pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "###### pluck ######\ntrue\ntrue\ntrue\ntrue\nLoaded suite /tmp/tmp8cay_rv1\nStarted\n.\nFinished in 0.000505244 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1979.24 tests/s, 15833.93 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n\t# Returns the smallest even value and its index from arr, or [] if there is no such value.\n\tif arr.length == 0\n\t\treturn []\n\tend\n\tmin = nil\n\tmin_index = nil\n\tarr.each_with_index do |value, index|\n\t\tif min == nil and value % 2 == 0\n\t\t\tmin = value\n\t\t\tmin_index = index\n\t\tend\n\t\tif value % 2 == 0 and value < min\n\t\t\tmin = value\n\t\t\tmin_index = index\n\t\tend\n\tend\n\tif min == nil\n\t\treturn []\n\tend\n\treturn [min, min_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmphc04yowt\nStarted\n.\nFinished in 0.000612492 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1632.67 tests/s, 13061.40 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.select { |i| i % 2 == 0 }\n  return [] if evens.empty?\n  [evens.min, arr.index(evens.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpw7gtml8a\nStarted\n.\nFinished in 0.000556151 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1798.07 tests/s, 14384.58 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  res = []\n  return res if arr.nil? or arr.empty?\n  min_ev = 2**32 - 1\n  n = arr.size\n  (0...n).each { |i|\n    if arr[i] % 2 == 0 and arr[i] < min_ev\n      min_ev = arr[i]\n      res = [min_ev, i]\n    end\n  }\n  res\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpn6kh9hfu\nStarted\n.\nFinished in 0.000437366 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2286.41 tests/s, 18291.32 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.select(&:even?)\n  return [] if evens.empty?\n  [evens.min, arr.index(evens.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpn41dvl5n\nStarted\n.\nFinished in 0.000508681 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1965.87 tests/s, 15726.95 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp2aulsn42\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp2aulsn42.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.007079618 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n141.25 tests/s, 141.25 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  min_index = nil\n  min_value = nil\n  arr.each_with_index do |node, index|\n    if node.even?\n      if min_value.nil? || node < min_value\n        min_value = node\n        min_index = index\n      end\n    end\n  end\n  return [] if min_value.nil?\n  [min_value, min_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp6zve92rn\nStarted\n.\nFinished in 0.00045207 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2212.05 tests/s, 17696.37 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  # write your code here\n  return [] if arr.empty?\n  evens = arr.select{|x| x.even?}\n  return [] if evens.empty?\n  min = evens.min\n  return [min, arr.index(min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpi730jp56\nStarted\n.\nFinished in 0.000424446 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2356.01 tests/s, 18848.10 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  arr.each_with_index { |e, i|\n    if e % 2 == 0\n      return [e, i]\n    end\n  }\n  []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpd60tr9zl\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpd60tr9zl.rb:39:in `test_pluck'\n     36: class TestHumanEval < Test::Unit::TestCase\n     37:   def test_pluck\n     38:     candidate = method(:pluck)\n  => 39:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     41:     assert_equal([], candidate.call([]))\n     42:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[4, 0]>\n\ndiff:\n? [2, 1]\n?  4  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.00693197 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n144.26 tests/s, 144.26 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  smallest_even = nil\n  smallest_even_index = nil\n  arr.each_with_index do |n, i|\n    if n.even?\n      if smallest_even.nil?\n        smallest_even = n\n        smallest_even_index = i\n      elsif n < smallest_even\n        smallest_even = n\n        smallest_even_index = i\n      end\n    end\n  end\n  return [smallest_even, smallest_even_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpkl_ok2l1\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpkl_ok2l1.rb:48:in `test_pluck'\n     45:     candidate = method(:pluck)\n     46:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     47:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n  => 48:     assert_equal([], candidate.call([]))\n     49:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     50:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     51:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n<[]> expected but was\n<[nil, nil]>\n\ndiff:\n? [nil, nil]\n===============================================================================\n\nFinished in 0.006692601 seconds.\n-------------------------------------------------------------------------------\n1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n149.42 tests/s, 448.26 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.empty?\n    evens = arr.select { |val| val.even? }\n    return [] if evens.empty?\n    min_val = evens.min\n    idx = arr.index(min_val)\n    [min_val, idx]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpniizkh_5\nStarted\n.\nFinished in 0.000414392 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2413.17 tests/s, 19305.39 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  # find even numbers\n  # sort by value\n  # sort by index\n  evens = arr.select { |e| e.even? }\n  return [] if evens.empty?\n  evens.sort.sort_by.with_index { |_, i| i }.first\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpr3oqgfae\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpr3oqgfae.rb:39:in `test_pluck'\n     36: class TestHumanEval < Test::Unit::TestCase\n     37:   def test_pluck\n     38:     candidate = method(:pluck)\n  => 39:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     41:     assert_equal([], candidate.call([]))\n     42:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<2>\n\ndiff:\n? [2, 1]\n===============================================================================\n\nFinished in 0.006827711 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n146.46 tests/s, 146.46 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = arr.select(&:even?)\n  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmps6i2yd36\nStarted\n.\nFinished in 0.000523427 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1910.49 tests/s, 15283.89 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp2aulsn42\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp2aulsn42.rb:33:in `test_pluck'\n     30: class TestHumanEval < Test::Unit::TestCase\n     31:   def test_pluck\n     32:     candidate = method(:pluck)\n  => 33:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     34:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     35:     assert_equal([], candidate.call([]))\n     36:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.007079618 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n141.25 tests/s, 141.25 assertions/s\n",
      "timestamp": 1659823491
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  min_value = arr.select { |e| e.even? }.min\n  min_index = arr.index(min_value)\n  return [min_value, min_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpf0wqf4qj\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpf0wqf4qj.rb:37:in `test_pluck'\n     34:     candidate = method(:pluck)\n     35:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n  => 37:     assert_equal([], candidate.call([]))\n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n     39:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     40:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n<[]> expected but was\n<[nil, nil]>\n\ndiff:\n? [nil, nil]\n===============================================================================\n\nFinished in 0.008618731 seconds.\n-------------------------------------------------------------------------------\n1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n116.03 tests/s, 348.08 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  min_even_node = arr.each_with_index.min { |(a, _), (b, _)| a.even? && b.even? ? a <=> b : a.even? ? -1 : 1 }\n  min_even_node ? [min_even_node[0], min_even_node[1]] : []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpnc6mcdg3\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmpnc6mcdg3.rb:41:in `test_pluck'\n     38:     assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n     39:     assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n     40:     assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n  => 41:     assert_equal([], candidate.call([7, 9, 7, 1]))\n     42:   end\n     43: end\n<[]> expected but was\n<[7, 0]>\n\ndiff:\n? [7, 0]\n===============================================================================\n\nFinished in 0.006435951 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n155.38 tests/s, 1243.02 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  index = 0\n  min = nil\n  min_index = 0\n  last_index = arr.length-1\n  while index <= last_index\n    if arr[index] % 2 == 0\n      if min.nil? || arr[index] < min\n        min = arr[index]\n        min_index = index\n      end\n    end\n    index += 1\n  end\n  min.nil? ? [] : [min, min_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp9jiidzd5\nStarted\n.\nFinished in 0.000421729 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2371.19 tests/s, 18969.53 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  evens = arr.select { |a| a.even? }\n  return [] if evens.empty?\n  [evens.min, arr.index(evens.min)]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpn8r4icor\nStarted\n.\nFinished in 0.000400229 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2498.57 tests/s, 19988.56 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    min_even_value = 2**32-1\n    min_even_index = 0\n    arr.each_with_index do |value,index|\n        if value % 2 == 0 && value < min_even_value\n            min_even_value = value\n            min_even_index = index\n        end\n    end\n    if min_even_value == 2**32-1\n        return []\n    else\n        return [min_even_value, min_even_index]\n    end\nend\nputs \"Expected: [2, 1]\"\nputs \"Output: #{pluck([4,2,3])}\"\nputs \"Expected: [2, 1]\"\nputs \"Output: #{pluck([1,2,3])}\"\nputs \"Expected: []\"\nputs \"Output: #{pluck([])}\"\nputs \"Expected: [0, 1]\"\nputs \"Output: #{pluck([5, 0, 3, 0, 4, 2])}\"\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Expected: [2, 1]\nOutput: [2, 1]\nExpected: [2, 1]\nOutput: [2, 1]\nExpected: []\nOutput: []\nExpected: [0, 1]\nOutput: [0, 1]\nLoaded suite /tmp/tmpn10y0mm7\nStarted\n.\nFinished in 0.000395558 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2528.07 tests/s, 20224.59 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.empty?\n    evens = arr.select { |n| n.even? }\n    smallest = evens.sort[0]\n    return [] if smallest.nil?\n    idx = arr.index(smallest)\n    return [smallest, idx]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpgifzw4kq\nStarted\n.\nFinished in 0.000421791 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2370.84 tests/s, 18966.74 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = arr.select(&:even?)\n  return [] if evens.empty?\n  [evens.min, arr.index(evens.min)]\nend\nputs \"Expected: [2, 1], Actual: #{pluck([4,2,3])}\"\nputs \"Expected: [2, 1], Actual: #{pluck([1,2,3])}\"\nputs \"Expected: [], Actual: #{pluck([])}\"\nputs \"Expected: [0, 1], Actual: #{pluck([5, 0, 3, 0, 4, 2])}\"\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Expected: [2, 1], Actual: [2, 1]\nExpected: [2, 1], Actual: [2, 1]\nExpected: [], Actual: []\nExpected: [0, 1], Actual: [0, 1]\nLoaded suite /tmp/tmp3tme_ur6\nStarted\n.\nFinished in 0.000414155 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2414.55 tests/s, 19316.44 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  i = 0\n  min_val = 10_000\n  min_i = 10_000\n  while i < arr.length\n    if arr[i] % 2 == 0\n      if arr[i] < min_val\n        min_val = arr[i]\n        min_i = i\n      end\n    end\n    i += 1\n  end\n  if min_val == 10_000\n    return []\n  else\n    return [min_val, min_i]\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpb_oyg5di\nStarted\n.\nFinished in 0.000412612 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2423.58 tests/s, 19388.68 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n    return [] if arr.empty?\n    even_numbers = arr.select { |e| e.even? }\n    return [] if even_numbers.empty?\n    even_numbers.sort!\n    target = even_numbers[0]\n    target_index = arr.index(target)\n    [target, target_index]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpnnyurhpr\nStarted\n.\nFinished in 0.000697262 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1434.18 tests/s, 11473.45 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    },
    {
      "exit_code": 1,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |val, index|\n    return [val, index] if val.even?\n  end\n  []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp2u6h39pf\nStarted\nF\n===============================================================================\nFailure: test_pluck(TestHumanEval)\n/tmp/tmp2u6h39pf.rb:36:in `test_pluck'\n     33: class TestHumanEval < Test::Unit::TestCase\n     34:   def test_pluck\n     35:     candidate = method(:pluck)\n  => 36:     assert_equal([2, 1], candidate.call([4, 2, 3]))\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\n     38:     assert_equal([], candidate.call([]))\n     39:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n<[2, 1]> expected but was\n<[4, 0]>\n\ndiff:\n? [2, 1]\n?  4  0 \n?  ?  ? \n===============================================================================\n\nFinished in 0.006639872 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n150.61 tests/s, 150.61 assertions/s\n",
      "timestamp": 1659823493
    },
    {
      "exit_code": 0,
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in a list, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n  return [] if arr.empty?\n  evens = arr.each_with_index.select { |x,_| x.even? }\n  evens.empty? ? [] : evens.min_by { |x,_| x }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpttzgggzz\nStarted\n.\nFinished in 0.00043737 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2286.39 tests/s, 18291.15 assertions/s\n",
      "stdout": "",
      "timestamp": 1659823493
    }
  ]
}