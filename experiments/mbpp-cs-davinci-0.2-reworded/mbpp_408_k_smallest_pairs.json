{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "cs",
  "prompt": "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\n    public static List<List<long>> KSmallestPairs(List<long> nums1, List<long> nums2, long k) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    public static void Main(string[] args) {\n    Debug.Assert(KSmallestPairs((new List<long>(new long[]{(long)1L, (long)3L, (long)7L})), (new List<long>(new long[]{(long)2L, (long)4L, (long)6L})), (2L)).Equals((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L}), (List<long>)new List<long>(new long[]{(long)1L, (long)4L})}))));\n    Debug.Assert(KSmallestPairs((new List<long>(new long[]{(long)1L, (long)3L, (long)7L})), (new List<long>(new long[]{(long)2L, (long)4L, (long)6L})), (1L)).Equals((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L})}))));\n    Debug.Assert(KSmallestPairs((new List<long>(new long[]{(long)1L, (long)3L, (long)7L})), (new List<long>(new long[]{(long)2L, (long)4L, (long)6L})), (7L)).Equals((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L}), (List<long>)new List<long>(new long[]{(long)1L, (long)4L}), (List<long>)new List<long>(new long[]{(long)3L, (long)2L}), (List<long>)new List<long>(new long[]{(long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)3L, (long)4L}), (List<long>)new List<long>(new long[]{(long)3L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)2L})}))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Insert(new Pair(0, 0, nums1[0] + nums2[0]));\n        visited.Add(\"0,0\");\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { nums1[pair.i], nums2[pair.j] });\n            if (pair.i + 1 < nums1.Count && !visited.Contains((pair.i + 1) + \",\" + pair.j)) {\n                minHeap.Insert(new Pair(pair.i + 1, pair.j, nums1[pair.i + 1] + nums2[pair.j]));\n                visited.Add((pair.i + 1) + \",\" + pair.j);\n            }\n            if (pair.j + 1 < nums2.Count && !visited.Contains(pair.i + \",\" + (pair.j + 1))) {\n                minHeap.Insert(new Pair(pair.i, pair.j + 1, nums1[pair.i] + nums2[pair.j + 1]));\n                visited.Add(pair.i + \",\" + (pair.j + 1));\n            }\n            k--;\n        }\n        return result;",
    "        // Assumptions:\n        // - nums1 and nums2 are not null\n        // - k >= 0\n        // Approach:\n        // - Use a min heap to store the pairs\n        // - For each element in nums1, add all pairs with nums2 to the heap\n        // - Pop the first k elements from the heap\n        // - Time complexity: O(n1 * n2 * log(k))\n        // - Space complexity: O(k)\n        var heap = new MinHeap<List<long>>();\n        foreach (var n1 in nums1) {\n            foreach (var n2 in nums2) {\n                heap.Add(new List<long> { n1, n2 });\n            }\n        }\n        var result = new List<List<long>>();\n        for (var i = 0; i < k; i++) {\n            result.Add(heap.Pop());\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // sort the first list\n        nums1.Sort();\n        // sort the second list\n        nums2.Sort();\n        // create a min heap\n        Heap<List<long>> minHeap = new Heap<List<long>>(nums1.Count * nums2.Count);\n        // add the first element from the first list and the first element from the second list\n        minHeap.Add(new List<long> { nums1[0], nums2[0] });\n        // create a hash set to store the pairs already added to the heap\n        HashSet<string> visited = new HashSet<string>();\n        visited.Add(nums1[0] + \",\" + nums2[0]);\n        // loop until the heap is empty or we have added k pairs\n        while (minHeap.Count > 0 && result.Count < k) {\n            // get the smallest pair from the heap\n            List<long> pair = minHeap.Remove();\n            // add the pair to the result\n            result.Add(pair);\n            // get the first element from the pair\n            long first = pair[0];\n            // get the second element from the pair\n            long second = pair[1];\n            // if the first element is not the last element in the first list\n            if (first < nums1[nums1.Count - 1]) {\n                // get the index of the first element in the first list\n                int firstIndex = nums1.IndexOf(first);\n                // get the next element in the first list\n                long nextFirst = nums1[firstIndex + 1];\n                // create a string to store the pair\n                string nextPair = nextFirst + \",\" + second;\n                // if the pair has not been added to the heap\n                if (!visited.Contains(nextPair)) {\n                    // add the pair to the heap\n                    minHeap.Add(new List<long> { nextFirst, second });\n                    // add the pair to the hash set",
    "        List<List<long>> result = new List<List<long>>();\n        // TODO: Write your code here\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        for (int i = 0; i < k && minHeap.Count > 0; i++) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Add(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \",\" + 0);\n        while (result.Count < k && minHeap.Count > 0) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { pair.First, pair.Second });\n            var i = pair.FirstIndex;\n            var j = pair.SecondIndex;\n            if (i + 1 < nums1.Count && !visited.Contains((i + 1) + \",\" + j)) {\n                minHeap.Add(new Pair(nums1[i + 1], nums2[j], i + 1, j));\n                visited.Add((i + 1) + \",\" + j);\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(i + \",\" + (j + 1))) {\n                minHeap.Add(new Pair(nums1[i], nums2[j + 1], i, j + 1));\n                visited.Add(i + \",\" + (j + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list.\n        nums1.Sort();\n        // Sort the second list.\n        nums2.Sort();\n        // Create a heap to store the pairs.\n        Heap<List<long>> heap = new Heap<List<long>>();\n        // Create a set to store the pairs.\n        HashSet<List<long>> set = new HashSet<List<long>>();\n        // Add the first pair to the heap.\n        heap.Add(new List<long>() { nums1[0], nums2[0] });\n        // Add the first pair to the set.\n        set.Add(new List<long>() { nums1[0], nums2[0] });\n        // While the heap is not empty and the result size is less than k.\n        while (heap.Count > 0 && result.Count < k) {\n            // Get the first pair.\n            List<long> pair = heap.Get();\n            // Add the pair to the result.\n            result.Add(pair);\n            // Get the first element of the pair.\n            long first = pair[0];\n            // Get the second element of the pair.\n            long second = pair[1];\n            // If the first element is not the last element of the first list.\n            if (first != nums1[nums1.Count - 1]) {\n                // Create a new pair.\n                List<long> newPair = new List<long>() { nums1[nums1.IndexOf(first) + 1], second };\n                // If the new pair is not in the set.\n                if (!set.Contains(newPair)) {\n                    // Add the new pair to the heap.\n                    heap.Add(newPair);\n                    // Add the new pair to the set.\n                    set.Add(newPair);\n                }\n            }\n            // If the second element is not the last element of the second list.\n            if (second != nums2[nums",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (minHeap.Count < k) {\n                    minHeap.Insert(new List<long> { nums1[i], nums2[j] });\n                } else if (sum < minHeap.Peek().Sum()) {\n                    minHeap.Pop();\n                    minHeap.Insert(new List<long> { nums1[i], nums2[j] });\n                }\n            }\n        }\n        while (minHeap.Count > 0) {\n            result.Add(minHeap.Pop());\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        if (k > nums1.Count * nums2.Count) {\n            k = nums1.Count * nums2.Count;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            long sum = sums[i];\n            for (int j = 0; j < nums1.Count; j++) {\n                for (int l = 0; l < nums2.Count; l++) {\n                    if (nums1[j] + nums2[l] == sum) {\n                        List<long> pair = new List<long>();\n                        pair.Add(nums1[j]);\n                        pair.Add(nums2[l]);\n                        result.Add(pair);\n                        break;\n                    }\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Add(new Pair(0, 0, nums1[0] + nums2[0]));\n        visited.Add(\"0,0\");\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { nums1[pair.i], nums2[pair.j] });\n            k--;\n            if (pair.i + 1 < nums1.Count && !visited.Contains((pair.i + 1) + \",\" + pair.j)) {\n                minHeap.Add(new Pair(pair.i + 1, pair.j, nums1[pair.i + 1] + nums2[pair.j]));\n                visited.Add((pair.i + 1) + \",\" + pair.j);\n            }\n            if (pair.j + 1 < nums2.Count && !visited.Contains(pair.i + \",\" + (pair.j + 1))) {\n                minHeap.Add(new Pair(pair.i, pair.j + 1, nums1[pair.i] + nums2[pair.j + 1]));\n                visited.Add(pair.i + \",\" + (pair.j + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var heap = new Heap<Tuple<long, long, long>>(k);\n        var visited = new HashSet<Tuple<long, long>>();\n        var start = new Tuple<long, long, long>(0, 0, nums1[0] + nums2[0]);\n        heap.Push(start);\n        visited.Add(new Tuple<long, long>(0, 0));\n        while (heap.Count > 0) {\n            var current = heap.Pop();\n            result.Add(new List<long> { nums1[current.Item1], nums2[current.Item2] });\n            if (result.Count == k) {\n                break;\n            }\n            var next1 = new Tuple<long, long, long>(current.Item1 + 1, current.Item2, nums1[current.Item1 + 1] + nums2[current.Item2]);\n            var next2 = new Tuple<long, long, long>(current.Item1, current.Item2 + 1, nums1[current.Item1] + nums2[current.Item2 + 1]);\n            if (current.Item1 + 1 < nums1.Count && !visited.Contains(new Tuple<long, long>(current.Item1 + 1, current.Item2))) {\n                heap.Push(next1);\n                visited.Add(new Tuple<long, long>(current.Item1 + 1, current.Item2));\n            }\n            if (current.Item2 + 1 < nums2.Count && !visited.Contains(new Tuple<long, long>(current.Item1, current.Item2 + 1))) {\n                heap.Push(next2);\n                visited.Add(new Tuple<long, long>(current.Item1, current.Item2 + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the two lists.\n        nums1.Sort();\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap heap = new MinHeap(nums1.Count);\n        // Add the first pair to the heap.\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // Add the first pair to the result.\n        result.Add(new List<long> { nums1[0], nums2[0] });\n        // Create a set to keep track of the pairs that have been added to the heap.\n        HashSet<string> set = new HashSet<string>();\n        set.Add(nums1[0].ToString() + \",\" + nums2[0].ToString());\n        // Loop until the heap is empty or we have found k pairs.\n        while (heap.Count > 0 && result.Count < k) {\n            // Get the pair with the smallest sum.\n            Pair pair = heap.Remove();\n            // Get the indices of the pair.\n            int i = pair.i;\n            int j = pair.j;\n            // Add the next pair with the same first element to the heap.\n            if (i + 1 < nums1.Count) {\n                string key = nums1[i + 1].ToString() + \",\" + nums2[j].ToString();\n                if (!set.Contains(key)) {\n                    heap.Add(new Pair(nums1[i + 1], nums2[j], i + 1, j));\n                    set.Add(key);\n                }\n            }\n            // Add the next pair with the same second element to the heap.\n            if (j + 1 < nums2.Count) {\n                string key = nums1[i].ToString() + \",\" + nums2[j + 1].ToString();\n                if (!set.Contains(key)) {\n                    heap.Add(new Pair(nums1[",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0)\n            return result;\n        var minHeap = new MinHeap(k);\n        for (int i = 0; i < nums1.Count; i++)\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        while (minHeap.Count > 0 && k > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1)\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap(k);\n        for (long i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[(int)i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            k--;\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[(int)pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        // Assumptions:\n        // - nums1 and nums2 are sorted\n        // - k is non-negative\n        // - nums1 and nums2 are not empty\n        // - k is less than or equal to the number of pairs\n        // Approach:\n        // - Use a min-heap to store the pairs\n        // - Add the first pair to the heap\n        // - Pop the minimum pair from the heap and add the next pair with the same first element\n        // - Repeat until k pairs have been popped\n        // Complexity:\n        // - Time: O(k log k)\n        // - Space: O(k)\n        var heap = new MinHeap<Pair>();\n        var result = new List<List<long>>();\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        for (long i = 0; i < k; i++) {\n            var pair = heap.Pop();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                heap.Add(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var pq = new PriorityQueue<List<long>>(k);\n        foreach (var n1 in nums1) {\n            foreach (var n2 in nums2) {\n                var sum = n1 + n2;\n                var pair = new List<long> { n1, n2 };\n                if (pq.Count < k) {\n                    pq.Enqueue(pair, sum);\n                } else {\n                    if (pq.PeekPriority() > sum) {\n                        pq.Dequeue();\n                        pq.Enqueue(pair, sum);\n                    }\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Dequeue());\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                minHeap.Insert(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(minHeap.Remove());\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            result.Add(new List<long>());\n            result[i].Add(sums[i]);\n            result[i].Add(sums[i] - nums1[0]);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Add(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Add(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \",\" + 0);\n        while (minHeap.Count > 0 && k > 0) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { pair.First, pair.Second });\n            k--;\n            var first = pair.FirstIndex;\n            var second = pair.SecondIndex;\n            if (first + 1 < nums1.Count && !visited.Contains((first + 1) + \",\" + second)) {\n                minHeap.Add(new Pair(nums1[first + 1], nums2[second], first + 1, second));\n                visited.Add((first + 1) + \",\" + second);\n            }\n            if (second + 1 < nums2.Count && !visited.Contains(first + \",\" + (second + 1))) {\n                minHeap.Add(new Pair(nums1[first], nums2[second + 1], first, second + 1));\n                visited.Add(first + \",\" + (second + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Create a min heap to store the pairs.\n        MinHeap<List<long>> minHeap = new MinHeap<List<long>>();\n        // Create a set to store the pairs which have been added to the min heap.\n        HashSet<string> set = new HashSet<string>();\n        // Add the first pair to the min heap.\n        minHeap.Add(new List<long>() { nums1[0], nums2[0] });\n        set.Add(nums1[0].ToString() + \",\" + nums2[0].ToString());\n        // Add the pairs to the min heap.\n        while (result.Count < k && minHeap.Count > 0) {\n            List<long> pair = minHeap.Remove();\n            result.Add(pair);\n            long num1 = pair[0];\n            long num2 = pair[1];\n            if (nums1.IndexOf(num1) + 1 < nums1.Count) {\n                long num1Next = nums1[nums1.IndexOf(num1) + 1];\n                if (!set.Contains(num1Next.ToString() + \",\" + num2.ToString())) {\n                    minHeap.Add(new List<long>() { num1Next, num2 });\n                    set.Add(num1Next.ToString() + \",\" + num2.ToString());\n                }\n            }\n            if (nums2.IndexOf(num2) + 1 < nums2.Count) {\n                long num2Next = nums2[nums2.IndexOf(num2) + 1];\n                if (!set.Contains(num1.ToString() + \",\" + num2Next.ToString())) {\n                    minHeap.Add(new List<long>() { num1, num2Next });\n                    set.Add(num1.ToString() + \",\" + num2Next.ToString());\n                }\n            }",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<Pair>();\n        var visited = new HashSet<Pair>();\n        minHeap.Add(new Pair(0, 0, nums1[0] + nums2[0]));\n        visited.Add(new Pair(0, 0, nums1[0] + nums2[0]));\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Pop();\n            result.Add(new List<long> { nums1[pair.i], nums2[pair.j] });\n            k--;\n            if (pair.i + 1 < nums1.Count) {\n                var newPair = new Pair(pair.i + 1, pair.j, nums1[pair.i + 1] + nums2[pair.j]);\n                if (!visited.Contains(newPair)) {\n                    minHeap.Add(newPair);\n                    visited.Add(newPair);\n                }\n            }\n            if (pair.j + 1 < nums2.Count) {\n                var newPair = new Pair(pair.i, pair.j + 1, nums1[pair.i] + nums2[pair.j + 1]);\n                if (!visited.Contains(newPair)) {\n                    minHeap.Add(newPair);\n                    visited.Add(newPair);\n                }\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list and the second list.\n        nums1.Sort();\n        nums2.Sort();\n        // Create a min heap to store the pairs.\n        MinHeap<List<long>> minHeap = new MinHeap<List<long>>();\n        // Create a set to store the pairs.\n        HashSet<List<long>> set = new HashSet<List<long>>();\n        // Add the first pair to the heap and set.\n        minHeap.Add(new List<long> { nums1[0], nums2[0] });\n        set.Add(new List<long> { nums1[0], nums2[0] });\n        // Add the pairs to the heap and set.\n        for (int i = 0; i < k; i++) {\n            // Get the pair with the smallest sum.\n            List<long> pair = minHeap.Remove();\n            // Add the pair to the result.\n            result.Add(pair);\n            // Get the next pair with the first element of the pair.\n            long first = pair[0];\n            long second = pair[1];\n            // If the first element is the last element of the first list, then we don't need to add the next pair.\n            if (first == nums1[nums1.Count - 1]) {\n                continue;\n            }\n            // Add the next pair to the heap and set.\n            int index = nums1.BinarySearch(first);\n            List<long> nextPair = new List<long> { nums1[index + 1], second };\n            if (!set.Contains(nextPair)) {\n                minHeap.Add(nextPair);\n                set.Add(nextPair);\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<Tuple<long, long, long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                heap.Insert(new Tuple<long, long, long>(sum, nums1[i], nums2[j]));\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var tuple = heap.Extract();\n            result.Add(new List<long>() { tuple.Item2, tuple.Item3 });\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        if (k == 0) return result;\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        long sum = sums[(int)k - 1];\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                if (nums1[i] + nums2[j] <= sum) {\n                    result.Add(new List<long> { nums1[i], nums2[j] });\n                }\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort nums1 and nums2.\n        nums1.Sort();\n        nums2.Sort();\n        // Create a heap of size k.\n        Heap heap = new Heap(k);\n        // Add the first k pairs to the heap.\n        for (int i = 0; i < k && i < nums1.Count; i++) {\n            heap.Add(new Pair(nums1[i], nums2[0], 0));\n        }\n        // Add the rest of the pairs to the heap.\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 1; j < nums2.Count; j++) {\n                heap.Add(new Pair(nums1[i], nums2[j], j));\n            }\n        }\n        // Pop the pairs from the heap.\n        while (heap.Size() > 0) {\n            Pair pair = heap.Pop();\n            result.Add(new List<long>() { pair.n1, pair.n2 });\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> sums = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!sums.ContainsKey(sum)) {\n                    sums.Add(sum, new List<List<long>>());\n                }\n                sums[sum].Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        foreach (long key in sums.Keys) {\n            foreach (List<long> pair in sums[key]) {\n                if (result.Count == k) {\n                    return result;\n                }\n                result.Add(pair);\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (pq.Count < k) {\n                    pq.Enqueue(new List<long> { nums1[i], nums2[j] });\n                } else {\n                    if (sum < pq.Peek()[0] + pq.Peek()[1]) {\n                        pq.Dequeue();\n                        pq.Enqueue(new List<long> { nums1[i], nums2[j] });\n                    }\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Dequeue());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<List<long>>(k);\n        var visited = new HashSet<List<long>>();\n        var firstPair = new List<long> { nums1[0], nums2[0] };\n        minHeap.Add(firstPair);\n        visited.Add(firstPair);\n        while (result.Count < k && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(pair);\n            var first = pair[0];\n            var second = pair[1];\n            var nextPair1 = new List<long> { first, second + 1 };\n            var nextPair2 = new List<long> { first + 1, second };\n            if (second + 1 < nums2.Count && !visited.Contains(nextPair1)) {\n                minHeap.Add(nextPair1);\n                visited.Add(nextPair1);\n            }\n            if (first + 1 < nums1.Count && !visited.Contains(nextPair2)) {\n                minHeap.Add(nextPair2);\n                visited.Add(nextPair2);\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list.\n        nums1.Sort();\n        // Sort the second list.\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap<long> minHeap = new MinHeap<long>();\n        // Add the first pair to the min heap.\n        minHeap.Add(nums1[0] + nums2[0], new List<long>() { nums1[0], nums2[0] });\n        // Create a hash set to keep track of the pairs we have already added to the min heap.\n        HashSet<string> hashSet = new HashSet<string>();\n        hashSet.Add(nums1[0].ToString() + \",\" + nums2[0].ToString());\n        // While the min heap is not empty and we have not added k pairs to the result.\n        while (minHeap.Count > 0 && result.Count < k) {\n            // Get the pair with the smallest sum.\n            List<long> pair = minHeap.RemoveMin();\n            // Add the pair to the result.\n            result.Add(pair);\n            // Get the first element of the pair.\n            long first = pair[0];\n            // Get the second element of the pair.\n            long second = pair[1];\n            // If the first element is not the last element of the first list.\n            if (first != nums1[nums1.Count - 1]) {\n                // Get the index of the first element in the first list.\n                int index = nums1.IndexOf(first);\n                // Get the next element in the first list.\n                long next = nums1[index + 1];\n                // If the pair has not been added to the min heap.\n                if (!hashSet.Contains(next.ToString() + \",\" + second.ToString())) {\n                    // Add the pair to the min heap.\n                    minHeap.Add(next + second, new List<long>()",
    "        // Assume that nums1 and nums2 are sorted.\n        var pairs = new List<List<long>>();\n        var heap = new Heap<long>();\n        for (var i = 0; i < nums1.Count; i++) {\n            for (var j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (heap.Count < k) {\n                    heap.Insert(sum);\n                } else if (sum < heap.Peek()) {\n                    heap.Pop();\n                    heap.Insert(sum);\n                }\n            }\n        }\n        while (heap.Count > 0) {\n            var sum = heap.Pop();\n            var pair = new List<long>();\n            for (var i = 0; i < nums1.Count; i++) {\n                for (var j = 0; j < nums2.Count; j++) {\n                    if (nums1[i] + nums2[j] == sum) {\n                        pair.Add(nums1[i]);\n                        pair.Add(nums2[j]);\n                        pairs.Add(pair);\n                        break;\n                    }\n                }\n            }\n        }\n        return pairs;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0 || k == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new Pair(nums1[i], nums2[0], 0));\n        }\n        for (int i = 0; i < k && !minHeap.IsEmpty(); i++) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.Index < nums2.Count - 1) {\n                minHeap.Add(new Pair(pair.First, nums2[pair.Index + 1], pair.Index + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (minHeap.Count < k) {\n                    minHeap.Add(new List<long> { nums1[i], nums2[j] });\n                } else {\n                    if (sum < minHeap.Peek()[0] + minHeap.Peek()[1]) {\n                        minHeap.Remove();\n                        minHeap.Add(new List<long> { nums1[i], nums2[j] });\n                    }\n                }\n            }\n        }\n        while (minHeap.Count > 0) {\n            result.Add(minHeap.Remove());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap(nums1.Count * nums2.Count);\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                minHeap.Insert(new List<long> { nums1[(int)i], nums2[(int)j] });\n            }\n        }\n        for (long i = 0; i < k; i++) {\n            result.Add(minHeap.ExtractMin());\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> dict = new SortedDictionary<long, List<List<long>>>();\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                long sum = nums1[(int)i] + nums2[(int)j];\n                if (!dict.ContainsKey(sum)) {\n                    dict.Add(sum, new List<List<long>>());\n                }\n                dict[sum].Add(new List<long>() { nums1[(int)i], nums2[(int)j] });\n            }\n        }\n        foreach (long key in dict.Keys) {\n            foreach (List<long> pair in dict[key]) {\n                if (result.Count == k) {\n                    return result;\n                }\n                result.Add(pair);\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                pq.Enqueue(new List<long> { sum, i, j });\n            }\n        }\n        while (k > 0 && pq.Count > 0) {\n            var pair = pq.Dequeue();\n            result.Add(new List<long> { nums1[(int)pair[1]], nums2[(int)pair[2]] });\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<Tuple<long, long, long>>(k);\n        for (long i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new Tuple<long, long, long>(nums1[(int)i] + nums2[0], i, 0));\n        }\n        for (long i = 0; i < k && minHeap.Count > 0; i++) {\n            var current = minHeap.ExtractMin();\n            result.Add(new List<long>() { nums1[(int)current.Item2], nums2[(int)current.Item3] });\n            if (current.Item3 + 1 < nums2.Count) {\n                minHeap.Add(new Tuple<long, long, long>(nums1[(int)current.Item2] + nums2[(int)current.Item3 + 1], current.Item2, current.Item3 + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list in ascending order.\n        nums1.Sort();\n        // Sort the second list in descending order.\n        nums2.Sort();\n        nums2.Reverse();\n        // Create a min heap of size k.\n        MinHeap heap = new MinHeap(k);\n        // Add the first k pairs to the heap.\n        for (long i = 0; i < k && i < nums1.Count; i++) {\n            heap.Insert(new List<long>() { nums1[(int)i], nums2[0] });\n        }\n        // For each element in the first list, add the next element from the second list to the heap.\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 1; j < nums2.Count; j++) {\n                heap.Insert(new List<long>() { nums1[(int)i], nums2[(int)j] });\n                break;\n            }\n        }\n        // Pop all elements from the heap and add them to the result.\n        while (heap.Size > 0) {\n            result.Add(heap.Pop());\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0 || k == 0) {\n            return result;\n        }\n        // Sort the first list.\n        nums1.Sort();\n        // Sort the second list.\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap<long> minHeap = new MinHeap<long>();\n        // Add the first pair to the min heap.\n        minHeap.Add(nums1[0] + nums2[0], new List<long> { nums1[0], nums2[0] });\n        // Create a hash set to store the pairs we've seen.\n        HashSet<List<long>> seen = new HashSet<List<long>>();\n        seen.Add(new List<long> { nums1[0], nums2[0] });\n        // While we haven't found k pairs.\n        while (result.Count < k) {\n            // Remove the smallest pair from the min heap.\n            List<long> pair = minHeap.RemoveMin();\n            // Add the pair to the result.\n            result.Add(pair);\n            // Get the first number in the pair.\n            long first = pair[0];\n            // Get the second number in the pair.\n            long second = pair[1];\n            // If the first number is not the last number in the first list.\n            if (first != nums1[nums1.Count - 1]) {\n                // Create a new pair with the next number in the first list.\n                List<long> newPair = new List<long> { nums1[nums1.IndexOf(first) + 1], second };\n                // If we haven't seen the new pair.\n                if (!seen.Contains(newPair)) {\n                    // Add the new pair to the min heap.\n                    minHeap.Add(newPair[0] + newPair[1], newPair);\n                    // Add the new pair to the hash set.\n                    seen.Add(newPair);\n                }\n            }\n            // If the",
    "        var result = new List<List<long>>();\n        var heap = new Heap<Tuple<long, long>>(k, (a, b) => a.Item1 + a.Item2 < b.Item1 + b.Item2);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                heap.Add(new Tuple<long, long>(nums1[i], nums2[j]));\n            }\n        }\n        while (heap.Count > 0) {\n            var pair = heap.Remove();\n            result.Add(new List<long>() { pair.Item1, pair.Item2 });\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<(long, long)>();\n        minHeap.Add(new Tuple<long, long>(0, 0));\n        visited.Add((0, 0));\n        while (k > 0 && minHeap.Count > 0) {\n            var current = minHeap.Pop();\n            var i = current.Item1;\n            var j = current.Item2;\n            result.Add(new List<long> { nums1[(int)i], nums2[(int)j] });\n            k--;\n            if (i + 1 < nums1.Count && !visited.Contains((i + 1, j))) {\n                minHeap.Add(new Tuple<long, long>(i + 1, j));\n                visited.Add((i + 1, j));\n            }\n            if (j + 1 < nums2.Count && !visited.Contains((i, j + 1))) {\n                minHeap.Add(new Tuple<long, long>(i, j + 1));\n                visited.Add((i, j + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Create a min heap of size k\n        MinHeap minHeap = new MinHeap(k);\n        // Add the first k pairs to the heap\n        for (int i = 0; i < k && i < nums1.Count; i++) {\n            minHeap.Add(new List<long> { nums1[i], nums2[0], 0 });\n        }\n        // While the heap is not empty\n        while (minHeap.Size > 0) {\n            // Remove the top element from the heap\n            List<long> pair = minHeap.Remove();\n            // Add the pair to the result\n            result.Add(new List<long> { pair[0], pair[1] });\n            // If the pair's second element is not the last element in nums2\n            if (pair[2] < nums2.Count - 1) {\n                // Add the next pair to the heap\n                minHeap.Add(new List<long> { pair[0], nums2[(int)pair[2] + 1], pair[2] + 1 });\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(new List<long> { nums1[0], nums2[0] }, (a, b) => a[0] + a[1] < b[0] + b[1]);\n        var visited = new HashSet<List<long>>();\n        visited.Add(new List<long> { 0, 0 });\n        while (k > 0 && pq.Count > 0) {\n            var pair = pq.Dequeue();\n            result.Add(pair);\n            k--;\n            var i = pair[0];\n            var j = pair[1];\n            if (i + 1 < nums1.Count && !visited.Contains(new List<long> { i + 1, j })) {\n                pq.Enqueue(new List<long> { i + 1, j });\n                visited.Add(new List<long> { i + 1, j });\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(new List<long> { i, j + 1 })) {\n                pq.Enqueue(new List<long> { i, j + 1 });\n                visited.Add(new List<long> { i, j + 1 });\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<long>(nums1.Count * nums2.Count);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                heap.Insert(nums1[i] + nums2[j]);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var sum = heap.ExtractMin();\n            var pair = new List<long>();\n            pair.Add(sum / nums2.Count);\n            pair.Add(sum % nums2.Count);\n            result.Add(pair);\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the lists\n        nums1.Sort();\n        nums2.Sort();\n        // Create a heap of size k\n        Heap<List<long>> heap = new Heap<List<long>>(k, (a, b) => a[0] + a[1] < b[0] + b[1]);\n        // Add the first k pairs to the heap\n        for (int i = 0; i < k && i < nums1.Count && i < nums2.Count; i++) {\n            heap.Add(new List<long>() { nums1[i], nums2[i] });\n        }\n        // Add the rest of the pairs to the heap\n        for (int i = k; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                List<long> pair = new List<long>() { nums1[i], nums2[j] };\n                if (heap.Count < k) {\n                    heap.Add(pair);\n                } else if (pair[0] + pair[1] < heap.Peek()[0] + heap.Peek()[1]) {\n                    heap.Pop();\n                    heap.Add(pair);\n                }\n            }\n        }\n        // Add the heap to the result\n        while (heap.Count > 0) {\n            result.Add(heap.Pop());\n        }\n        // Return the result\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (sums.IndexOf(sum) < k) {\n                    result.Add(new List<long> { nums1[i], nums2[j] });\n                }\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        pairs.Sort((a, b) => (int)(a[0] + a[1] - b[0] - b[1]));\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[i]);\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list in ascending order.\n        nums1.Sort();\n        // Sort the second list in descending order.\n        nums2.Sort((a, b) => b.CompareTo(a));\n        // Create a min heap of size k.\n        MinHeap<long> minHeap = new MinHeap<long>(k);\n        // Add the first k elements of the second list to the min heap.\n        for (long i = 0; i < k && i < nums2.Count; i++) {\n            minHeap.Add(nums2[(int)i]);\n        }\n        // Iterate over the first list.\n        foreach (long num in nums1) {\n            // Iterate over the second list.\n            foreach (long num2 in nums2) {\n                // If the sum of the current elements is less than the minimum element in the min heap, add it to the min heap.\n                if (num + num2 < minHeap.Peek()) {\n                    minHeap.Add(num + num2);\n                }\n            }\n        }\n        // Iterate over the min heap.\n        while (minHeap.Count > 0) {\n            // Pop the minimum element from the min heap.\n            long min = minHeap.Pop();\n            // Find the first element in the first list that is less than the minimum element.\n            long num1 = nums1.Find(x => x < min);\n            // Find the first element in the second list that is less than the minimum element.\n            long num2 = nums2.Find(x => x < min);\n            // Add the pair to the result.\n            result.Add(new List<long>() { num1, num2 });\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list.\n        nums1.Sort();\n        // Sort the second list.\n        nums2.Sort();\n        // Initialize the heap.\n        List<List<long>> heap = new List<List<long>>();\n        heap.Add(new List<long> { nums1[0] + nums2[0], 0, 0 });\n        // Initialize the visited array.\n        bool[,] visited = new bool[nums1.Count, nums2.Count];\n        visited[0, 0] = true;\n        // Start the loop.\n        while (result.Count < k && heap.Count > 0) {\n            // Extract the minimum from the heap.\n            List<long> current = heap[0];\n            heap.RemoveAt(0);\n            // Add the current pair to the result.\n            result.Add(new List<long> { nums1[(int)current[1]], nums2[(int)current[2]] });\n            // Add the next pair to the heap.\n            if (current[1] + 1 < nums1.Count && !visited[(int)current[1] + 1, (int)current[2]]) {\n                heap.Add(new List<long> { nums1[(int)current[1] + 1] + nums2[(int)current[2]], current[1] + 1, current[2] });\n                visited[(int)current[1] + 1, (int)current[2]] = true;\n            }\n            if (current[2] + 1 < nums2.Count && !visited[(int)current[1], (int)current[2] + 1]) {\n                heap.Add(new List<long> { nums1[(int)current[1]] + nums2[(int)current[2] + 1], current[1], current[2] + 1 });\n                visited[(int)current[1], (int)current[",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        pairs.Sort((a, b) => (int)(a[0] + a[1] - b[0] - b[1]));\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[i]);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Add(new Pair(nums1[0], nums2[0]));\n        visited.Add(nums1[0] + \",\" + nums2[0]);\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { pair.First, pair.Second });\n            k--;\n            var first = pair.First;\n            var second = pair.Second;\n            if (first + 1 < nums1.Count && !visited.Contains(first + 1 + \",\" + second)) {\n                minHeap.Add(new Pair(first + 1, second));\n                visited.Add(first + 1 + \",\" + second);\n            }\n            if (second + 1 < nums2.Count && !visited.Contains(first + \",\" + (second + 1))) {\n                minHeap.Add(new Pair(first, second + 1));\n                visited.Add(first + \",\" + (second + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<Tuple<long, long, long>>(false);\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                heap.Add(new Tuple<long, long, long>(nums1[i] + nums2[j], i, j));\n            }\n        }\n        while (k > 0 && heap.Count > 0) {\n            var t = heap.Pop();\n            result.Add(new List<long> { nums1[t.Item2], nums2[t.Item3] });\n            k--;\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        for (int i = 0; i < k && !minHeap.IsEmpty(); i++) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<Tuple<long, long, long>>(Comparer<Tuple<long, long, long>>.Create((a, b) => a.Item3.CompareTo(b.Item3)));\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                heap.Insert(new Tuple<long, long, long>(i, j, nums1[i] + nums2[j]));\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var item = heap.Extract();\n            if (item == null) {\n                break;\n            }\n            result.Add(new List<long> { nums1[(int)item.Item1], nums2[(int)item.Item2] });\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0 || k == 0) {\n            return result;\n        }\n        // Sort the lists\n        nums1.Sort();\n        nums2.Sort();\n        // Create a heap of size k\n        Heap<List<long>> heap = new Heap<List<long>>(k, new List<long>());\n        // Add the first pair to the heap\n        heap.Add(new List<long>() { nums1[0], nums2[0] });\n        // Create a set to keep track of the pairs we've already seen\n        HashSet<List<long>> seen = new HashSet<List<long>>();\n        seen.Add(heap.Peek());\n        // While the heap is not empty\n        while (heap.Count > 0) {\n            // Remove the smallest pair from the heap\n            List<long> pair = heap.Remove();\n            // Add the pair to the result\n            result.Add(pair);\n            // If we've seen all the pairs, we're done\n            if (result.Count == k) {\n                break;\n            }\n            // Find the next pair for the first element in the pair\n            long next1 = pair[0] + 1;\n            if (next1 < nums1.Count) {\n                List<long> nextPair = new List<long>() { next1, pair[1] };\n                // If we haven't seen the pair before, add it to the heap\n                if (!seen.Contains(nextPair)) {\n                    heap.Add(nextPair);\n                    seen.Add(nextPair);\n                }\n            }\n            // Find the next pair for the second element in the pair\n            long next2 = pair[1] + 1;\n            if (next2 < nums2.Count) {\n                List<long> nextPair = new List<long>() { pair[0], next2 };\n                // If we haven't seen the pair before, add it to the heap\n                if (!seen.Contains(nextPair)) {\n                    heap.Add(next",
    "        var result = new List<List<long>>();\n        var pq = new PriorityQueue<List<long>>((a, b) => a[0] + a[1] > b[0] + b[1]);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pq.Enqueue(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(pq.Dequeue());\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        Dictionary<long, List<long>> nums1Map = new Dictionary<long, List<long>>();\n        foreach (long num in nums1) {\n            if (!nums1Map.ContainsKey(num)) {\n                nums1Map.Add(num, new List<long>());\n            }\n            nums1Map[num].Add(num);\n        }\n        Dictionary<long, List<long>> nums2Map = new Dictionary<long, List<long>>();\n        foreach (long num in nums2) {\n            if (!nums2Map.ContainsKey(num)) {\n                nums2Map.Add(num, new List<long>());\n            }\n            nums2Map[num].Add(num);\n        }\n        Dictionary<long, List<long>> sumMap = new Dictionary<long, List<long>>();\n        foreach (long num1 in nums1) {\n            foreach (long num2 in nums2) {\n                long sum = num1 + num2;\n                if (!sumMap.ContainsKey(sum)) {\n                    sumMap.Add(sum, new List<long>());\n                }\n                sumMap[sum].Add(num1);\n                sumMap[sum].Add(num2);\n            }\n        }\n        List<long> sums = sumMap.Keys.ToList();\n        sums.Sort();\n        for (int i = 0; i < sums.Count; i++) {\n            long sum = sums[i];\n            List<long> pair = sumMap[sum];\n            long num1 = pair[0];\n            long num2 = pair[1];\n            if (nums1Map[num1].Count > 0 && nums2Map[num2].Count > 0) {\n                result.Add(new List<long>() { num1, num2 });\n                nums1Map[num1].RemoveAt(0);\n                nums2Map[num",
    "        var result = new List<List<long>>();\n        var heap = new Heap<long>();\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                heap.Add(nums1[(int)i] + nums2[(int)j]);\n            }\n        }\n        for (long i = 0; i < k; i++) {\n            var sum = heap.ExtractMin();\n            var pair = new List<long>();\n            pair.Add(sum / nums2.Count);\n            pair.Add(sum % nums2.Count);\n            result.Add(pair);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        var pq = new PriorityQueue<List<long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (pq.Count < k) {\n                    pq.Add(new List<long> { nums1[i], nums2[j] });\n                } else if (sum < pq.Peek()[0] + pq.Peek()[1]) {\n                    pq.Remove();\n                    pq.Add(new List<long> { nums1[i], nums2[j] });\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Remove());\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list\n        nums1.Sort();\n        // Sort the second list\n        nums2.Sort();\n        // Create a min heap of size k\n        MinHeap<List<long>> minHeap = new MinHeap<List<long>>(k);\n        // Add the first k pairs to the heap\n        for (int i = 0; i < k && i < nums1.Count; i++) {\n            minHeap.Add(new List<long>() { nums1[i], nums2[0], 0 });\n        }\n        // Add the rest of the pairs to the heap\n        while (minHeap.Count > 0) {\n            // Get the pair with the smallest sum\n            List<long> pair = minHeap.Remove();\n            // Add the pair to the result\n            result.Add(new List<long>() { pair[0], pair[1] });\n            // Get the index of the second element in the pair\n            long index = pair[2];\n            // If the index is less than the length of the second list, add the next pair to the heap\n            if (index < nums2.Count - 1) {\n                minHeap.Add(new List<long>() { pair[0], nums2[index + 1], index + 1 });\n            }\n        }\n        return result;",
    "        // Assume nums1 and nums2 are sorted in ascending order.\n        // Assume k is not greater than the number of pairs.\n        // Assume nums1 and nums2 are not empty.\n        // Assume k is not negative.\n        // Assume nums1 and nums2 have no duplicates.\n        // Assume nums1 and nums2 have no zeros.\n        // Assume nums1 and nums2 have no negative numbers.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        // Assume nums1 and nums2 have no numbers greater than 2^32.\n        //",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // sort the first list\n        nums1.Sort();\n        // sort the second list\n        nums2.Sort();\n        // initialize the heap\n        Heap<List<long>> heap = new Heap<List<long>>(false);\n        // add the first pair to the heap\n        heap.Add(new List<long>() { nums1[0], nums2[0], 0, 0 });\n        // add the pairs to the result\n        while (k > 0 && heap.Count > 0) {\n            // get the pair with the smallest sum\n            List<long> pair = heap.Remove();\n            result.Add(new List<long>() { pair[0], pair[1] });\n            // add the next pair to the heap\n            if (pair[2] < nums1.Count - 1) {\n                heap.Add(new List<long>() { nums1[(int)pair[2] + 1], nums2[(int)pair[3]], pair[2] + 1, pair[3] });\n            }\n            // add the next pair to the heap\n            if (pair[2] == 0 && pair[3] < nums2.Count - 1) {\n                heap.Add(new List<long>() { nums1[(int)pair[2]], nums2[(int)pair[3] + 1], pair[2], pair[3] + 1 });\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        for (int i = 0; i < k && !minHeap.IsEmpty(); i++) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list\n        nums1.Sort();\n        // Sort the second list\n        nums2.Sort();\n        // Create a min heap\n        MinHeap heap = new MinHeap();\n        // Add the first pair to the heap\n        heap.Insert(new Pair(nums1[0], nums2[0]));\n        // Add the first pair to the result\n        result.Add(new List<long>() { nums1[0], nums2[0] });\n        // Create a hashset to keep track of the pairs we have already seen\n        HashSet<string> seen = new HashSet<string>();\n        seen.Add(nums1[0].ToString() + \",\" + nums2[0].ToString());\n        // While the heap is not empty and we have not found k pairs\n        while (heap.Count > 0 && result.Count < k) {\n            // Get the pair with the smallest sum\n            Pair pair = heap.ExtractMin();\n            // Add the pair to the result\n            result.Add(new List<long>() { pair.First, pair.Second });\n            // If the first number in the pair is not the last number in the first list\n            if (pair.FirstIndex < nums1.Count - 1) {\n                // Create a new pair with the next number in the first list and the same number in the second list\n                Pair newPair = new Pair(nums1[pair.FirstIndex + 1], pair.Second, pair.FirstIndex + 1, pair.SecondIndex);\n                // If we have not seen this pair before\n                if (!seen.Contains(newPair.First.ToString() + \",\" + newPair.Second.ToString())) {\n                    // Add the pair to the heap\n                    heap.Insert(newPair);\n                    // Add the pair to the hashset\n                    seen.Add(newPair.First.ToString() + \",\" + newPair.Second.ToString());\n                }\n",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(k);\n        var visited = new HashSet<List<long>>();\n        var initial = new List<long>() { 0, 0, nums1[0] + nums2[0] };\n        pq.Add(initial);\n        visited.Add(initial);\n        while (pq.Count > 0 && result.Count < k) {\n            var cur = pq.Remove();\n            result.Add(new List<long>() { nums1[(int)cur[0]], nums2[(int)cur[1]] });\n            if (cur[0] + 1 < nums1.Count) {\n                var next = new List<long>() { cur[0] + 1, cur[1], nums1[(int)cur[0] + 1] + nums2[(int)cur[1]] };\n                if (!visited.Contains(next)) {\n                    pq.Add(next);\n                    visited.Add(next);\n                }\n            }\n            if (cur[1] + 1 < nums2.Count) {\n                var next = new List<long>() { cur[0], cur[1] + 1, nums1[(int)cur[0]] + nums2[(int)cur[1] + 1] };\n                if (!visited.Contains(next)) {\n                    pq.Add(next);\n                    visited.Add(next);\n                }\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        for(int i = 0; i < nums1.Count; i++) {\n            for(int j = 0; j < nums2.Count; j++) {\n                List<long> pair = new List<long>();\n                pair.Add(nums1[i]);\n                pair.Add(nums2[j]);\n                result.Add(pair);\n            }\n        }\n        result.Sort((a, b) => (int)(a[0] + a[1] - b[0] - b[1]));\n        return result.Take((int)k).ToList();",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list\n        nums1.Sort();\n        // Sort the second list\n        nums2.Sort();\n        // Create a min heap of size k\n        MinHeap<long> minHeap = new MinHeap<long>(k);\n        // Add the first k elements of the first list to the min heap\n        for (int i = 0; i < k && i < nums1.Count; i++) {\n            minHeap.Add(nums1[i]);\n        }\n        // Iterate through the second list\n        for (int i = 0; i < nums2.Count; i++) {\n            // Get the current element from the second list\n            long current = nums2[i];\n            // Get the minimum element from the min heap\n            long min = minHeap.Peek();\n            // If the current element is less than the minimum element\n            if (current < min) {\n                // Remove the minimum element from the min heap\n                minHeap.Remove();\n                // Add the current element to the min heap\n                minHeap.Add(current);\n            }\n        }\n        // Iterate through the min heap\n        while (minHeap.Count > 0) {\n            // Get the minimum element from the min heap\n            long min = minHeap.Remove();\n            // Iterate through the first list\n            for (int i = 0; i < nums1.Count; i++) {\n                // Get the current element from the first list\n                long current = nums1[i];\n                // If the current element is less than the minimum element\n                if (current < min) {\n                    // Add the current element and the minimum element to the result\n                    result.Add(new List<long> { current, min });\n                }\n            }\n        }\n        // Return the result\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list\n        nums1.Sort();\n        // Sort the second list\n        nums2.Sort();\n        // Create a heap\n        Heap<List<long>> heap = new Heap<List<long>>();\n        // Add the first pair to the heap\n        heap.Add(new List<long>() { nums1[0], nums2[0] });\n        // Create a set to keep track of the pairs we have already added to the heap\n        HashSet<List<long>> set = new HashSet<List<long>>();\n        set.Add(new List<long>() { 0, 0 });\n        // While the heap is not empty and we have not found k pairs\n        while (heap.Count > 0 && result.Count < k) {\n            // Remove the pair with the smallest sum from the heap\n            List<long> pair = heap.Remove();\n            // Add the pair to the result\n            result.Add(pair);\n            // Get the indices of the elements in the pair\n            long i = pair[0];\n            long j = pair[1];\n            // If the first element in the pair is not the last element in the first list\n            if (i < nums1.Count - 1) {\n                // If we have not already added the pair with the next element in the first list and the same element in the second list to the heap\n                if (!set.Contains(new List<long>() { i + 1, j })) {\n                    // Add the pair to the heap\n                    heap.Add(new List<long>() { nums1[i + 1], nums2[j] });\n                    // Add the pair to the set\n                    set.Add(new List<long>() { i + 1, j });\n                }\n            }\n            // If the second element in the pair is not the last element in the second list\n            if (j < nums2.Count - 1) {\n                // If we have not already added the pair with the same element in the first",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            for (int j = 0; j < nums1.Count; j++) {\n                for (int l = 0; l < nums2.Count; l++) {\n                    if (nums1[j] + nums2[l] == sums[i]) {\n                        List<long> pair = new List<long>();\n                        pair.Add(nums1[j]);\n                        pair.Add(nums2[l]);\n                        result.Add(pair);\n                        nums1.RemoveAt(j);\n                        nums2.RemoveAt(l);\n                        break;\n                    }\n                }\n            }\n        }\n        return result;",
    "        // Assume nums1 and nums2 are sorted.\n        var result = new List<List<long>>();\n        var heap = new Heap<List<long>>(k);\n        foreach (var n1 in nums1) {\n            foreach (var n2 in nums2) {\n                var pair = new List<long> { n1, n2 };\n                if (heap.Count < k) {\n                    heap.Add(pair);\n                } else if (heap.Peek()[0] + heap.Peek()[1] > n1 + n2) {\n                    heap.Pop();\n                    heap.Add(pair);\n                }\n            }\n        }\n        while (heap.Count > 0) {\n            result.Add(heap.Pop());\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0 || k == 0) {\n            return result;\n        }\n        // Sort the first list.\n        nums1.Sort();\n        // Sort the second list.\n        nums2.Sort();\n        // Initialize the heap.\n        Heap heap = new Heap();\n        // Add the first pair to the heap.\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // Add the first pair to the result.\n        result.Add(new List<long> { nums1[0], nums2[0] });\n        // Keep track of the pairs that have been added to the heap.\n        HashSet<Pair> set = new HashSet<Pair>();\n        set.Add(new Pair(nums1[0], nums2[0]));\n        // Keep track of the pairs that have been added to the result.\n        HashSet<Pair> resultSet = new HashSet<Pair>();\n        resultSet.Add(new Pair(nums1[0], nums2[0]));\n        // Keep track of the indices of the pairs that have been added to the heap.\n        HashSet<Pair> indexSet = new HashSet<Pair>();\n        indexSet.Add(new Pair(0, 0));\n        // While the result set is smaller than k.\n        while (resultSet.Count < k) {\n            // Get the smallest pair from the heap.\n            Pair pair = heap.Remove();\n            // Add the pair to the result set.\n            resultSet.Add(pair);\n            // Add the pair to the result.\n            result.Add(new List<long> { pair.Num1, pair.Num2 });\n            // Get the indices of the pair.\n            long index1 = pair.Num1;\n            long index2 = pair.Num2;\n            // If the pair is not the last pair in the first list.\n            if (index1 < nums1.Count - 1) {\n                // Get the pair with the next element in the first list.\n",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                var pair = new List<long> {nums1[i], nums2[j]};\n                if (pq.Count < k) {\n                    pq.Add(pair, sum);\n                } else {\n                    if (pq.Peek() > sum) {\n                        pq.Poll();\n                        pq.Add(pair, sum);\n                    }\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Poll());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>((a, b) => a[0] + a[1] - b[0] - b[1]);\n        var visited = new HashSet<List<long>>();\n        pq.Enqueue(new List<long> { nums1[0], nums2[0] });\n        visited.Add(new List<long> { 0, 0 });\n        while (k > 0 && pq.Count > 0) {\n            var pair = pq.Dequeue();\n            result.Add(pair);\n            k--;\n            var i = pair[0];\n            var j = pair[1];\n            if (i + 1 < nums1.Count && !visited.Contains(new List<long> { i + 1, j })) {\n                pq.Enqueue(new List<long> { nums1[i + 1], nums2[j] });\n                visited.Add(new List<long> { i + 1, j });\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(new List<long> { i, j + 1 })) {\n                pq.Enqueue(new List<long> { nums1[i], nums2[j + 1] });\n                visited.Add(new List<long> { i, j + 1 });\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        long[,] matrix = new long[nums1.Count, nums2.Count];\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                matrix[i, j] = nums1[(int)i] + nums2[(int)j];\n            }\n        }\n        long[,] sorted = SortMatrix(matrix);\n        for (long i = 0; i < k; i++) {\n            List<long> pair = new List<long>();\n            pair.Add(sorted[i, 0]);\n            pair.Add(sorted[i, 1]);\n            result.Add(pair);\n        }\n        return result;",
    "        // Assume that nums1 and nums2 are sorted in ascending order.\n        // Assume that k is not greater than the length of nums1 * nums2.\n        // Assume that k is not less than 1.\n        // Assume that nums1 and nums2 are not null.\n        // Assume that nums1 and nums2 are not empty.\n        // Assume that k is not greater than the length of nums1 * nums2.\n        // Assume that k is not less than 1.\n        // Assume that nums1 and nums2 are not null.\n        // Assume that nums1 and nums2 are not empty.\n        // Assume that k is not greater than the length of nums1 * nums2.\n        // Assume that k is not less than 1.\n        // Assume that nums1 and nums2 are not null.\n        // Assume that nums1 and nums2 are not empty.\n        // Assume that k is not greater than the length of nums1 * nums2.\n        // Assume that k is not less than 1.\n        // Assume that nums1 and nums2 are not null.\n        // Assume that nums1 and nums2 are not empty.\n        // Assume that k is not greater than the length of nums1 * nums2.\n        // Assume that k is not less than 1.\n        // Assume that nums1 and nums2 are not null.\n        // Assume that nums1 and nums2 are not empty.\n        // Assume that k is not greater than the length of nums1 * nums2.\n        // Assume that k is not less than 1.\n        // Assume that nums1 and nums2 are not null.\n        // Assume that nums1 and nums2 are not empty.\n        // Assume that k is not greater than the length of nums1 * nums2.\n        // Assume that k is not less than 1.\n        // Assume that nums1 and nums2 are not null.\n        // Assume that nums1 and nums2 are not empty.\n        // Assume that k is not greater",
    "        var result = new List<List<long>>();\n        var heap = new Heap<List<long>>(k);\n        foreach (var n1 in nums1) {\n            foreach (var n2 in nums2) {\n                var pair = new List<long> { n1, n2 };\n                if (heap.Count < k) {\n                    heap.Add(pair);\n                } else {\n                    if (heap.Peek()[0] + heap.Peek()[1] > n1 + n2) {\n                        heap.Remove();\n                        heap.Add(pair);\n                    }\n                }\n            }\n        }\n        while (heap.Count > 0) {\n            result.Add(heap.Remove());\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list.\n        nums1.Sort();\n        // Sort the second list.\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap heap = new MinHeap(nums1.Count);\n        // Add the first element of the first list and the first element of the second list to the min heap.\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // Add the first element of the first list and the second element of the second list to the min heap.\n        heap.Add(new Pair(nums1[0], nums2[1]));\n        // Create a set to store the pairs that have already been added to the result.\n        HashSet<Pair> set = new HashSet<Pair>();\n        // Add the first element of the first list and the first element of the second list to the set.\n        set.Add(new Pair(nums1[0], nums2[0]));\n        // Add the first element of the first list and the second element of the second list to the set.\n        set.Add(new Pair(nums1[0], nums2[1]));\n        // While the result has less than k elements.\n        while (result.Count < k) {\n            // Get the minimum element from the min heap.\n            Pair pair = heap.GetMin();\n            // Add the pair to the result.\n            result.Add(new List<long>() { pair.first, pair.second });\n            // If the first element of the pair is the last element of the first list.\n            if (pair.first == nums1[nums1.Count - 1]) {\n                // If the second element of the pair is the last element of the second list.\n                if (pair.second == nums2[nums2.Count - 1]) {\n                    // Break.\n                    break;\n                }\n                // Get the index of the second element of the pair in the second list.\n               ",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        foreach (var num1 in nums1) {\n            foreach (var num2 in nums2) {\n                minHeap.Add(new List<long> { num1, num2 });\n            }\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            result.Add(minHeap.Pop());\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n            k--;\n        }\n        return result;",
    "        // Assume nums1 and nums2 are sorted.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap<Pair>();\n        var visited = new HashSet<Pair>();\n        var start = new Pair(0, 0, nums1[0] + nums2[0]);\n        minHeap.Insert(start);\n        visited.Add(start);\n        while (result.Count < k && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { nums1[pair.i], nums2[pair.j] });\n            if (pair.i + 1 < nums1.Count) {\n                var next = new Pair(pair.i + 1, pair.j, nums1[pair.i + 1] + nums2[pair.j]);\n                if (!visited.Contains(next)) {\n                    minHeap.Insert(next);\n                    visited.Add(next);\n                }\n            }\n            if (pair.j + 1 < nums2.Count) {\n                var next = new Pair(pair.i, pair.j + 1, nums1[pair.i] + nums2[pair.j + 1]);\n                if (!visited.Contains(next)) {\n                    minHeap.Insert(next);\n                    visited.Add(next);\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var heap = new Heap<long>(k, (a, b) => a < b);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                heap.Add(nums1[i] + nums2[j]);\n            }\n        }\n        while (heap.Count > 0) {\n            var sum = heap.Remove();\n            var pair = new List<long>();\n            for (int i = 0; i < nums1.Count; i++) {\n                for (int j = 0; j < nums2.Count; j++) {\n                    if (nums1[i] + nums2[j] == sum) {\n                        pair.Add(nums1[i]);\n                        pair.Add(nums2[j]);\n                        result.Add(pair);\n                        break;\n                    }\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        var pq = new PriorityQueue<List<long>>(k);\n        var visited = new HashSet<List<long>>();\n        pq.Enqueue(new List<long> { nums1[0], nums2[0], 0, 0 });\n        visited.Add(new List<long> { 0, 0 });\n        while (pq.Count > 0 && result.Count < k) {\n            var cur = pq.Dequeue();\n            result.Add(new List<long> { cur[0], cur[1] });\n            var i = cur[2];\n            var j = cur[3];\n            if (i + 1 < nums1.Count && !visited.Contains(new List<long> { i + 1, j })) {\n                pq.Enqueue(new List<long> { nums1[i + 1], nums2[j], i + 1, j });\n                visited.Add(new List<long> { i + 1, j });\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(new List<long> { i, j + 1 })) {\n                pq.Enqueue(new List<long> { nums1[i], nums2[j + 1], i, j + 1 });\n                visited.Add(new List<long> { i, j + 1 });\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list\n        nums1.Sort();\n        // Sort the second list\n        nums2.Sort();\n        // Create a priority queue to store the pairs\n        PriorityQueue<List<long>> pq = new PriorityQueue<List<long>>();\n        // Add the first pair to the queue\n        pq.Enqueue(new List<long>() { nums1[0], nums2[0], 0, 0 });\n        // Keep track of the pairs we have already added\n        HashSet<string> visited = new HashSet<string>();\n        visited.Add(\"0,0\");\n        // While we have not added k pairs\n        while (result.Count < k && pq.Count > 0) {\n            // Get the pair with the smallest sum\n            List<long> pair = pq.Dequeue();\n            // Add the pair to the result\n            result.Add(new List<long>() { pair[0], pair[1] });\n            // Get the indices of the pair\n            long i = pair[2];\n            long j = pair[3];\n            // If we can add the next pair from the first list\n            if (i + 1 < nums1.Count) {\n                // If we have not already added the pair\n                if (!visited.Contains((i + 1) + \",\" + j)) {\n                    // Add the pair to the queue\n                    pq.Enqueue(new List<long>() { nums1[i + 1], nums2[j], i + 1, j });\n                    // Add the pair to the visited set\n                    visited.Add((i + 1) + \",\" + j);\n                }\n            }\n            // If we can add the next pair from the second list\n            if (j + 1 < nums2.Count) {\n                // If we have not already added the pair\n                if (!visited.Contains(i + \",\" + (j + 1))) {\n                    // Add the pair to the queue\n                    pq.Enqueue",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list\n        nums1.Sort();\n        // Sort the second list\n        nums2.Sort();\n        // Create a min heap with the first element of each list\n        MinHeap heap = new MinHeap();\n        heap.Insert(new Pair(nums1[0], nums2[0]));\n        // Create a set to track which pairs have been added to the heap\n        HashSet<Pair> set = new HashSet<Pair>();\n        set.Add(new Pair(nums1[0], nums2[0]));\n        // Add the first pair to the result\n        result.Add(new List<long> { nums1[0], nums2[0] });\n        // Loop through the heap and add the next smallest pair\n        for (long i = 1; i < k; i++) {\n            // Get the next smallest pair\n            Pair pair = heap.ExtractMin();\n            // Add the pair to the result\n            result.Add(new List<long> { pair.First, pair.Second });\n            // Add the next smallest pair with the first element of the first list\n            if (pair.FirstIndex < nums1.Count - 1) {\n                Pair newPair = new Pair(nums1[pair.FirstIndex + 1], pair.Second);\n                if (!set.Contains(newPair)) {\n                    heap.Insert(newPair);\n                    set.Add(newPair);\n                }\n            }\n            // Add the next smallest pair with the first element of the second list\n            if (pair.SecondIndex < nums2.Count - 1) {\n                Pair newPair = new Pair(pair.First, nums2[pair.SecondIndex + 1]);\n                if (!set.Contains(newPair)) {\n                    heap.Insert(newPair);\n                    set.Add(newPair);\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (pq.Count < k) {\n                    pq.Enqueue(new List<long> { nums1[i], nums2[j] });\n                } else if (pq.Peek()[0] + pq.Peek()[1] > sum) {\n                    pq.Dequeue();\n                    pq.Enqueue(new List<long> { nums1[i], nums2[j] });\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Dequeue());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var pq = new PriorityQueue<Tuple<long, long, long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pq.Enqueue(new Tuple<long, long, long>(nums1[i] + nums2[j], nums1[i], nums2[j]));\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            if (pq.Count == 0) {\n                break;\n            }\n            var t = pq.Dequeue();\n            result.Add(new List<long>() { t.Item2, t.Item3 });\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new Tuple<long, long>(nums1[i], nums2[0]), nums1[i] + nums2[0]);\n        }\n        for (int i = 0; i < k && minHeap.Count > 0; i++) {\n            var min = minHeap.ExtractMin();\n            result.Add(new List<long> { min.Item1.Item1, min.Item1.Item2 });\n            if (min.Item1.Item2 != nums2[nums2.Count - 1]) {\n                minHeap.Add(new Tuple<long, long>(min.Item1.Item1, nums2[(int)min.Item1.Item2 + 1]), min.Item1.Item1 + nums2[(int)min.Item1.Item2 + 1]);\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<Tuple<long, long>>();\n        minHeap.Add(new Tuple<long, long>(0, 0), nums1[0] + nums2[0]);\n        visited.Add(new Tuple<long, long>(0, 0));\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Pop();\n            var i = pair.Item1;\n            var j = pair.Item2;\n            result.Add(new List<long> { nums1[i], nums2[j] });\n            k--;\n            if (i + 1 < nums1.Count) {\n                var newPair = new Tuple<long, long>(i + 1, j);\n                if (!visited.Contains(newPair)) {\n                    minHeap.Add(newPair, nums1[i + 1] + nums2[j]);\n                    visited.Add(newPair);\n                }\n            }\n            if (j + 1 < nums2.Count) {\n                var newPair = new Tuple<long, long>(i, j + 1);\n                if (!visited.Contains(newPair)) {\n                    minHeap.Add(newPair, nums1[i] + nums2[j + 1]);\n                    visited.Add(newPair);\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0 || k == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<Node>();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new Node(nums1[i], nums2[0], 0));\n        }\n        for (int i = 0; i < k && minHeap.Count > 0; i++) {\n            var node = minHeap.Remove();\n            result.Add(new List<long> { node.Num1, node.Num2 });\n            if (node.Index2 + 1 < nums2.Count) {\n                minHeap.Add(new Node(node.Num1, nums2[node.Index2 + 1], node.Index2 + 1));\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            result.Add(new List<long>());\n            result[i].Add(sums[i]);\n            result[i].Add(sums[i]);\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        pairs.Sort((a, b) => (a[0] + a[1]).CompareTo(b[0] + b[1]));\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[i]);\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        Dictionary<long, List<long>> map = new Dictionary<long, List<long>>();\n        foreach (long num1 in nums1) {\n            foreach (long num2 in nums2) {\n                long sum = num1 + num2;\n                if (map.ContainsKey(sum)) {\n                    map[sum].Add(num1);\n                    map[sum].Add(num2);\n                } else {\n                    map.Add(sum, new List<long> { num1, num2 });\n                }\n            }\n        }\n        List<long> sums = map.Keys.ToList();\n        sums.Sort();\n        foreach (long sum in sums) {\n            if (map[sum].Count >= 2) {\n                result.Add(map[sum].GetRange(0, 2));\n                map[sum].RemoveRange(0, 2);\n                if (result.Count == k) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the two lists.\n        nums1.Sort();\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap heap = new MinHeap();\n        // Add the first pair to the heap.\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // Keep track of the pairs we have already seen.\n        HashSet<Pair> seen = new HashSet<Pair>();\n        seen.Add(new Pair(nums1[0], nums2[0]));\n        // Add the first pair to the result.\n        result.Add(new List<long>() { nums1[0], nums2[0] });\n        // While we have not found k pairs.\n        while (result.Count < k) {\n            // Get the pair with the smallest sum.\n            Pair pair = heap.Remove();\n            // Add the pair to the result.\n            result.Add(new List<long>() { pair.First, pair.Second });\n            // Get the next pair with the first element being the same as the first element of the current pair.\n            Pair nextPair1 = new Pair(pair.First, pair.Second + 1);\n            // Get the next pair with the second element being the same as the second element of the current pair.\n            Pair nextPair2 = new Pair(pair.First + 1, pair.Second);\n            // If we have not seen the next pair with the first element being the same as the first element of the current pair.\n            if (nextPair1.Second < nums2.Count && !seen.Contains(nextPair1)) {\n                // Add the next pair to the heap.\n                heap.Add(nextPair1);\n                // Add the next pair to the set of seen pairs.\n                seen.Add(nextPair1);\n            }\n            // If we have not seen the next pair with the second element being the same as the second element of the current pair.\n            if (",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> dict = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!dict.ContainsKey(sum)) {\n                    dict.Add(sum, new List<List<long>>());\n                }\n                dict[sum].Add(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        foreach (long key in dict.Keys) {\n            foreach (List<long> pair in dict[key]) {\n                if (result.Count == k) {\n                    return result;\n                }\n                result.Add(pair);\n            }\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Size() > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            k--;\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list.\n        nums1.Sort();\n        // Sort the second list.\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap heap = new MinHeap();\n        // Add the first element of the first list and the first element of the second list to the heap.\n        heap.Insert(new List<long> { nums1[0], nums2[0] });\n        // Create a hash set to store the pairs that have been added to the heap.\n        HashSet<string> set = new HashSet<string>();\n        set.Add(nums1[0] + \",\" + nums2[0]);\n        // While the heap is not empty and the number of pairs in the result is less than k.\n        while (heap.Count > 0 && result.Count < k) {\n            // Remove the minimum pair from the heap.\n            List<long> pair = heap.RemoveMin();\n            // Add the pair to the result.\n            result.Add(pair);\n            // Get the indices of the elements of the pair in the first and second lists.\n            long i = pair[0];\n            long j = pair[1];\n            // If the element in the first list is not the last element in the first list.\n            if (i < nums1[nums1.Count - 1]) {\n                // Get the index of the next element in the first list.\n                long nextI = nums1[nums1.BinarySearch(i) + 1];\n                // If the pair consisting of the next element in the first list and the element in the second list has not been added to the heap.\n                if (!set.Contains(nextI + \",\" + j)) {\n                    // Add the pair to the heap.\n                    heap.Insert(new List<long> { nextI, j });\n                    // Add the pair to the hash set.\n                    set.Add(nextI + \",\" + j);\n                }\n            }\n            // If the element",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Initialize a heap of size k.\n        Heap<List<long>> heap = new Heap<List<long>>(k);\n        // Initialize a list of pointers to the second list.\n        List<long> pointers = new List<long>();\n        for (long i = 0; i < nums1.Count; i++) {\n            pointers.Add(0);\n        }\n        // Add the first k pairs to the heap.\n        for (long i = 0; i < nums1.Count; i++) {\n            if (pointers[(int)i] < nums2.Count) {\n                heap.Add(new List<long> { nums1[(int)i], nums2[(int)pointers[(int)i]] });\n                pointers[(int)i]++;\n            }\n        }\n        // Pop the smallest pair from the heap and add the next pair from the same list to the heap.\n        for (long i = 0; i < k; i++) {\n            List<long> pair = heap.Pop();\n            result.Add(pair);\n            long index = pair[0];\n            if (pointers[(int)index] < nums2.Count) {\n                heap.Add(new List<long> { nums1[(int)index], nums2[(int)pointers[(int)index]] });\n                pointers[(int)index]++;\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list\n        nums1.Sort();\n        // Sort the second list\n        nums2.Sort();\n        // Create a min heap\n        MinHeap<List<long>> heap = new MinHeap<List<long>>();\n        // Add the first pair to the heap\n        heap.Add(new List<long> { nums1[0], nums2[0] });\n        // Create a hash set to keep track of the pairs we've seen\n        HashSet<List<long>> seen = new HashSet<List<long>>();\n        seen.Add(new List<long> { nums1[0], nums2[0] });\n        // While we haven't found k pairs\n        while (result.Count < k) {\n            // Get the smallest pair\n            List<long> pair = heap.Remove();\n            // Add the pair to the result\n            result.Add(pair);\n            // Get the indices of the pair\n            long i = pair[0];\n            long j = pair[1];\n            // If we can add the pair with the next element in the first list\n            if (i + 1 < nums1.Count) {\n                // Create the pair\n                List<long> nextPair = new List<long> { nums1[(int)i + 1], j };\n                // If we haven't seen this pair\n                if (!seen.Contains(nextPair)) {\n                    // Add the pair to the heap\n                    heap.Add(nextPair);\n                    // Add the pair to the hash set\n                    seen.Add(nextPair);\n                }\n            }\n            // If we can add the pair with the next element in the second list\n            if (j + 1 < nums2.Count) {\n                // Create the pair\n                List<long> nextPair = new List<long> { i, nums2[(int)j + 1] };\n                // If we haven't seen this pair\n                if (!seen.Contains(nextPair",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list.\n        nums1.Sort();\n        // Sort the second list.\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap heap = new MinHeap();\n        // Add the first pair to the heap.\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // Create a set to store the pairs we have already seen.\n        HashSet<Pair> seen = new HashSet<Pair>();\n        // Add the first pair to the set.\n        seen.Add(new Pair(nums1[0], nums2[0]));\n        // While we have not found k pairs.\n        while (result.Count < k) {\n            // Get the smallest pair.\n            Pair pair = heap.GetMin();\n            // Add the pair to the result.\n            result.Add(new List<long>() { pair.First, pair.Second });\n            // Get the next pair with the first element of the pair we just added.\n            Pair nextPair = new Pair(pair.First, nums2[nums2.IndexOf(pair.Second) + 1]);\n            // If we have not seen this pair before.\n            if (!seen.Contains(nextPair)) {\n                // Add the pair to the heap.\n                heap.Add(nextPair);\n                // Add the pair to the set.\n                seen.Add(nextPair);\n            }\n            // Get the next pair with the second element of the pair we just added.\n            nextPair = new Pair(nums1[nums1.IndexOf(pair.First) + 1], pair.Second);\n            // If we have not seen this pair before.\n            if (!seen.Contains(nextPair)) {\n                // Add the pair to the heap.\n                heap.Add(nextPair);\n                // Add the pair to the set.\n                seen.Add(nextPair);\n            }\n        }\n        //",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedSet<Tuple<long, long, long>> set = new SortedSet<Tuple<long, long, long>>(new TupleComparer());\n        set.Add(new Tuple<long, long, long>(nums1[0] + nums2[0], 0, 0));\n        while (result.Count < k && set.Count > 0) {\n            Tuple<long, long, long> pair = set.Min;\n            set.Remove(pair);\n            result.Add(new List<long> { nums1[pair.Item2], nums2[pair.Item3] });\n            if (pair.Item2 + 1 < nums1.Count) {\n                set.Add(new Tuple<long, long, long>(nums1[pair.Item2 + 1] + nums2[pair.Item3], pair.Item2 + 1, pair.Item3));\n            }\n            if (pair.Item2 == 0 && pair.Item3 + 1 < nums2.Count) {\n                set.Add(new Tuple<long, long, long>(nums1[pair.Item2] + nums2[pair.Item3 + 1], pair.Item2, pair.Item3 + 1));\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> dict = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!dict.ContainsKey(sum)) {\n                    dict[sum] = new List<List<long>>();\n                }\n                dict[sum].Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        foreach (long key in dict.Keys) {\n            foreach (List<long> pair in dict[key]) {\n                if (result.Count == k) {\n                    return result;\n                }\n                result.Add(pair);\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (result.Count < k && minHeap.Count > 0) {\n            var pair = minHeap.Pop();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Add(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap(k);\n        for (var i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new List<long> { nums1[i], nums2[0], 0 });\n        }\n        while (result.Count < k && !minHeap.IsEmpty()) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { pair[0], pair[1] });\n            var nextIndex = pair[2] + 1;\n            if (nextIndex < nums2.Count) {\n                minHeap.Add(new List<long> { pair[0], nums2[nextIndex], nextIndex });\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list.\n        nums1.Sort();\n        // Sort the second list.\n        nums2.Sort();\n        // Create a heap of size k.\n        Heap heap = new Heap(k);\n        // Add the first pair to the heap.\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // Create a set to keep track of the pairs we've already seen.\n        HashSet<Pair> seen = new HashSet<Pair>();\n        seen.Add(new Pair(nums1[0], nums2[0]));\n        // While the heap is not empty.\n        while (heap.Count > 0) {\n            // Remove the smallest pair from the heap.\n            Pair pair = heap.Remove();\n            // Add the pair to the result.\n            result.Add(new List<long> { pair.First, pair.Second });\n            // If the result has k pairs, we're done.\n            if (result.Count == k) {\n                break;\n            }\n            // Add the next pair with the first element from the first list and the second element from the second list.\n            if (pair.FirstIndex + 1 < nums1.Count) {\n                Pair nextPair = new Pair(nums1[pair.FirstIndex + 1], pair.Second, pair.FirstIndex + 1, pair.SecondIndex);\n                if (!seen.Contains(nextPair)) {\n                    heap.Add(nextPair);\n                    seen.Add(nextPair);\n                }\n            }\n            // Add the next pair with the first element from the second list and the second element from the first list.\n            if (pair.SecondIndex + 1 < nums2.Count) {\n                Pair nextPair = new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.FirstIndex, pair.SecondIndex + 1);\n                if (!seen.Contains(nextPair)) {\n                    heap.Add",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the lists\n        nums1.Sort();\n        nums2.Sort();\n        // Create a priority queue\n        PriorityQueue<List<long>> pq = new PriorityQueue<List<long>>();\n        // Add the first element of each list to the priority queue\n        pq.Enqueue(new List<long> { nums1[0], nums2[0], 0, 0 });\n        // Keep track of the elements we've already seen\n        HashSet<List<long>> seen = new HashSet<List<long>>();\n        seen.Add(new List<long> { 0, 0 });\n        // While we have fewer than k elements in the result\n        while (result.Count < k && pq.Count > 0) {\n            // Get the next element from the priority queue\n            List<long> next = pq.Dequeue();\n            // Add it to the result\n            result.Add(new List<long> { next[0], next[1] });\n            // If we haven't seen the next element in the first list\n            if (!seen.Contains(new List<long> { next[2] + 1, next[3] })) {\n                // Add it to the priority queue\n                pq.Enqueue(new List<long> { nums1[next[2] + 1], next[1], next[2] + 1, next[3] });\n                // And add it to the set of seen elements\n                seen.Add(new List<long> { next[2] + 1, next[3] });\n            }\n            // If we haven't seen the next element in the second list\n            if (!seen.Contains(new List<long> { next[2], next[3] + 1 })) {\n                // Add it to the priority queue\n                pq.Enqueue(new List<long> { next[0], nums2[next[3] + 1], next[2], next[3] + 1 });\n                // And add it to the set of seen elements\n",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> sums = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!sums.ContainsKey(sum)) {\n                    sums.Add(sum, new List<List<long>>());\n                }\n                sums[sum].Add(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        foreach (long sum in sums.Keys) {\n            foreach (List<long> pair in sums[sum]) {\n                result.Add(pair);\n                k--;\n                if (k == 0) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<List<long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (minHeap.Count < k) {\n                    minHeap.Add(new List<long> { nums1[i], nums2[j] });\n                } else if (sum < minHeap.Peek()[0] + minHeap.Peek()[1]) {\n                    minHeap.Remove();\n                    minHeap.Add(new List<long> { nums1[i], nums2[j] });\n                }\n            }\n        }\n        while (minHeap.Count > 0) {\n            result.Add(minHeap.Remove());\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            result.Add(new List<long>());\n            result[i].Add(sums[i]);\n            result[i].Add(sums[i]);\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list.\n        nums1.Sort();\n        // Sort the second list.\n        nums2.Sort();\n        // Create a min heap of size k.\n        MinHeap heap = new MinHeap(k);\n        // Add the first pair to the heap.\n        heap.Add(new List<long>() { nums1[0], nums2[0] });\n        // Create a set to store the pairs we have already visited.\n        HashSet<string> visited = new HashSet<string>();\n        visited.Add(nums1[0] + \",\" + nums2[0]);\n        // While the heap is not empty.\n        while (heap.Size() > 0) {\n            // Pop the smallest pair from the heap.\n            List<long> pair = heap.Pop();\n            // Add the pair to the result.\n            result.Add(pair);\n            // If the result size is equal to k, return the result.\n            if (result.Count == k) {\n                return result;\n            }\n            // If the first element of the pair is equal to the last element of the first list.\n            if (pair[0] == nums1[nums1.Count - 1]) {\n                // Add the pair with the last element of the second list.\n                heap.Add(new List<long>() { pair[0], nums2[nums2.Count - 1] });\n            } else {\n                // Find the index of the first element of the pair in the first list.\n                int index = nums1.IndexOf(pair[0]);\n                // Add the pair with the next element of the first list.\n                heap.Add(new List<long>() { nums1[index + 1], pair[1] });\n            }\n            // If the second element of the pair is equal to the last element of the second list.\n            if (pair[1] == nums2[nums2.Count - 1]) {\n                // Add the",
    "        var result = new List<List<long>>();\n        var heap = new Heap<Tuple<long, long, long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                heap.Add(new Tuple<long, long, long>(sum, nums1[i], nums2[j]));\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var pair = heap.Pop();\n            result.Add(new List<long>() { pair.Item2, pair.Item3 });\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            result.Add(new List<long>());\n            result[i].Add(sums[i]);\n            result[i].Add(sums[i] - nums1[0]);\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> sums = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!sums.ContainsKey(sum)) {\n                    sums.Add(sum, new List<List<long>>());\n                }\n                sums[sum].Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        foreach (long key in sums.Keys) {\n            foreach (List<long> pair in sums[key]) {\n                if (result.Count == k) {\n                    return result;\n                }\n                result.Add(pair);\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the lists.\n        nums1.Sort();\n        nums2.Sort();\n        // Create a min heap to store the pairs.\n        MinHeap<List<long>> heap = new MinHeap<List<long>>();\n        // Add the first pair to the heap.\n        heap.Add(new List<long>() { nums1[0], nums2[0] });\n        // Create a hashset to store the pairs that have been added to the heap.\n        HashSet<List<long>> set = new HashSet<List<long>>();\n        set.Add(new List<long>() { nums1[0], nums2[0] });\n        // While the heap is not empty and the result size is less than k.\n        while (heap.Count > 0 && result.Count < k) {\n            // Get the pair with the smallest sum.\n            List<long> pair = heap.Remove();\n            // Add the pair to the result.\n            result.Add(pair);\n            // Get the indices of the pair.\n            long i = pair[0];\n            long j = pair[1];\n            // Add the pair with the next element from nums1 to the heap if it is not in the set.\n            if (i + 1 < nums1.Count && !set.Contains(new List<long>() { i + 1, j })) {\n                heap.Add(new List<long>() { i + 1, j });\n                set.Add(new List<long>() { i + 1, j });\n            }\n            // Add the pair with the next element from nums2 to the heap if it is not in the set.\n            if (j + 1 < nums2.Count && !set.Contains(new List<long>() { i, j + 1 })) {\n                heap.Add(new List<long>() { i, j + 1 });\n                set.Add(new List<long>() { i, j + 1 });\n           ",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> sums = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!sums.ContainsKey(sum)) {\n                    sums.Add(sum, new List<List<long>>());\n                }\n                sums[sum].Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        foreach (long sum in sums.Keys) {\n            foreach (List<long> pair in sums[sum]) {\n                result.Add(pair);\n                k--;\n                if (k == 0) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list\n        nums1.Sort();\n        // Sort the second list\n        nums2.Sort();\n        // Create a min heap\n        MinHeap<long> minHeap = new MinHeap<long>();\n        // Add the first pair to the min heap\n        minHeap.Add(nums1[0] + nums2[0], new List<long>() { nums1[0], nums2[0] });\n        // Create a set to keep track of the pairs we've already seen\n        HashSet<string> seen = new HashSet<string>();\n        seen.Add(nums1[0] + \",\" + nums2[0]);\n        // While we haven't found k pairs\n        while (result.Count < k) {\n            // Get the smallest pair\n            List<long> pair = minHeap.GetMin();\n            // Add the pair to the result\n            result.Add(pair);\n            // Get the first and second elements of the pair\n            long first = pair[0];\n            long second = pair[1];\n            // If the first element is not the last element in the first list\n            if (first != nums1[nums1.Count - 1]) {\n                // Add the next pair with the first element and the second element\n                long nextFirst = nums1[nums1.IndexOf(first) + 1];\n                string key = nextFirst + \",\" + second;\n                if (!seen.Contains(key)) {\n                    minHeap.Add(nextFirst + second, new List<long>() { nextFirst, second });\n                    seen.Add(key);\n                }\n            }\n            // If the second element is not the last element in the second list\n            if (second != nums2[nums2.Count - 1]) {\n                // Add the next pair with the first element and the second element\n                long nextSecond = nums2[nums2.IndexOf(second) + 1];\n                string key",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                minHeap.Insert(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(minHeap.ExtractMin());\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (var i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        for (var i = 0; i < k && minHeap.Size > 0; i++) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<(long, long)>(k, (a, b) => a.Item1 + a.Item2 < b.Item1 + b.Item2);\n        foreach (var a in nums1) {\n            foreach (var b in nums2) {\n                heap.Push((a, b));\n            }\n        }\n        while (heap.Count > 0) {\n            var (a, b) = heap.Pop();\n            result.Add(new List<long> { a, b });\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var pq = new PriorityQueue<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pq.Enqueue(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(pq.Dequeue());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Insert(new Pair(nums1[0], nums2[0]));\n        visited.Add(nums1[0] + \",\" + nums2[0]);\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            k--;\n            if (nums1.Count > 1) {\n                var newPair = new Pair(nums1[1], pair.Second);\n                if (!visited.Contains(newPair.ToString())) {\n                    minHeap.Insert(newPair);\n                    visited.Add(newPair.ToString());\n                }\n            }\n            if (nums2.Count > 1) {\n                var newPair = new Pair(pair.First, nums2[1]);\n                if (!visited.Contains(newPair.ToString())) {\n                    minHeap.Insert(newPair);\n                    visited.Add(newPair.ToString());\n                }\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the lists.\n        nums1.Sort();\n        nums2.Sort();\n        // Create a priority queue to store the pairs.\n        PriorityQueue<List<long>> queue = new PriorityQueue<List<long>>();\n        // Add the first pair to the queue.\n        queue.Enqueue(new List<long> { nums1[0], nums2[0], nums1[0] + nums2[0] });\n        // Create a set to store the pairs that have been added to the queue.\n        HashSet<string> set = new HashSet<string>();\n        set.Add(nums1[0] + \",\" + nums2[0]);\n        // While the queue is not empty and the number of pairs is less than k.\n        while (queue.Count > 0 && result.Count < k) {\n            // Dequeue the pair with the smallest sum.\n            List<long> pair = queue.Dequeue();\n            // Add the pair to the result.\n            result.Add(new List<long> { pair[0], pair[1] });\n            // Find the next pair with the smallest sum.\n            long sum = pair[2];\n            long x = pair[0];\n            long y = pair[1];\n            // If the next pair is not in the set, add it to the queue.\n            if (x + 1 < nums1.Count && !set.Contains(nums1[(int)x + 1] + \",\" + y)) {\n                queue.Enqueue(new List<long> { nums1[(int)x + 1], y, nums1[(int)x + 1] + y });\n                set.Add(nums1[(int)x + 1] + \",\" + y);\n            }\n            // If the next pair is not in the set, add it to the queue.\n            if (y + 1 < nums2.Count && !set.Contains(x + \",\" + nums2[(int",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (minHeap.Count < k) {\n                    minHeap.Add(new Pair(nums1[i], nums2[j], sum));\n                } else {\n                    if (sum < minHeap.Peek().Sum) {\n                        minHeap.Pop();\n                        minHeap.Add(new Pair(nums1[i], nums2[j], sum));\n                    }\n                }\n            }\n        }\n        while (minHeap.Count > 0) {\n            var pair = minHeap.Pop();\n            result.Add(new List<long> { pair.Num1, pair.Num2 });\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Size > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<Tuple<long, long, long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new Tuple<long, long, long>(nums1[i] + nums2[0], i, 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var tuple = minHeap.Remove();\n            result.Add(new List<long> { nums1[tuple.Item2], nums2[tuple.Item3] });\n            k--;\n            if (tuple.Item3 + 1 < nums2.Count) {\n                minHeap.Add(new Tuple<long, long, long>(nums1[tuple.Item2] + nums2[tuple.Item3 + 1], tuple.Item2, tuple.Item3 + 1));\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            long sum = sums[i];\n            for (int j = 0; j < nums1.Count; j++) {\n                for (int l = 0; l < nums2.Count; l++) {\n                    if (nums1[j] + nums2[l] == sum) {\n                        List<long> pair = new List<long>();\n                        pair.Add(nums1[j]);\n                        pair.Add(nums2[l]);\n                        result.Add(pair);\n                    }\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>();\n        foreach (var n1 in nums1) {\n            foreach (var n2 in nums2) {\n                var pair = new List<long> { n1, n2 };\n                pq.Enqueue(pair);\n            }\n        }\n        while (k > 0 && pq.Count > 0) {\n            result.Add(pq.Dequeue());\n            k--;\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list\n        nums1.Sort();\n        // Sort the second list\n        nums2.Sort();\n        // Create a min heap to store the pairs\n        MinHeap<List<long>> minHeap = new MinHeap<List<long>>();\n        // Add the first pair to the heap\n        minHeap.Add(new List<long>() { nums1[0], nums2[0], 0, 0 });\n        // Add the pairs to the heap\n        while (minHeap.Count > 0 && result.Count < k) {\n            // Get the pair with the smallest sum\n            List<long> pair = minHeap.Remove();\n            // Add the pair to the result\n            result.Add(new List<long>() { pair[0], pair[1] });\n            // Get the indices of the elements in the pair\n            long i = pair[2];\n            long j = pair[3];\n            // If the first element in the pair is the last element in the first list, then we can't add any more pairs\n            if (i == nums1.Count - 1) {\n                continue;\n            }\n            // Add the pair with the next element in the first list and the same element in the second list\n            minHeap.Add(new List<long>() { nums1[i + 1], nums2[j], i + 1, j });\n            // If the second element in the pair is the last element in the second list, then we can't add any more pairs\n            if (j == nums2.Count - 1) {\n                continue;\n            }\n            // Add the pair with the same element in the first list and the next element in the second list\n            minHeap.Add(new List<long>() { nums1[i], nums2[j + 1], i, j + 1 });\n        }\n        // Return the result\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { pair.Num1, pair.Num2 });\n            k--;\n            if (pair.Index2 + 1 < nums2.Count) {\n                minHeap.Add(new Pair(pair.Num1, nums2[pair.Index2 + 1], pair.Index2 + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            result.Add(new List<long>() { sums[i] });\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Insert(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \",\" + 0);\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            var i = pair.i;\n            var j = pair.j;\n            result.Add(new List<long> { nums1[i], nums2[j] });\n            k--;\n            if (i + 1 < nums1.Count && !visited.Contains((i + 1) + \",\" + j)) {\n                minHeap.Insert(new Pair(nums1[i + 1], nums2[j], i + 1, j));\n                visited.Add((i + 1) + \",\" + j);\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(i + \",\" + (j + 1))) {\n                minHeap.Insert(new Pair(nums1[i], nums2[j + 1], i, j + 1));\n                visited.Add(i + \",\" + (j + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            long sum = sums[i];\n            for (int j = 0; j < nums1.Count; j++) {\n                for (int l = 0; l < nums2.Count; l++) {\n                    if (nums1[j] + nums2[l] == sum) {\n                        List<long> pair = new List<long>();\n                        pair.Add(nums1[j]);\n                        pair.Add(nums2[l]);\n                        result.Add(pair);\n                        break;\n                    }\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<Tuple<long, long, long>>(k);\n        for (var i = 0; i < nums1.Count; i++) {\n            minHeap.Push(new Tuple<long, long, long>(i, 0, nums1[i] + nums2[0]));\n        }\n        for (var i = 0; i < k && minHeap.Count > 0; i++) {\n            var item = minHeap.Pop();\n            result.Add(new List<long> { nums1[item.Item1], nums2[item.Item2] });\n            if (item.Item2 + 1 < nums2.Count) {\n                minHeap.Push(new Tuple<long, long, long>(item.Item1, item.Item2 + 1, nums1[item.Item1] + nums2[item.Item2 + 1]));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var pq = new PriorityQueue<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                var pair = new List<long>() { nums1[i], nums2[j] };\n                if (pq.Count < k) {\n                    pq.Enqueue(pair, sum);\n                } else {\n                    if (pq.PeekPriority() > sum) {\n                        pq.Dequeue();\n                        pq.Enqueue(pair, sum);\n                    }\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Dequeue());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(Comparer<List<long>>.Create((a, b) => (int)(a[0] + a[1] - b[0] - b[1])));\n        for (int i = 0; i < nums1.Count; i++) {\n            pq.Enqueue(new List<long> { nums1[i], nums2[0], 0 });\n        }\n        while (k > 0 && pq.Count > 0) {\n            var pair = pq.Dequeue();\n            result.Add(new List<long> { pair[0], pair[1] });\n            if (pair[2] < nums2.Count - 1) {\n                pq.Enqueue(new List<long> { pair[0], nums2[(int)pair[2] + 1], pair[2] + 1 });\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (pq.Count < k) {\n                    pq.Add(new List<long> { nums1[i], nums2[j] });\n                } else if (sum < pq.Peek()[0] + pq.Peek()[1]) {\n                    pq.Poll();\n                    pq.Add(new List<long> { nums1[i], nums2[j] });\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Poll());\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> sums = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!sums.ContainsKey(sum)) {\n                    sums.Add(sum, new List<List<long>>());\n                }\n                sums[sum].Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        foreach (long sum in sums.Keys) {\n            foreach (List<long> pair in sums[sum]) {\n                result.Add(pair);\n                k--;\n                if (k == 0) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (pq.Count < k) {\n                    pq.Enqueue(new List<long>() { nums1[i], nums2[j] });\n                } else {\n                    if (sum < pq.Peek()[0] + pq.Peek()[1]) {\n                        pq.Dequeue();\n                        pq.Enqueue(new List<long>() { nums1[i], nums2[j] });\n                    }\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Dequeue());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var heap = new Heap<List<long>>();\n        var visited = new HashSet<List<long>>();\n        heap.Add(new List<long>() { nums1[0], nums2[0], 0, 0 });\n        visited.Add(new List<long>() { 0, 0 });\n        while (heap.Count > 0 && result.Count < k) {\n            var pair = heap.Remove();\n            result.Add(new List<long>() { pair[0], pair[1] });\n            var i = pair[2];\n            var j = pair[3];\n            if (i + 1 < nums1.Count && !visited.Contains(new List<long>() { i + 1, j })) {\n                heap.Add(new List<long>() { nums1[i + 1], nums2[j], i + 1, j });\n                visited.Add(new List<long>() { i + 1, j });\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(new List<long>() { i, j + 1 })) {\n                heap.Add(new List<long>() { nums1[i], nums2[j + 1], i, j + 1 });\n                visited.Add(new List<long>() { i, j + 1 });\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(k);\n        var visited = new HashSet<List<long>>();\n        var start = new List<long>() { 0, 0 };\n        pq.Enqueue(start, nums1[0] + nums2[0]);\n        visited.Add(start);\n        while (pq.Count > 0 && result.Count < k) {\n            var cur = pq.Dequeue();\n            var i = cur[0];\n            var j = cur[1];\n            result.Add(new List<long>() { nums1[(int)i], nums2[(int)j] });\n            if (i + 1 < nums1.Count) {\n                var next = new List<long>() { i + 1, j };\n                if (!visited.Contains(next)) {\n                    pq.Enqueue(next, nums1[(int)i + 1] + nums2[(int)j]);\n                    visited.Add(next);\n                }\n            }\n            if (j + 1 < nums2.Count) {\n                var next = new List<long>() { i, j + 1 };\n                if (!visited.Contains(next)) {\n                    pq.Enqueue(next, nums1[(int)i] + nums2[(int)j + 1]);\n                    visited.Add(next);\n                }\n            }\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var pq = new PriorityQueue<List<long>>(new List<long>());\n        var visited = new HashSet<string>();\n        pq.Enqueue(new List<long> { nums1[0], nums2[0], 0, 0 });\n        visited.Add(nums1[0] + \",\" + nums2[0]);\n        while (pq.Count > 0 && result.Count < k) {\n            var current = pq.Dequeue();\n            result.Add(new List<long> { current[0], current[1] });\n            var i = current[2];\n            var j = current[3];\n            if (i + 1 < nums1.Count && !visited.Contains(nums1[i + 1] + \",\" + nums2[j])) {\n                pq.Enqueue(new List<long> { nums1[i + 1], nums2[j], i + 1, j });\n                visited.Add(nums1[i + 1] + \",\" + nums2[j]);\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(nums1[i] + \",\" + nums2[j + 1])) {\n                pq.Enqueue(new List<long> { nums1[i], nums2[j + 1], i, j + 1 });\n                visited.Add(nums1[i] + \",\" + nums2[j + 1]);\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0 || k == 0) {\n            return result;\n        }\n        // Sort the first list.\n        nums1.Sort();\n        // Sort the second list.\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap<long> heap = new MinHeap<long>();\n        // Add the first element of the first list and the first element of the second list to the min heap.\n        heap.Add(nums1[0] + nums2[0], new List<long>() { nums1[0], nums2[0] });\n        // Create a set to store the elements that have been added to the min heap.\n        HashSet<string> set = new HashSet<string>();\n        // Add the first element of the first list and the first element of the second list to the set.\n        set.Add(nums1[0] + \",\" + nums2[0]);\n        // While the min heap is not empty and the result list has less than k elements.\n        while (heap.Count > 0 && result.Count < k) {\n            // Remove the minimum element from the min heap.\n            List<long> pair = heap.RemoveMin();\n            // Add the removed element to the result list.\n            result.Add(pair);\n            // If the first element of the removed element is not the last element of the first list.\n            if (pair[0] != nums1[nums1.Count - 1]) {\n                // Find the index of the first element of the removed element in the first list.\n                int index = nums1.IndexOf(pair[0]);\n                // Add the element of the first list at the next index and the second element of the removed element to the min heap.\n                if (!set.Contains(nums1[index + 1] + \",\" + pair[1])) {\n                    heap.Add(nums1[index + 1] + pair[1], new List<long>() { nums1[index + 1], pair[1] });\n                    set.Add(",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        minHeap.Add(new Pair(nums1[0], nums2[0]));\n        var visited = new HashSet<Pair>();\n        visited.Add(new Pair(nums1[0], nums2[0]));\n        while (result.Count < k && minHeap.Count > 0) {\n            var pair = minHeap.Pop();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.FirstIndex + 1 < nums1.Count) {\n                var newPair = new Pair(nums1[pair.FirstIndex + 1], pair.Second);\n                if (!visited.Contains(newPair)) {\n                    minHeap.Add(newPair);\n                    visited.Add(newPair);\n                }\n            }\n            if (pair.SecondIndex + 1 < nums2.Count) {\n                var newPair = new Pair(pair.First, nums2[pair.SecondIndex + 1]);\n                if (!visited.Contains(newPair)) {\n                    minHeap.Add(newPair);\n                    visited.Add(newPair);\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var heap = new Heap<List<long>>(nums1.Count * nums2.Count);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                heap.Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(heap.Pop());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        for (int i = 0; i < k && !minHeap.IsEmpty(); i++) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> dict = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (dict.ContainsKey(sum)) {\n                    dict[sum].Add(new List<long>() { nums1[i], nums2[j] });\n                } else {\n                    dict.Add(sum, new List<List<long>>() { new List<long>() { nums1[i], nums2[j] } });\n                }\n            }\n        }\n        foreach (long key in dict.Keys) {\n            foreach (List<long> pair in dict[key]) {\n                result.Add(pair);\n                if (result.Count == k) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (pq.Count < k) {\n                    pq.Enqueue(new List<long> { nums1[i], nums2[j] });\n                } else {\n                    if (sum < pq.Peek()[0] + pq.Peek()[1]) {\n                        pq.Dequeue();\n                        pq.Enqueue(new List<long> { nums1[i], nums2[j] });\n                    }\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Dequeue());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Insert(new List<long> { nums1[0], nums2[0], 0, 0 });\n        visited.Add(nums1[0] + \",\" + nums2[0]);\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            var i = pair[2];\n            var j = pair[3];\n            result.Add(new List<long> { pair[0], pair[1] });\n            k--;\n            if (i + 1 < nums1.Count && !visited.Contains(nums1[i + 1] + \",\" + nums2[j])) {\n                minHeap.Insert(new List<long> { nums1[i + 1], nums2[j], i + 1, j });\n                visited.Add(nums1[i + 1] + \",\" + nums2[j]);\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(nums1[i] + \",\" + nums2[j + 1])) {\n                minHeap.Insert(new List<long> { nums1[i], nums2[j + 1], i, j + 1 });\n                visited.Add(nums1[i] + \",\" + nums2[j + 1]);\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        for (int i = 0; i < k && minHeap.Count > 0; i++) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Size > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.Num1, pair.Num2 });\n            if (pair.Index2 + 1 < nums2.Count) {\n                minHeap.Insert(new Pair(pair.Num1, nums2[(int)pair.Index2 + 1], pair.Index2 + 1));\n            }\n            k--;\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        // sort the two lists\n        nums1.Sort();\n        nums2.Sort();\n        // create a min heap of size k\n        MinHeap<long> minHeap = new MinHeap<long>(k);\n        // add the first k pairs to the heap\n        for (int i = 0; i < k && i < nums1.Count; i++) {\n            minHeap.Add(nums1[i] + nums2[0]);\n        }\n        // for each element in the first list\n        for (int i = 0; i < nums1.Count; i++) {\n            // for each element in the second list\n            for (int j = 0; j < nums2.Count; j++) {\n                // if the current pair is smaller than the largest pair in the heap\n                if (nums1[i] + nums2[j] < minHeap.Peek()) {\n                    // remove the largest pair from the heap\n                    minHeap.Remove();\n                    // add the current pair to the heap\n                    minHeap.Add(nums1[i] + nums2[j]);\n                }\n            }\n        }\n        // add the pairs in the heap to the result\n        while (minHeap.Count > 0) {\n            result.Add(new List<long> { minHeap.Remove() });\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var pq = new PriorityQueue<List<long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (pq.Count < k) {\n                    pq.Enqueue(new List<long> { nums1[i], nums2[j] });\n                } else if (sum < pq.Peek()[0] + pq.Peek()[1]) {\n                    pq.Dequeue();\n                    pq.Enqueue(new List<long> { nums1[i], nums2[j] });\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Dequeue());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<long>();\n        var visited = new HashSet<long>();\n        foreach (var n1 in nums1) {\n            foreach (var n2 in nums2) {\n                var sum = n1 + n2;\n                if (!visited.Contains(sum)) {\n                    heap.Insert(sum);\n                    visited.Add(sum);\n                }\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var sum = heap.ExtractMin();\n            var pair = new List<long>();\n            foreach (var n1 in nums1) {\n                foreach (var n2 in nums2) {\n                    if (n1 + n2 == sum) {\n                        pair.Add(n1);\n                        pair.Add(n2);\n                        break;\n                    }\n                }\n                if (pair.Count > 0) {\n                    break;\n                }\n            }\n            result.Add(pair);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap(k);\n        for (var i = 0; i < nums1.Count; i++) {\n            for (var j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (minHeap.Count < k) {\n                    minHeap.Add(new List<long> { nums1[i], nums2[j] });\n                } else if (sum < minHeap.Peek()[0] + minHeap.Peek()[1]) {\n                    minHeap.Poll();\n                    minHeap.Add(new List<long> { nums1[i], nums2[j] });\n                }\n            }\n        }\n        while (minHeap.Count > 0) {\n            result.Add(minHeap.Poll());\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list.\n        nums1.Sort();\n        // Sort the second list.\n        nums2.Sort();\n        // Initialize the heap with the first element of the first list and the first element of the second list.\n        Heap heap = new Heap(new List<long>() { nums1[0], nums2[0] });\n        // Initialize the first index of the first list to 0.\n        long i = 0;\n        // Initialize the first index of the second list to 0.\n        long j = 0;\n        // Iterate until the heap is empty or k elements have been added to the result.\n        while (heap.Count > 0 && result.Count < k) {\n            // Get the smallest pair from the heap.\n            List<long> pair = heap.Pop();\n            // Add the pair to the result.\n            result.Add(pair);\n            // If the first element of the pair is the last element of the first list, then increment the first index of the second list.\n            if (pair[0] == nums1[nums1.Count - 1]) {\n                j++;\n            }\n            // If the second element of the pair is the last element of the second list, then increment the first index of the first list.\n            else if (pair[1] == nums2[nums2.Count - 1]) {\n                i++;\n            }\n            // If the first element of the pair is the last element of the first list and the second element of the pair is the last element of the second list, then break.\n            else if (pair[0] == nums1[nums1.Count - 1] && pair[1] == nums2[nums2.Count - 1]) {\n                break;\n            }\n            // Otherwise, add the next pair to the heap.\n            else {\n                heap.Push(new List<long>() { nums1[i], nums2[j + 1] });\n                heap.Push(new List<",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var pair = new List<long> { nums1[i], nums2[j] };\n                if (pq.Count < k) {\n                    pq.Enqueue(pair);\n                } else {\n                    if (pq.Peek()[0] + pq.Peek()[1] > nums1[i] + nums2[j]) {\n                        pq.Dequeue();\n                        pq.Enqueue(pair);\n                    }\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Dequeue());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (minHeap.Count < k) {\n                    minHeap.Insert(new List<long>() { nums1[i], nums2[j] });\n                } else {\n                    if (sum < minHeap.Peek().Sum()) {\n                        minHeap.Pop();\n                        minHeap.Insert(new List<long>() { nums1[i], nums2[j] });\n                    }\n                }\n            }\n        }\n        while (minHeap.Count > 0) {\n            result.Add(minHeap.Pop());\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        foreach (var num1 in nums1) {\n            foreach (var num2 in nums2) {\n                minHeap.Insert(new List<long> { num1, num2 });\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(minHeap.Remove());\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        // Sort the first list\n        nums1.Sort();\n        // Sort the second list\n        nums2.Sort();\n        // Create a min heap\n        MinHeap heap = new MinHeap(nums1.Count);\n        // Add the first element of the second list to the heap\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // Add the first element of the first list to the set\n        HashSet<long> set = new HashSet<long>();\n        set.Add(nums1[0]);\n        // While the heap is not empty and we have not found k pairs\n        while (heap.Count > 0 && result.Count < k) {\n            // Get the smallest pair\n            Pair pair = heap.Pop();\n            // Add the pair to the result\n            result.Add(new List<long>() { pair.First, pair.Second });\n            // If the first element of the pair is the last element of the first list\n            if (pair.First == nums1[nums1.Count - 1]) {\n                // If the second element of the pair is not the last element of the second list\n                if (pair.Second != nums2[nums2.Count - 1]) {\n                    // Add the pair with the second element incremented by one to the heap\n                    heap.Add(new Pair(pair.First, pair.Second + 1));\n                }\n            } else {\n                // If the second element of the pair is the last element of the second list\n                if (pair.Second == nums2[nums2.Count - 1]) {\n                    // If the first element of the pair is not the last element of the first list\n                    if (pair.First != nums1[nums1.Count - 1]) {\n                        // Add the pair with the first element incremented by one to the heap\n                        heap.Add(new Pair(pair.First + 1, pair.Second));\n                    }\n                } else {\n                    // If the first element of the pair is not",
    "        var result = new List<List<long>>();\n        var heap = new Heap<long>();\n        for (var i = 0; i < nums1.Count; i++) {\n            for (var j = 0; j < nums2.Count; j++) {\n                heap.Add(nums1[i] + nums2[j]);\n            }\n        }\n        for (var i = 0; i < k; i++) {\n            result.Add(new List<long> { heap.ExtractMin(), heap.ExtractMin() });\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        // TODO: Write your code here\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> sums = new SortedDictionary<long, List<List<long>>>();\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                long sum = nums1[(int)i] + nums2[(int)j];\n                if (!sums.ContainsKey(sum)) {\n                    sums.Add(sum, new List<List<long>>());\n                }\n                sums[sum].Add(new List<long>() { nums1[(int)i], nums2[(int)j] });\n            }\n        }\n        foreach (long key in sums.Keys) {\n            foreach (List<long> pair in sums[key]) {\n                result.Add(pair);\n                k--;\n                if (k == 0) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        minHeap.Insert(new Pair(nums1[0], nums2[0]));\n        var visited = new HashSet<Pair>();\n        visited.Add(new Pair(nums1[0], nums2[0]));\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            k--;\n            if (pair.FirstIndex + 1 < nums1.Count) {\n                var newPair = new Pair(nums1[pair.FirstIndex + 1], pair.Second, pair.FirstIndex + 1, pair.SecondIndex);\n                if (!visited.Contains(newPair)) {\n                    minHeap.Insert(newPair);\n                    visited.Add(newPair);\n                }\n            }\n            if (pair.FirstIndex == 0 && pair.SecondIndex + 1 < nums2.Count) {\n                var newPair = new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.FirstIndex, pair.SecondIndex + 1);\n                if (!visited.Contains(newPair)) {\n                    minHeap.Insert(newPair);\n                    visited.Add(newPair);\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (minHeap.Count < k) {\n                    minHeap.Insert(sum, new List<long> { nums1[i], nums2[j] });\n                } else {\n                    if (sum < minHeap.Peek().Key) {\n                        minHeap.ExtractMin();\n                        minHeap.Insert(sum, new List<long> { nums1[i], nums2[j] });\n                    }\n                }\n            }\n        }\n        while (minHeap.Count > 0) {\n            result.Add(minHeap.ExtractMin().Value);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var queue = new SortedSet<Tuple<long, int, int>>();\n        for (int i = 0; i < nums1.Count && i < k; i++) {\n            queue.Add(Tuple.Create(nums1[i] + nums2[0], i, 0));\n        }\n        while (k-- > 0 && queue.Any()) {\n            var current = queue.Min;\n            queue.Remove(current);\n            result.Add(new List<long>() { nums1[current.Item2], nums2[current.Item3] });\n            if (current.Item3 == nums2.Count - 1) {\n                continue;\n            }\n            queue.Add(Tuple.Create(nums1[current.Item2] + nums2[current.Item3 + 1], current.Item2, current.Item3 + 1));\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        if (k > nums1.Count * nums2.Count) {\n            k = nums1.Count * nums2.Count;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            long sum = sums[i];\n            long num1 = 0;\n            long num2 = 0;\n            for (int j = 0; j < nums1.Count; j++) {\n                for (int l = 0; l < nums2.Count; l++) {\n                    if (nums1[j] + nums2[l] == sum) {\n                        num1 = nums1[j];\n                        num2 = nums2[l];\n                        break;\n                    }\n                }\n            }\n            result.Add(new List<long>() { num1, num2 });\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // sort the lists\n        nums1.Sort();\n        nums2.Sort();\n        // initialize the heap\n        Heap heap = new Heap(k);\n        // add the first pair\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // keep track of the pairs we've already seen\n        HashSet<Pair> seen = new HashSet<Pair>();\n        seen.Add(new Pair(nums1[0], nums2[0]));\n        // loop through the heap\n        while (heap.Count > 0) {\n            Pair pair = heap.Pop();\n            result.Add(new List<long> { pair.First, pair.Second });\n            // add the next pair from the first list\n            if (pair.FirstIndex + 1 < nums1.Count) {\n                Pair newPair = new Pair(nums1[pair.FirstIndex + 1], pair.Second);\n                if (!seen.Contains(newPair)) {\n                    heap.Add(newPair);\n                    seen.Add(newPair);\n                }\n            }\n            // add the next pair from the second list\n            if (pair.SecondIndex + 1 < nums2.Count) {\n                Pair newPair = new Pair(pair.First, nums2[pair.SecondIndex + 1]);\n                if (!seen.Contains(newPair)) {\n                    heap.Add(newPair);\n                    seen.Add(newPair);\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                heap.Insert(nums1[i] + nums2[j]);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var sum = heap.ExtractMin();\n            var pair = new List<long>();\n            pair.Add(sum / 2);\n            pair.Add(sum / 2);\n            result.Add(pair);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var pq = new PriorityQueue<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                pq.Enqueue(new List<long> { sum, nums1[i], nums2[j] });\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            if (pq.Count == 0) {\n                break;\n            }\n            var item = pq.Dequeue();\n            result.Add(new List<long> { item[1], item[2] });\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Insert(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \",\" + 0);\n        while (result.Count < k && minHeap.Count > 0) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.FirstIndex + 1 < nums1.Count && !visited.Contains((pair.FirstIndex + 1) + \",\" + pair.SecondIndex)) {\n                minHeap.Insert(new Pair(nums1[pair.FirstIndex + 1], nums2[pair.SecondIndex], pair.FirstIndex + 1, pair.SecondIndex));\n                visited.Add((pair.FirstIndex + 1) + \",\" + pair.SecondIndex);\n            }\n            if (pair.SecondIndex + 1 < nums2.Count && !visited.Contains(pair.FirstIndex + \",\" + (pair.SecondIndex + 1))) {\n                minHeap.Insert(new Pair(nums1[pair.FirstIndex], nums2[pair.SecondIndex + 1], pair.FirstIndex, pair.SecondIndex + 1));\n                visited.Add(pair.FirstIndex + \",\" + (pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        pairs.Sort((a, b) => {\n            if (a[0] + a[1] == b[0] + b[1]) {\n                return 0;\n            }\n            return (a[0] + a[1] < b[0] + b[1]) ? -1 : 1;\n        });\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[i]);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var pq = new PriorityQueue<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (pq.Count < k) {\n                    pq.Add(new List<long>() { nums1[i], nums2[j] });\n                } else if (sum < pq.Peek()[0] + pq.Peek()[1]) {\n                    pq.Remove();\n                    pq.Add(new List<long>() { nums1[i], nums2[j] });\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Remove());\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0)\n            return result;\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                if (sums[0] == nums1[i] + nums2[j]) {\n                    result.Add(new List<long> { nums1[i], nums2[j] });\n                    sums.RemoveAt(0);\n                    if (result.Count == k)\n                        return result;\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<Tuple<long, long, long>>(k, (a, b) => a.Item3.CompareTo(b.Item3));\n        foreach (var n1 in nums1) {\n            foreach (var n2 in nums2) {\n                heap.Add(new Tuple<long, long, long>(n1, n2, n1 + n2));\n            }\n        }\n        while (heap.Count > 0) {\n            var pair = heap.Pop();\n            result.Add(new List<long> { pair.Item1, pair.Item2 });\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.Index < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.Index + 1], pair.Index + 1));\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Add(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \",\" + 0);\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Pop();\n            result.Add(new List<long> { pair.Num1, pair.Num2 });\n            var i = pair.Index1;\n            var j = pair.Index2;\n            if (i + 1 < nums1.Count && !visited.Contains((i + 1) + \",\" + j)) {\n                minHeap.Add(new Pair(nums1[i + 1], nums2[j], i + 1, j));\n                visited.Add((i + 1) + \",\" + j);\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(i + \",\" + (j + 1))) {\n                minHeap.Add(new Pair(nums1[i], nums2[j + 1], i, j + 1));\n                visited.Add(i + \",\" + (j + 1));\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                heap.Insert(nums1[i] + nums2[j]);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var sum = heap.ExtractMin();\n            var pair = new List<long>();\n            pair.Add(sum / nums2.Count);\n            pair.Add(sum % nums2.Count);\n            result.Add(pair);\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0 || k == 0) {\n            return result;\n        }\n        // Sort the first list\n        nums1.Sort();\n        // Sort the second list\n        nums2.Sort();\n        // Create a min heap\n        MinHeap<long> minHeap = new MinHeap<long>();\n        // Add the first pair to the min heap\n        minHeap.Add(nums1[0] + nums2[0], new List<long> { nums1[0], nums2[0] });\n        // Create a set to store the pairs\n        HashSet<List<long>> set = new HashSet<List<long>>();\n        set.Add(new List<long> { nums1[0], nums2[0] });\n        // Loop until we have k pairs\n        while (result.Count < k) {\n            // Get the minimum pair\n            List<long> pair = minHeap.GetMin();\n            // Add the pair to the result\n            result.Add(pair);\n            // Get the indices of the pair\n            long i = pair[0];\n            long j = pair[1];\n            // Check if we can add the next pair\n            if (i + 1 < nums1.Count && !set.Contains(new List<long> { i + 1, j })) {\n                // Add the next pair to the min heap\n                minHeap.Add(nums1[(int)(i + 1)] + nums2[(int)j], new List<long> { i + 1, j });\n                // Add the next pair to the set\n                set.Add(new List<long> { i + 1, j });\n            }\n            // Check if we can add the next pair\n            if (j + 1 < nums2.Count && !set.Contains(new List<long> { i, j + 1 })) {\n                // Add the next pair to the min heap\n                minHeap.Add(nums1[(int)i] + nums2[(int)(j + 1",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0 || k == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Add(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \",\" + 0);\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Pop();\n            result.Add(new List<long> { pair.Num1, pair.Num2 });\n            k--;\n            if (pair.Index1 + 1 < nums1.Count && !visited.Contains((pair.Index1 + 1) + \",\" + pair.Index2)) {\n                minHeap.Add(new Pair(nums1[pair.Index1 + 1], nums2[pair.Index2], pair.Index1 + 1, pair.Index2));\n                visited.Add((pair.Index1 + 1) + \",\" + pair.Index2);\n            }\n            if (pair.Index2 + 1 < nums2.Count && !visited.Contains(pair.Index1 + \",\" + (pair.Index2 + 1))) {\n                minHeap.Add(new Pair(nums1[pair.Index1], nums2[pair.Index2 + 1], pair.Index1, pair.Index2 + 1));\n                visited.Add(pair.Index1 + \",\" + (pair.Index2 + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        Dictionary<long, List<long>> dict = new Dictionary<long, List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!dict.ContainsKey(sum)) {\n                    dict.Add(sum, new List<long>());\n                }\n                dict[sum].Add(nums1[i]);\n                dict[sum].Add(nums2[j]);\n            }\n        }\n        List<long> keys = dict.Keys.ToList();\n        keys.Sort();\n        for (int i = 0; i < keys.Count; i++) {\n            for (int j = 0; j < dict[keys[i]].Count; j += 2) {\n                result.Add(new List<long>() { dict[keys[i]][j], dict[keys[i]][j + 1] });\n                if (result.Count == k) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<Tuple<long, long, long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            heap.Insert(new Tuple<long, long, long>(nums1[i] + nums2[0], i, 0));\n        }\n        while (k > 0 && heap.Count > 0) {\n            var item = heap.Extract();\n            result.Add(new List<long>() { nums1[item.Item2], nums2[item.Item3] });\n            if (item.Item3 + 1 < nums2.Count) {\n                heap.Insert(new Tuple<long, long, long>(nums1[item.Item2] + nums2[item.Item3 + 1], item.Item2, item.Item3 + 1));\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                heap.Add(nums1[i] + nums2[j]);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(new List<long> { heap.Pop(), heap.Pop() });\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<long>();\n        foreach (var n1 in nums1) {\n            foreach (var n2 in nums2) {\n                heap.Add(n1 + n2);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var n = heap.Remove();\n            var pair = new List<long>();\n            pair.Add(n);\n            pair.Add(n);\n            result.Add(pair);\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (var i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (result.Count < k && !minHeap.IsEmpty()) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for(int i = 0; i < nums1.Count; i++) {\n            for(int j = 0; j < nums2.Count; j++) {\n                minHeap.Insert(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        while(k > 0) {\n            result.Add(minHeap.ExtractMin());\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                heap.Insert(nums1[i] + nums2[j]);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var element = heap.ExtractMin();\n            if (element == null) break;\n            result.Add(new List<long> { element.Value });\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        pairs.Sort((a, b) => (int)(a[0] + a[1] - b[0] - b[1]));\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[i]);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>((a, b) => a[0] + a[1] - b[0] - b[1]);\n        for (int i = 0; i < nums1.Count; i++) {\n            pq.Push(new List<long>() { nums1[i], nums2[0], 0 });\n        }\n        while (k > 0 && pq.Count > 0) {\n            var pair = pq.Pop();\n            result.Add(new List<long>() { pair[0], pair[1] });\n            if (pair[2] < nums2.Count - 1) {\n                pq.Push(new List<long>() { pair[0], nums2[(int)pair[2] + 1], pair[2] + 1 });\n            }\n            k--;\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first list.\n        nums1.Sort();\n        // Sort the second list.\n        nums2.Sort();\n        // Create a min heap of size k.\n        MinHeap heap = new MinHeap(k);\n        // Add the first k pairs to the heap.\n        for (int i = 0; i < k && i < nums1.Count; i++) {\n            heap.Add(new List<long>() { nums1[i], nums2[0], 0 });\n        }\n        // Pop the top pair from the heap and add it to the result.\n        // Add the next pair to the heap.\n        while (heap.Count > 0) {\n            List<long> pair = heap.Pop();\n            result.Add(new List<long>() { pair[0], pair[1] });\n            if (pair[2] < nums2.Count - 1) {\n                heap.Add(new List<long>() { pair[0], nums2[(int)pair[2] + 1], pair[2] + 1 });\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<long, List<long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (pq.Count < k) {\n                    pq.Enqueue(sum, new List<long> { nums1[i], nums2[j] });\n                } else {\n                    if (sum < pq.Peek().Key) {\n                        pq.Dequeue();\n                        pq.Enqueue(sum, new List<long> { nums1[i], nums2[j] });\n                    }\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Dequeue().Value);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<int>();\n        minHeap.Insert(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0);\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            k--;\n            var nextI = pair.I + 1;\n            var nextJ = pair.J + 1;\n            if (nextI < nums1.Count && !visited.Contains(nextI * nums2.Count + pair.J)) {\n                minHeap.Insert(new Pair(nums1[nextI], nums2[pair.J], nextI, pair.J));\n                visited.Add(nextI * nums2.Count + pair.J);\n            }\n            if (nextJ < nums2.Count && !visited.Contains(pair.I * nums2.Count + nextJ)) {\n                minHeap.Insert(new Pair(nums1[pair.I], nums2[nextJ], pair.I, nextJ));\n                visited.Add(pair.I * nums2.Count + nextJ);\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        if (k > nums1.Count * nums2.Count) {\n            k = nums1.Count * nums2.Count;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                if (sums[0] == nums1[i] + nums2[j]) {\n                    result.Add(new List<long> { nums1[i], nums2[j] });\n                    sums.RemoveAt(0);\n                    k--;\n                    if (k == 0) {\n                        return result;\n                    }\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap<Tuple<long, long, long>>();\n        for (var i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new Tuple<long, long, long>(nums1[i] + nums2[0], i, 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { nums1[pair.Item2], nums2[pair.Item3] });\n            if (pair.Item3 < nums2.Count - 1) {\n                minHeap.Add(new Tuple<long, long, long>(nums1[pair.Item2] + nums2[pair.Item3 + 1], pair.Item2, pair.Item3 + 1));\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var pq = new PriorityQueue<Tuple<long, long, long>>(k);\n        foreach (var n1 in nums1) {\n            foreach (var n2 in nums2) {\n                pq.Enqueue(new Tuple<long, long, long>(n1 + n2, n1, n2));\n            }\n        }\n        while (pq.Count > 0) {\n            var t = pq.Dequeue();\n            result.Add(new List<long> { t.Item2, t.Item3 });\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<Pair>();\n        var visited = new HashSet<Pair>();\n        var firstPair = new Pair(0, 0, nums1[0] + nums2[0]);\n        minHeap.Add(firstPair);\n        visited.Add(firstPair);\n        for (int i = 0; i < k && minHeap.Count > 0; i++) {\n            var smallestPair = minHeap.ExtractMin();\n            result.Add(new List<long> { nums1[smallestPair.FirstIndex], nums2[smallestPair.SecondIndex] });\n            var firstPair = new Pair(smallestPair.FirstIndex, smallestPair.SecondIndex + 1, nums1[smallestPair.FirstIndex] + nums2[smallestPair.SecondIndex + 1]);\n            var secondPair = new Pair(smallestPair.FirstIndex + 1, smallestPair.SecondIndex, nums1[smallestPair.FirstIndex + 1] + nums2[smallestPair.SecondIndex]);\n            if (smallestPair.SecondIndex + 1 < nums2.Count && !visited.Contains(firstPair)) {\n                minHeap.Add(firstPair);\n                visited.Add(firstPair);\n            }\n            if (smallestPair.FirstIndex + 1 < nums1.Count && !visited.Contains(secondPair)) {\n                minHeap.Add(secondPair);\n                visited.Add(secondPair);\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var heap = new Heap<Tuple<long, long, long>>(k, (a, b) => a.Item3.CompareTo(b.Item3));\n        var visited = new HashSet<Tuple<long, long>>();\n        var first = new Tuple<long, long, long>(0, 0, nums1[0] + nums2[0]);\n        heap.Add(first);\n        visited.Add(new Tuple<long, long>(0, 0));\n        while (result.Count < k && heap.Count > 0) {\n            var current = heap.Remove();\n            result.Add(new List<long>() { nums1[current.Item1], nums2[current.Item2] });\n            if (current.Item1 + 1 < nums1.Count && !visited.Contains(new Tuple<long, long>(current.Item1 + 1, current.Item2))) {\n                heap.Add(new Tuple<long, long, long>(current.Item1 + 1, current.Item2, nums1[current.Item1 + 1] + nums2[current.Item2]));\n                visited.Add(new Tuple<long, long>(current.Item1 + 1, current.Item2));\n            }\n            if (current.Item2 + 1 < nums2.Count && !visited.Contains(new Tuple<long, long>(current.Item1, current.Item2 + 1))) {\n                heap.Add(new Tuple<long, long, long>(current.Item1, current.Item2 + 1, nums1[current.Item1] + nums2[current.Item2 + 1]));\n                visited.Add(new Tuple<long, long>(current.Item1, current.Item2 + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<Tuple<long, long, long>>(false);\n        for (var i = 0; i < nums1.Count; i++) {\n            for (var j = 0; j < nums2.Count; j++) {\n                heap.Add(new Tuple<long, long, long>(nums1[i] + nums2[j], i, j));\n            }\n        }\n        for (var i = 0; i < k; i++) {\n            var item = heap.Remove();\n            result.Add(new List<long>() { nums1[item.Item2], nums2[item.Item3] });\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> sumToPairs = new SortedDictionary<long, List<List<long>>>();\n        foreach (long num1 in nums1) {\n            foreach (long num2 in nums2) {\n                long sum = num1 + num2;\n                if (!sumToPairs.ContainsKey(sum)) {\n                    sumToPairs.Add(sum, new List<List<long>>());\n                }\n                sumToPairs[sum].Add(new List<long>() { num1, num2 });\n            }\n        }\n        foreach (long sum in sumToPairs.Keys) {\n            foreach (List<long> pair in sumToPairs[sum]) {\n                result.Add(pair);\n                k--;\n                if (k == 0) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Size() > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                minHeap.Insert(sum, new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(minHeap.ExtractMin().Value);\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n            k--;\n        }\n        return result;"
  ]
}