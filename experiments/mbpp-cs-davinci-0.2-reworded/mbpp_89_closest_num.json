{
  "name": "mbpp_89_closest_num",
  "language": "cs",
  "prompt": "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    // Write a function to find the closest smaller number than n.\n    public static long ClosestNum(long N) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_89_closest_num.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestNum((11L)) == (10L));\n    Debug.Assert(ClosestNum((7L)) == (6L));\n    Debug.Assert(ClosestNum((12L)) == (11L));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        var s = N.ToString();\n        var n = s.Length;\n        var i = n - 1;\n        while (i > 0 && s[i] <= s[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return -1;\n        }\n        var j = n - 1;\n        while (s[j] >= s[i - 1]) {\n            j--;\n        }\n        var t = s[i - 1];\n        s = s.Remove(i - 1, 1).Insert(i - 1, s[j].ToString());\n        s = s.Remove(j, 1).Insert(j, t.ToString());\n        var k = n - 1;\n        while (i < k) {\n            t = s[i];\n            s = s.Remove(i, 1).Insert(i, s[k].ToString());\n            s = s.Remove(k, 1).Insert(k, t.ToString());\n            i++;\n            k--;\n        }\n        return long.Parse(s);",
    "        long n = N;\n        long i = 0;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                break;\n            }\n            i++;\n            n >>= 1;\n        }\n        return N - (1 << i);",
    "        // Write your code here\n        // To debug: Console.Error.WriteLine(\"Debug messages...\");\n        long n = N;\n        long max = 0;\n        long min = 0;\n        long mid = 0;\n        long max_mid = 0;\n        long min_mid = 0;\n        long max_min = 0;\n        long min_max = 0;\n        long max_max = 0;\n        long min_min = 0;\n        long max_max_min = 0;\n        long min_min_max = 0;\n        long max_max_max = 0;\n        long min_min_min = 0;\n        long max_max_max_min = 0;\n        long min_min_min_max = 0;\n        long max_max_max_max = 0;\n        long min_min_min_min = 0;\n        long max_max_max_max_min = 0;\n        long min_min_min_min_max = 0;\n        long max_max_max_max_max = 0;\n        long min_min_min_min_min = 0;\n        long max_max_max_max_max_min = 0;\n        long min_min_min_min_min_max = 0;\n        long max_max_max_max_max_max = 0;\n        long min_min_min_min_min_min = 0;\n        long max_max_max_max_max_max_min = 0;\n        long min_min_min_min_min_min_max = 0;\n        long max_max_max_max_max_max_max = 0;\n        long min_min_min_min_min_min_min = 0;\n        long max_max_max_max_max_max_max_min = 0;\n        long min_min_min_min_min_min_min_max = 0;\n        long max_max_max_max_max_max_max_max = 0;\n        long min_min_min_min_min_min_min_min = 0;\n        long max_max_max_max_max_max_max_max_min = 0",
    "        var s = N.ToString();\n        var n = s.Length;\n        var i = n - 1;\n        while (i > 0 && s[i - 1] <= s[i]) i--;\n        if (i == 0) return -1;\n        var j = n - 1;\n        while (s[j] >= s[i - 1]) j--;\n        var t = s[i - 1];\n        s = s.Remove(i - 1, 1).Insert(i - 1, s[j].ToString());\n        s = s.Remove(j, 1).Insert(j, t.ToString());\n        var s1 = s.Substring(0, i);\n        var s2 = s.Substring(i);\n        var s3 = new string(s2.Reverse().ToArray());\n        return long.Parse(s1 + s3);",
    "        var bits = new List<bool>();\n        while (N > 0) {\n            bits.Add((N & 1) == 1);\n            N >>= 1;\n        }\n        bits.Reverse();\n        for (int i = 0; i < bits.Count; i++) {\n            if (bits[i] && !bits[i + 1]) {\n                bits[i] = false;\n                bits[i + 1] = true;\n                break;\n            }\n        }\n        long ret = 0;\n        for (int i = 0; i < bits.Count; i++) {\n            ret |= (bits[i] ? 1 : 0) << i;\n        }\n        return ret;",
    "        var n = N;\n        var i = 0;\n        while (n > 0) {\n            if ((n & 1) == 0) {\n                n = n >> 1;\n            } else {\n                n = n >> 1;\n                break;\n            }\n            i++;\n        }\n        return N - (1L << i);",
    "        // Find the number of digits in N\n        int digits = (int)Math.Floor(Math.Log10(N)) + 1;\n        // Find the closest power of 10\n        long closestPower = (long)Math.Pow(10, digits - 1);\n        // Find the closest number\n        long closestNum = 0;\n        for (int i = 0; i < digits; i++) {\n            closestNum += (N / closestPower) * closestPower;\n            N %= closestPower;\n            closestPower /= 10;\n        }\n        return closestNum;",
    "        // Find the first bit that is 1.\n        int i = 0;\n        while ((N & (1 << i)) == 0) {\n            i++;\n        }\n        // Flip the bit to 0.\n        N &= ~(1 << i);\n        // Set the next bit to 1.\n        N |= (1 << (i - 1));\n        return N;",
    "        var digits = new List<long>();\n        var n = N;\n        while (n > 0) {\n            digits.Add(n % 10);\n            n /= 10;\n        }\n        digits.Reverse();\n        var len = digits.Count;\n        for (int i = 1; i < len; i++) {\n            if (digits[i] < digits[i - 1]) {\n                var tmp = digits[i];\n                digits[i] = digits[i - 1];\n                digits[i - 1] = tmp;\n                break;\n            }\n        }\n        var res = 0L;\n        for (int i = 0; i < len; i++) {\n            res = res * 10 + digits[i];\n        }\n        return res;",
    "        var n = N;\n        var i = 0;\n        while (n > 0) {\n            if ((n & 1) == 0) {\n                n >>= 1;\n                i++;\n            } else {\n                n -= 1;\n                break;\n            }\n        }\n        return N - (1 << i);",
    "        // Find the first 1 bit from the right.\n        int i = 0;\n        while ((N & (1 << i)) == 0) {\n            i++;\n        }\n        // Find the first 0 bit from the right.\n        int j = i + 1;\n        while ((N & (1 << j)) != 0) {\n            j++;\n        }\n        // Swap the bits.\n        N = N & ~(1 << i) & ~(1 << j);\n        N = N | (1 << i) | (1 << j);\n        return N;",
    "        long[] digits = new long[20];\n        long n = N;\n        int len = 0;\n        while (n > 0) {\n            digits[len++] = n % 10;\n            n /= 10;\n        }\n        for (int i = len - 1; i > 0; i--) {\n            if (digits[i] < digits[i - 1]) {\n                long tmp = digits[i - 1];\n                digits[i - 1] = digits[i];\n                digits[i] = tmp;\n                break;\n            }\n        }\n        long res = 0;\n        for (int i = len - 1; i >= 0; i--) {\n            res = res * 10 + digits[i];\n        }\n        return res;",
    "        long n = N;\n        int i = 0;\n        while (n > 0) {\n            n >>= 1;\n            i++;\n        }\n        long mask = (1L << i) - 1;\n        return N & mask;",
    "        // Find the number of bits in N\n        int bits = (int)Math.Floor(Math.Log(N, 2)) + 1;\n        // Find the largest power of 2 less than N\n        long largestPower = (long)Math.Pow(2, bits - 1);\n        // Find the closest number to N that is smaller than N and is a power of 2\n        return largestPower - 1;",
    "        var s = N.ToString();\n        var l = s.Length;\n        var d = s[l - 1];\n        var p = s.Substring(0, l - 1);\n        if (d == '0') {\n            return long.Parse(p + \"9\");\n        }\n        return long.Parse(p + (char)(d - 1));",
    "        // Find the first 1 bit from the right.\n        int i = 0;\n        while ((N & (1 << i)) == 0) {\n            i++;\n        }\n        // Flip the first 1 bit from the right.\n        N = N & ~(1 << i);\n        // Add 1 to the right of the flipped bit.\n        N = N | (1 << (i - 1));\n        return N;",
    "        // Convert N to binary\n        string binary = Convert.ToString(N, 2);\n        // Find the first 1 from the right\n        int index = binary.LastIndexOf('1');\n        // If there is no 1, then return 0\n        if (index == -1)\n            return 0;\n        // If there is a 1, then flip the bit at index\n        binary = binary.Substring(0, index) + '0' + binary.Substring(index + 1);\n        // Convert the binary string back to decimal\n        return Convert.ToInt64(binary, 2);",
    "        // Find the first 1 bit from the right.\n        int i = 0;\n        while ((N & (1 << i)) == 0) {\n            i++;\n        }\n        // Flip the first 0 bit from the right.\n        return N & ~(1 << i);",
    "        // Find the closest smaller number than n.\n        // The number must be a multiple of 3.\n        // The number must have the same number of digits as n.\n        // The number must be a palindrome.\n        // The number must be less than n.\n        // The number must be greater than 0.\n        // The number must be a multiple of 3.\n        // The number must have the same number of digits as n.\n        // The number must be a palindrome.\n        // The number must be less than n.\n        // The number must be greater than 0.\n        // The number must be a multiple of 3.\n        // The number must have the same number of digits as n.\n        // The number must be a palindrome.\n        // The number must be less than n.\n        // The number must be greater than 0.\n        // The number must be a multiple of 3.\n        // The number must have the same number of digits as n.\n        // The number must be a palindrome.\n        // The number must be less than n.\n        // The number must be greater than 0.\n        // The number must be a multiple of 3.\n        // The number must have the same number of digits as n.\n        // The number must be a palindrome.\n        // The number must be less than n.\n        // The number must be greater than 0.\n        // The number must be a multiple of 3.\n        // The number must have the same number of digits as n.\n        // The number must be a palindrome.\n        // The number must be less than n.\n        // The number must be greater than 0.\n        // The number must be a multiple of 3.\n        // The number must have the same number of digits as n.\n        // The number must be a palindrome.\n        // The number must be less than n.\n        // The number must be greater than 0.\n        // The number must be a multiple of 3.\n        // The number must have the same number of digits as n.\n        // The number must be a palindrome.\n        // The number must be less than n.\n        // The number must be greater than 0.\n        // The number must be a multiple of 3.\n",
    "        var digits = new List<int>();\n        while (N > 0) {\n            digits.Add((int)(N % 10));\n            N /= 10;\n        }\n        digits.Reverse();\n        var n = digits.Count;\n        var i = n - 1;\n        while (i > 0 && digits[i] >= digits[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return -1;\n        }\n        var j = n - 1;\n        while (digits[j] >= digits[i - 1]) {\n            j--;\n        }\n        var temp = digits[i - 1];\n        digits[i - 1] = digits[j];\n        digits[j] = temp;\n        j = n - 1;\n        while (i < j) {\n            temp = digits[i];\n            digits[i] = digits[j];\n            digits[j] = temp;\n            i++;\n            j--;\n        }\n        var result = 0L;\n        foreach (var d in digits) {\n            result = result * 10 + d;\n        }\n        return result;"
  ]
}