{
  "name": "mbpp_301_dict_depth",
  "language": "cs",
  "prompt": "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    // Write a function to find the depth of a dictionary.\n    public static long DictDepth(object d) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_301_dict_depth.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    public static void Main(string[] args) {\n    Debug.Assert(DictDepth((new object()}}}}}})) == (4L));\n    Debug.Assert(DictDepth((new object(){{\"c\", \"python\"}}}})) == (2L));\n    Debug.Assert(DictDepth((new object(){{4L, \"Mon\"}}}}}})) == (3L));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        if (d is Dictionary<object, object>) {\n            var dict = (Dictionary<object, object>)d;\n            return 1 + dict.Values.Max(v => DictDepth(v));\n        } else {\n            return 0;\n        }",
    "        if (d == null) {\n            return 0;\n        }\n        if (d is IDictionary<string, object>) {\n            var dict = (IDictionary<string, object>)d;\n            if (dict.Count == 0) {\n                return 1;\n            }\n            return 1 + dict.Values.Select(DictDepth).Max();\n        }\n        return 0;",
    "        if (d is IDictionary<string, object>) {\n            return 1 + DictDepth(((IDictionary<string, object>)d).Values.Max(x => x));\n        }\n        return 0;",
    "        if (d == null) {\n            return 0;\n        }\n        if (d is string) {\n            return 0;\n        }\n        if (d is IDictionary<string, object>) {\n            var dict = (IDictionary<string, object>)d;\n            return 1 + dict.Values.Select(DictDepth).Max();\n        }\n        throw new ArgumentException(\"d must be a dictionary\");",
    "        if (d is Dictionary<string, object>) {\n            return 1 + DictDepth(((Dictionary<string, object>)d).Values.Max());\n        } else {\n            return 0;\n        }",
    "        if (d == null) {\n            return 0;\n        }\n        if (d is Dictionary<string, object>) {\n            var dict = (Dictionary<string, object>)d;\n            var maxDepth = 0L;\n            foreach (var kv in dict) {\n                maxDepth = Math.Max(maxDepth, DictDepth(kv.Value));\n            }\n            return maxDepth + 1;\n        }\n        return 0;",
    "        long depth = 0;\n        if (d is Dictionary<object, object>) {\n            foreach (var k in (d as Dictionary<object, object>).Keys) {\n                depth = Math.Max(depth, DictDepth((d as Dictionary<object, object>)[k]));\n            }\n            depth += 1;\n        }\n        return depth;",
    "        if (d is Dictionary<string, object>) {\n            var dd = d as Dictionary<string, object>;\n            return 1 + dd.Values.Max(x => DictDepth(x));\n        } else {\n            return 0;\n        }",
    "        if (d is Dictionary<string, object>) {\n            var dict = (Dictionary<string, object>)d;\n            if (dict.Count == 0) {\n                return 1;\n            }\n            return 1 + dict.Values.Max(DictDepth);\n        }\n        return 0;",
    "        if (d is Dictionary<string, object>) {\n            Dictionary<string, object> dict = (Dictionary<string, object>)d;\n            long max = 0;\n            foreach (var kvp in dict) {\n                long depth = DictDepth(kvp.Value);\n                if (depth > max) {\n                    max = depth;\n                }\n            }\n            return max + 1;\n        }\n        return 0;",
    "        if (d is Dictionary<string, object>) {\n            return 1 + DictDepth(((Dictionary<string, object>)d).Values.Max());\n        }\n        return 0;",
    "        if (d is Dictionary<object, object>) {\n            var dict = (Dictionary<object, object>)d;\n            if (dict.Count == 0) {\n                return 1;\n            }\n            return 1 + dict.Values.Select(DictDepth).Max();\n        }\n        return 0;",
    "        long depth = 0;\n        foreach (var k in ((Dictionary<string, object>)d).Keys) {\n            depth = Math.Max(depth, DictDepth(((Dictionary<string, object>)d)[k]));\n        }\n        return depth + 1;",
    "        if (d is Dictionary<string, object>) {\n            var dict = (Dictionary<string, object>)d;\n            return 1 + dict.Values.Select(DictDepth).Max();\n        } else {\n            return 0;\n        }",
    "        if (d is Dictionary<string, object>) {\n            var dict = (Dictionary<string, object>)d;\n            long max = 0;\n            foreach (var kv in dict) {\n                long depth = DictDepth(kv.Value);\n                if (depth > max) {\n                    max = depth;\n                }\n            }\n            return max + 1;\n        } else {\n            return 0;\n        }",
    "        if (d is Dictionary<string, object>) {\n            var dd = d as Dictionary<string, object>;\n            long max = 0;\n            foreach (var kv in dd) {\n                long depth = DictDepth(kv.Value);\n                if (depth > max) {\n                    max = depth;\n                }\n            }\n            return max + 1;\n        }\n        return 0;",
    "        if (d == null) return 0;\n        if (d is string) return 1;\n        if (d is IEnumerable<object>) {\n            long max = 0;\n            foreach (object o in (IEnumerable<object>)d) {\n                max = Math.Max(max, DictDepth(o));\n            }\n            return max + 1;\n        }\n        return 1;",
    "        if (d == null) return 0;\n        if (d is string) return 1;\n        if (d is IDictionary<string, object>) {\n            var dd = (IDictionary<string, object>)d;\n            return 1 + dd.Values.Select(DictDepth).Max();\n        }\n        throw new ArgumentException(\"dictionary expected\");",
    "        if (d is Dictionary<string, object>) {\n            var dd = (Dictionary<string, object>)d;\n            return 1 + dd.Values.Max(x => DictDepth(x));\n        } else {\n            return 0;\n        }",
    "        if (d == null) return 0;\n        if (d is string) return 0;\n        if (d is int) return 0;\n        if (d is double) return 0;\n        if (d is long) return 0;\n        if (d is float) return 0;\n        if (d is decimal) return 0;\n        if (d is bool) return 0;\n        if (d is Dictionary<string, object>) {\n            var dd = (Dictionary<string, object>)d;\n            if (dd.Count == 0) return 1;\n            var depths = dd.Values.Select(DictDepth).ToList();\n            return depths.Max() + 1;\n        }\n        throw new Exception(\"Unsupported type\");"
  ]
}