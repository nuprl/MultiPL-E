{
  "name": "mbpp_103_eulerian_num",
  "language": "cs",
  "prompt": "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    // Write a function to find the Eulerian number a(n, m).\n    public static long EulerianNum(long n, long m) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_103_eulerian_num.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    public static void Main(string[] args) {\n    Debug.Assert(EulerianNum((3L), (1L)) == (4L));\n    Debug.Assert(EulerianNum((4L), (1L)) == (11L));\n    Debug.Assert(EulerianNum((5L), (3L)) == (26L));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        long[,] eulerian = new long[n + 1, m + 1];\n        for (long i = 0; i <= n; i++) {\n            for (long j = 0; j <= m; j++) {\n                if (i == 0 || j == 0) {\n                    eulerian[i, j] = 1;\n                } else {\n                    eulerian[i, j] = eulerian[i - 1, j - 1] + (i * eulerian[i - 1, j]);\n                }\n            }\n        }\n        return eulerian[n, m];",
    "        if (n < m)\n            return 0;\n        if (n == m)\n            return 1;\n        if (m == 0)\n            return 1;\n        return (n - m + 1) * EulerianNum(n, m - 1) + (m + 1) * EulerianNum(n, m + 1);",
    "        if (n < m) return 0;\n        if (n == m) return 1;\n        if (m == 0) return 1;\n        return (n - m) * EulerianNum(n - 1, m) + m * EulerianNum(n - 1, m - 1);",
    "        // Eulerian number is the number of permutations of n elements with exactly m ascents.\n        // a(n, m) = (n - m) * a(n - 1, m) + (m + 1) * a(n - 1, m - 1)\n        // a(n, 0) = a(n, n) = 1\n        // a(n, m) = 0 if m > n or m < 0\n        // a(n, m) = n! / (n - m)! if m <= n / 2\n        // a(n, m) = a(n, n - m) if m > n / 2\n        // a(n, m) = a(n - 1, m - 1) + a(n - 1, m) if m <= n / 2\n        // a(n, m) = a(n - 1, m) + a(n - 1, m + 1) if m > n / 2\n        // a(n, m) = a(n - 1, m) + a(n - 1, m - 1) if m <= n / 2\n        // a(n, m) = a(n - 1, m - 1) + a(n - 1, m + 1) if m > n / 2\n        // a(n, m) = a(n - 1, m) + a(n - 1, m - 1) if m <= n / 2\n        // a(n, m) = a(n - 1, m - 1) + a(n - 1, m + 1) if m > n / 2\n        // a(n, m) = a(n - 1, m) + a(n - 1, m - 1) if m <= n / 2\n        // a(n, m) = a(n - 1, m - 1) + a(n - 1, m + 1) if m > n / 2\n        // a(n, m) = a(n - 1, m) + a(n - 1, m - 1) if m <= n / 2\n        // a(n, m) = a(n - 1, m - 1) + a(n - 1, m + 1) if m > n / 2\n        // a(n",
    "        if (n < m) return 0;\n        if (n == m) return 1;\n        return (n - m) * EulerianNum(n - 1, m) + EulerianNum(n - 1, m - 1);",
    "        // The Eulerian number a(n, m) is the number of permutations of n\n        // elements with exactly m ascents.\n        //\n        // The Eulerian number a(n, m) can be computed using the following\n        // recurrence:\n        //\n        // a(n, m) = (m + 1) * a(n - 1, m) + (n - m) * a(n - 1, m - 1)\n        //\n        // with the initial conditions:\n        //\n        // a(0, 0) = 1\n        // a(n, 0) = 0 for n > 0\n        // a(0, m) = 0 for m > 0\n        //\n        // The Eulerian number a(n, m) can also be computed using the\n        // following formula:\n        //\n        // a(n, m) = n! * (1 / (1! * 1) + 1 / (2! * 2) + ... + 1 / (m! * m))\n        //\n        // The Eulerian number a(n, m) can also be computed using the\n        // following formula:\n        //\n        // a(n, m) = n! * Sum_{k=1..m} (-1)^(k+1) * (1 / k!) *\n        //           Sum_{i=0..k} (1 / (n - i)!) * (k choose i)\n        //\n        // The Eulerian number a(n, m) can also be computed using the\n        // following formula:\n        //\n        // a(n, m) = n! * Sum_{k=1..m} (-1)^(k+1) * (1 / k!) *\n        //           Sum_{i=0..k} (1 / (n - i)!) * (k choose i)\n        //\n        // The Eulerian number a(n, m) can also be computed using the\n        // following formula:\n        //\n        // a(n, m) = n! * Sum_{k=1..m} (-1)^(k+1) * (1 / k!) *\n        //           Sum_{i=0..k} (1 / (n",
    "        if (n < m) return 0;\n        if (n == m) return 1;\n        if (m == 0) return 1;\n        return (n - m) * EulerianNum(n - 1, m) + m * EulerianNum(n - 1, m - 1);",
    "        if (n < m) return 0;\n        if (n == m) return 1;\n        long ans = 1;\n        for (long i = 0; i < m; i++) {\n            ans *= n - i;\n            ans /= i + 1;\n        }\n        return ans;",
    "        if (n < m) return 0;\n        if (n == m) return 1;\n        if (m == 0) return 1;\n        return (n - m) * EulerianNum(n - 1, m) + m * EulerianNum(n - 1, m - 1);",
    "        if (n < m) return 0;\n        if (n == m) return 1;\n        return (n - 1) * EulerianNum(n - 1, m) + (m + 1) * EulerianNum(n - 1, m + 1);",
    "        long[,] a = new long[n + 1, m + 1];\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= m; j++) {\n                if (i == 0 && j == 0) {\n                    a[i, j] = 1;\n                } else if (i == 0) {\n                    a[i, j] = 0;\n                } else if (j == 0) {\n                    a[i, j] = 1;\n                } else {\n                    a[i, j] = (i - j) * a[i - 1, j] + (j + 1) * a[i - 1, j - 1];\n                }\n            }\n        }\n        return a[n, m];",
    "        if (n < m) return 0;\n        if (m == 0) return 1;\n        if (m == 1) return n;\n        return (n - m + 1) * EulerianNum(n, m - 1) + (m + 1) * EulerianNum(n, m - 2);",
    "        if (n < m) return 0;\n        if (n == m) return 1;\n        return (n - m) * EulerianNum(n - 1, m) + m * EulerianNum(n - 1, m - 1);",
    "        if (n < m) return 0;\n        if (n == m) return 1;\n        if (m == 0) return 1;\n        return (n - m + 1) * EulerianNum(n, m - 1) + (m + 1) * EulerianNum(n, m + 1);",
    "        if (n < m) return 0;\n        if (n == m) return 1;\n        return (n - m) * EulerianNum(n - 1, m) + EulerianNum(n - 1, m - 1);",
    "        if (n < m) return 0;\n        if (n == m) return 1;\n        return (n - m) * EulerianNum(n - 1, m) + m * EulerianNum(n - 1, m - 1);",
    "        if (n < m) return 0;\n        if (n == m) return 1;\n        return (n - m) * EulerianNum(n - 1, m) + m * EulerianNum(n - 1, m - 1);",
    "        // Eulerian number is the number of permutations of n elements with exactly m descents.\n        // Eulerian number can be calculated using the following recurrence relation:\n        // a(n, m) = (n - m) * a(n - 1, m) + (m + 1) * a(n - 1, m - 1)\n        // a(n, 0) = a(n, n) = 1\n        // a(n, m) = 0 if n < m or m < 0\n        // Time complexity: O(n * m)\n        // Space complexity: O(n * m)\n        long[,] dp = new long[n + 1, m + 1];\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= m; j++) {\n                if (i == 0 && j == 0) {\n                    dp[i, j] = 1;\n                } else if (i == 0 || j == 0) {\n                    dp[i, j] = 0;\n                } else {\n                    dp[i, j] = (i - j) * dp[i - 1, j] + (j + 1) * dp[i - 1, j - 1];\n                }\n            }\n        }\n        return dp[n, m];",
    "        if (m > n) return 0;\n        if (m == n) return 1;\n        if (m == 1) return n;\n        return (n - m + 1) * EulerianNum(n, m - 1) + (m + 1) * EulerianNum(n, m + 1);",
    "        if (n < m) return 0;\n        if (n == m) return 1;\n        if (m == 0) return 1;\n        return (n - m + 1) * EulerianNum(n, m - 1) + (m + 1) * EulerianNum(n, m + 1);"
  ]
}