{
  "name": "mbpp_721_maxAverageOfPath",
  "language": "js",
  "prompt": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py",
  "prompt_terminology": "reworded",
  "tests": "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
  "stop_tokens": [
    "\nfunction ",
    "\n/*",
    "\n//",
    "\nconsole.log"
  ],
  "results": [
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    //initialize a 2d array to store the max average of each cell\n    let maxAvg = [];\n    for(let i = 0; i < cost.length; i++){\n        maxAvg.push([]);\n    }\n    //initialize the first cell to the cost of the first cell\n    maxAvg[0][0] = cost[0][0];\n    //initialize the first row to the sum of the first row\n    for(let i = 1; i < cost.length; i++){\n        maxAvg[0][i] = maxAvg[0][i-1] + cost[0][i];\n    }\n    //initialize the first column to the sum of the first column\n    for(let i = 1; i < cost.length; i++){\n        maxAvg[i][0] = maxAvg[i-1][0] + cost[i][0];\n    }\n    //loop through the rest of the matrix and find the max average of each cell\n    for(let i = 1; i < cost.length; i++){\n        for(let j = 1; j < cost.length; j++){\n            //find the max average of the cell above and to the left\n            let max = Math.max(maxAvg[i-1][j], maxAvg[i][j-1]);\n            //add the cost of the current cell to the max average\n            maxAvg[i][j] = max + cost[i][j];\n        }\n    }\n    //return the max average of the bottom right cell\n    return maxAvg[cost.length-1][cost.length-1] / (cost.length * 2 - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var n = cost.length;\n    var dp = [];\n    for(var i = 0; i < n; i++){\n        dp[i] = [];\n        for(var j = 0; j < n; j++){\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(var i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(var i = 1; i < n; i++){\n        for(var j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        for(let j = 0; j < n; j++){\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        dp[i][0] = cost[i][0];\n    }\n    for(let j = 0; j < n; j++){\n        dp[0][j] = cost[0][j];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4.8\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmpyfj58ten.js:25:10)\n    at Object.<anonymous> (/tmp/tmpyfj58ten.js:31:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4.8,\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < col; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1]/(row+col-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let m = cost[0].length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < m; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < m; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < m; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][m-1] / (n+m-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n    dp[i].fill(0);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows);\n    for(let i=0; i<rows; i++){\n        dp[i] = new Array(cols);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1; i<rows; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j=1; j<cols; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i=1; i<rows; i++){\n        for(let j=1; j<cols; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[rows-1][cols-1]/(rows+cols-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var n = cost.length;\n    var dp = [];\n    for(var i = 0; i < n; i++){\n        dp[i] = [];\n        for(var j = 0; j < n; j++){\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(var i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(var i = 1; i < n; i++){\n        for(var j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var rows = cost.length;\n    var cols = cost[0].length;\n    var dp = new Array(rows);\n    for(var i = 0; i < rows; i++){\n        dp[i] = new Array(cols);\n    }\n    dp[0][0] = cost[0][0];\n    for(var i = 1; i < rows; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(var j = 1; j < cols; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(var i = 1; i < rows; i++){\n        for(var j = 1; j < cols; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[rows-1][cols-1] / (rows + cols - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows).fill(0).map(()=>new Array(cols).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<rows;i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j=1;j<cols;j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i=1;i<rows;i++){\n        for(let j=1;j<cols;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[rows-1][cols-1]/(rows+cols-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < col; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n        dp[i][0] = cost[i][0];\n    }\n    for(let i=0;i<n;i++){\n        dp[0][i] = cost[0][i];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4.8\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmpvvzgm1uw.js:25:10)\n    at Object.<anonymous> (/tmp/tmpvvzgm1uw.js:31:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4.8,\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row).fill(0).map(() => new Array(col).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < col; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i - 1] + cost[0][i];\n    dp[i][0] = dp[i - 1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n    }\n  }\n  return dp[n - 1][n - 1] / (2 * n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  var n = cost.length;\n  var dp = [];\n  for(var i=0;i<n;i++){\n    dp[i] = [];\n    for(var j=0;j<n;j++){\n      dp[i][j] = cost[i][j];\n    }\n  }\n  for(var i=1;i<n;i++){\n    dp[0][i] += dp[0][i-1];\n    dp[i][0] += dp[i-1][0];\n  }\n  for(var i=1;i<n;i++){\n    for(var j=1;j<n;j++){\n      dp[i][j] += Math.max(dp[i-1][j],dp[i][j-1]);\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let m = cost.length;\n    let n = cost[0].length;\n    let dp = new Array(m);\n    for(let i = 0; i < m; i++){\n        dp[i] = new Array(n).fill(0);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < m; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < n; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < m; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[m-1][n-1]/(m+n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        dp[i][0] = cost[i][0];\n    }\n    for(let j = 0; j < n; j++){\n        dp[0][j] = cost[0][j];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4.8\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmpwz43xlrh.js:25:10)\n    at Object.<anonymous> (/tmp/tmpwz43xlrh.js:31:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4.8,\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let dp = [];\n    for(let i = 0; i < cost.length; i++){\n        dp.push([]);\n        for(let j = 0; j < cost[0].length; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < cost.length; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < cost[0].length; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < cost.length; i++){\n        for(let j = 1; j < cost[0].length; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[cost.length-1][cost[0].length-1] / (cost.length + cost[0].length - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = Array(n).fill(0).map(() => Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows);\n    for(let i = 0; i < rows; i++){\n        dp[i] = new Array(cols);\n        for(let j = 0; j < cols; j++){\n            dp[i][j] = new Array(2);\n        }\n    }\n    dp[0][0][0] = cost[0][0];\n    dp[0][0][1] = 1;\n    for(let i = 1; i < rows; i++){\n        dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n        dp[i][0][1] = dp[i-1][0][1] + 1;\n    }\n    for(let j = 1; j < cols; j++){\n        dp[0][j][0] = dp[0][j-1][0] + cost[0][j];\n        dp[0][j][1] = dp[0][j-1][1] + 1;\n    }\n    for(let i = 1; i < rows; i++){\n        for(let j = 1; j < cols; j++){\n            let left = dp[i][j-1][0]/dp[i][j-1][1];\n            let up = dp[i-1][j][0]/dp[i-1][j][1];\n            if(left > up){\n                dp[i][j][0] = dp[i][j-1][0] + cost[i][j];\n                dp[i][j][1] = dp[i][j-1][1] + 1;\n            }else{\n                dp[i][j][0] = dp[i-1][j][0] + cost[i][j];\n                dp[i][j][1] = dp[i-1][j][1] + 1;\n            }\n        }\n    }\n    return dp[rows-\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "/tmp/tmpmhzuljhh.js:36\nconst assert = require('node:assert');\n^^^^^\n\nSyntaxError: Unexpected token 'const'\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var n = cost.length;\n    var dp = new Array(n);\n    for(var i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(var i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(var i = 1; i < n; i++){\n        for(var j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var n = cost.length;\n    var dp = [];\n    for(var i = 0; i < n; i++){\n        dp[i] = [];\n        for(var j = 0; j < n; j++){\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(var i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(var i = 1; i < n; i++){\n        for(var j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var n = cost.length;\n    var dp = [];\n    for(var i = 0; i < n; i++){\n        dp.push([]);\n    }\n    dp[0][0] = cost[0][0];\n    for(var i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(var i = 1; i < n; i++){\n        for(var j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var n = cost.length;\n    var dp = new Array(n);\n    for(var i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(var i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(var i = 1; i < n; i++){\n        for(var j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = [];\n  for(let i = 0; i < n; i++){\n    dp.push([]);\n    for(let j = 0; j < n; j++){\n      dp[i].push(0);\n    }\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows);\n    for(let i = 0; i < rows; i++){\n        dp[i] = new Array(cols);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < rows; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < cols; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < rows; i++){\n        for(let j = 1; j < cols; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[rows-1][cols-1] / (rows+cols-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows).fill(0).map(() => new Array(cols).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < rows; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < cols; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < rows; i++){\n        for(let j = 1; j < cols; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[rows-1][cols-1] / (rows + cols - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n).fill(0);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var rows = cost.length;\n    var cols = cost[0].length;\n    var dp = [];\n    for(var i=0;i<rows;i++){\n        dp[i] = [];\n        for(var j=0;j<cols;j++){\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(var i=1;i<rows;i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(var j=1;j<cols;j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(var i=1;i<rows;i++){\n        for(var j=1;j<cols;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[rows-1][cols-1]/(rows+cols-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n6.4\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmp72d2hc7m.js:23:10)\n    at Object.<anonymous> (/tmp/tmp72d2hc7m.js:29:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 6.4,\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < col; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row+col-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var n = cost.length;\n    var dp = [];\n    for(var i = 0; i < n; i++){\n        dp[i] = [];\n        for(var j = 0; j < n; j++){\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(var i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(var i = 1; i < n; i++){\n        for(var j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = Array(n).fill(0).map(() => Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let row = cost.length;\n  let col = cost[0].length;\n  let dp = new Array(row);\n  for(let i = 0; i < row; i++){\n    dp[i] = new Array(col);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < row; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < col; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < row; i++){\n    for(let j = 1; j < col; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows).fill(0).map(() => new Array(cols).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < rows; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < cols; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < rows; i++){\n        for(let j = 1; j < cols; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[rows-1][cols-1] / (rows + cols - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let row = cost.length;\n  let col = cost[0].length;\n  let dp = new Array(row);\n  for(let i = 0; i < row; i++){\n    dp[i] = new Array(col);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < row; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < col; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < row; i++){\n    for(let j = 1; j < col; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col).fill(0);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < col; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows);\n    for(let i = 0; i < rows; i++){\n        dp[i] = new Array(cols);\n        for(let j = 0; j < cols; j++){\n            dp[i][j] = new Array(2);\n        }\n    }\n    dp[0][0][0] = cost[0][0];\n    dp[0][0][1] = 1;\n    for(let i = 1; i < rows; i++){\n        dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n        dp[i][0][1] = dp[i-1][0][1] + 1;\n    }\n    for(let i = 1; i < cols; i++){\n        dp[0][i][0] = dp[0][i-1][0] + cost[0][i];\n        dp[0][i][1] = dp[0][i-1][1] + 1;\n    }\n    for(let i = 1; i < rows; i++){\n        for(let j = 1; j < cols; j++){\n            if(dp[i-1][j][0]/dp[i-1][j][1] > dp[i][j-1][0]/dp[i][j-1][1]){\n                dp[i][j][0] = dp[i-1][j][0] + cost[i][j];\n                dp[i][j][1] = dp[i-1][j][1] + 1;\n            }\n            else{\n                dp[i][j][0] = dp[i][j-1][0] + cost[i][j];\n                dp[i][j][1] = dp[i][j-1][1] + 1;\n            }\n        }\n    }\n    return dp[rows-1][cols-1][0]/dp\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "/tmp/tmpruo03y3s.js:46\ntest();\n       \n\nSyntaxError: Unexpected end of input\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let rows = cost.length;\n  let cols = cost[0].length;\n  let dp = new Array(rows).fill(0).map(() => new Array(cols).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < rows; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < cols; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < rows; i++){\n    for(let j = 1; j < cols; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[rows-1][cols-1] / (rows + cols - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows);\n    for(let i = 0; i < rows; i++){\n        dp[i] = new Array(cols);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < rows; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < cols; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < rows; i++){\n        for(let j = 1; j < cols; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[rows-1][cols-1] / (rows + cols - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < col; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row).fill(0).map(()=>new Array(col).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<row;i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j=1;j<col;j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i=1;i<row;i++){\n        for(let j=1;j<col;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1]/(row+col-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let m = cost.length;\n    let n = cost[0].length;\n    let dp = new Array(m);\n    for(let i = 0; i < m; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < m; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < m; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    let path = [];\n    let i = m-1;\n    let j = n-1;\n    while(i >= 0 && j >= 0){\n        path.push(cost[i][j]);\n        if(i === 0){\n            j--;\n        }else if(j === 0){\n            i--;\n        }else{\n            if(dp[i-1][j] > dp[i][j-1]){\n                i--;\n            }else{\n                j--;\n            }\n        }\n    }\n    return path.reverse();\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  1,\n  6,\n  7,\n  3,\n  9\n]\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmpj7aca2jk.js:46:10)\n    at Object.<anonymous> (/tmp/tmpj7aca2jk.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 1, 6, 7, 3, 9 ],\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = [];\n    for(let i=0;i<n;i++){\n        dp[i] = [];\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1]+cost[0][i];\n        dp[i][0] = dp[i-1][0]+cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])+cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  var n = cost.length;\n  var dp = [];\n  for(var i = 0; i < n; i++){\n    dp[i] = [];\n    for(var j = 0; j < n; j++){\n      dp[i][j] = 0;\n    }\n  }\n  dp[0][0] = cost[0][0];\n  for(var i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(var i = 1; i < n; i++){\n    for(var j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows).fill(0).map(()=>new Array(cols).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<rows;i++){\n        dp[i][0] = dp[i-1][0]+cost[i][0];\n    }\n    for(let j=1;j<cols;j++){\n        dp[0][j] = dp[0][j-1]+cost[0][j];\n    }\n    for(let i=1;i<rows;i++){\n        for(let j=1;j<cols;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])+cost[i][j];\n        }\n    }\n    let path = [];\n    let i=rows-1;\n    let j=cols-1;\n    while(i>0 || j>0){\n        path.push(cost[i][j]);\n        if(i==0){\n            j--;\n        }else if(j==0){\n            i--;\n        }else{\n            if(dp[i-1][j]>dp[i][j-1]){\n                i--;\n            }else{\n                j--;\n            }\n        }\n    }\n    path.push(cost[0][0]);\n    let sum = path.reduce((acc,curr)=>acc+curr);\n    return sum/path.length;\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows).fill(0).map(()=>new Array(cols).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<rows;i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j=1;j<cols;j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i=1;i<rows;i++){\n        for(let j=1;j<cols;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[rows-1][cols-1] / (rows+cols-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var n = cost.length;\n    var dp = new Array(n);\n    for(var i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        for(var j = 0; j < n; j++){\n            dp[i][j] = new Array(2);\n            dp[i][j][0] = 0;\n            dp[i][j][1] = 0;\n        }\n    }\n    dp[0][0][0] = cost[0][0];\n    dp[0][0][1] = 1;\n    for(var i = 1; i < n; i++){\n        dp[0][i][0] = dp[0][i-1][0] + cost[0][i];\n        dp[0][i][1] = dp[0][i-1][1] + 1;\n        dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n        dp[i][0][1] = dp[i-1][0][1] + 1;\n    }\n    for(var i = 1; i < n; i++){\n        for(var j = 1; j < n; j++){\n            if(dp[i-1][j][0]/dp[i-1][j][1] > dp[i][j-1][0]/dp[i][j-1][1]){\n                dp[i][j][0] = dp[i-1][j][0] + cost[i][j];\n                dp[i][j][1] = dp[i-1][j][1] + 1;\n            }else{\n                dp[i][j][0] = dp[i][j-1][0] + cost[i][j];\n                dp[i][j][1] = dp[i][j-1][1] + 1;\n            }\n        }\n    }\n    return dp[n-1][n-1][0]/dp[n-1][n-1][1\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "/tmp/tmpaucrs_b1.js:33\nconst assert = require('node:assert');\n^^^^^\n\nSyntaxError: Unexpected token 'const'\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  var n = cost.length;\n  var dp = new Array(n);\n  for(var i = 0; i < n; i++){\n    dp[i] = new Array(n);\n    for(var j = 0; j < n; j++){\n      dp[i][j] = 0;\n    }\n  }\n  dp[0][0] = cost[0][0];\n  for(var i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(var i = 1; i < n; i++){\n    for(var j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  const n = cost.length;\n  const dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n).fill(0);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i - 1] + cost[0][i];\n    dp[i][0] = dp[i - 1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n    }\n  }\n  return dp[n - 1][n - 1] / (2 * n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    //initialize the dp array\n    let dp = new Array(cost.length);\n    for(let i = 0; i < cost.length; i++){\n        dp[i] = new Array(cost[0].length);\n    }\n    //base case\n    dp[0][0] = cost[0][0];\n    //fill the first row\n    for(let i = 1; i < cost[0].length; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    //fill the first column\n    for(let i = 1; i < cost.length; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    //fill the rest of the dp array\n    for(let i = 1; i < cost.length; i++){\n        for(let j = 1; j < cost[0].length; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    //return the last element of the dp array divided by the number of cells visited\n    return dp[cost.length-1][cost[0].length-1] / (cost.length + cost[0].length - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i=1;i<n;i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i=1;i<n;i++){\n    for(let j=1;j<n;j++){\n      dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var n = cost.length;\n    var dp = new Array(n);\n    for(var i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(var i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(var i = 1; i < n; i++){\n        for(var j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n    for(let j = 0; j < n; j++){\n      dp[i][j] = new Array(2);\n      dp[i][j][0] = 0;\n      dp[i][j][1] = 0;\n    }\n  }\n  dp[0][0][0] = cost[0][0];\n  dp[0][0][1] = 1;\n  for(let i = 1; i < n; i++){\n    dp[0][i][0] = dp[0][i-1][0] + cost[0][i];\n    dp[0][i][1] = dp[0][i-1][1] + 1;\n    dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n    dp[i][0][1] = dp[i-1][0][1] + 1;\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      if(dp[i-1][j][0]/dp[i-1][j][1] > dp[i][j-1][0]/dp[i][j-1][1]){\n        dp[i][j][0] = dp[i-1][j][0] + cost[i][j];\n        dp[i][j][1] = dp[i-1][j][1] + 1;\n      }else{\n        dp[i][j][0] = dp[i][j-1][0] + cost[i][j];\n        dp[i][j][1] = dp[i][j-1][1] + 1;\n      }\n    }\n  }\n  return dp[n-1][n-1][0]/dp[n-1][n-1][1\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "/tmp/tmp8e3e3i0r.js:33\nconst assert = require('node:assert');\n^^^^^\n\nSyntaxError: Unexpected token 'const'\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = Array(n).fill(0).map(()=>Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row).fill(0).map(()=>new Array(col).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < col; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp[i] = [];\n        for(let j = 0; j < n; j++){\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows).fill(0).map(() => new Array(cols).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < rows; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < cols; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < rows; i++){\n        for(let j = 1; j < cols; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[rows-1][cols-1] / (rows + cols - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var dp = [];\n    var n = cost.length;\n    for(var i = 0; i < n; i++){\n        dp[i] = [];\n        for(var j = 0; j < n; j++){\n            dp[i][j] = cost[i][j];\n        }\n    }\n    for(var i = 1; i < n; i++){\n        dp[0][i] += dp[0][i-1];\n        dp[i][0] += dp[i-1][0];\n    }\n    for(var i = 1; i < n; i++){\n        for(var j = 1; j < n; j++){\n            dp[i][j] += Math.max(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n\tvar n = cost.length;\n\tvar dp = new Array(n);\n\tfor(var i = 0; i < n; i++){\n\t\tdp[i] = new Array(n);\n\t}\n\tdp[0][0] = cost[0][0];\n\tfor(var i = 1; i < n; i++){\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor(var i = 1; i < n; i++){\n\t\tfor(var j = 1; j < n; j++){\n\t\t\tdp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < col; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row+col-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < col; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let rows = cost.length;\n  let cols = cost[0].length;\n  let dp = new Array(rows).fill(0).map(() => new Array(cols).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < rows; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < cols; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < rows; i++){\n    for(let j = 1; j < cols; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[rows-1][cols-1] / (rows + cols - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  var n = cost.length;\n  var dp = new Array(n);\n  for(var i = 0; i < n; i++){\n    dp[i] = new Array(n);\n    for(var j = 0; j < n; j++){\n      dp[i][j] = new Array(2);\n      dp[i][j][0] = 0;\n      dp[i][j][1] = 0;\n    }\n  }\n  dp[0][0][0] = cost[0][0];\n  dp[0][0][1] = 1;\n  for(var i = 1; i < n; i++){\n    dp[0][i][0] = dp[0][i-1][0] + cost[0][i];\n    dp[0][i][1] = dp[0][i-1][1] + 1;\n    dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n    dp[i][0][1] = dp[i-1][0][1] + 1;\n  }\n  for(var i = 1; i < n; i++){\n    for(var j = 1; j < n; j++){\n      if(dp[i-1][j][0]/dp[i-1][j][1] > dp[i][j-1][0]/dp[i][j-1][1]){\n        dp[i][j][0] = dp[i-1][j][0] + cost[i][j];\n        dp[i][j][1] = dp[i-1][j][1] + 1;\n      }else{\n        dp[i][j][0] = dp[i][j-1][0] + cost[i][j];\n        dp[i][j][1] = dp[i][j-1][1] + 1;\n      }\n    }\n  }\n  return dp[n-1][n-1][0]/dp[n-1][n-1][1\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "/tmp/tmpqrd2edyv.js:33\nconst assert = require('node:assert');\n^^^^^\n\nSyntaxError: Unexpected token 'const'\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1; i<n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1; i<n; i++){\n        for(let j=1; j<n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < col; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row + col - 1);\n}\n\nlet cost = [[4,4,5],[1,2,6],[7,4,6]];\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let rows = cost.length;\n  let cols = cost[0].length;\n  let dp = new Array(rows).fill().map(() => new Array(cols).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < rows; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < cols; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < rows; i++){\n    for(let j = 1; j < cols; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[rows-1][cols-1] / (rows + cols - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var n = cost.length;\n    var dp = [];\n    for(var i = 0; i < n; i++){\n        dp[i] = [];\n        for(var j = 0; j < n; j++){\n            dp[i][j] = [];\n        }\n    }\n    dp[0][0][0] = cost[0][0];\n    dp[0][0][1] = 1;\n    for(var i = 1; i < n; i++){\n        dp[0][i][0] = dp[0][i-1][0] + cost[0][i];\n        dp[0][i][1] = dp[0][i-1][1] + 1;\n        dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n        dp[i][0][1] = dp[i-1][0][1] + 1;\n    }\n    for(var i = 1; i < n; i++){\n        for(var j = 1; j < n; j++){\n            if(dp[i-1][j][0]/dp[i-1][j][1] > dp[i][j-1][0]/dp[i][j-1][1]){\n                dp[i][j][0] = dp[i-1][j][0] + cost[i][j];\n                dp[i][j][1] = dp[i-1][j][1] + 1;\n            }else{\n                dp[i][j][0] = dp[i][j-1][0] + cost[i][j];\n                dp[i][j][1] = dp[i][j-1][1] + 1;\n            }\n        }\n    }\n    return dp[n-1][n-1][0]/dp[n-1][n-1][1];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n        for(let j=0;j<n;j++){\n            dp[i][j] = new Array(2);\n        }\n    }\n    dp[0][0][0] = cost[0][0];\n    dp[0][0][1] = 1;\n    for(let i=1;i<n;i++){\n        dp[0][i][0] = dp[0][i-1][0] + cost[0][i];\n        dp[0][i][1] = dp[0][i-1][1] + 1;\n        dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n        dp[i][0][1] = dp[i-1][0][1] + 1;\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            if(dp[i-1][j][0]/dp[i-1][j][1] > dp[i][j-1][0]/dp[i][j-1][1]){\n                dp[i][j][0] = dp[i-1][j][0] + cost[i][j];\n                dp[i][j][1] = dp[i-1][j][1] + 1;\n            }else{\n                dp[i][j][0] = dp[i][j-1][0] + cost[i][j];\n                dp[i][j][1] = dp[i][j-1][1] + 1;\n            }\n        }\n    }\n    return dp[n-1][n-1][0]/dp[n-1][n-1][1];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let rows = cost.length;\n  let cols = cost[0].length;\n  let dp = new Array(rows).fill(0).map(() => new Array(cols).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < rows; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < cols; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < rows; i++){\n    for(let j = 1; j < cols; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[rows-1][cols-1] / (rows + cols - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let dp = new Array(cost.length).fill(0).map(()=>new Array(cost[0].length).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<cost.length;i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j=1;j<cost[0].length;j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i=1;i<cost.length;i++){\n        for(let j=1;j<cost[0].length;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[cost.length-1][cost[0].length-1]/(cost.length+cost[0].length-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        dp[i][0] = cost[i][0];\n    }\n    for(let j = 0; j < n; j++){\n        dp[0][j] = cost[0][j];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = cost[i][j] + Math.max(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4.8\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmpt40g1e44.js:25:10)\n    at Object.<anonymous> (/tmp/tmpt40g1e44.js:31:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4.8,\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < col; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i=1;i<n;i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i=1;i<n;i++){\n    for(let j=1;j<n;j++){\n      dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var n = cost.length;\n    var dp = [];\n    for(var i=0;i<n;i++){\n        dp[i] = [];\n        for(var j=0;j<n;j++){\n            dp[i][j] = {\n                cost: cost[i][j],\n                count: 1\n            };\n            if(i>0){\n                dp[i][j].cost += dp[i-1][j].cost;\n                dp[i][j].count += dp[i-1][j].count;\n            }\n            if(j>0){\n                dp[i][j].cost += dp[i][j-1].cost;\n                dp[i][j].count += dp[i][j-1].count;\n            }\n            if(i>0 && j>0){\n                dp[i][j].cost -= dp[i-1][j-1].cost;\n                dp[i][j].count -= dp[i-1][j-1].count;\n            }\n        }\n    }\n    var max = 0;\n    for(var i=0;i<n;i++){\n        for(var j=0;j<n;j++){\n            for(var k=i;k<n;k++){\n                for(var l=j;l<n;l++){\n                    var sum = dp[k][l].cost;\n                    var count = dp[k][l].count;\n                    if(i>0){\n                        sum -= dp[i-1][l].cost;\n                        count -= dp[i-1][l].count;\n                    }\n                    if(j>0){\n                        sum -= dp[k][j-1].cost;\n                        count -= dp[k][j-1].count;\n                    }\n                    if(i>0 && j>0){\n                        sum += dp[i-1][j-1].cost;\n                        count += dp[i-1][j-1].count;\n                    }\n                    max = Math.max(max, sum/count);\n                }\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "/tmp/tmp7kl7skxm.js:58\ntest();\n       \n\nSyntaxError: Unexpected end of input\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var n = cost.length;\n    var dp = [];\n    for(var i=0;i<n;i++){\n        dp.push([]);\n        for(var j=0;j<n;j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(var i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(var i=1;i<n;i++){\n        for(var j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = cost[i][j] + Math.max(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  var n = cost.length;\n  var dp = [];\n  for(var i = 0; i < n; i++){\n    dp.push([]);\n  }\n  dp[0][0] = cost[0][0];\n  for(var i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(var i = 1; i < n; i++){\n    for(var j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        dp[i][0] = cost[i][0];\n    }\n    for(let j = 0; j < n; j++){\n        dp[0][j] = cost[0][j];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = cost[i][j] + Math.max(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4.8\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmpt40g1e44.js:25:10)\n    at Object.<anonymous> (/tmp/tmpt40g1e44.js:31:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4.8,\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let maxAvg = 0;\n  let maxPath = [];\n  let path = [];\n  let avg = 0;\n  let sum = 0;\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let n = cost.length;\n  while(i < n && j < n){\n    path.push(cost[i][j]);\n    sum += cost[i][j];\n    count++;\n    if(i === n - 1 && j === n - 1){\n      avg = sum / count;\n      if(avg > maxAvg){\n        maxAvg = avg;\n        maxPath = path;\n      }\n      path = [];\n      sum = 0;\n      count = 0;\n      i = 0;\n      j = 0;\n    }\n    else if(i === n - 1){\n      j++;\n      i = 0;\n    }\n    else{\n      i++;\n    }\n  }\n  return maxPath;\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i=0;i<n;i++){\n    dp[i] = new Array(n);\n    dp[i][0] = cost[i][0];\n    for(let j=1;j<n;j++){\n      dp[i][j] = dp[i][j-1] + cost[i][j];\n    }\n  }\n  for(let i=1;i<n;i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n  }\n  for(let i=1;i<n;i++){\n    for(let j=1;j<n;j++){\n      dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4.8\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmp97iqeumy.js:28:10)\n    at Object.<anonymous> (/tmp/tmp97iqeumy.js:34:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4.8,\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let rows = cost.length;\n  let cols = cost[0].length;\n  let dp = new Array(rows);\n  for(let i=0;i<rows;i++){\n    dp[i] = new Array(cols);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i=1;i<rows;i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j=1;j<cols;j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i=1;i<rows;i++){\n    for(let j=1;j<cols;j++){\n      dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[rows-1][cols-1]/(rows+cols-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n        for(let j=0;j<n;j++){\n            dp[i][j] = new Array(2);\n        }\n    }\n    dp[0][0][0] = cost[0][0];\n    dp[0][0][1] = 1;\n    for(let i=1;i<n;i++){\n        dp[0][i][0] = dp[0][i-1][0] + cost[0][i];\n        dp[0][i][1] = dp[0][i-1][1] + 1;\n        dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n        dp[i][0][1] = dp[i-1][0][1] + 1;\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            let a = dp[i-1][j][0] + cost[i][j];\n            let b = dp[i-1][j][1] + 1;\n            let c = dp[i][j-1][0] + cost[i][j];\n            let d = dp[i][j-1][1] + 1;\n            if(a/b > c/d){\n                dp[i][j][0] = a;\n                dp[i][j][1] = b;\n            }else{\n                dp[i][j][0] = c;\n                dp[i][j][1] = d;\n            }\n        }\n    }\n    return dp[n-1][n-1][0]/dp[n-1][n-1][1];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509917,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let dp = [];\n    for(let i = 0; i < cost.length; i++){\n        dp[i] = [];\n        for(let j = 0; j < cost[0].length; j++){\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < cost.length; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < cost[0].length; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < cost.length; i++){\n        for(let j = 1; j < cost[0].length; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[cost.length-1][cost[0].length-1] / (cost.length + cost[0].length - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124035,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124034,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}