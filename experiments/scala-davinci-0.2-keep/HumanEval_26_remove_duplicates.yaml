name: HumanEval_26_remove_duplicates
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a list of integers, remove all elements that occur more than once.\n\
  \    // Keep order of elements left the same as in the input.\n    // >>> remove_duplicates([1,\
  \ 2, 3, 2, 4])\n    // [1, 3, 4]\n    def removeDuplicates(numbers : List[Long])\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(removeDuplicates((List[Long]())).equals((List[Long]())));\n\
  \    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(removeDuplicates((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong,\
  \ 4l.toLong, 5l.toLong))));\n    }\n\n}\n"
completions: ["        val numbersSet = numbers.toSet\n        numbersSet.toList",
  "        val set = new HashSet[Long]\n        numbers.filter(x => {\n          \
    \  if (set.contains(x)) false\n            else {\n                set += x\n\
    \                true\n            }\n        })", "        val set = new HashSet[Long]\n\
    \        val list = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             list += number\n            }\n        }\n        list.toList",
  "        val map = new HashMap[Long, Long]\n        for (number <- numbers) {\n\
    \            if (map.contains(number)) map(number) += 1\n            else map(number)\
    \ = 1\n        }\n        numbers.filter(number => map(number) == 1)", "     \
    \   val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n \
    \       for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        val map = new HashMap[Long, Int]\n\
    \        numbers.foreach(n => map(n) = map.getOrElse(n, 0) + 1)\n        numbers.filter(n\
    \ => map(n) == 1)", "        val set = new HashSet[Long]\n        val result =\
    \ new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        val numbersSet = numbers.toSet\n\
    \        numbersSet.toList", "        val map = new HashMap[Long, Int]\n     \
    \   for (number <- numbers) {\n            if (map.contains(number)) map(number)\
    \ += 1\n            else map(number) = 1\n        }\n        val result = new\
    \ ListBuffer[Long]\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) result += number\n        }\n        result.toList", "        val map\
    \ = new HashMap[Long, Int]()\n        for (number <- numbers) {\n            if\
    \ (map.contains(number)) {\n                map(number) += 1\n            } else\
    \ {\n                map(number) = 1\n            }\n        }\n        val result\
    \ = new ListBuffer[Long]()\n        for (number <- numbers) {\n            if\
    \ (map(number) == 1) {\n                result += number\n            }\n    \
    \    }\n        result.toList", "        val set = HashSet[Long]()\n        val\
    \ result = ListBuffer[Long]()\n        for (number <- numbers) {\n           \
    \ if (!set.contains(number)) {\n                set += number\n              \
    \  result += number\n            }\n        }\n        result.toList", "     \
    \   val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n \
    \       for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        val counts = new HashMap[Long,\
    \ Int]\n        for (number <- numbers) {\n            if (counts.contains(number))\
    \ counts(number) += 1\n            else counts(number) = 1\n        }\n      \
    \  numbers.filter(number => counts(number) == 1)", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        val map = new HashMap[Long, Int]\n        for (number <- numbers) {\n \
    \           if (map.contains(number)) map(number) += 1\n            else map(number)\
    \ = 1\n        }\n        numbers.filter(number => map(number) == 1)", "     \
    \   val set = HashSet[Long]()\n        val result = ListBuffer[Long]()\n     \
    \   for (number <- numbers) {\n            if (!set.contains(number)) {\n    \
    \            set += number\n                result += number\n            }\n\
    \        }\n        result.toList", "        val set = new HashSet[Long]\n   \
    \     val result = new ListBuffer[Long]\n        for (number <- numbers) {\n \
    \           if (!set.contains(number)) {\n                set += number\n    \
    \            result += number\n            }\n        }\n        result.toList",
  "        val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        val map = new HashMap[Long, Int]\n\
    \        for (number <- numbers) {\n            if (map.contains(number)) map(number)\
    \ += 1\n            else map(number) = 1\n        }\n        numbers.filter(number\
    \ => map(number) == 1)", "        val map = new HashMap[Long, Int]\n        for\
    \ (number <- numbers) {\n            if (map.contains(number)) map(number) +=\
    \ 1\n            else map(number) = 1\n        }\n        numbers.filter(number\
    \ => map(number) == 1)"]
stop_tokens:
- "\n    }\n"
