name: HumanEval_58_common
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return sorted unique common elements for two lists.\n    // >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    // [1, 5, 653]\n    // >>>\
  \ common([5, 3, 2, 8], [3, 2])\n    // [2, 3]\n    def common(l1 : List[Long], l2\
  \ : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(common((List[Long](1l.toLong,\
  \ 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong,\
  \ 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong))).equals((List[Long](1l.toLong,\
  \ 5l.toLong, 653l.toLong))));\n    assert(common((List[Long](5l.toLong, 3l.toLong,\
  \ 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong,\
  \ 3l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong,\
  \ 8l.toLong)), (List[Long](3l.toLong, 2l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
  \ 3l.toLong, 4l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong,\
  \ 2l.toLong, 8l.toLong)), (List[Long]())).equals((List[Long]())));\n    }\n\n}\n"
completions: ["        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 &\
    \ s2).toList.sorted", "        val l1s = l1.sorted\n        val l2s = l2.sorted\n\
    \        var l1i = 0\n        var l2i = 0\n        var result = List[Long]()\n\
    \        while (l1i < l1s.length && l2i < l2s.length) {\n            if (l1s(l1i)\
    \ == l2s(l2i)) {\n                result = l1s(l1i) :: result\n              \
    \  l1i += 1\n                l2i += 1\n            } else if (l1s(l1i) < l2s(l2i))\
    \ {\n                l1i += 1\n            } else {\n                l2i += 1\n\
    \            }\n        }\n        result.reverse", "        val s1 = l1.toSet\n\
    \        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", "        val m1\
    \ = l1.groupBy(x => x).mapValues(_.size)\n        val m2 = l2.groupBy(x => x).mapValues(_.size)\n\
    \        val m = m1.filter(x => m2.contains(x._1)).map(x => (x._1, min(x._2, m2(x._1))))\n\
    \        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted", "        val m1\
    \ = l1.groupBy(x => x).mapValues(_.size)\n        val m2 = l2.groupBy(x => x).mapValues(_.size)\n\
    \        val m3 = m1.filter(x => m2.contains(x._1))\n        m3.map(x => List.fill(min(x._2,\
    \ m2(x._1)))(x._1)).flatten.sorted", "        val m1 = l1.groupBy(x => x).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(x => x).mapValues(_.size)\n        val m = m1.filter(x\
    \ => m2.contains(x._1)).map(x => (x._1, min(x._2, m2(x._1))))\n        m.keys.toList.sorted",
  "        val m1 = l1.groupBy(x => x).mapValues(_.size)\n        val m2 = l2.groupBy(x\
    \ => x).mapValues(_.size)\n        val m = m1.filter(x => m2.contains(x._1)).map(x\
    \ => (x._1, min(x._2, m2(x._1))))\n        m.toList.sortBy(_._1).map(x => List.fill(x._2)(x._1)).flatten",
  "        val set1 = l1.toSet\n        val set2 = l2.toSet\n        (set1 & set2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        val s3 = s1.intersect(s2)\n\
    \        s3.toList.sorted", "        val set1 = l1.toSet\n        val set2 = l2.toSet\n\
    \        (set1 & set2).toList.sorted", "        val s1 = l1.toSet\n        val\
    \ s2 = l2.toSet\n        (s1 & s2).toList.sorted", "        val m1 = l1.groupBy(identity).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(identity).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted",
  "        val l = l1.intersect(l2)\n        l.sorted", "        val s1 = l1.toSet\n\
    \        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", "        val m1\
    \ = l1.toSet\n        val m2 = l2.toSet\n        (m1 & m2).toList.sorted", " \
    \       val m1 = l1.groupBy(x => x).mapValues(_.size)\n        val m2 = l2.groupBy(x\
    \ => x).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.flatMap(x => List.fill(x._2)(x._1)).toList.sorted",
  "        val m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m3 = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m3.flatMap(x => List.fill(x._2)(x._1)).toList.sorted", "        val s1\
    \ = l1.toSet\n        val s2 = l2.toSet\n        val s3 = s1.intersect(s2)\n \
    \       s3.toList.sorted", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        (s1 & s2).toList.sorted", "        val m1 = l1.groupBy(identity).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(identity).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.keys.toList.sorted.flatMap(x =>\
    \ List.fill(m(x))(x))", "        val l1s = l1.sorted\n        val l2s = l2.sorted\n\
    \        var i = 0\n        var j = 0\n        var result = List[Long]()\n   \
    \     while (i < l1s.length && j < l2s.length) {\n            if (l1s(i) == l2s(j))\
    \ {\n                result = result :+ l1s(i)\n                i += 1\n     \
    \           j += 1\n            } else if (l1s(i) < l2s(j)) {\n              \
    \  i += 1\n            } else {\n                j += 1\n            }\n     \
    \   }\n        result", "        val m1 = l1.groupBy(x => x).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(x => x).mapValues(_.size)\n        val m = m1.toList.filter(x\
    \ => m2.contains(x._1)).map(x => (x._1, min(x._2, m2(x._1))))\n        m.flatMap(x\
    \ => List.fill(x._2)(x._1)).sorted", "        val s1 = l1.toSet\n        val s2\
    \ = l2.toSet\n        (s1 & s2).toList.sorted", "        val s1 = l1.toSet\n \
    \       val s2 = l2.toSet\n        val s3 = s1.intersect(s2)\n        s3.toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        val s3 = s1 & s2\n\
    \        s3.toList.sorted", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        (s1 & s2).toList.sorted", "        val m1 = l1.groupBy(x => x).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(x => x).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.flatMap(x => List.fill(x._2)(x._1)).toList.sorted",
  "        val set1 = l1.toSet\n        val set2 = l2.toSet\n        (set1 & set2).toList.sorted",
  "        val m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.keys.toList.sorted.flatMap(x => List.fill(m(x))(x))", "        val\
    \ l3 = l1.intersect(l2)\n        l3.sorted", "        val m1 = l1.groupBy(x =>\
    \ x).mapValues(_.size)\n        val m2 = l2.groupBy(x => x).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.keys.toList.sorted.flatMap(x => List.fill(m(x))(x))", "        val\
    \ s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val l3 = l1.intersect(l2)\n        l3.sorted", "        val m1 = l1.groupBy(identity).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(identity).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.keys.toList.sorted.flatMap(x =>\
    \ List.fill(m(x))(x))", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        (s1 & s2).toList.sorted", "        val s1 = l1.toSet\n        val s2\
    \ = l2.toSet\n        (s1 & s2).toList.sorted", "        val m = new HashMap[Long,\
    \ Int]\n        for (i <- l1) {\n            if (m.contains(i)) m(i) += 1\n  \
    \          else m(i) = 1\n        }\n        val result = new ListBuffer[Long]\n\
    \        for (i <- l2) {\n            if (m.contains(i) && m(i) > 0) {\n     \
    \           result += i\n                m(i) -= 1\n            }\n        }\n\
    \        result.toList.sorted", "        val m1 = l1.groupBy(identity).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(identity).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.flatMap(x => List.fill(x._2)(x._1)).toList.sorted",
  "        val m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m3 = m1.filter(x => m2.contains(x._1))\n        val m4 = m3.map(x\
    \ => (x._1, min(x._2, m2(x._1))))\n        m4.keys.toList.sorted", "        val\
    \ l1s = l1.sorted\n        val l2s = l2.sorted\n        var i = 0\n        var\
    \ j = 0\n        var result = List[Long]()\n        while (i < l1s.length && j\
    \ < l2s.length) {\n            if (l1s(i) == l2s(j)) {\n                result\
    \ = l1s(i) :: result\n                i += 1\n                j += 1\n       \
    \     } else if (l1s(i) < l2s(j)) {\n                i += 1\n            } else\
    \ {\n                j += 1\n            }\n        }\n        result.reverse",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        val s3 = s1.intersect(s2)\n\
    \        s3.toList.sorted", "        val m1 = l1.groupBy(x => x).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(x => x).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val m1 = l1.toSet\n        val m2 = l2.toSet\n        val m = m1.intersect(m2)\n\
    \        m.toList.sorted", "        val m1 = l1.groupBy(identity).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(identity).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted",
  "        val m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted", "        val l1Set\
    \ = l1.toSet\n        val l2Set = l2.toSet\n        val l1Set2 = l1Set.intersect(l2Set)\n\
    \        l1Set2.toList.sorted", "        val m1 = l1.groupBy(identity).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(identity).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.flatMap(x => List.fill(x._2)(x._1)).toList.sorted",
  "        val m1 = l1.groupBy(x => x).mapValues(_.size)\n        val m2 = l2.groupBy(x\
    \ => x).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted",
  "        val l = l1.intersect(l2)\n        l.sorted", "        val m1 = l1.groupBy(x\
    \ => x).mapValues(_.size)\n        val m2 = l2.groupBy(x => x).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted", "        val l3\
    \ = l1.intersect(l2)\n        l3.sorted", "        val set1 = l1.toSet\n     \
    \   val set2 = l2.toSet\n        (set1 & set2).toList.sorted", "        val s1\
    \ = l1.toSet\n        val s2 = l2.toSet\n        s1.intersect(s2).toList.sorted",
  "        val l = l1.intersect(l2)\n        l.sorted", "        val s1 = l1.toSet\n\
    \        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", "        val s1\
    \ = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", " \
    \       val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val set1 = l1.toSet\n        val set2 = l2.toSet\n        (set1 & set2).toList.sorted",
  "        val h1 = l1.toSet\n        val h2 = l2.toSet\n        val h3 = h1.intersect(h2)\n\
    \        h3.toList.sorted", "        val m1 = l1.toSet\n        val m2 = l2.toSet\n\
    \        (m1 & m2).toList.sorted", "        val m1 = l1.groupBy(identity).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(identity).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted",
  "        val set1 = l1.toSet\n        val set2 = l2.toSet\n        val set3 = set1.intersect(set2)\n\
    \        set3.toList.sorted", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        val s3 = s1 & s2\n        s3.toList.sorted", "        val s1 = l1.toSet\n\
    \        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", "        val s1\
    \ = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", " \
    \       val m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted", "        val m1\
    \ = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted", "        val s1\
    \ = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", " \
    \       val m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted", "        val h1\
    \ = l1.toSet\n        val h2 = l2.toSet\n        (h1 & h2).toList.sorted", " \
    \       val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val set1 = l1.toSet\n        val set2 = l2.toSet\n        (set1 & set2).toList.sorted",
  "        val m1 = l1.groupBy(x => x).mapValues(_.size)\n        val m2 = l2.groupBy(x\
    \ => x).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted",
  "        val m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted", "        val s1\
    \ = l1.toSet\n        val s2 = l2.toSet\n        val s3 = s1.intersect(s2)\n \
    \       s3.toList.sorted", "        val m1 = l1.toSet\n        val m2 = l2.toSet\n\
    \        (m1 & m2).toList.sorted", "        val s1 = l1.toSet\n        val s2\
    \ = l2.toSet\n        (s1 & s2).toList.sorted", "        val map = HashMap[Long,\
    \ Int]()\n        for (i <- l1) {\n            if (map.contains(i)) map(i) +=\
    \ 1\n            else map(i) = 1\n        }\n        for (i <- l2) {\n       \
    \     if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n\
    \        val result = ListBuffer[Long]()\n        for ((k, v) <- map) {\n    \
    \        if (v == 2) result += k\n        }\n        result.toList.sorted", " \
    \       val m1 = l1.toSet\n        val m2 = l2.toSet\n        val m3 = m1.intersect(m2)\n\
    \        m3.toList.sorted", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        (s1 & s2).toList.sorted", "        val s1 = l1.toSet\n        val s2\
    \ = l2.toSet\n        (s1 & s2).toList.sorted", "        val s1 = l1.toSet\n \
    \       val s2 = l2.toSet\n        (s1 & s2).toList.sorted", "        val s1 =\
    \ l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", "   \
    \     val l1s = l1.sorted\n        val l2s = l2.sorted\n        var l1i = 0\n\
    \        var l2i = 0\n        var result = List[Long]()\n        while (l1i <\
    \ l1s.length && l2i < l2s.length) {\n            if (l1s(l1i) == l2s(l2i)) {\n\
    \                result = l1s(l1i) :: result\n                l1i += 1\n     \
    \           l2i += 1\n            } else if (l1s(l1i) < l2s(l2i)) {\n        \
    \        l1i += 1\n            } else {\n                l2i += 1\n          \
    \  }\n        }\n        result.reverse", "        val set1 = l1.toSet\n     \
    \   val set2 = l2.toSet\n        val set3 = set1.intersect(set2)\n        set3.toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val set1 = l1.toSet\n        val set2 = l2.toSet\n        (set1 & set2).toList.sorted",
  "        val l1s = l1.sorted\n        val l2s = l2.sorted\n        var i = 0\n \
    \       var j = 0\n        var result = List[Long]()\n        while (i < l1s.length\
    \ && j < l2s.length) {\n            if (l1s(i) == l2s(j)) {\n                result\
    \ = l1s(i) :: result\n                i += 1\n                j += 1\n       \
    \     } else if (l1s(i) < l2s(j)) {\n                i += 1\n            } else\
    \ {\n                j += 1\n            }\n        }\n        result.reverse",
  "        val l = l1.intersect(l2)\n        l.sorted", "        val m1 = l1.groupBy(identity).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(identity).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.keys.toList.sorted.flatMap(x =>\
    \ List.fill(m(x))(x))", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        (s1 & s2).toList.sorted", "        val s1 = l1.toSet\n        val s2\
    \ = l2.toSet\n        (s1 & s2).toList.sorted", "        val m1 = l1.groupBy(x\
    \ => x).mapValues(_.size)\n        val m2 = l2.groupBy(x => x).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.keySet.toList.sorted.flatMap(x => List.fill(m(x))(x))", "        val\
    \ m1 = l1.toSet\n        val m2 = l2.toSet\n        (m1 & m2).toList.sorted",
  "        val m1 = l1.groupBy(x => x).mapValues(_.size)\n        val m2 = l2.groupBy(x\
    \ => x).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.keys.toList.sorted.flatMap(x =>\
    \ List.fill(m(x))(x))", "        val m1 = l1.groupBy(identity).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(identity).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted",
  "        val l = l1.intersect(l2)\n        l.sorted", "        val l = l1.intersect(l2)\n\
    \        l.sorted", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n  \
    \      (s1 & s2).toList.sorted", "        val s1 = l1.toSet\n        val s2 =\
    \ l2.toSet\n        (s1 & s2).toList.sorted", "        val s1 = l1.toSet\n   \
    \     val s2 = l2.toSet\n        (s1 & s2).toList.sorted", "        val s1 = l1.toSet\n\
    \        val s2 = l2.toSet\n        val s3 = s1 & s2\n        s3.toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val l1Set = l1.toSet\n        val l2Set = l2.toSet\n        val commonSet\
    \ = l1Set & l2Set\n        commonSet.toList.sorted", "        val m1 = l1.groupBy(x\
    \ => x).mapValues(_.size)\n        val m2 = l2.groupBy(x => x).mapValues(_.size)\n\
    \        (m1.keySet & m2.keySet).toList.sorted.map(x => List.fill(min(m1(x), m2(x)))(x)).flatten",
  "        var m1 = Map[Long, Int]()\n        var m2 = Map[Long, Int]()\n        for\
    \ (i <- l1) {\n            if (m1.contains(i)) m1(i) += 1\n            else m1(i)\
    \ = 1\n        }\n        for (i <- l2) {\n            if (m2.contains(i)) m2(i)\
    \ += 1\n            else m2(i) = 1\n        }\n        var result = List[Long]()\n\
    \        for (i <- m1.keys) {\n            if (m2.contains(i)) {\n           \
    \     val count = min(m1(i), m2(i))\n                for (j <- 0 until count)\
    \ result = i :: result\n            }\n        }\n        result.sorted", "  \
    \      val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val m1 = new HashMap[Long, Int]\n        val m2 = new HashMap[Long, Int]\n\
    \        for (i <- l1) {\n            if (m1.contains(i)) m1(i) += 1\n       \
    \     else m1(i) = 1\n        }\n        for (i <- l2) {\n            if (m2.contains(i))\
    \ m2(i) += 1\n            else m2(i) = 1\n        }\n        val m = new HashMap[Long,\
    \ Int]\n        for (i <- m1.keys) {\n            if (m2.contains(i)) m(i) = min(m1(i),\
    \ m2(i))\n        }\n        val l = new ListBuffer[Long]\n        for (i <- m.keys)\
    \ {\n            for (j <- 0 until m(i)) l += i\n        }\n        l.toList.sorted",
  "        val m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted", "        val s1\
    \ = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", " \
    \       val h1 = l1.toSet\n        val h2 = l2.toSet\n        val h3 = h1.intersect(h2)\n\
    \        h3.toList.sorted", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        (s1 & s2).toList.sorted", "        val s1 = l1.toSet\n        val s2\
    \ = l2.toSet\n        (s1 & s2).toList.sorted", "        val m1 = l1.groupBy(x\
    \ => x).mapValues(_.size)\n        val m2 = l2.groupBy(x => x).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted", "        val s1\
    \ = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", " \
    \       val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val map = new HashMap[Long, Int]()\n        for (i <- l1) {\n         \
    \   if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n\
    \        val result = new ListBuffer[Long]()\n        for (i <- l2) {\n      \
    \      if (map.contains(i) && map(i) > 0) {\n                result += i\n   \
    \             map(i) -= 1\n            }\n        }\n        result.toList.sorted",
  "        val m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted", "        val s1\
    \ = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", " \
    \       val set1 = l1.toSet\n        val set2 = l2.toSet\n        (set1 & set2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted", "        val set1\
    \ = l1.toSet\n        val set2 = l2.toSet\n        val set3 = set1.intersect(set2)\n\
    \        set3.toList.sorted", "        val set1 = l1.toSet\n        val set2 =\
    \ l2.toSet\n        val set3 = set1.intersect(set2)\n        set3.toList.sorted",
  "        val h1 = l1.toSet\n        val h2 = l2.toSet\n        val h3 = h1.intersect(h2)\n\
    \        h3.toList.sorted", "        val m1 = l1.groupBy(identity).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(identity).mapValues(_.size)\n        val m3 = m1.filter(p\
    \ => m2.contains(p._1))\n        val m4 = m3.map(p => (p._1, min(p._2, m2(p._1))))\n\
    \        m4.keys.toList.sorted", "        val m1 = l1.groupBy(x => x).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(x => x).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.keySet.toList.sorted.flatMap(x =>\
    \ List.fill(m(x))(x))", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        (s1 & s2).toList.sorted", "        val set1 = l1.toSet\n        val set2\
    \ = l2.toSet\n        val set3 = set1.intersect(set2)\n        set3.toList.sorted",
  "        val m1 = l1.toSet\n        val m2 = l2.toSet\n        (m1 & m2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        val s3 = s1.intersect(s2)\n\
    \        s3.toList.sorted", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        (s1 & s2).toList.sorted", "        val h = new HashMap[Long, Int]\n \
    \       for (x <- l1) h(x) = 1\n        for (x <- l2) h(x) = h.getOrElse(x, 0)\
    \ + 1\n        h.filter(x => x._2 == 2).keys.toList.sorted", "        val h1 =\
    \ l1.toSet\n        val h2 = l2.toSet\n        (h1 & h2).toList.sorted", "   \
    \     val map = new HashMap[Long, Int]\n        for (x <- l1) {\n            if\
    \ (map.contains(x)) map(x) += 1\n            else map(x) = 1\n        }\n    \
    \    val result = new ListBuffer[Long]\n        for (x <- l2) {\n            if\
    \ (map.contains(x) && map(x) > 0) {\n                result += x\n           \
    \     map(x) -= 1\n            }\n        }\n        result.toList.sorted", " \
    \       val s1 = l1.toSet\n        val s2 = l2.toSet\n        val s3 = s1.intersect(s2)\n\
    \        s3.toList.sorted", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        val s3 = s1.intersect(s2)\n        s3.toList.sorted", "        val s1\
    \ = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", " \
    \       val set1 = l1.toSet\n        val set2 = l2.toSet\n        (set1 & set2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val set1 = l1.toSet\n        val set2 = l2.toSet\n        val set3 = set1.intersect(set2)\n\
    \        set3.toList.sorted", "        val m1 = l1.groupBy(identity).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(identity).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted",
  "        val m1 = l1.toSet\n        val m2 = l2.toSet\n        (m1 & m2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  '        l1.intersect(l2).sorted', "        val m1 = l1.groupBy(x => x).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(x => x).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted",
  "        val m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.toList.flatMap(x => List.fill(x._2)(x._1)).sorted", "        val m1\
    \ = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.keys.toList.sorted.flatMap(x => List.fill(m(x))(x))", "        val\
    \ s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.keySet.toList.sorted.flatMap(x => List.fill(m(x))(x))", "        val\
    \ m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.flatMap(x => List.fill(x._2)(x._1)).toList.sorted", "        val s1\
    \ = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", " \
    \       val s1 = l1.toSet\n        val s2 = l2.toSet\n        val s3 = s1 & s2\n\
    \        s3.toList.sorted", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        (s1 & s2).toList.sorted", "        val s1 = l1.toSet\n        val s2\
    \ = l2.toSet\n        val s3 = s1.intersect(s2)\n        s3.toList.sorted", " \
    \       val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val l = l1.intersect(l2)\n        l.sorted", "        val m1 = l1.groupBy(identity).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(identity).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.keys.toList.sorted.flatMap(x =>\
    \ List.fill(m(x))(x))", "        val l = l1.intersect(l2)\n        l.sorted",
  "        val m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(e => (e, min(m1(e), m2(e)))).toMap\n\
    \        m.keys.toList.sorted.flatMap(e => List.fill(m(e))(e))", "        val\
    \ m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.keySet.toList.sorted.flatMap(x => List.fill(m(x))(x))", "        var\
    \ l = List[Long]()\n        for (i <- l1) {\n            if (l2.contains(i)) l\
    \ = i :: l\n        }\n        l.sorted", "        val s1 = l1.toSet\n       \
    \ val s2 = l2.toSet\n        (s1 & s2).toList.sorted", "        val h1 = l1.toSet\n\
    \        val h2 = l2.toSet\n        val h3 = h1.intersect(h2)\n        h3.toList.sorted",
  '        l1.intersect(l2).sorted', "        val m1 = l1.groupBy(identity).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(identity).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.keys.toList.sorted.flatMap(x =>\
    \ List.fill(m(x))(x))", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        (s1 & s2).toList.sorted", "        val s1 = l1.toSet\n        val s2\
    \ = l2.toSet\n        (s1 & s2).toList.sorted", "        val m1 = l1.toSet\n \
    \       val m2 = l2.toSet\n        val m3 = m1.intersect(m2)\n        m3.toList.sorted",
  "        val map = new HashMap[Long, Int]\n        for (i <- l1) {\n           \
    \ if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n \
    \       val result = new ListBuffer[Long]\n        for (i <- l2) {\n         \
    \   if (map.contains(i) && map(i) > 0) {\n                result += i\n      \
    \          map(i) -= 1\n            }\n        }\n        result.toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        val s3 = s1.intersect(s2)\n\
    \        s3.toList.sorted", "        val set1 = l1.toSet\n        val set2 = l2.toSet\n\
    \        val set3 = set1.intersect(set2)\n        set3.toList.sorted", "     \
    \   val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val m1 = l1.groupBy(identity).mapValues(_.size)\n        val m2 = l2.groupBy(identity).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.flatMap(x => List.fill(x._2)(x._1)).toList.sorted", "        val s1\
    \ = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", " \
    \       val s1 = l1.toSet\n        val s2 = l2.toSet\n        val s3 = s1 & s2\n\
    \        s3.toList.sorted", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        (s1 & s2).toList.sorted", "        val s1 = l1.toSet\n        val s2\
    \ = l2.toSet\n        (s1 & s2).toList.sorted", "        val m1 = l1.groupBy(x\
    \ => x).mapValues(_.size)\n        val m2 = l2.groupBy(x => x).mapValues(_.size)\n\
    \        val m = m1.keySet.intersect(m2.keySet).map(x => (x, min(m1(x), m2(x)))).toMap\n\
    \        m.flatMap(x => List.fill(x._2)(x._1)).toList.sorted", "        val set1\
    \ = l1.toSet\n        val set2 = l2.toSet\n        (set1 & set2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val set1 = l1.toSet\n        val set2 = l2.toSet\n        (set1 & set2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        val s3 = s1 & s2\n\
    \        s3.toList.sorted", "        val l = l1.intersect(l2)\n        l.sorted",
  "        val l = l1.intersect(l2)\n        l.sorted"]
stop_tokens:
- "\n    }\n"
