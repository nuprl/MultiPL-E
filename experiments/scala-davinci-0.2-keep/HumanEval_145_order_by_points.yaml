name: HumanEval_145_order_by_points
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function which sorts the given list of integers\n    // in ascending\
  \ order according to the sum of their digits.\n    // Note: if there are several\
  \ items with similar sum of their digits,\n    // order them based on their index\
  \ in original list.\n    // For example:\n    // >>> order_by_points([1, 11, -1,\
  \ -11, -12]) == [-1, -11, 1, -12, 11]\n    // >>> order_by_points([]) == []\n  \
  \  def orderByPoints(nums : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(orderByPoints((List[Long](1l.toLong,\
  \ 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong))).equals((List[Long](-1l.toLong,\
  \ -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))));\n    assert(orderByPoints((List[Long](1234l.toLong,\
  \ 423l.toLong, 463l.toLong, 145l.toLong, 2l.toLong, 423l.toLong, 423l.toLong, 53l.toLong,\
  \ 6l.toLong, 37l.toLong, 3457l.toLong, 3l.toLong, 56l.toLong, 0l.toLong, 46l.toLong))).equals((List[Long](0l.toLong,\
  \ 2l.toLong, 3l.toLong, 6l.toLong, 53l.toLong, 423l.toLong, 423l.toLong, 423l.toLong,\
  \ 1234l.toLong, 145l.toLong, 37l.toLong, 46l.toLong, 56l.toLong, 463l.toLong, 3457l.toLong))));\n\
  \    assert(orderByPoints((List[Long]())).equals((List[Long]())));\n    assert(orderByPoints((List[Long](1l.toLong,\
  \ -11l.toLong, -32l.toLong, 43l.toLong, 54l.toLong, -98l.toLong, 2l.toLong, -3l.toLong))).equals((List[Long](-3l.toLong,\
  \ -32l.toLong, -98l.toLong, -11l.toLong, 1l.toLong, 2l.toLong, 43l.toLong, 54l.toLong))));\n\
  \    assert(orderByPoints((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
  \ 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong))).equals((List[Long](1l.toLong,\
  \ 10l.toLong, 2l.toLong, 11l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong,\
  \ 7l.toLong, 8l.toLong, 9l.toLong))));\n    assert(orderByPoints((List[Long](0l.toLong,\
  \ 6l.toLong, 6l.toLong, -76l.toLong, -21l.toLong, 23l.toLong, 4l.toLong))).equals((List[Long](-76l.toLong,\
  \ -21l.toLong, 0l.toLong, 4l.toLong, 23l.toLong, 6l.toLong, 6l.toLong))));\n   \
  \ }\n\n}\n"
completions: ["        val numsWithPoints = nums.zipWithIndex.map(x => (x._1, x._1.toString.map(_.asDigit).sum,\
    \ x._2))\n        numsWithPoints.sortBy(x => (x._2, x._3)).map(_._1)", "     \
    \   val map = new HashMap[Long, List[Long]]\n        for (i <- 0 until nums.length)\
    \ {\n            val sum = nums(i).toString.map(_.asDigit).sum\n            if\
    \ (!map.contains(sum)) map(sum) = List(nums(i))\n            else map(sum) = map(sum)\
    \ :+ nums(i)\n        }\n        val keys = map.keys.toList.sorted\n        var\
    \ result = List[Long]()\n        for (key <- keys) result = result ::: map(key)\n\
    \        result", "        val numsWithPoints = nums.map(n => (n, n.toString.map(_.asDigit).sum))\n\
    \        numsWithPoints.sortBy(n => (n._2, nums.indexOf(n._1))).map(_._1)", '        nums.sortWith((a,
    b) => sumDigits(a) < sumDigits(b))', "        val map = new HashMap[Long, List[Long]]\n\
    \        for (num <- nums) {\n            val key = num.abs.toString.map(_.asDigit).sum\n\
    \            if (!map.contains(key)) map(key) = List(num)\n            else map(key)\
    \ = map(key) :+ num\n        }\n        val keys = map.keys.toList.sorted\n  \
    \      val result = new ListBuffer[Long]\n        for (key <- keys) {\n      \
    \      val list = map(key)\n            for (num <- list) result += num\n    \
    \    }\n        result.toList", "        var map = new HashMap[Long, List[Long]]()\n\
    \        for (num <- nums) {\n            var sum = 0L\n            var n = num\n\
    \            while (n != 0) {\n                sum += n % 10\n               \
    \ n /= 10\n            }\n            if (!map.contains(sum)) map(sum) = List()\n\
    \            map(sum) = map(sum) :+ num\n        }\n        var list = List[Long]()\n\
    \        for (num <- nums) {\n            var sum = 0L\n            var n = num\n\
    \            while (n != 0) {\n                sum += n % 10\n               \
    \ n /= 10\n            }\n            list = list :+ map(sum).head\n         \
    \   map(sum) = map(sum).tail\n        }\n        list", "        nums.sortWith((a,\
    \ b) => {\n            val aSum = a.toString.map(_.asDigit).sum\n            val\
    \ bSum = b.toString.map(_.asDigit).sum\n            if (aSum == bSum) a < b else\
    \ aSum < bSum\n        })", "        nums.sortWith((a, b) => {\n            val\
    \ sumA = a.toString.map(x => x.asDigit).sum\n            val sumB = b.toString.map(x\
    \ => x.asDigit).sum\n            if (sumA == sumB) a < b else sumA < sumB\n  \
    \      })", "        nums.sortWith((a, b) => {\n            val aSum = a.toString.map(_.asDigit).sum\n\
    \            val bSum = b.toString.map(_.asDigit).sum\n            if (aSum ==\
    \ bSum) a < b else aSum < bSum\n        })", "        val map = new HashMap[Long,\
    \ List[Long]]\n        for (num <- nums) {\n            val sum = num.toString.map(_.asDigit).sum\n\
    \            if (!map.contains(sum)) map += (sum -> List(num))\n            else\
    \ map(sum) = map(sum) :+ num\n        }\n        val keys = map.keys.toList.sorted\n\
    \        val result = new ListBuffer[Long]\n        for (key <- keys) result ++=\
    \ map(key)\n        result.toList", "        nums.sortWith((x, y) => {\n     \
    \       val xSum = x.toString.map(c => c.asDigit).sum\n            val ySum =\
    \ y.toString.map(c => c.asDigit).sum\n            if (xSum == ySum) {\n      \
    \          nums.indexOf(x) < nums.indexOf(y)\n            } else {\n         \
    \       xSum < ySum\n            }\n        })", "        nums.sortWith((a, b)\
    \ => {\n            val aSum = a.toString.map(_.asDigit).sum\n            val\
    \ bSum = b.toString.map(_.asDigit).sum\n            if (aSum == bSum) a < b else\
    \ aSum < bSum\n        })", "        nums.sortWith((a, b) => {\n            val\
    \ aSum = a.toString.map(_.asDigit).sum\n            val bSum = b.toString.map(_.asDigit).sum\n\
    \            if (aSum == bSum) a < b else aSum < bSum\n        })", "        nums.sortWith((a,\
    \ b) => {\n            val aSum = a.toString.map(_.asDigit).sum\n            val\
    \ bSum = b.toString.map(_.asDigit).sum\n            if (aSum == bSum) a < b else\
    \ aSum < bSum\n        })", "        val numsWithPoints = nums.zipWithIndex.map(x\
    \ => (x._1, x._1.toString.map(_.asDigit).sum, x._2))\n        numsWithPoints.sortBy(x\
    \ => (x._2, x._3)).map(_._1)", "        nums.sortWith((a, b) => {\n          \
    \  val sumA = a.toString.map(_.asDigit).sum\n            val sumB = b.toString.map(_.asDigit).sum\n\
    \            if (sumA == sumB) a < b else sumA < sumB\n        })", "        nums.sortWith((a,\
    \ b) => {\n            val aSum = a.toString.map(_.asDigit).sum\n            val\
    \ bSum = b.toString.map(_.asDigit).sum\n            if (aSum == bSum) a < b else\
    \ aSum < bSum\n        })", "        nums.sortWith((a, b) => {\n            val\
    \ aSum = a.toString.map(x => x.asDigit).sum\n            val bSum = b.toString.map(x\
    \ => x.asDigit).sum\n            if (aSum == bSum) a < b else aSum < bSum\n  \
    \      })", "        nums.sortWith((a, b) => {\n            val aSum = a.toString.map(x\
    \ => x.asDigit).sum\n            val bSum = b.toString.map(x => x.asDigit).sum\n\
    \            if (aSum == bSum) a < b else aSum < bSum\n        })", "        val\
    \ map = new HashMap[Long, List[Long]]\n        for (num <- nums) {\n         \
    \   val sum = num.toString.map(c => c.asDigit).sum\n            if (!map.contains(sum))\
    \ map(sum) = List(num)\n            else map(sum) = map(sum) :+ num\n        }\n\
    \        val sorted = map.toList.sortBy(_._1)\n        sorted.map(x => x._2).flatten"]
stop_tokens:
- "\n    }\n"
