language: scala
name: HumanEval_11_string_xor
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val xor_int = a_int ^ b_int\n\
    \        val xor_string = Integer.toBinaryString(xor_int)\n        return xor_string\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeaub0f0_.scala:16)\n\tat Problem.main(tmpeaub0f0_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792971
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(i => i.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toList.map(x => x.toString.toInt)\n\
    \        val bBits = b.toList.map(x => x.toString.toInt)\n        val cBits =\
    \ aBits.zip(bBits).map(x => x._1 ^ x._2)\n        cBits.map(x => x.toString).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aa = a.toList.map(_.toString.toInt)\n\
    \        val bb = b.toList.map(_.toString.toInt)\n        val cc = aa.zip(bb).map(x\
    \ => x._1 ^ x._2)\n        cc.map(_.toString).reduceLeft(_ + _)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            result += ((a(i) - '0') ^ (b(i) - '0')\
    \ + '0').toChar\n        }\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val sb = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            sb.append((a(i) - '0') ^ (b(i) - '0'))\n\
    \        }\n        sb.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_array = a.toCharArray\n        val b_array\
    \ = b.toCharArray\n        var result = \"\"\n        for (i <- 0 until a_array.length)\
    \ {\n            if (a_array(i) == b_array(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val n = a.length\n        val m = b.length\n\
    \        if (n != m) throw new IllegalArgumentException\n        val sb = new\
    \ StringBuilder\n        for (i <- 0 until n) {\n            if (a(i) == b(i))\
    \ sb.append('0')\n            else sb.append('1')\n        }\n        sb.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            result += (if (a(i) == b(i)) \"0\" else \"1\")\n  \
    \      }\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val result = aBits.zip(bBits).map(c\
    \ => c._1 ^ c._2)\n        result.map(c => c.toString).mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aa = a.toCharArray\n        val bb = b.toCharArray\n\
    \        val cc = new Array[Char](aa.length)\n        for (i <- 0 until aa.length)\
    \ {\n            if (aa(i) == bb(i)) cc(i) = '0'\n            else cc(i) = '1'\n\
    \        }\n        return cc.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(i => i.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(x => x.toString.toInt)\n\
    \        val bBits = b.map(x => x.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(x\
    \ => x._1 ^ x._2)\n        xorBits.map(x => x.toString).mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            result += (if (a(i) == b(i)) '0' else\
    \ '1')\n        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_array = a.toCharArray\n        val b_array\
    \ = b.toCharArray\n        val result = new StringBuilder\n        for (i <- 0\
    \ until a_array.length) {\n            if (a_array(i) == b_array(i)) result.append(\"\
    0\")\n            else result.append(\"1\")\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val c = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) c.append('0')\n      \
    \      else c.append('1')\n        }\n        c.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val c = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            c.append((a(i) - '0') ^ (b(i) - '0'))\n\
    \        }\n        c.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val c = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            c.append((a(i) - '0') ^ (b(i) - '0'))\n\
    \        }\n        c.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_bits = a.toList.map(_.toString.toInt)\n\
    \        val b_bits = b.toList.map(_.toString.toInt)\n        val c_bits = a_bits.zip(b_bits).map(x\
    \ => x._1 ^ x._2)\n        c_bits.map(_.toString).mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val xor_int = a_int ^ b_int\n\
    \        val xor_string = Integer.toBinaryString(xor_int)\n        return xor_string\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeaub0f0_.scala:16)\n\tat Problem.main(tmpeaub0f0_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBin = a.toInt(2)\n        val bBin =\
    \ b.toInt(2)\n        val xor = aBin ^ bBin\n        xor.toBinaryString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpm3v_i2m3.scala:9:21 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBin\e[0m = a.toInt(\e[31m2\e\
    [0m)\n\e[31m\e[31m  |\e[0m                   ^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \              \e[33mmethod\e[0m \e[35mtoInt\e[0m in \e[33mclass\e[0m \e[35mStringOps\e\
    [0m does not take parameters\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmpm3v_i2m3.scala:10:21 -----------------------------\e[0m\e[0m\n\e[31m10\
    \ |\e[0m        \e[33mval\e[0m \e[36mbBin\e[0m = b.toInt(\e[31m2\e[0m)\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                \e\
    [33mmethod\e[0m \e[35mtoInt\e[0m in \e[33mclass\e[0m \e[35mStringOps\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792970
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val xor_int = a_int ^ b_int\n\
    \        val xor_string = Integer.toBinaryString(xor_int)\n        return xor_string\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeaub0f0_.scala:16)\n\tat Problem.main(tmpeaub0f0_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792971
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        if (a.length != b.length) {\n            throw\
    \ new IllegalArgumentException(\"Input strings must be of equal length\")\n  \
    \      }\n        var result = \"\"\n        for (i <- 0 until a.length) {\n \
    \           result += (if (a(i) == b(i)) \"0\" else \"1\")\n        }\n      \
    \  return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result += '0'\n   \
    \         else result += '1'\n        }\n        result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val cList = ListBuffer[Char]()\n        for (i <- 0 until\
    \ aList.length) {\n            if (aList(i) == bList(i)) cList += '0'\n      \
    \      else cList += '1'\n        }\n        cList.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = a.toInt(2)\n        val b_int\
    \ = b.toInt(2)\n        val c_int = a_int ^ b_int\n        val c = c_int.toBinaryString\n\
    \        c\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpu834sk1a.scala:9:22 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36ma_int\e[0m = a.toInt(\e[31m2\e\
    [0m)\n\e[31m\e[31m  |\e[0m                    ^^^^^^^\e[0m\n\e[31m  |\e[0m   \
    \               \e[33mmethod\e[0m \e[35mtoInt\e[0m in \e[33mclass\e[0m \e[35mStringOps\e\
    [0m does not take parameters\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmpu834sk1a.scala:10:22 -----------------------------\e[0m\e[0m\n\e[31m10\
    \ |\e[0m        \e[33mval\e[0m \e[36mb_int\e[0m = b.toInt(\e[31m2\e[0m)\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ \e[33mmethod\e[0m \e[35mtoInt\e[0m in \e[33mclass\e[0m \e[35mStringOps\e[0m\
    \ does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val result = aBits.zip(bBits).map(x\
    \ => x._1 ^ x._2)\n        result.map(x => x.toString).reduceLeft(_ + _)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toList.map(x => x.toString.toInt)\n\
    \        val bBits = b.toList.map(x => x.toString.toInt)\n        val xorBits\
    \ = aBits.zip(bBits).map(x => x._1 ^ x._2)\n        xorBits.map(x => x.toString).reduceLeft(_\
    \ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aa = a.toCharArray\n        val bb = b.toCharArray\n\
    \        val cc = new Array[Char](aa.length)\n        for (i <- 0 until aa.length)\
    \ {\n            cc(i) = (aa(i) ^ bb(i)).toChar\n        }\n        return cc.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxayel61o.scala:18)\n\tat Problem.main(tmpxayel61o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val sb = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append('0')\n     \
    \       else sb.append('1')\n        }\n        sb.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val n = a.length\n        val m = b.length\n\
    \        if (n != m) throw new Exception(\"Strings must be of equal length\")\n\
    \        val sb = new StringBuilder\n        for (i <- 0 until n) {\n        \
    \    val x = a(i)\n            val y = b(i)\n            if (x == '0' && y ==\
    \ '0') sb.append('0')\n            else if (x == '1' && y == '1') sb.append('0')\n\
    \            else sb.append('1')\n        }\n        sb.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            result += (if (a(i) == b(i)) '0' else '1')\n      \
    \  }\n        return result\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val sb = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append('0')\n     \
    \       else sb.append('1')\n        }\n        sb.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toList.map(x => x.toString.toInt)\n\
    \        val bBits = b.toList.map(x => x.toString.toInt)\n        val xorBits\
    \ = aBits.zip(bBits).map(x => x._1 ^ x._2)\n        xorBits.mkString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_list = a.toList\n        val b_list\
    \ = b.toList\n        val result = for (i <- 0 until a_list.length) yield {\n\
    \            if (a_list(i) == b_list(i)) \"0\" else \"1\"\n        }\n       \
    \ result.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val n = a.length\n        val m = b.length\n\
    \        if (n != m) throw new IllegalArgumentException(\"Strings must be of equal\
    \ length\")\n        val sb = new StringBuilder\n        for (i <- 0 until n)\
    \ {\n            if (a(i) == b(i)) sb.append('0')\n            else sb.append('1')\n\
    \        }\n        sb.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val result = a_int ^ b_int\n \
    \       Integer.toBinaryString(result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_fpubyqo.scala:15)\n\tat Problem.main(tmp_fpubyqo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792976
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val c_int = a_int ^ b_int\n  \
    \      val c = Integer.toBinaryString(c_int)\n        return c\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmj7qp5x3.scala:16)\n\tat Problem.main(tmpmj7qp5x3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = a.toInt(2)\n        val b_int\
    \ = b.toInt(2)\n        val c_int = a_int ^ b_int\n        val c = c_int.toBinaryString\n\
    \        return c\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpc_szgdo5.scala:9:22 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36ma_int\e[0m = a.toInt(\e[31m2\e\
    [0m)\n\e[31m\e[31m  |\e[0m                    ^^^^^^^\e[0m\n\e[31m  |\e[0m   \
    \               \e[33mmethod\e[0m \e[35mtoInt\e[0m in \e[33mclass\e[0m \e[35mStringOps\e\
    [0m does not take parameters\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmpc_szgdo5.scala:10:22 -----------------------------\e[0m\e[0m\n\e[31m10\
    \ |\e[0m        \e[33mval\e[0m \e[36mb_int\e[0m = b.toInt(\e[31m2\e[0m)\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ \e[33mmethod\e[0m \e[35mtoInt\e[0m in \e[33mclass\e[0m \e[35mStringOps\e[0m\
    \ does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        require(a.length == b.length)\n        val\
    \ sb = new StringBuilder\n        for (i <- 0 until a.length) {\n            if\
    \ (a(i) == b(i)) sb.append('0')\n            else sb.append('1')\n        }\n\
    \        sb.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_arr = a.toCharArray()\n        val b_arr\
    \ = b.toCharArray()\n        val c_arr = new Array[Char](a_arr.length)\n     \
    \   for (i <- 0 until a_arr.length) {\n            if (a_arr(i) == b_arr(i)) c_arr(i)\
    \ = '0'\n            else c_arr(i) = '1'\n        }\n        return c_arr.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val sb = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append('0')\n     \
    \       else sb.append('1')\n        }\n        sb.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result += '0'\n   \
    \         else result += '1'\n        }\n        result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_array = a.toCharArray\n        val b_array\
    \ = b.toCharArray\n        val result = new Array[Char](a_array.length)\n    \
    \    for (i <- 0 until a_array.length) {\n            if (a_array(i) == b_array(i))\
    \ result(i) = '0'\n            else result(i) = '1'\n        }\n        result.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(x\
    \ => x._1 ^ x._2)\n        xorBits.map(x => x.toString).mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toList.map(c => c.toString.toInt)\n\
    \        val bBits = b.toList.map(c => c.toString.toInt)\n        val cBits =\
    \ aBits.zip(bBits).map(x => x._1 ^ x._2)\n        cBits.map(x => x.toString).reduceLeft(_\
    \ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aa = a.toCharArray\n        val bb = b.toCharArray\n\
    \        val cc = new Array[Char](aa.length)\n        for (i <- 0 until aa.length)\
    \ {\n            cc(i) = (aa(i) ^ bb(i)).toChar\n        }\n        return cc.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxayel61o.scala:18)\n\tat Problem.main(tmpxayel61o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val sb = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append('0')\n     \
    \       else sb.append('1')\n        }\n        sb.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val result = (a_int ^ b_int).toBinaryString\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc89lj1cf.scala:15)\n\tat Problem.main(tmpc89lj1cf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_array = a.toCharArray\n        val b_array\
    \ = b.toCharArray\n        val result = new Array[Char](a_array.length)\n    \
    \    for (i <- 0 until a_array.length) {\n            if (a_array(i) == b_array(i))\
    \ result(i) = '0'\n            else result(i) = '1'\n        }\n        result.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val n = a.length\n        val c = new Array[Char](n)\n\
    \        for (i <- 0 until n) {\n            if (a(i) == b(i)) c(i) = '0'\n  \
    \          else c(i) = '1'\n        }\n        return c.mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val xor_int = a_int ^ b_int\n\
    \        val xor_str = Integer.toBinaryString(xor_int)\n        return xor_str\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3g7wfjsp.scala:16)\n\tat Problem.main(tmp3g7wfjsp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val c = a.zip(b).map(x => (x._1.toInt ^ x._2.toInt).toString)\n\
    \        c.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792979
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val c_int = a_int ^ b_int\n  \
    \      val c = Integer.toBinaryString(c_int)\n        return c\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmj7qp5x3.scala:16)\n\tat Problem.main(tmpmj7qp5x3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val n = a.length\n        val m = b.length\n\
    \        if (n != m) throw new IllegalArgumentException(\"Length of strings must\
    \ be equal.\")\n        val sb = new StringBuilder\n        for (i <- 0 until\
    \ n) {\n            val x = a(i)\n            val y = b(i)\n            if (x\
    \ == '0' && y == '0') sb.append('0')\n            else if (x == '1' && y == '1')\
    \ sb.append('0')\n            else sb.append('1')\n        }\n        sb.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val sb = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append('0')\n     \
    \       else sb.append('1')\n        }\n        sb.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result += '0'\n   \
    \         else result += '1'\n        }\n        result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val n = a.length\n        val m = b.length\n\
    \        if (n != m) throw new Exception(\"Strings must be of equal length\")\n\
    \        val c = new StringBuilder\n        for (i <- 0 until n) {\n         \
    \   if (a(i) == b(i)) c.append('0')\n            else c.append('1')\n        }\n\
    \        c.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_list = a.toList\n        val b_list\
    \ = b.toList\n        val c_list = a_list.zip(b_list).map(x => (x._1, x._2, x._1\
    \ ^ x._2))\n        c_list.map(x => x._3.toString).mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aa = a.toCharArray\n        val bb = b.toCharArray\n\
    \        val cc = new Array[Char](aa.length)\n        for (i <- 0 until aa.length)\
    \ {\n            if (aa(i) == bb(i)) cc(i) = '0'\n            else cc(i) = '1'\n\
    \        }\n        return cc.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val c = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            c.append((a(i) - '0') ^ (b(i) - '0'))\n\
    \        }\n        c.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_arr = a.toCharArray\n        val b_arr\
    \ = b.toCharArray\n        val result = new StringBuilder\n        for (i <- 0\
    \ until a_arr.length) {\n            if (a_arr(i) == b_arr(i)) {\n           \
    \     result.append('0')\n            } else {\n                result.append('1')\n\
    \            }\n        }\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val c = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            c.append((a(i) - '0') ^ (b(i) - '0'))\n\
    \        }\n        c.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val result = a_int ^ b_int\n \
    \       return Integer.toBinaryString(result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpumdgwq1v.scala:15)\n\tat Problem.main(tmpumdgwq1v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val result = a_int ^ b_int\n \
    \       return result.toBinaryString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzlv8tmi.scala:15)\n\tat Problem.main(tmpqzlv8tmi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val c_int = a_int ^ b_int\n  \
    \      val c = Integer.toBinaryString(c_int)\n        return c\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmj7qp5x3.scala:16)\n\tat Problem.main(tmpmj7qp5x3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val c = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            c.append((a(i) - '0') ^ (b(i) - '0'))\n\
    \        }\n        c.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toList.map(_.toString.toInt)\n\
    \        val bBits = b.toList.map(_.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(x\
    \ => x._1 ^ x._2)\n        xorBits.map(_.toString).reduce(_ + _)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aInt = Integer.parseInt(a, 2)\n      \
    \  val bInt = Integer.parseInt(b, 2)\n        val result = aInt ^ bInt\n     \
    \   return Integer.toBinaryString(result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpadk4wiis.scala:15)\n\tat Problem.main(tmpadk4wiis.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val c_int = a_int ^ b_int\n  \
    \      return Integer.toBinaryString(c_int)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3xh6lvjb.scala:15)\n\tat Problem.main(tmp3xh6lvjb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(i => i.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val n = a.length\n        val m = b.length\n\
    \        if (n != m) throw new Exception(\"Inputs must be of equal length\")\n\
    \        val sb = new StringBuilder\n        for (i <- 0 until n) {\n        \
    \    val x = a(i)\n            val y = b(i)\n            if (x == '0' && y ==\
    \ '0') sb.append('0')\n            else if (x == '1' && y == '1') sb.append('0')\n\
    \            else sb.append('1')\n        }\n        sb.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(i => i.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(i => i.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val sb = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append('0')\n     \
    \       else sb.append('1')\n        }\n        sb.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        if (a.length != b.length) throw new Exception(\"\
    Strings must be of equal length.\")\n        val result = new StringBuilder\n\
    \        for (i <- 0 until a.length) {\n            if (a(i) == b(i)) result +=\
    \ '0'\n            else result += '1'\n        }\n        result.toString\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toList.map(_.toInt - 48)\n \
    \       val bBits = b.toList.map(_.toInt - 48)\n        val cBits = aBits.zip(bBits).map(x\
    \ => x._1 ^ x._2)\n        cBits.map(_.toString).reduce(_ + _)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val sb = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append('0')\n     \
    \       else sb.append('1')\n        }\n        sb.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            result += (if (a(i) == b(i)) \"0\" else \"1\")\n  \
    \      }\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        xorBits.map(b => b.toString).mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val result = a_int ^ b_int\n \
    \       return Integer.toBinaryString(result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpumdgwq1v.scala:15)\n\tat Problem.main(tmpumdgwq1v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toList.map(_.toString.toInt)\n\
    \        val bBits = b.toList.map(_.toString.toInt)\n        val cBits = aBits.zip(bBits).map(x\
    \ => x._1 ^ x._2)\n        cBits.map(_.toString).mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result += '0'\n   \
    \         else result += '1'\n        }\n        result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(_.toString.toInt)\n    \
    \    val bBits = b.map(_.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(x\
    \ => x._1 ^ x._2)\n        xorBits.map(_.toString).reduceLeft(_ + _)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        if (a.length != b.length) throw new IllegalArgumentException(\"\
    Inputs must be of equal length\")\n        val sb = new StringBuilder\n      \
    \  for (i <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append('0')\n\
    \            else sb.append('1')\n        }\n        sb.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val n = a.length\n        val m = b.length\n\
    \        if (n != m) throw new IllegalArgumentException(\"Strings must be of equal\
    \ length\")\n        val sb = new StringBuilder\n        for (i <- 0 until n)\
    \ {\n            if (a(i) == b(i)) sb.append('0')\n            else sb.append('1')\n\
    \        }\n        sb.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val result = a_int ^ b_int\n \
    \       Integer.toBinaryString(result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_fpubyqo.scala:15)\n\tat Problem.main(tmp_fpubyqo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792976
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(i => i.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val sb = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append('0')\n     \
    \       else sb.append('1')\n        }\n        sb.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_bin = BigInt(a, 2)\n        val b_bin\
    \ = BigInt(b, 2)\n        val c_bin = a_bin ^ b_bin\n        c_bin.toString(2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp25us35ny.scala:15)\n\tat Problem.main(tmp25us35ny.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val c_int = a_int ^ b_int\n  \
    \      val c = Integer.toBinaryString(c_int)\n        return c\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmj7qp5x3.scala:16)\n\tat Problem.main(tmpmj7qp5x3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val xor_int = a_int ^ b_int\n\
    \        val xor_str = Integer.toBinaryString(xor_int)\n        return xor_str\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3g7wfjsp.scala:16)\n\tat Problem.main(tmp3g7wfjsp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => if (c == '1') 1 else\
    \ 0)\n        val bBits = b.map(c => if (c == '1') 1 else 0)\n        val xorBits\
    \ = aBits.zip(bBits).map(t => t._1 ^ t._2)\n        xorBits.map(b => if (b ==\
    \ 1) '1' else '0').mkString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = (aBits\
    \ zip bBits).map(t => t._1 ^ t._2)\n        xorBits.map(b => b.toString).reduceLeft(_\
    \ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toList.map(x => x.toString.toInt)\n\
    \        val bBits = b.toList.map(x => x.toString.toInt)\n        val xorBits\
    \ = (aBits zip bBits).map(x => x._1 ^ x._2)\n        xorBits.map(x => x.toString).reduceLeft(_\
    \ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val sb = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append('0')\n     \
    \       else sb.append('1')\n        }\n        sb.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(i => i.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(i => i.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toList.map(x => x.toString.toInt)\n\
    \        val bBits = b.toList.map(x => x.toString.toInt)\n        val cBits =\
    \ aBits.zip(bBits).map(x => x._1 ^ x._2)\n        cBits.map(x => x.toString).reduceLeft(_\
    \ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val c_int = a_int ^ b_int\n  \
    \      val c = Integer.toBinaryString(c_int)\n        return c\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmj7qp5x3.scala:16)\n\tat Problem.main(tmpmj7qp5x3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val result = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        result.map(i => i.toString).reduceLeft(_ + _)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val c = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            c.append((a(i) - '0') ^ (b(i) - '0'))\n\
    \        }\n        c.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val n = a.length\n        val m = b.length\n\
    \        if (n != m) throw new Exception(\"Inputs must be of equal length\")\n\
    \        val result = new StringBuilder\n        for (i <- 0 until n) {\n    \
    \        if (a(i) == b(i)) result.append(\"0\")\n            else result.append(\"\
    1\")\n        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toList.map(x => x.toString.toInt)\n\
    \        val bBits = b.toList.map(x => x.toString.toInt)\n        val xorBits\
    \ = aBits.zip(bBits).map(x => x._1 ^ x._2)\n        xorBits.map(x => x.toString).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792985
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        if (a.length != b.length) {\n            throw\
    \ new IllegalArgumentException(\"Strings must be of equal length\")\n        }\n\
    \        val aList = a.toList\n        val bList = b.toList\n        val result\
    \ = aList.zip(bList).map(x => (x._1, x._2)).map(x => if (x._1 == x._2) '0' else\
    \ '1').mkString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_array = a.toCharArray\n        val b_array\
    \ = b.toCharArray\n        val result = new Array[Char](a_array.length)\n    \
    \    for (i <- 0 until a_array.length) {\n            if (a_array(i) == b_array(i))\
    \ result(i) = '0'\n            else result(i) = '1'\n        }\n        result.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val sb = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append('0')\n     \
    \       else sb.append('1')\n        }\n        sb.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val c_int = a_int ^ b_int\n  \
    \      val c = Integer.toBinaryString(c_int)\n        return c\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmj7qp5x3.scala:16)\n\tat Problem.main(tmpmj7qp5x3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_array = a.toCharArray\n        val b_array\
    \ = b.toCharArray\n        val result = new StringBuilder\n        for (i <- 0\
    \ until a_array.length) {\n            if (a_array(i) == b_array(i)) result.append(\"\
    0\")\n            else result.append(\"1\")\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val c_int = a_int ^ b_int\n  \
    \      Integer.toBinaryString(c_int)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmejxpxam.scala:15)\n\tat Problem.main(tmpmejxpxam.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(_.toString.toInt)\n    \
    \    val bBits = b.map(_.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(x\
    \ => x._1 ^ x._2)\n        xorBits.map(_.toString).reduceLeft(_ + _)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toList.map(c => c.toString.toInt)\n\
    \        val bBits = b.toList.map(c => c.toString.toInt)\n        val cBits =\
    \ aBits.zip(bBits).map(x => x._1 ^ x._2)\n        cBits.map(x => x.toString).reduceLeft(_\
    \ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_bin = Integer.parseInt(a, 2)\n     \
    \   val b_bin = Integer.parseInt(b, 2)\n        val result = a_bin ^ b_bin\n \
    \       return Integer.toBinaryString(result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9fxdu94t.scala:15)\n\tat Problem.main(tmp9fxdu94t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toList.map(c => c.toString.toInt)\n\
    \        val bBits = b.toList.map(c => c.toString.toInt)\n        val result =\
    \ aBits.zip(bBits).map(x => x._1 ^ x._2)\n        result.map(x => x.toString).reduceLeft(_\
    \ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBinary = a.toInt(2)\n        val bBinary\
    \ = b.toInt(2)\n        val result = aBinary ^ bBinary\n        result.toBinaryString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpybwp2hxj.scala:9:24 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBinary\e[0m = a.toInt(\e\
    [31m2\e[0m)\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m  |\e\
    [0m                  \e[33mmethod\e[0m \e[35mtoInt\e[0m in \e[33mclass\e[0m \e\
    [35mStringOps\e[0m does not take parameters\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E050]\
    \ Type Error: /tmp/tmpybwp2hxj.scala:10:24 -----------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBinary\e[0m = b.toInt(\e[31m2\e\
    [0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                \e[33mmethod\e[0m \e[35mtoInt\e[0m in \e[33mclass\e[0m \e[35mStringOps\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val sb = new StringBuilder\n        for (i\
    \ <- 0 until a.length) {\n            sb.append((a(i) - '0') ^ (b(i) - '0'))\n\
    \        }\n        sb.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val cBits = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        cBits.map(c => c.toString).reduceLeft(_ + _)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792985
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val a_int = Integer.parseInt(a, 2)\n     \
    \   val b_int = Integer.parseInt(b, 2)\n        val result = a_int ^ b_int\n \
    \       return Integer.toBinaryString(result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpumdgwq1v.scala:15)\n\tat Problem.main(tmpumdgwq1v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBinary = a.toInt(2)\n        val bBinary\
    \ = b.toInt(2)\n        val xor = aBinary ^ bBinary\n        xor.toBinaryString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpx_ov3c5q.scala:9:24 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBinary\e[0m = a.toInt(\e\
    [31m2\e[0m)\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m  |\e\
    [0m                  \e[33mmethod\e[0m \e[35mtoInt\e[0m in \e[33mclass\e[0m \e\
    [35mStringOps\e[0m does not take parameters\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E050]\
    \ Type Error: /tmp/tmpx_ov3c5q.scala:10:24 -----------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBinary\e[0m = b.toInt(\e[31m2\e\
    [0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                \e[33mmethod\e[0m \e[35mtoInt\e[0m in \e[33mclass\e[0m \e[35mStringOps\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = new StringBuilder\n        for\
    \ (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val result = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        result.map(i => i.toString).reduceLeft(_ + _)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792983
