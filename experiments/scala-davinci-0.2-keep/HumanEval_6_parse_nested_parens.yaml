name: HumanEval_6_parse_nested_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n    // For each of the group, output the deepest\
  \ level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of\
  \ nesting while ((())) has three.\n    // >>> parse_nested_parens('(()()) ((()))\
  \ () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string :\
  \ String) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
  (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
  \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
  )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
completions: ["        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.filter(y => y == '(' || y == ')').map(y =>\
    \ if (y == '(') 1 else -1).scanLeft(0)(_ + _).max).toList\n        paren_levels",
  "        val groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- groups) {\n            var max_level = 0\n            var\
    \ level = 0\n            for (c <- group) {\n                if (c == '(') {\n\
    \                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]\n        for (group <- paren_groups) {\n            var\
    \ nesting_level = 0\n            var max_nesting_level = 0\n            for (c\
    \ <- group) {\n                if (c == '(') nesting_level += 1\n            \
    \    else if (c == ')') nesting_level -= 1\n                if (nesting_level\
    \ > max_nesting_level) max_nesting_level = nesting_level\n            }\n    \
    \        max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') depth += 1\n                else depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result = result :+ max_depth\n\
    \        }\n        result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]\n        for (group\
    \ <- paren_groups) {\n            var max_nesting_level = 0\n            var current_nesting_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') level +=\
    \ 1\n                else if (paren == ')') level -= 1\n                if (level\
    \ > max_level) max_level = level\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') level += 1\n                else\
    \ if (c == ')') level -= 1\n                if (level > max_level) max_level =\
    \ level\n            }\n            paren_levels += max_level\n        }\n   \
    \     paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]\n        for (paren_group\
    \ <- paren_groups) {\n            var max_nesting_level = 0\n            var current_nesting_level\
    \ = 0\n            for (paren <- paren_group) {\n                if (paren ==\
    \ '(') {\n                    current_nesting_level += 1\n                   \
    \ if (current_nesting_level > max_nesting_level) max_nesting_level = current_nesting_level\n\
    \                }\n                else if (paren == ')') {\n               \
    \     current_nesting_level -= 1\n                }\n            }\n         \
    \   max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_nesting\
    \ = 0\n            var current_nesting = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    current_nesting += 1\n  \
    \                  max_nesting = max(max_nesting, current_nesting)\n         \
    \       } else if (c == ')') {\n                    current_nesting -= 1\n   \
    \             }\n            }\n            result += max_nesting\n        }\n\
    \        result.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val paren_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result += max_depth\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x =>\
    \ x.count(y => y == '(') - x.count(y => y == ')'))\n        val max_level = paren_levels.max\n\
    \        val min_level = paren_levels.min\n        val paren_levels_mapped = paren_levels.map(x\
    \ => x - min_level)\n        paren_levels_mapped.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n   \
    \     for (group <- paren_groups) {\n            var level = 0\n            var\
    \ max_level = 0\n            for (c <- group) {\n                if (c == '(')\
    \ level += 1\n                else if (c == ')') level -= 1\n                max_level\
    \ = max(max_level, level)\n            }\n            result += max_level\n  \
    \      }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_counts = paren_groups.map(x => {\n            var count\
    \ = 0\n            var max_count = 0\n            for (i <- 0 until x.length)\
    \ {\n                if (x(i) == '(') count += 1\n                else if (x(i)\
    \ == ')') count -= 1\n                max_count = max(max_count, count)\n    \
    \        }\n            max_count\n        })\n        paren_counts.toList", " \
    \       val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 max_level = max(max_level, level)\n                } else if\
    \ (paren == ')') {\n                    level -= 1\n                }\n      \
    \      }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]\n        for (group <- paren_groups) {\n            val\
    \ stack = new Stack[Char]\n            var max_level = 0\n            var current_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    current_level += 1\n                    max_level = max(max_level,\
    \ current_level)\n                    stack.push(paren)\n                } else\
    \ if (paren == ')') {\n                    current_level -= 1\n              \
    \      if (stack.isEmpty) {\n                        println(\"Invalid paren string\"\
    )\n                        return List()\n                    }\n            \
    \        stack.pop\n                }\n            }\n            if (!stack.isEmpty)\
    \ {\n                println(\"Invalid paren string\")\n                return\
    \ List()\n            }\n            max_nesting_levels += max_level\n       \
    \ }\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') depth += 1\n         \
    \       else depth -= 1\n                max_depth = max(max_depth, depth)\n \
    \           }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result += max_depth\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n   \
    \     for (i <- 0 until paren_groups.length) {\n            var max_depth = 0\n\
    \            var depth = 0\n            for (j <- 0 until paren_groups(i).length)\
    \ {\n                if (paren_groups(i)(j) == '(') depth += 1\n             \
    \   else depth -= 1\n                max_depth = max(max_depth, depth)\n     \
    \       }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 max_level = max(max_level, level)\n                } else if\
    \ (paren == ')') {\n                    level -= 1\n                }\n      \
    \      }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') depth += 1\n                else if (paren == ')') depth -= 1\n    \
    \            max_depth = max(max_depth, depth)\n            }\n            result\
    \ = result :+ max_depth\n        }\n        result", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n   \
    \     for (group <- paren_groups) {\n            var count = 0\n            var\
    \ max = 0\n            for (ch <- group) {\n                if (ch == '(') count\
    \ += 1\n                else count -= 1\n                max = max max count\n\
    \            }\n            result += max\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (paren_group <- paren_groups) {\n            var max_depth = 0\n\
    \            var depth = 0\n            for (c <- paren_group) {\n           \
    \     if (c == '(') depth += 1\n                else depth -= 1\n            \
    \    max_depth = max(max_depth, depth)\n            }\n            result += max_depth\n\
    \        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_depth += 1\n                    max_depth = max(max_depth, current_depth)\n\
    \                } else if (c == ')') {\n                    current_depth -=\
    \ 1\n                }\n            }\n            result += max_depth\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') {\n   \
    \                 level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (paren == ')') {\n                    level -= 1\n\
    \                }\n            }\n            paren_levels += max_level\n   \
    \     }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') level += 1\n                else\
    \ if (c == ')') level -= 1\n                if (level > max_level) max_level =\
    \ level\n            }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 max_level = max(max_level, level)\n                } else if\
    \ (paren == ')') {\n                    level -= 1\n                }\n      \
    \      }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val max_level = paren_levels.max\n        val min_level = paren_levels.min\n\
    \        val paren_levels_final = paren_levels.map(x => max_level - x + 1)\n \
    \       return paren_levels_final.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (c <- group) {\n                if (c == '(') {\n           \
    \         level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (c == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            paren_levels += max_level\n       \
    \ }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val levels = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') level += 1\n                else\
    \ if (c == ')') level -= 1\n                max_level = max(max_level, level)\n\
    \            }\n            levels += max_level\n        }\n        levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var current_level = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') {\n                    current_level += 1\n\
    \                    max_level = max(max_level, current_level)\n             \
    \   } else if (paren == ')') {\n                    current_level -= 1\n     \
    \           }\n            }\n            result += max_level\n        }\n   \
    \     result.toList", "        var result = List[Long]()\n        for (paren_group\
    \ <- paren_string.split(\" \")) {\n            var max_level = 0\n           \
    \ var level = 0\n            for (ch <- paren_group) {\n                if (ch\
    \ == '(') level += 1\n                else if (ch == ')') level -= 1\n       \
    \         max_level = max(max_level, level)\n            }\n            result\
    \ = result :+ max_level\n        }\n        return result", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n     \
    \   for (i <- 0 until paren_groups.length) {\n            var count = 0\n    \
    \        var max_count = 0\n            for (j <- 0 until paren_groups(i).length)\
    \ {\n                if (paren_groups(i)(j) == '(') count += 1\n             \
    \   else if (paren_groups(i)(j) == ')') count -= 1\n                if (count\
    \ > max_count) max_count = count\n            }\n            result += max_count\n\
    \        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var max_nesting\
    \ = 0\n            var current_nesting = 0\n            for (ch <- group) {\n\
    \                if (ch == '(') {\n                    current_nesting += 1\n\
    \                    max_nesting = max(max_nesting, current_nesting)\n       \
    \         } else if (ch == ')') {\n                    current_nesting -= 1\n\
    \                }\n            }\n            result += max_nesting\n       \
    \ }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]\n        for (group\
    \ <- paren_groups) {\n            var max_nesting_level = 0\n            var current_nesting_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    current_nesting_level += 1\n                    max_nesting_level\
    \ = max(max_nesting_level, current_nesting_level)\n                } else if (paren\
    \ == ')') {\n                    current_nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_levels += max_nesting_level\n        }\n\
    \        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var count = 0\n            var max = 0\n            for (c <-\
    \ group) {\n                if (c == '(') count += 1\n                else if\
    \ (c == ')') count -= 1\n                max = max.max(count)\n            }\n\
    \            result += max\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n     \
    \   for (group <- paren_groups) {\n            var max_depth = 0\n           \
    \ var depth = 0\n            for (c <- group) {\n                if (c == '(')\
    \ depth += 1\n                else if (c == ')') depth -= 1\n                if\
    \ (depth > max_depth) max_depth = depth\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]\n        for (group <- paren_groups) {\n            var\
    \ max_nesting_level = 0\n            var current_nesting_level = 0\n         \
    \   for (paren <- group) {\n                if (paren == '(') {\n            \
    \        current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) {\n                        max_nesting_level = current_nesting_level\n\
    \                    }\n                } else if (paren == ')') {\n         \
    \           current_nesting_level -= 1\n                }\n            }\n   \
    \         max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n    \
    \        var level = 0\n            var max_level = 0\n            for (paren\
    \ <- paren_group) {\n                if (paren == '(') {\n                   \
    \ level += 1\n                    max_level = max(max_level, level)\n        \
    \        } else if (paren == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var count = 0\n            var max = 0\n            for (c <-\
    \ group) {\n                if (c == '(') count += 1\n                else if\
    \ (c == ')') count -= 1\n                if (count > max) max = count\n      \
    \      }\n            result += max\n        }\n        result.toList", "    \
    \    val groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- groups) {\n            var max_level = 0\n            var\
    \ level = 0\n            for (c <- group) {\n                if (c == '(') {\n\
    \                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result = result :+ max_level\n\
    \        }\n        result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n\
    \        for (group <- groups) {\n            var max_depth = 0\n            var\
    \ depth = 0\n            for (c <- group) {\n                if (c == '(') depth\
    \ += 1\n                else if (c == ')') depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result += max_depth\n  \
    \      }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (c <- group) {\n                if (c == '(') {\n           \
    \         level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (c == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            paren_levels += max_level\n       \
    \ }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') level +=\
    \ 1\n                else if (paren == ')') level -= 1\n                if (level\
    \ > max_level) max_level = level\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (i <- 0 until paren_groups.length)\
    \ {\n            val paren_group = paren_groups(i)\n            var max_level\
    \ = 0\n            var level = 0\n            for (j <- 0 until paren_group.length)\
    \ {\n                if (paren_group(j) == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else {\n                    level -= 1\n                }\n            }\n \
    \           result += max_level\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_group_levels = new\
    \ ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- paren_group)\
    \ {\n                if (paren == '(') level += 1\n                else if (paren\
    \ == ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            paren_group_levels += max_level\n        }\n     \
    \   paren_group_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            result += max_depth\n        }\n        result.toList", "       \
    \ val paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var current_depth = 0\n            for (paren <- group) {\n           \
    \     if (paren == '(') {\n                    current_depth += 1\n          \
    \          max_depth = max(max_depth, current_depth)\n                } else if\
    \ (paren == ')') {\n                    current_depth -= 1\n                }\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_levels_abs = paren_levels.map(x => abs(x))\n        paren_levels_abs.toList",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else if (c == ')') depth -= 1\n           \
    \     max_depth = max(max_depth, depth)\n            }\n            result = result\
    \ :+ max_depth\n        }\n        result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = paren_groups.map(x => {\n            var\
    \ max_nesting_level = 0\n            var current_nesting_level = 0\n         \
    \   for (i <- 0 until x.length) {\n                if (x(i) == '(') {\n      \
    \              current_nesting_level += 1\n                    max_nesting_level\
    \ = max(max_nesting_level, current_nesting_level)\n                } else {\n\
    \                    current_nesting_level -= 1\n                }\n         \
    \   }\n            max_nesting_level\n        })\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') level += 1\n                else if (paren\
    \ == ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') level += 1\n                else if (paren\
    \ == ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else depth -= 1\n            \
    \    max_depth = max(max_depth, depth)\n            }\n            result += max_depth\n\
    \        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') level +=\
    \ 1\n                else if (paren == ')') level -= 1\n                if (level\
    \ > max_level) max_level = level\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') level +=\
    \ 1\n                else if (paren == ')') level -= 1\n                max_level\
    \ = max(max_level, level)\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (i <- 0\
    \ until paren_groups.length) {\n            val paren_group = paren_groups(i)\n\
    \            var level = 0\n            var max_level = 0\n            for (j\
    \ <- 0 until paren_group.length) {\n                val paren = paren_group(j)\n\
    \                if (paren == '(') level += 1\n                else if (paren\
    \ == ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        paren_groups.map(group\
    \ => {\n            val stack = new Stack[Char]\n            var max_depth = 0\n\
    \            var depth = 0\n            for (c <- group) {\n                if\
    \ (c == '(') {\n                    depth += 1\n                    max_depth\
    \ = max(max_depth, depth)\n                } else if (c == ')') {\n          \
    \          depth -= 1\n                }\n            }\n            max_depth\n\
    \        }).toList", "        var result = List[Long]()\n        var current_level\
    \ = 0\n        var max_level = 0\n        for (c <- paren_string) {\n        \
    \    if (c == '(') {\n                current_level += 1\n                max_level\
    \ = max(max_level, current_level)\n            } else if (c == ')') {\n      \
    \          current_level -= 1\n            } else if (c == ' ') {\n          \
    \      result = result :+ max_level\n                max_level = 0\n         \
    \       current_level = 0\n            }\n        }\n        result = result :+\
    \ max_level\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            result += max_depth\n        }\n        result.toList", "       \
    \ val paren_groups = paren_string.split(\" \")\n        val paren_groups_list\
    \ = paren_groups.toList\n        paren_groups_list.map(x => parseNestedParensHelper(x))",
  "        val groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n\
    \        for (group <- groups) {\n            var max_level = 0\n            var\
    \ level = 0\n            for (c <- group) {\n                if (c == '(') level\
    \ += 1\n                else if (c == ')') level -= 1\n                max_level\
    \ = max(max_level, level)\n            }\n            result += max_level\n  \
    \      }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (ch <- group) {\n                if (ch == '(') {\n               \
    \     current_depth += 1\n                    max_depth = max(max_depth, current_depth)\n\
    \                } else if (ch == ')') {\n                    current_depth -=\
    \ 1\n                }\n            }\n            result += max_depth\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        paren_groups.map(x => {\n            var max_depth = 0\n      \
    \      var current_depth = 0\n            for (c <- x) {\n                if (c\
    \ == '(') {\n                    current_depth += 1\n                    max_depth\
    \ = max(max_depth, current_depth)\n                } else if (c == ')') {\n  \
    \                  current_depth -= 1\n                }\n            }\n    \
    \        max_depth\n        }).toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (i <- 0 until paren_groups.length)\
    \ {\n            val paren_group = paren_groups(i)\n            var max_nesting\
    \ = 0\n            var current_nesting = 0\n            for (j <- 0 until paren_group.length)\
    \ {\n                if (paren_group(j) == '(') {\n                    current_nesting\
    \ += 1\n                    max_nesting = max(max_nesting, current_nesting)\n\
    \                }\n                else {\n                    current_nesting\
    \ -= 1\n                }\n            }\n            result += max_nesting\n\
    \        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_level = 0\n      \
    \      var level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => parseNestedParens(x, 0))\n\
    \        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]\n        for (group\
    \ <- paren_groups) {\n            var nesting_level = 0\n            var max_nesting_level\
    \ = 0\n            for (i <- 0 until group.length) {\n                if (group(i)\
    \ == '(') nesting_level += 1\n                else if (group(i) == ')') nesting_level\
    \ -= 1\n                if (nesting_level > max_nesting_level) max_nesting_level\
    \ = nesting_level\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result = max_depth :: result\n        }\n\
    \        result.reverse", "        val paren_groups = paren_string.split(\" \"\
    )\n        val paren_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (char <- group) {\n                if (char == '(') level += 1\n           \
    \     else if (char == ')') level -= 1\n                if (level > max_level)\
    \ max_level = level\n            }\n            paren_levels += max_level\n  \
    \      }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]\n        for (paren_group\
    \ <- paren_groups) {\n            var max_level = 0\n            var current_level\
    \ = 0\n            for (paren <- paren_group) {\n                if (paren ==\
    \ '(') {\n                    current_level += 1\n                    max_level\
    \ = max(max_level, current_level)\n                } else if (paren == ')') {\n\
    \                    current_level -= 1\n                }\n            }\n  \
    \          max_nesting_levels += max_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var current_depth = 0\n            for (c <- group) {\n   \
    \             if (c == '(') {\n                    current_depth += 1\n      \
    \              max_depth = max(max_depth, current_depth)\n                } else\
    \ if (c == ')') {\n                    current_depth -= 1\n                }\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_level = 0\n      \
    \      var level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val depths = new ListBuffer[Long]\n        for (paren_group <-\
    \ paren_groups) {\n            var depth = 0\n            var max_depth = 0\n\
    \            for (paren <- paren_group) {\n                if (paren == '(') depth\
    \ += 1\n                else if (paren == ')') depth -= 1\n                if\
    \ (depth > max_depth) max_depth = depth\n            }\n            depths +=\
    \ max_depth\n        }\n        depths.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (ch <- group) {\n                if (ch == '(') depth += 1\n               \
    \ else if (ch == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n    \
    \        var level = 0\n            var max_level = 0\n            for (paren\
    \ <- paren_group) {\n                if (paren == '(') level += 1\n          \
    \      else if (paren == ')') level -= 1\n                if (level > max_level)\
    \ max_level = level\n            }\n            paren_levels += max_level\n  \
    \      }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        paren_groups.map(x => x.count(y => y == '(') - x.count(y => y ==\
    \ ')')).toList", "        // Split the input string into groups of parentheses.\n\
    \        val paren_groups = paren_string.split(\" \")\n        // For each group,\
    \ find the deepest level of nesting.\n        paren_groups.map(group => {\n  \
    \          var max_depth = 0\n            var current_depth = 0\n            for\
    \ (i <- 0 until group.length) {\n                if (group(i) == '(') {\n    \
    \                current_depth += 1\n                    max_depth = max(max_depth,\
    \ current_depth)\n                } else {\n                    current_depth\
    \ -= 1\n                }\n            }\n            max_depth\n        }).toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result += max_depth\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n   \
    \     for (group <- paren_groups) {\n            var max_depth = 0\n         \
    \   var current_depth = 0\n            for (paren <- group) {\n              \
    \  if (paren == '(') {\n                    current_depth += 1\n             \
    \       max_depth = max(max_depth, current_depth)\n                } else if (paren\
    \ == ')') {\n                    current_depth -= 1\n                }\n     \
    \       }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_levels_abs = paren_levels.map(x => abs(x))\n        val max_level\
    \ = paren_levels_abs.max\n        val paren_levels_abs_max = paren_levels_abs.map(x\
    \ => max_level - x)\n        paren_levels_abs_max.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val max_nesting_levels = new ListBuffer[Long]\n\
    \        for (group <- paren_groups) {\n            var max_level = 0\n      \
    \      var current_level = 0\n            for (paren <- group) {\n           \
    \     if (paren == '(') {\n                    current_level += 1\n          \
    \          max_level = max(max_level, current_level)\n                } else if\
    \ (paren == ')') {\n                    current_level -= 1\n                }\n\
    \            }\n            max_nesting_levels += max_level\n        }\n     \
    \   max_nesting_levels.toList", "        var result = List[Long]()\n        var\
    \ stack = Stack[Char]()\n        var max_depth = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                stack.push(c)\n            \
    \    max_depth = max(max_depth, stack.size)\n            } else if (c == ')')\
    \ {\n                stack.pop\n            } else if (c == ' ') {\n         \
    \       result = result :+ max_depth\n                max_depth = 0\n        \
    \    }\n        }\n        result = result :+ max_depth\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_level = 0\n      \
    \      var level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (i <- 0 until paren_groups.length)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (j <- 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j)\
    \ == '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (paren_groups(i)(j) == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') level +=\
    \ 1\n                else if (paren == ')') level -= 1\n                if (level\
    \ > max_level) max_level = level\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]\n        for (group\
    \ <- paren_groups) {\n            var nesting_level = 0\n            var max_nesting_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') nesting_level\
    \ += 1\n                else if (c == ')') nesting_level -= 1\n              \
    \  if (nesting_level > max_nesting_level) max_nesting_level = nesting_level\n\
    \            }\n            max_nesting_levels += max_nesting_level\n        }\n\
    \        max_nesting_levels.toList", "        var result = List[Long]()\n    \
    \    var max_depth = 0\n        var current_depth = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                current_depth += 1\n       \
    \         max_depth = max(max_depth, current_depth)\n            } else if (c\
    \ == ')') {\n                current_depth -= 1\n            } else if (c == '\
    \ ') {\n                result = result :+ max_depth\n                max_depth\
    \ = 0\n                current_depth = 0\n            }\n        }\n        result\
    \ = result :+ max_depth\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (paren <- group) {\n       \
    \         if (paren == '(') depth += 1\n                else if (paren == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result += max_depth\n        }\n        result.toList",
  "        val groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- groups) {\n            var max_depth = 0\n            var\
    \ depth = 0\n            for (c <- group) {\n                if (c == '(') depth\
    \ += 1\n                else depth -= 1\n                max_depth = max(max_depth,\
    \ depth)\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val depths = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var depth\
    \ = 0\n            var max_depth = 0\n            for (c <- group) {\n       \
    \         if (c == '(') depth += 1\n                else if (c == ')') depth -=\
    \ 1\n                max_depth = max(max_depth, depth)\n            }\n      \
    \      depths += max_depth\n        }\n        depths.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') level += 1\n                else if (paren == ')') level -= 1\n    \
    \            if (level > max_level) max_level = level\n            }\n       \
    \     paren_levels += max_level\n        }\n        paren_levels.toList", "  \
    \      val paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (i <- 0 until group.length) {\n        \
    \        if (group(i) == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (group(i)\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList", "       \
    \ val paren_groups = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(group\
    \ => {\n            var level = 0\n            var max_level = 0\n           \
    \ for (c <- group) {\n                if (c == '(') level += 1\n             \
    \   else level -= 1\n                max_level = max(max_level, level)\n     \
    \       }\n            max_level\n        })\n        paren_levels.toList", " \
    \       val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n\
    \            var paren_level = 0\n            var max_paren_level = 0\n      \
    \      for (j <- 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j)\
    \ == '(') paren_level += 1\n                else if (paren_groups(i)(j) == ')')\
    \ paren_level -= 1\n                max_paren_level = max(max_paren_level, paren_level)\n\
    \            }\n            paren_levels += max_paren_level\n        }\n     \
    \   paren_levels.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        var max_depth = 0\n        var depth = 0\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            for (c <- group) {\n     \
    \           if (c == '(') depth += 1\n                else depth -= 1\n      \
    \          max_depth = max(max_depth, depth)\n            }\n            result\
    \ = max_depth :: result\n            max_depth = 0\n            depth = 0\n  \
    \      }\n        result.reverse", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (i <- 0 until group.length) {\n                if (group(i) == '(')\
    \ current_depth += 1\n                else if (group(i) == ')') current_depth\
    \ -= 1\n                max_depth = max(max_depth, current_depth)\n          \
    \  }\n            result += max_depth\n        }\n        result.toList", "  \
    \      val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]\n        for (group <- paren_groups) {\n            var\
    \ max_nesting_level = 0\n            var current_nesting_level = 0\n         \
    \   for (ch <- group) {\n                if (ch == '(') {\n                  \
    \  current_nesting_level += 1\n                    max_nesting_level = max(max_nesting_level,\
    \ current_nesting_level)\n                } else if (ch == ')') {\n          \
    \          current_nesting_level -= 1\n                }\n            }\n    \
    \        max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_level = 0\n      \
    \      var current_level = 0\n            for (paren <- group) {\n           \
    \     if (paren == '(') {\n                    current_level += 1\n          \
    \          max_level = max(max_level, current_level)\n                } else if\
    \ (paren == ')') {\n                    current_level -= 1\n                }\n\
    \            }\n            result = result :+ max_level\n        }\n        result",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result += max_depth\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') level += 1\n                else if (paren == ')') level -= 1\n    \
    \            if (level > max_level) max_level = level\n            }\n       \
    \     paren_levels += max_level\n        }\n        paren_levels.toList", "  \
    \      val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_nesting\
    \ = 0\n            var current_nesting = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    current_nesting += 1\n  \
    \                  max_nesting = max(max_nesting, current_nesting)\n         \
    \       } else if (c == ')') {\n                    current_nesting -= 1\n   \
    \             }\n            }\n            result += max_nesting\n        }\n\
    \        result.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_depth += 1\n                    max_depth = max(max_depth, current_depth)\n\
    \                } else if (c == ')') {\n                    current_depth -=\
    \ 1\n                }\n            }\n            result += max_depth\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        paren_groups.map(x => parseNestedParensHelper(x, 0, 0)).toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_levels =\
    \ new ListBuffer[Long]\n        for (group <- paren_groups) {\n            var\
    \ level = 0\n            var max_level = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') level += 1\n                else if (paren\
    \ == ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            max_levels += max_level\n        }\n        max_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        var max_levels =\
    \ List[Long]()\n        for (group <- paren_groups) {\n            var level =\
    \ 0\n            var max_level = 0\n            for (paren <- group) {\n     \
    \           if (paren == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (paren ==\
    \ ')') {\n                    level -= 1\n                }\n            }\n \
    \           max_levels = max_levels :+ max_level\n        }\n        max_levels",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var cur_level = 0\n            var max_level = 0\n            for (paren <-\
    \ group) {\n                if (paren == '(') cur_level += 1\n               \
    \ else if (paren == ')') cur_level -= 1\n                max_level = max(max_level,\
    \ cur_level)\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (i <- 0 until\
    \ paren_groups.length) {\n            val paren_group = paren_groups(i)\n    \
    \        var max_depth = 0\n            var depth = 0\n            for (j <- 0\
    \ until paren_group.length) {\n                if (paren_group(j) == '(') depth\
    \ += 1\n                else if (paren_group(j) == ')') depth -= 1\n         \
    \       max_depth = max(max_depth, depth)\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_depth += 1\n                    max_depth = max(max_depth, current_depth)\n\
    \                } else if (c == ')') {\n                    current_depth -=\
    \ 1\n                }\n            }\n            result += max_depth\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') level += 1\n         \
    \       else if (paren == ')') level -= 1\n                max_level = max(max_level,\
    \ level)\n            }\n            paren_levels += max_level\n        }\n  \
    \      paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]\n        for (group\
    \ <- paren_groups) {\n            var max_nesting_level = 0\n            var current_nesting_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList", "        val groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nestings\
    \ = new ListBuffer[Long]\n        for (group <- paren_groups) {\n            var\
    \ max_nesting = 0\n            var current_nesting = 0\n            for (paren\
    \ <- group) {\n                if (paren == '(') {\n                    current_nesting\
    \ += 1\n                    max_nesting = max(max_nesting, current_nesting)\n\
    \                } else if (paren == ')') {\n                    current_nesting\
    \ -= 1\n                }\n            }\n            max_nestings += max_nesting\n\
    \        }\n        max_nestings.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]\n        for (group\
    \ <- paren_groups) {\n            var nesting_level = 0\n            var max_nesting_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    nesting_level += 1\n                    if (nesting_level\
    \ > max_nesting_level) max_nesting_level = nesting_level\n                }\n\
    \                else if (paren == ')') {\n                    nesting_level -=\
    \ 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') {\n   \
    \                 level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (paren == ')') {\n                    level -= 1\n\
    \                }\n            }\n            paren_levels += max_level\n   \
    \     }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') {\n   \
    \                 level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (paren == ')') {\n                    level -= 1\n\
    \                }\n            }\n            paren_levels += max_level\n   \
    \     }\n        paren_levels.toList", "        val parens = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (paren <- parens) {\n  \
    \          var max_level = 0\n            var level = 0\n            for (c <-\
    \ paren) {\n                if (c == '(') {\n                    level += 1\n\
    \                    max_level = max(max_level, level)\n                } else\
    \ {\n                    level -= 1\n                }\n            }\n      \
    \      result = result :+ max_level\n        }\n        result", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_level = 0\n      \
    \      var level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (paren_group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (paren <- paren_group) {\n                if (paren == '(') {\n            \
    \        depth += 1\n                    max_depth = max(max_depth, depth)\n \
    \               } else if (paren == ')') {\n                    depth -= 1\n \
    \               }\n            }\n            result += max_depth\n        }\n\
    \        result.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val max_nesting_levels = new ListBuffer[Long]\n        for (paren_group\
    \ <- paren_groups) {\n            var max_level = 0\n            var current_level\
    \ = 0\n            for (paren <- paren_group) {\n                if (paren ==\
    \ '(') {\n                    current_level += 1\n                    max_level\
    \ = max(max_level, current_level)\n                } else if (paren == ')') {\n\
    \                    current_level -= 1\n                }\n            }\n  \
    \          max_nesting_levels += max_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n\
    \        for (group <- groups) {\n            var max_level = 0\n            var\
    \ level = 0\n            for (c <- group) {\n                if (c == '(') level\
    \ += 1\n                else if (c == ')') level -= 1\n                max_level\
    \ = max(max_level, level)\n            }\n            result += max_level\n  \
    \      }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') level += 1\n                else\
    \ if (c == ')') level -= 1\n                if (level > max_level) max_level =\
    \ level\n            }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else if (c == ')') depth -= 1\n           \
    \     max_depth = max(max_depth, depth)\n            }\n            result = result\
    \ :+ max_depth\n        }\n        result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (paren_group\
    \ <- paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- paren_group) {\n                if (paren == '(') {\n\
    \                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (paren == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val parens = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (paren <- parens)\
    \ {\n            var max_nesting = 0\n            var current_nesting = 0\n  \
    \          for (c <- paren) {\n                if (c == '(') {\n             \
    \       current_nesting += 1\n                    max_nesting = max(max_nesting,\
    \ current_nesting)\n                } else if (c == ')') {\n                 \
    \   current_nesting -= 1\n                }\n            }\n            result\
    \ += max_nesting\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n   \
    \     for (group <- paren_groups) {\n            var max_level = 0\n         \
    \   var level = 0\n            for (c <- group) {\n                if (c == '(')\
    \ {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    depth +=\
    \ 1\n                    max_depth = max(max_depth, depth)\n                }\
    \ else if (c == ')') {\n                    depth -= 1\n                }\n  \
    \          }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]\n        for (group <- paren_groups) {\n            var\
    \ max_nesting_level = 0\n            var nesting_level = 0\n            for (paren\
    \ <- group) {\n                if (paren == '(') nesting_level += 1\n        \
    \        else if (paren == ')') nesting_level -= 1\n                if (nesting_level\
    \ > max_nesting_level) max_nesting_level = nesting_level\n            }\n    \
    \        max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n\
    \            val paren_group = paren_groups(i)\n            var level = 0\n  \
    \          var max_level = 0\n            for (j <- 0 until paren_group.length)\
    \ {\n                if (paren_group(j) == '(') level += 1\n                else\
    \ level -= 1\n                max_level = max(max_level, level)\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var depth\
    \ = 0\n            var max_depth = 0\n            for (i <- 0 until group.length)\
    \ {\n                if (group(i) == '(') depth += 1\n                else if\
    \ (group(i) == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        paren_groups.map(x\
    \ => parseNestedParens(x, 0, 0)).toList", "        var result = List[Long]()\n\
    \        var current_level = 0\n        var max_level = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                current_level += 1\n       \
    \         max_level = max(max_level, current_level)\n            } else if (c\
    \ == ')') {\n                current_level -= 1\n            } else if (c == '\
    \ ') {\n                result = result :+ max_level\n                max_level\
    \ = 0\n                current_level = 0\n            }\n        }\n        result\
    \ = result :+ max_level\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result += max_depth\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n   \
    \     for (group <- paren_groups) {\n            var max_depth = 0\n         \
    \   var depth = 0\n            for (c <- group) {\n                if (c == '(')\
    \ depth += 1\n                else if (c == ')') depth -= 1\n                if\
    \ (depth > max_depth) max_depth = depth\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                if (depth > max_depth) max_depth = depth\n            }\n   \
    \         result += max_depth\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (i <- 0 until group.length) {\n        \
    \        if (group(i) == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (group(i)\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList", "       \
    \ val paren_groups = paren_string.split(\" \")\n        val paren_levels = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var level\
    \ = 0\n            var max_level = 0\n            for (c <- group) {\n       \
    \         if (c == '(') {\n                    level += 1\n                  \
    \  max_level = max(max_level, level)\n                } else if (c == ')') {\n\
    \                    level -= 1\n                }\n            }\n          \
    \  paren_levels += max_level\n        }\n        paren_levels.toList", "     \
    \   val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var count = 0\n          \
    \  var max_count = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') count += 1\n                else if (c == ')') count -= 1\n           \
    \     if (count > max_count) max_count = count\n            }\n            result\
    \ = max_count :: result\n        }\n        result.reverse", "        val groups\
    \ = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n     \
    \   for (group <- groups) {\n            var max_depth = 0\n            var depth\
    \ = 0\n            for (c <- group) {\n                if (c == '(') depth +=\
    \ 1\n                else if (c == ')') depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result += max_depth\n  \
    \      }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') level += 1\n                else if (paren\
    \ == ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]\n        for (group <- paren_groups) {\n            var\
    \ max_nesting_level = 0\n            var current_nesting_level = 0\n         \
    \   for (paren <- group) {\n                if (paren == '(') {\n            \
    \        current_nesting_level += 1\n                    max_nesting_level = max(max_nesting_level,\
    \ current_nesting_level)\n                } else if (paren == ')') {\n       \
    \             current_nesting_level -= 1\n                }\n            }\n \
    \           max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (ch <- group)\
    \ {\n                if (ch == '(') {\n                    level += 1\n      \
    \              max_level = max(max_level, level)\n                } else if (ch\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    depth += 1\n                    max_depth\
    \ = max(max_depth, depth)\n                } else if (c == ')') {\n          \
    \          depth -= 1\n                }\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var depth = 0\n            var max_depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 max_level = max(max_level, level)\n                } else if\
    \ (paren == ')') {\n                    level -= 1\n                }\n      \
    \      }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var level\
    \ = 0\n            var max_level = 0\n            for (c <- group) {\n       \
    \         if (c == '(') level += 1\n                else if (c == ')') level -=\
    \ 1\n                if (level > max_level) max_level = level\n            }\n\
    \            result += max_level\n        }\n        result.toList", "       \
    \ var result = List[Long]()\n        var paren_stack = Stack[Char]()\n       \
    \ var max_depth = 0\n        var depth = 0\n        for (c <- paren_string) {\n\
    \            if (c == '(') {\n                paren_stack.push(c)\n          \
    \      depth += 1\n                max_depth = max(max_depth, depth)\n       \
    \     } else if (c == ')') {\n                if (paren_stack.isEmpty) throw new\
    \ Exception(\"Invalid parentheses string\")\n                paren_stack.pop\n\
    \                depth -= 1\n            } else if (c == ' ') {\n            \
    \    if (paren_stack.isEmpty) {\n                    result = result :+ max_depth\n\
    \                    max_depth = 0\n                    depth = 0\n          \
    \      }\n            } else {\n                throw new Exception(\"Invalid\
    \ parentheses string\")\n            }\n        }\n        if (!paren_stack.isEmpty)\
    \ throw new Exception(\"Invalid parentheses string\")\n        result = result\
    \ :+ max_depth\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result = result :+ max_level\n        }\n        result",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n    \
    \        var max_level = 0\n            var level = 0\n            for (paren\
    \ <- paren_group) {\n                if (paren == '(') {\n                   \
    \ level += 1\n                    max_level = max(max_level, level)\n        \
    \        } else if (paren == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList", "        var result = List[Long]()\n        for\
    \ (group <- paren_string.split(\" \")) {\n            var max_depth = 0\n    \
    \        var depth = 0\n            for (paren <- group) {\n                if\
    \ (paren == '(') depth += 1\n                else depth -= 1\n               \
    \ max_depth = max(max_depth, depth)\n            }\n            result = result\
    \ :+ max_depth\n        }\n        return result", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val max_nesting_levels = paren_groups.map(group\
    \ => {\n            var max_nesting_level = 0\n            var nesting_level =\
    \ 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    nesting_level += 1\n                    max_nesting_level\
    \ = max(max_nesting_level, nesting_level)\n                } else if (paren ==\
    \ ')') {\n                    nesting_level -= 1\n                }\n        \
    \    }\n            max_nesting_level\n        })\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') level += 1\n                else if (paren\
    \ == ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var level\
    \ = 0\n            var max_level = 0\n            for (paren <- group) {\n   \
    \             if (paren == '(') level += 1\n                else if (paren ==\
    \ ')') level -= 1\n                max_level = max(max_level, level)\n       \
    \     }\n            result += max_level\n        }\n        result.toList", " \
    \       val parens = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n\
    \        for (paren <- parens) {\n            var max_depth = 0\n            var\
    \ depth = 0\n            for (c <- paren) {\n                if (c == '(') depth\
    \ += 1\n                else depth -= 1\n                max_depth = max(max_depth,\
    \ depth)\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_levels =\
    \ new ListBuffer[Long]\n        for (group <- paren_groups) {\n            var\
    \ level = 0\n            var max_level = 0\n            for (c <- group) {\n \
    \               if (c == '(') level += 1\n                else if (c == ')') level\
    \ -= 1\n                if (level > max_level) max_level = level\n           \
    \ }\n            max_levels += max_level\n        }\n        max_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var level\
    \ = 0\n            var max_level = 0\n            for (paren <- group) {\n   \
    \             if (paren == '(') level += 1\n                else if (paren ==\
    \ ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ level = 0\n            var max_level = 0\n            for (c <- group) {\n \
    \               if (c == '(') level += 1\n                else if (c == ')') level\
    \ -= 1\n                max_level = max(max_level, level)\n            }\n   \
    \         paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result += max_depth\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n   \
    \     for (group <- paren_groups) {\n            var max_depth = 0\n         \
    \   var depth = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') depth += 1\n                else if (paren == ')') depth -= 1\n    \
    \            max_depth = max(max_depth, depth)\n            }\n            result\
    \ += max_depth\n        }\n        result.toList", "        var result = List[Long]()\n\
    \        var paren_stack = Stack[Char]()\n        var max_depth = 0\n        var\
    \ depth = 0\n        for (c <- paren_string) {\n            if (c == '(') {\n\
    \                paren_stack.push(c)\n                depth += 1\n           \
    \     max_depth = max(max_depth, depth)\n            } else if (c == ')') {\n\
    \                if (paren_stack.isEmpty) throw new Exception(\"Unbalanced parentheses\"\
    )\n                paren_stack.pop\n                depth -= 1\n            }\
    \ else if (c == ' ') {\n                if (paren_stack.isEmpty) {\n         \
    \           result = result :+ max_depth\n                    max_depth = 0\n\
    \                    depth = 0\n                }\n            }\n        }\n\
    \        if (!paren_stack.isEmpty) throw new Exception(\"Unbalanced parentheses\"\
    )\n        result = result :+ max_depth\n        return result", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else if (c == ')') depth -= 1\n           \
    \     max_depth = max(max_depth, depth)\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') level += 1\n         \
    \       else if (paren == ')') level -= 1\n                if (level > max_level)\
    \ max_level = level\n            }\n            paren_levels += max_level\n  \
    \      }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') level += 1\n                else\
    \ if (c == ')') level -= 1\n                max_level = max(max_level, level)\n\
    \            }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_counts\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var count = 0\n            var max_count = 0\n            for (c <- group)\
    \ {\n                if (c == '(') count += 1\n                else if (c == ')')\
    \ count -= 1\n                if (count > max_count) max_count = count\n     \
    \       }\n            paren_counts += max_count\n        }\n        paren_counts.toList",
  "        val parens = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n\
    \        for (paren <- parens) {\n            var max_depth = 0\n            var\
    \ current_depth = 0\n            for (c <- paren) {\n                if (c ==\
    \ '(') {\n                    current_depth += 1\n                    max_depth\
    \ = max(max_depth, current_depth)\n                } else if (c == ')') {\n  \
    \                  current_depth -= 1\n                }\n            }\n    \
    \        result += max_depth\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (i <- 0 until group.length) {\n        \
    \        if (group(i) == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (group(i)\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var depth = 0\n          \
    \  var max_depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else if (c == ')') depth -= 1\n           \
    \     if (depth > max_depth) max_depth = depth\n            }\n            result\
    \ = max_depth :: result\n        }\n        result.reverse", "        val paren_groups\
    \ = paren_string.split(\" \")\n        paren_groups.map(x => parseNestedParens(x,\
    \ 0, 0)).toList", "        val paren_groups = paren_string.split(\" \")\n    \
    \    var result = List[Long]()\n        for (group <- paren_groups) {\n      \
    \      var current_level = 0\n            var max_level = 0\n            for (c\
    \ <- group) {\n                if (c == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (c == ')') {\n                    current_level -= 1\n  \
    \              }\n            }\n            result = result :+ max_level\n  \
    \      }\n        result", "        val paren_groups = paren_string.split(\" \"\
    )\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n\
    \        for (group <- groups) {\n            var max_depth = 0\n            var\
    \ depth = 0\n            for (c <- group) {\n                if (c == '(') depth\
    \ += 1\n                else if (c == ')') depth -= 1\n                if (depth\
    \ > max_depth) max_depth = depth\n            }\n            result += max_depth\n\
    \        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        paren_groups.map(x => {\n            val stack = new Stack[Char]\n\
    \            var max_depth = 0\n            var depth = 0\n            for (i\
    \ <- 0 until x.length) {\n                if (x(i) == '(') {\n               \
    \     stack.push('(')\n                    depth += 1\n                    max_depth\
    \ = max(max_depth, depth)\n                } else if (x(i) == ')') {\n       \
    \             stack.pop\n                    depth -= 1\n                }\n \
    \           }\n            max_depth\n        }).toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        var result = List[Long]()\n        for\
    \ (group <- paren_groups) {\n            var max_depth = 0\n            var depth\
    \ = 0\n            for (c <- group) {\n                if (c == '(') depth +=\
    \ 1\n                else if (c == ')') depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result = result :+ max_depth\n\
    \        }\n        result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParens(x, 0))\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_levels =\
    \ new ListBuffer[Long]\n        for (group <- paren_groups) {\n            var\
    \ level = 0\n            var max_level = 0\n            for (c <- group) {\n \
    \               if (c == '(') level += 1\n                else if (c == ')') level\
    \ -= 1\n                if (level > max_level) max_level = level\n           \
    \ }\n            max_levels += max_level\n        }\n        max_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]\n        for (group <- paren_groups) {\n            var\
    \ max_nesting_level = 0\n            var current_nesting_level = 0\n         \
    \   for (paren <- group) {\n                if (paren == '(') {\n            \
    \        current_nesting_level += 1\n                    max_nesting_level = max(max_nesting_level,\
    \ current_nesting_level)\n                } else if (paren == ')') {\n       \
    \             current_nesting_level -= 1\n                }\n            }\n \
    \           max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        var paren_levels\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var level\
    \ = 0\n            var max_level = 0\n            for (paren <- group) {\n   \
    \             if (paren == '(') {\n                    level += 1\n          \
    \          max_level = max(max_level, level)\n                } else if (paren\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels = paren_levels :+ max_level\n        }\n        paren_levels",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]\n        for (paren_group <- paren_groups) {\n      \
    \      var max_nesting_level = 0\n            var current_nesting_level = 0\n\
    \            for (paren <- paren_group) {\n                if (paren == '(') {\n\
    \                    current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') {\n   \
    \                 level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (paren == ')') {\n                    level -= 1\n\
    \                }\n            }\n            paren_levels += max_level\n   \
    \     }\n        paren_levels.toList"]
stop_tokens:
- "\n    }\n"
