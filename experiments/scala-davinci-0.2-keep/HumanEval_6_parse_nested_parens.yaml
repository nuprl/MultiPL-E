name: HumanEval_6_parse_nested_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n    // For each of the group, output the deepest\
  \ level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of\
  \ nesting while ((())) has three.\n    // >>> parse_nested_parens('(()()) ((()))\
  \ () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string :\
  \ String) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
  (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
  \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
  )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
completions: ["        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.filter(y => y == '(' || y == ')').map(y =>\
    \ if (y == '(') 1 else -1).scanLeft(0)(_ + _).max).toList\n        paren_levels",
  "        val groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- groups) {\n            var max_level = 0\n            var\
    \ level = 0\n            for (c <- group) {\n                if (c == '(') {\n\
    \                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]\n        for (group <- paren_groups) {\n            var\
    \ nesting_level = 0\n            var max_nesting_level = 0\n            for (c\
    \ <- group) {\n                if (c == '(') nesting_level += 1\n            \
    \    else if (c == ')') nesting_level -= 1\n                if (nesting_level\
    \ > max_nesting_level) max_nesting_level = nesting_level\n            }\n    \
    \        max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') depth += 1\n                else depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result = result :+ max_depth\n\
    \        }\n        result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]\n        for (group\
    \ <- paren_groups) {\n            var max_nesting_level = 0\n            var current_nesting_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') level +=\
    \ 1\n                else if (paren == ')') level -= 1\n                if (level\
    \ > max_level) max_level = level\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') level += 1\n                else\
    \ if (c == ')') level -= 1\n                if (level > max_level) max_level =\
    \ level\n            }\n            paren_levels += max_level\n        }\n   \
    \     paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]\n        for (paren_group\
    \ <- paren_groups) {\n            var max_nesting_level = 0\n            var current_nesting_level\
    \ = 0\n            for (paren <- paren_group) {\n                if (paren ==\
    \ '(') {\n                    current_nesting_level += 1\n                   \
    \ if (current_nesting_level > max_nesting_level) max_nesting_level = current_nesting_level\n\
    \                }\n                else if (paren == ')') {\n               \
    \     current_nesting_level -= 1\n                }\n            }\n         \
    \   max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_nesting\
    \ = 0\n            var current_nesting = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    current_nesting += 1\n  \
    \                  max_nesting = max(max_nesting, current_nesting)\n         \
    \       } else if (c == ')') {\n                    current_nesting -= 1\n   \
    \             }\n            }\n            result += max_nesting\n        }\n\
    \        result.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val paren_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result += max_depth\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x =>\
    \ x.count(y => y == '(') - x.count(y => y == ')'))\n        val max_level = paren_levels.max\n\
    \        val min_level = paren_levels.min\n        val paren_levels_mapped = paren_levels.map(x\
    \ => x - min_level)\n        paren_levels_mapped.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n   \
    \     for (group <- paren_groups) {\n            var level = 0\n            var\
    \ max_level = 0\n            for (c <- group) {\n                if (c == '(')\
    \ level += 1\n                else if (c == ')') level -= 1\n                max_level\
    \ = max(max_level, level)\n            }\n            result += max_level\n  \
    \      }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_counts = paren_groups.map(x => {\n            var count\
    \ = 0\n            var max_count = 0\n            for (i <- 0 until x.length)\
    \ {\n                if (x(i) == '(') count += 1\n                else if (x(i)\
    \ == ')') count -= 1\n                max_count = max(max_count, count)\n    \
    \        }\n            max_count\n        })\n        paren_counts.toList", " \
    \       val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 max_level = max(max_level, level)\n                } else if\
    \ (paren == ')') {\n                    level -= 1\n                }\n      \
    \      }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]\n        for (group <- paren_groups) {\n            val\
    \ stack = new Stack[Char]\n            var max_level = 0\n            var current_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    current_level += 1\n                    max_level = max(max_level,\
    \ current_level)\n                    stack.push(paren)\n                } else\
    \ if (paren == ')') {\n                    current_level -= 1\n              \
    \      if (stack.isEmpty) {\n                        println(\"Invalid paren string\"\
    )\n                        return List()\n                    }\n            \
    \        stack.pop\n                }\n            }\n            if (!stack.isEmpty)\
    \ {\n                println(\"Invalid paren string\")\n                return\
    \ List()\n            }\n            max_nesting_levels += max_level\n       \
    \ }\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') depth += 1\n         \
    \       else depth -= 1\n                max_depth = max(max_depth, depth)\n \
    \           }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result += max_depth\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n   \
    \     for (i <- 0 until paren_groups.length) {\n            var max_depth = 0\n\
    \            var depth = 0\n            for (j <- 0 until paren_groups(i).length)\
    \ {\n                if (paren_groups(i)(j) == '(') depth += 1\n             \
    \   else depth -= 1\n                max_depth = max(max_depth, depth)\n     \
    \       }\n            result += max_depth\n        }\n        result.toList"]
stop_tokens:
- "\n    }\n"
