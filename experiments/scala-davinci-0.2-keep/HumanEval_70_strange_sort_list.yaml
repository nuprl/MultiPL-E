name: HumanEval_70_strange_sort_list
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given list of integers, return list in strange order.\n    // Strange sorting,\
  \ is when you start with the minimum value,\n    // then maximum of the remaining\
  \ integers, then minimum and so on.\n    // Examples:\n    // strange_sort_list([1,\
  \ 2, 3, 4]) == [1, 4, 2, 3]\n    // strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
  \ 5]\n    // strange_sort_list([]) == []\n    def strangeSortList(lst : List[Long])\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(strangeSortList((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 2l.toLong,\
  \ 3l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong, 9l.toLong))).equals((List[Long](5l.toLong, 9l.toLong, 6l.toLong, 8l.toLong,\
  \ 7l.toLong))));\n    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 4l.toLong,\
  \ 3l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong, 9l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 9l.toLong, 5l.toLong,\
  \ 8l.toLong, 6l.toLong, 7l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong,\
  \ 5l.toLong, 5l.toLong, 5l.toLong))).equals((List[Long](5l.toLong, 5l.toLong, 5l.toLong,\
  \ 5l.toLong))));\n    assert(strangeSortList((List[Long]())).equals((List[Long]())));\n\
  \    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
  \ 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong))).equals((List[Long](1l.toLong, 8l.toLong,\
  \ 2l.toLong, 7l.toLong, 3l.toLong, 6l.toLong, 4l.toLong, 5l.toLong))));\n    assert(strangeSortList((List[Long](0l.toLong,\
  \ 2l.toLong, 2l.toLong, 2l.toLong, 5l.toLong, 5l.toLong, -5l.toLong, -5l.toLong))).equals((List[Long](-5l.toLong,\
  \ 5l.toLong, -5l.toLong, 5l.toLong, 0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));\n\
  \    assert(strangeSortList((List[Long](111111l.toLong))).equals((List[Long](111111l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        if (lst.length == 0) return lst\n        val sorted = lst.sorted\n\
    \        val result = new ListBuffer[Long]\n        var i = 0\n        var j =\
    \ sorted.length - 1\n        while (i <= j) {\n            result += sorted(i)\n\
    \            if (i != j) result += sorted(j)\n            i += 1\n           \
    \ j -= 1\n        }\n        result.toList", "        if (lst.length == 0) return\
    \ lst\n        var lst2 = lst.sorted\n        var result = ListBuffer[Long]()\n\
    \        var i = 0\n        while (lst2.length > 0) {\n            if (i % 2 ==\
    \ 0) {\n                result += lst2.head\n                lst2 = lst2.tail\n\
    \            } else {\n                result += lst2.last\n                lst2\
    \ = lst2.init\n            }\n            i += 1\n        }\n        result.toList",
  "        if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n        val\
    \ min = sorted.head\n        val max = sorted.last\n        val mid = sorted.slice(1,\
    \ sorted.length - 1)\n        val mid_min = mid.head\n        val mid_max = mid.last\n\
    \        val mid_mid = mid.slice(1, mid.length - 1)\n        val mid_mid_min =\
    \ mid_mid.head\n        val mid_mid_max = mid_mid.last\n        val mid_mid_mid\
    \ = mid_mid.slice(1, mid_mid.length - 1)\n        val mid_mid_mid_min = mid_mid_mid.head\n\
    \        val mid_mid_mid_max = mid_mid_mid.last\n        val mid_mid_mid_mid =\
    \ mid_mid_mid.slice(1, mid_mid_mid.length - 1)\n        val mid_mid_mid_mid_min\
    \ = mid_mid_mid_mid.head\n        val mid_mid_mid_mid_max = mid_mid_mid_mid.last\n\
    \        val mid_mid_mid_mid_mid = mid_mid_mid_mid.slice(1, mid_mid_mid_mid.length\
    \ - 1)\n        val mid_mid_mid_mid_mid_min = mid_mid_mid_mid_mid.head\n     \
    \   val mid_mid_mid_mid_mid_max = mid_mid_mid_mid_mid.last\n        val mid_mid_mid_mid_mid_mid\
    \ = mid_mid_mid_mid_mid.slice(1, mid_mid_mid_mid_mid.length - 1)\n        val\
    \ mid_mid_mid_mid_mid_mid_min = mid_mid_mid_mid_mid_mid.head\n        val mid_mid_mid_mid_mid_mid_max\
    \ = mid_mid_mid_mid_mid_mid.last\n        val mid_mid_mid_mid_mid_mid_mid = mid_mid_mid_mid_mid_mid.slice(1,\
    \ mid_mid_mid_mid_mid_mid.length - 1)\n        val mid_mid_mid_mid_mid", "   \
    \     if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n        val\
    \ result = new ListBuffer[Long]\n        var i = 0\n        while (i < sorted.length)\
    \ {\n            if (i % 2 == 0) result += sorted(i)\n            else result\
    \ += sorted(sorted.length - 1 - i)\n            i += 1\n        }\n        result.toList",
  "        val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n  \
    \      var i = 0\n        var j = sorted.length - 1\n        while (i <= j) {\n\
    \            result += sorted(i)\n            if (i != j) result += sorted(j)\n\
    \            i += 1\n            j -= 1\n        }\n        result.toList", " \
    \       val sorted = lst.sorted\n        var result = List[Long]()\n        var\
    \ i = 0\n        while (i < sorted.length) {\n            if (i % 2 == 0) {\n\
    \                result = result :+ sorted(i)\n            } else {\n        \
    \        result = sorted(i) +: result\n            }\n            i += 1\n   \
    \     }\n        result", "        if (lst.length == 0) return lst\n        val\
    \ sorted = lst.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val (minLst, maxLst) = sorted.tail.partition(_ == min)\n        val minRest\
    \ = minLst.tail\n        val maxRest = maxLst.tail\n        val minRestSorted\
    \ = minRest.sorted\n        val maxRestSorted = maxRest.sorted\n        val minRestSortedReversed\
    \ = minRestSorted.reverse\n        val maxRestSortedReversed = maxRestSorted.reverse\n\
    \        val minRestSortedReversedTail = minRestSortedReversed.tail\n        val\
    \ maxRestSortedReversedTail = maxRestSortedReversed.tail\n        val minRestSortedReversedTailSorted\
    \ = minRestSortedReversedTail.sorted\n        val maxRestSortedReversedTailSorted\
    \ = maxRestSortedReversedTail.sorted\n        val minRestSortedReversedTailSortedReversed\
    \ = minRestSortedReversedTailSorted.reverse\n        val maxRestSortedReversedTailSortedReversed\
    \ = maxRestSortedReversedTailSorted.reverse\n        val minRestSortedReversedTailSortedReversedTail\
    \ = minRestSortedReversedTailSortedReversed.tail\n        val maxRestSortedReversedTailSortedReversedTail\
    \ = maxRestSortedReversedTailSortedReversed.tail\n        val minRestSortedReversedTailSortedReversedTailSorted\
    \ = minRestSortedReversedTailSortedReversedTail.sorted\n        val maxRestSortedReversedTailSortedReversedTailSorted\
    \ = maxRestSortedReversedTailSortedReversedTail.sorted\n        val minRestSortedReversedTailSortedReversedTailSortedReversed\
    \ = minRestSortedReversedTailSortedReversedTailSorted.reverse\n        val maxRestSortedRe",
  "        if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n        val\
    \ min = sorted.head\n        val max = sorted.last\n        val (left, right)\
    \ = sorted.tail.span(_ != max)\n        val (left2, right2) = right.tail.span(_\
    \ != min)\n        List(min) ++ right ++ left ++ List(max) ++ right2 ++ left2",
  "        if (lst.length == 0) return lst\n        var lst2 = lst.sorted\n      \
    \  var lst3 = ListBuffer[Long]()\n        while (lst2.length > 0) {\n        \
    \    lst3 += lst2.head\n            lst2 = lst2.tail\n            if (lst2.length\
    \ > 0) {\n                lst3 += lst2.last\n                lst2 = lst2.dropRight(1)\n\
    \            }\n        }\n        lst3.toList", "        if (lst.isEmpty) return\
    \ lst\n        val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = sorted.length - 1\n        while (i <= j)\
    \ {\n            result += sorted(i)\n            if (i != j) result += sorted(j)\n\
    \            i += 1\n            j -= 1\n        }\n        result.toList", " \
    \       if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n       \
    \ val min = sorted.head\n        val max = sorted.last\n        val (left, right)\
    \ = sorted.tail.init.partition(_ <= min)\n        val left_sorted = left.sorted\n\
    \        val right_sorted = right.sorted\n        val left_sorted_reversed = left_sorted.reverse\n\
    \        val right_sorted_reversed = right_sorted.reverse\n        val result\
    \ = ListBuffer[Long]()\n        var i = 0\n        while (i < left_sorted.length)\
    \ {\n            result += left_sorted(i)\n            result += right_sorted_reversed(i)\n\
    \            i += 1\n        }\n        result += min\n        result += max\n\
    \        i = 0\n        while (i < right_sorted.length) {\n            result\
    \ += right_sorted(i)\n            result += left_sorted_reversed(i)\n        \
    \    i += 1\n        }\n        result.toList", "        if (lst.length == 0)\
    \ return List()\n        var lst2 = lst.sorted\n        var lst3 = ListBuffer[Long]()\n\
    \        var i = 0\n        while (lst2.length > 0) {\n            if (i % 2 ==\
    \ 0) {\n                lst3 += lst2.head\n                lst2 = lst2.tail\n\
    \            } else {\n                lst3 += lst2.last\n                lst2\
    \ = lst2.dropRight(1)\n            }\n            i += 1\n        }\n        lst3.toList",
  "        if (lst.isEmpty) return lst\n        var lst2 = lst.sorted\n        var\
    \ result = ListBuffer[Long]()\n        var i = 0\n        while (lst2.nonEmpty)\
    \ {\n            if (i % 2 == 0) {\n                result += lst2.head\n    \
    \            lst2 = lst2.tail\n            } else {\n                result +=\
    \ lst2.last\n                lst2 = lst2.dropRight(1)\n            }\n       \
    \     i += 1\n        }\n        result.toList", "        if (lst.length == 0)\
    \ return lst\n        val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = sorted.length - 1\n        while (i <= j)\
    \ {\n            result += sorted(i)\n            if (i != j) result += sorted(j)\n\
    \            i += 1\n            j -= 1\n        }\n        result.toList", " \
    \       if (lst.length == 0) return lst\n        var lst2 = lst.sorted\n     \
    \   var lst3 = ListBuffer[Long]()\n        var i = 0\n        while (lst2.length\
    \ > 0) {\n            if (i % 2 == 0) {\n                lst3 += lst2.head\n \
    \               lst2 = lst2.tail\n            } else {\n                lst3 +=\
    \ lst2.last\n                lst2 = lst2.dropRight(1)\n            }\n       \
    \     i += 1\n        }\n        lst3.toList", "        if (lst.length == 0) return\
    \ lst\n        var lst2 = lst.sorted\n        var lst3 = ListBuffer[Long]()\n\
    \        var i = 0\n        while (lst2.length > 0) {\n            if (i % 2 ==\
    \ 0) {\n                lst3 += lst2.head\n                lst2 = lst2.tail\n\
    \            } else {\n                lst3 += lst2.last\n                lst2\
    \ = lst2.dropRight(1)\n            }\n            i += 1\n        }\n        lst3.toList",
  "        val sorted = lst.sorted\n        val min = sorted.head\n        val max\
    \ = sorted.last\n        val lst1 = sorted.filter(_ != min)\n        val lst2\
    \ = sorted.filter(_ != max)\n        val lst3 = lst1.filter(_ != max)\n      \
    \  val lst4 = lst2.filter(_ != min)\n        val lst5 = lst3.filter(_ != min)\n\
    \        val lst6 = lst4.filter(_ != max)\n        val lst7 = lst5.filter(_ !=\
    \ max)\n        val lst8 = lst6.filter(_ != min)\n        val lst9 = lst7.filter(_\
    \ != min)\n        val lst10 = lst8.filter(_ != max)\n        val lst11 = lst9.filter(_\
    \ != max)\n        val lst12 = lst10.filter(_ != min)\n        val lst13 = lst11.filter(_\
    \ != min)\n        val lst14 = lst12.filter(_ != max)\n        val lst15 = lst13.filter(_\
    \ != max)\n        val lst16 = lst14.filter(_ != min)\n        val lst17 = lst15.filter(_\
    \ != min)\n        val lst18 = lst16.filter(_ != max)\n        val lst19 = lst17.filter(_\
    \ != max)\n        val lst20 = lst18.filter(_ != min)\n        val lst21 = lst19.filter(_\
    \ != min)\n        val lst22 = lst20.filter(_ != max)\n        val lst23 = lst21.filter(_\
    \ != max)\n        val lst24 = lst22.filter(_ != min)\n        val lst25 = lst23.filter(_\
    \ != min)\n        val lst26 = lst24.filter(_ != max)\n        val lst27 = lst25.filter(_\
    \ != max)\n        val lst28 = lst26.filter(_ != min)\n        val lst29 = lst27.filter(_\
    \ != min)\n        val lst30 = lst28.filter(_ != max)\n        val lst31 = lst29",
  "        if (lst.length == 0) return lst\n        var sorted = lst.sorted\n    \
    \    var result = ListBuffer[Long]()\n        var i = 0\n        while (i < sorted.length)\
    \ {\n            if (i % 2 == 0) result += sorted(i)\n            else result\
    \ += sorted(sorted.length - 1 - i)\n            i += 1\n        }\n        return\
    \ result.toList", "        if (lst.length == 0) return lst\n        var min =\
    \ lst.min\n        var max = lst.max\n        var lst2 = lst.filter(x => x !=\
    \ min && x != max)\n        var lst3 = List[Long]()\n        var lst4 = List[Long]()\n\
    \        var lst5 = List[Long]()\n        var lst6 = List[Long]()\n        if\
    \ (lst.length % 2 == 0) {\n            lst3 = lst3 :+ min\n            lst3 =\
    \ lst3 :+ max\n            lst4 = strangeSortList(lst2)\n            lst5 = lst3\
    \ ++ lst4\n        } else {\n            lst3 = lst3 :+ min\n            lst4\
    \ = strangeSortList(lst2)\n            lst5 = lst3 ++ lst4\n            lst6 =\
    \ lst6 :+ max\n            lst5 = lst5 ++ lst6\n        }\n        return lst5",
  "        val sorted = lst.sorted\n        val n = sorted.length\n        val result\
    \ = new ListBuffer[Long]\n        var i = 0\n        while (i < n) {\n       \
    \     if (i % 2 == 0) result += sorted(i)\n            else result += sorted(n\
    \ - i / 2 - 1)\n            i += 1\n        }\n        result.toList", "     \
    \   if (lst.length == 0) return lst\n        var result = List[Long]()\n     \
    \   var lst2 = lst.sorted\n        var i = 0\n        while (lst2.length > 0)\
    \ {\n            if (i % 2 == 0) {\n                result = result :+ lst2.head\n\
    \                lst2 = lst2.tail\n            } else {\n                result\
    \ = result :+ lst2.last\n                lst2 = lst2.init\n            }\n   \
    \         i += 1\n        }\n        result", "        val sorted = lst.sorted\n\
    \        val n = sorted.length\n        val result = new Array[Long](n)\n    \
    \    var i = 0\n        var j = 0\n        var k = n - 1\n        while (i < n)\
    \ {\n            if (i % 2 == 0) {\n                result(i) = sorted(j)\n  \
    \              j += 1\n            } else {\n                result(i) = sorted(k)\n\
    \                k -= 1\n            }\n            i += 1\n        }\n      \
    \  result.toList", "        if (lst.isEmpty) return lst\n        val sorted =\
    \ lst.sorted\n        val n = sorted.length\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = n - 1\n        while (i <= j) {\n        \
    \    result += sorted(i)\n            if (i != j) result += sorted(j)\n      \
    \      i += 1\n            j -= 1\n        }\n        result.toList", "      \
    \  if (lst.isEmpty) return lst\n        var result = ListBuffer[Long]()\n    \
    \    var remaining = lst.toBuffer\n        while (remaining.nonEmpty) {\n    \
    \        result += remaining.min\n            remaining -= remaining.min\n   \
    \         if (remaining.nonEmpty) {\n                result += remaining.max\n\
    \                remaining -= remaining.max\n            }\n        }\n      \
    \  result.toList", "        if (lst.length == 0) return lst\n        var sorted\
    \ = lst.sorted\n        var result = ListBuffer[Long]()\n        var i = 0\n \
    \       while (i < sorted.length) {\n            if (i % 2 == 0) result += sorted(i)\n\
    \            else result += sorted(sorted.length - 1 - i)\n            i += 1\n\
    \        }\n        return result.toList", "        if (lst.isEmpty) return lst\n\
    \        val sorted = lst.sorted\n        val n = sorted.length\n        val result\
    \ = new ArrayBuffer[Long]\n        var i = 0\n        while (i < n) {\n      \
    \      if (i % 2 == 0) result += sorted(i)\n            else result += sorted(n\
    \ - i / 2 - 1)\n            i += 1\n        }\n        result.toList", "     \
    \   val sorted = lst.sorted\n        val n = sorted.length\n        val result\
    \ = new ListBuffer[Long]\n        var i = 0\n        while (i < n) {\n       \
    \     if (i % 2 == 0) result += sorted(i)\n            else result += sorted(n\
    \ - i / 2 - 1)\n            i += 1\n        }\n        result.toList", "     \
    \   if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n        val\
    \ min = sorted.head\n        val max = sorted.last\n        val mid = sorted.slice(1,\
    \ sorted.length - 1)\n        val result = new ListBuffer[Long]\n        result\
    \ += min\n        var i = 0\n        while (i < mid.length) {\n            result\
    \ += mid(mid.length - 1 - i)\n            result += mid(i)\n            i += 1\n\
    \        }\n        if (mid.length % 2 == 1) result += mid.last\n        result\
    \ += max\n        result.toList", "        if (lst.isEmpty) return lst\n     \
    \   var lst2 = lst.sorted\n        var lst3 = ListBuffer[Long]()\n        var\
    \ i = 0\n        while (lst2.nonEmpty) {\n            if (i % 2 == 0) {\n    \
    \            lst3 += lst2.head\n                lst2 = lst2.tail\n           \
    \ } else {\n                lst3 += lst2.last\n                lst2 = lst2.init\n\
    \            }\n            i += 1\n        }\n        lst3.toList", "       \
    \ if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n        val result\
    \ = new ListBuffer[Long]\n        var i = 0\n        var j = sorted.length - 1\n\
    \        while (i <= j) {\n            result += sorted(i)\n            if (i\
    \ != j) result += sorted(j)\n            i += 1\n            j -= 1\n        }\n\
    \        result.toList", "        if (lst.isEmpty) return lst\n        val sorted\
    \ = lst.sorted\n        val result = new ListBuffer[Long]\n        var i = 0\n\
    \        var j = sorted.length - 1\n        while (i <= j) {\n            result\
    \ += sorted(i)\n            if (i != j) result += sorted(j)\n            i +=\
    \ 1\n            j -= 1\n        }\n        result.toList", "        if (lst.isEmpty)\
    \ return lst\n        val sorted = lst.sorted\n        val n = sorted.length\n\
    \        val result = new ListBuffer[Long]\n        var i = 0\n        var j =\
    \ n - 1\n        while (i <= j) {\n            result += sorted(i)\n         \
    \   if (i != j) result += sorted(j)\n            i += 1\n            j -= 1\n\
    \        }\n        result.toList", "        if (lst.length == 0) return lst\n\
    \        val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = sorted.length - 1\n        while (i <= j)\
    \ {\n            result += sorted(i)\n            if (i != j) result += sorted(j)\n\
    \            i += 1\n            j -= 1\n        }\n        result.toList", " \
    \       if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n       \
    \ val (left, right) = sorted.splitAt(sorted.length / 2)\n        val (left2, right2)\
    \ = if (sorted.length % 2 == 0) (left, right) else (left.tail, right)\n      \
    \  val (left3, right3) = (left2.reverse, right2.reverse)\n        val result =\
    \ new ListBuffer[Long]\n        for (i <- 0 until left3.length) {\n          \
    \  result += left3(i)\n            result += right3(i)\n        }\n        if\
    \ (sorted.length % 2 == 1) result += left3.last\n        result.toList", "   \
    \     if (lst.isEmpty) return lst\n        var lst2 = lst.sorted\n        var\
    \ lst3 = ListBuffer[Long]()\n        while (!lst2.isEmpty) {\n            lst3\
    \ += lst2.head\n            lst2 = lst2.tail\n            if (!lst2.isEmpty) {\n\
    \                lst3 += lst2.last\n                lst2 = lst2.init\n       \
    \     }\n        }\n        lst3.toList", "        if (lst.isEmpty) return lst\n\
    \        var lst2 = lst.sorted\n        var lst3 = ListBuffer[Long]()\n      \
    \  var i = 0\n        while (lst2.nonEmpty) {\n            if (i % 2 == 0) {\n\
    \                lst3 += lst2.head\n                lst2 = lst2.tail\n       \
    \     } else {\n                lst3 += lst2.last\n                lst2 = lst2.init\n\
    \            }\n            i += 1\n        }\n        lst3.toList", "       \
    \ var result = List[Long]()\n        var lst2 = lst.sorted\n        while (lst2.length\
    \ > 0) {\n            result = result :+ lst2.head\n            lst2 = lst2.tail\n\
    \            if (lst2.length > 0) {\n                result = result :+ lst2.last\n\
    \                lst2 = lst2.dropRight(1)\n            }\n        }\n        result",
  "        if (lst.length == 0) return lst\n        val sorted = lst.sorted\n    \
    \    val result = new ListBuffer[Long]\n        var i = 0\n        var j = sorted.length\
    \ - 1\n        while (i <= j) {\n            result += sorted(i)\n           \
    \ if (i != j) result += sorted(j)\n            i += 1\n            j -= 1\n  \
    \      }\n        result.toList", "        val sorted = lst.sorted\n        val\
    \ (min, max) = (sorted.head, sorted.last)\n        val (min_lst, max_lst) = (sorted.filter(_\
    \ != min), sorted.filter(_ != max))\n        val min_max_lst = (min_lst.zip(max_lst)).flatMap(x\
    \ => List(x._1, x._2))\n        if (min_lst.size == max_lst.size) min_max_lst\n\
    \        else min_max_lst :+ (if (min_lst.size > max_lst.size) min else max)",
  "        if (lst.length == 0) return lst\n        var result = List[Long]()\n  \
    \      var min = lst.min\n        var max = lst.max\n        var lst2 = lst.filter(x\
    \ => x != min && x != max)\n        var min_max = List(min, max)\n        var\
    \ min_max_lst = min_max ::: lst2\n        var min_max_lst2 = min_max_lst.sortWith(_\
    \ < _)\n        var min_max_lst3 = min_max_lst2.reverse\n        var min_max_lst4\
    \ = min_max_lst3.filter(x => x != min && x != max)\n        var min_max_lst5 =\
    \ min_max ::: min_max_lst4\n        var min_max_lst6 = min_max_lst5.sortWith(_\
    \ < _)\n        var min_max_lst7 = min_max_lst6.reverse\n        var min_max_lst8\
    \ = min_max_lst7.filter(x => x != min && x != max)\n        var min_max_lst9 =\
    \ min_max ::: min_max_lst8\n        var min_max_lst10 = min_max_lst9.sortWith(_\
    \ < _)\n        var min_max_lst11 = min_max_lst10.reverse\n        var min_max_lst12\
    \ = min_max_lst11.filter(x => x != min && x != max)\n        var min_max_lst13\
    \ = min_max ::: min_max_lst12\n        var min_max_lst14 = min_max_lst13.sortWith(_\
    \ < _)\n        var min_max_lst15 = min_max_lst14.reverse\n        var min_max_lst16\
    \ = min_max_lst15.filter(x => x != min && x != max)\n        var min_max_lst17\
    \ = min_max ::: min_max_lst16\n        var min_max_lst18 = min_max_lst17.sortWith(_",
  "        if (lst.isEmpty) return lst\n        var list = lst.sorted\n        var\
    \ result = ListBuffer[Long]()\n        var i = 0\n        while (i < list.length)\
    \ {\n            if (i % 2 == 0) result += list(i)\n            else result +=\
    \ list(list.length - 1 - i)\n            i += 1\n        }\n        return result.toList",
  "        if (lst.length == 0) return lst\n        val sorted = lst.sorted\n    \
    \    val result = new ListBuffer[Long]\n        var i = 0\n        var j = sorted.length\
    \ - 1\n        while (i <= j) {\n            result += sorted(i)\n           \
    \ if (i != j) result += sorted(j)\n            i += 1\n            j -= 1\n  \
    \      }\n        result.toList", "        if (lst.isEmpty) return lst\n     \
    \   var min = lst.min\n        var max = lst.max\n        var lst2 = lst.filter(x\
    \ => x != min && x != max)\n        var lst3 = List[Long]()\n        var i = 0\n\
    \        while (lst2.length > 0) {\n            if (i % 2 == 0) {\n          \
    \      lst3 = lst3 :+ min\n                min = lst2.min\n                lst2\
    \ = lst2.filter(x => x != min)\n            } else {\n                lst3 = lst3\
    \ :+ max\n                max = lst2.max\n                lst2 = lst2.filter(x\
    \ => x != max)\n            }\n            i += 1\n        }\n        if (i %\
    \ 2 == 0) {\n            lst3 = lst3 :+ min :+ max\n        } else {\n       \
    \     lst3 = lst3 :+ max :+ min\n        }\n        return lst3", "        if\
    \ (lst.length == 0) return lst\n        var min = lst.min\n        var max = lst.max\n\
    \        var lst2 = lst.filter(x => x != min && x != max)\n        var lst3 =\
    \ List[Long]()\n        var i = 0\n        while (lst2.length > 0) {\n       \
    \     if (i % 2 == 0) {\n                lst3 = lst3 :+ min\n                min\
    \ = lst2.min\n                lst2 = lst2.filter(x => x != min)\n            }\
    \ else {\n                lst3 = lst3 :+ max\n                max = lst2.max\n\
    \                lst2 = lst2.filter(x => x != max)\n            }\n          \
    \  i += 1\n        }\n        if (i % 2 == 0) lst3 = lst3 :+ min :+ max\n    \
    \    else lst3 = lst3 :+ max :+ min\n        return lst3", "        if (lst.length\
    \ == 0) return lst\n        var result = List[Long]()\n        var sorted = lst.sorted\n\
    \        var i = 0\n        while (i < sorted.length) {\n            if (i % 2\
    \ == 0) result = result :+ sorted(i)\n            else result = sorted(i) +: result\n\
    \            i += 1\n        }\n        result", "        if (lst.isEmpty) return\
    \ lst\n        var result = List[Long]()\n        var min = lst.min\n        var\
    \ max = lst.max\n        var remaining = lst.filter(x => x != min && x != max)\n\
    \        var ascending = true\n        while (remaining.nonEmpty) {\n        \
    \    if (ascending) {\n                result = result :+ min\n              \
    \  min = remaining.min\n                remaining = remaining.filter(x => x !=\
    \ min)\n            } else {\n                result = result :+ max\n       \
    \         max = remaining.max\n                remaining = remaining.filter(x\
    \ => x != max)\n            }\n            ascending = !ascending\n        }\n\
    \        if (ascending) result = result :+ min :+ max\n        else result = result\
    \ :+ max :+ min\n        return result", "        var lst2 = lst.sorted\n    \
    \    var lst3 = ListBuffer[Long]()\n        var i = 0\n        while (i < lst2.length)\
    \ {\n            if (i % 2 == 0) lst3 += lst2(i)\n            else lst3 += lst2(lst2.length\
    \ - 1 - i)\n            i += 1\n        }\n        lst3.toList", "        if (lst.length\
    \ == 0) return lst\n        var result = new ListBuffer[Long]\n        var min\
    \ = lst.min\n        var max = lst.max\n        var lst2 = lst.filter(x => x !=\
    \ min && x != max)\n        var min_count = lst.count(x => x == min)\n       \
    \ var max_count = lst.count(x => x == max)\n        var min_max_count = min_count\
    \ + max_count\n        var min_max_count_half = min_max_count / 2\n        var\
    \ min_max_count_half_remainder = min_max_count % 2\n        var min_max_count_half_remainder_count\
    \ = 0\n        var min_max_count_half_remainder_count_max = 0\n        if (min_max_count_half_remainder\
    \ == 1) {\n            min_max_count_half_remainder_count_max = 1\n        }\n\
    \        for (i <- 0 until min_max_count_half) {\n            result += min\n\
    \            result += max\n        }\n        if (min_max_count_half_remainder\
    \ == 1) {\n            result += min\n        }\n        var min_max_count_half_remainder_count_min\
    \ = 0\n        if (min_max_count_half_remainder == 1) {\n            min_max_count_half_remainder_count_min\
    \ = 1\n        }\n        while (lst2.length > 0) {\n            if (min_max_count_half_remainder_count\
    \ == min_max_count_half_remainder_count_max) {\n                min_max_count_half_remainder_count\
    \ = min_max_count_half_remainder_count_min\n                min = lst2.min\n \
    \               max = lst2.max\n                lst2 = lst2.filter(x => x != min\
    \ && x != max)\n                result += min\n                result += max\n\
    \            } else {\n                min_max_count_half_remainder_count += 1\n\
    \                min = lst2", "        val sorted = lst.sorted\n        val result\
    \ = new ListBuffer[Long]\n        var i = 0\n        while (i < sorted.length)\
    \ {\n            if (i % 2 == 0) result += sorted(i)\n            else result\
    \ += sorted(sorted.length - 1 - i)\n            i += 1\n        }\n        result.toList",
  "        if (lst.isEmpty) return lst\n        var lst2 = lst.sorted\n        var\
    \ lst3 = ListBuffer[Long]()\n        var i = 0\n        while (lst2.length > 0)\
    \ {\n            if (i % 2 == 0) {\n                lst3 += lst2.head\n      \
    \          lst2 = lst2.tail\n            } else {\n                lst3 += lst2.last\n\
    \                lst2 = lst2.dropRight(1)\n            }\n            i += 1\n\
    \        }\n        lst3.toList", "        if (lst.isEmpty) return List()\n  \
    \      var lst2 = lst.sorted\n        var lst3 = ListBuffer[Long]()\n        var\
    \ i = 0\n        while (lst2.length > 0) {\n            if (i % 2 == 0) {\n  \
    \              lst3 += lst2.head\n                lst2 = lst2.tail\n         \
    \   } else {\n                lst3 += lst2.last\n                lst2 = lst2.init\n\
    \            }\n            i += 1\n        }\n        lst3.toList", "       \
    \ if (lst.isEmpty) return lst\n        var lst2 = lst.sorted\n        var lst3\
    \ = ListBuffer[Long]()\n        while (!lst2.isEmpty) {\n            lst3 += lst2.head\n\
    \            lst2 = lst2.tail\n            if (!lst2.isEmpty) {\n            \
    \    lst3 += lst2.last\n                lst2 = lst2.init\n            }\n    \
    \    }\n        lst3.toList", "        var lst2 = lst.sorted\n        var lst3\
    \ = ListBuffer[Long]()\n        var i = 0\n        while (i < lst2.length) {\n\
    \            if (i % 2 == 0) lst3 += lst2(i)\n            else lst3 += lst2(lst2.length\
    \ - 1 - i)\n            i += 1\n        }\n        lst3.toList", "        if (lst.isEmpty)\
    \ return lst\n        val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = sorted.length - 1\n        while (i <= j)\
    \ {\n            result += sorted(i)\n            if (i != j) result += sorted(j)\n\
    \            i += 1\n            j -= 1\n        }\n        result.toList", " \
    \       if (lst.length == 0) return List()\n        val sorted = lst.sorted\n\
    \        var result = ListBuffer[Long]()\n        var i = 0\n        var j = sorted.length\
    \ - 1\n        while (i <= j) {\n            result += sorted(i)\n           \
    \ if (i != j) result += sorted(j)\n            i += 1\n            j -= 1\n  \
    \      }\n        result.toList", "        if (lst.length == 0) return lst\n \
    \       var lst2 = lst.sorted\n        var lst3 = List[Long]()\n        var i\
    \ = 0\n        while (lst2.length > 0) {\n            if (i % 2 == 0) {\n    \
    \            lst3 = lst3 :+ lst2.head\n                lst2 = lst2.tail\n    \
    \        } else {\n                lst3 = lst3 :+ lst2.last\n                lst2\
    \ = lst2.dropRight(1)\n            }\n            i += 1\n        }\n        return\
    \ lst3", "        if (lst.length == 0) return lst\n        val sorted = lst.sorted\n\
    \        val result = new ListBuffer[Long]\n        val min = sorted.head\n  \
    \      val max = sorted.last\n        var i = 0\n        while (i < sorted.length)\
    \ {\n            if (i % 2 == 0) result += min\n            else result += max\n\
    \            i += 1\n        }\n        result.toList", "        if (lst.length\
    \ == 0) return lst\n        val sorted = lst.sorted\n        val result = new\
    \ ListBuffer[Long]\n        var i = 0\n        var j = sorted.length - 1\n   \
    \     while (i <= j) {\n            result += sorted(i)\n            if (i !=\
    \ j) result += sorted(j)\n            i += 1\n            j -= 1\n        }\n\
    \        result.toList", "        if (lst.length == 0) return lst\n        var\
    \ lst2 = lst.sorted\n        var lst3 = ListBuffer[Long]()\n        var i = 0\n\
    \        while (lst2.length > 0) {\n            if (i % 2 == 0) {\n          \
    \      lst3 += lst2.head\n                lst2 = lst2.tail\n            } else\
    \ {\n                lst3 += lst2.last\n                lst2 = lst2.dropRight(1)\n\
    \            }\n            i += 1\n        }\n        lst3.toList", "       \
    \ if (lst.length == 0) return lst\n        var min = lst.min\n        var max\
    \ = lst.max\n        var lst2 = lst.filter(_ != min)\n        var lst3 = lst2.filter(_\
    \ != max)\n        var lst4 = List(min)\n        var lst5 = List(max)\n      \
    \  var lst6 = lst4 ::: lst5\n        var lst7 = lst6 ::: strangeSortList(lst3)\n\
    \        return lst7", "        val sorted = lst.sorted\n        val n = sorted.length\n\
    \        if (n % 2 == 0) {\n            val (first, second) = sorted.splitAt(n\
    \ / 2)\n            val result = new ListBuffer[Long]\n            for (i <- 0\
    \ until n / 2) {\n                result += first(i)\n                result +=\
    \ second(n / 2 - i - 1)\n            }\n            result.toList\n        } else\
    \ {\n            val (first, second) = sorted.splitAt(n / 2)\n            val\
    \ result = new ListBuffer[Long]\n            for (i <- 0 until n / 2) {\n    \
    \            result += first(i)\n                result += second(n / 2 - i)\n\
    \            }\n            result += first(n / 2)\n            result.toList\n\
    \        }", "        val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        while (i < sorted.length) {\n            result +=\
    \ sorted(i)\n            if (i + 1 < sorted.length) result += sorted(sorted.length\
    \ - i - 1)\n            i += 1\n        }\n        result.toList", "        if\
    \ (lst.isEmpty) return lst\n        val sorted = lst.sorted\n        val result\
    \ = new ListBuffer[Long]\n        var i = 0\n        var j = sorted.length - 1\n\
    \        while (i <= j) {\n            result += sorted(i)\n            if (i\
    \ != j) result += sorted(j)\n            i += 1\n            j -= 1\n        }\n\
    \        result.toList", "        if (lst.length == 0) return lst\n        var\
    \ lst2 = lst.sortWith(_ < _)\n        var lst3 = ListBuffer[Long]()\n        var\
    \ i = 0\n        while (lst2.length > 0) {\n            if (i % 2 == 0) {\n  \
    \              lst3 += lst2.head\n                lst2 = lst2.tail\n         \
    \   } else {\n                lst3 += lst2.last\n                lst2 = lst2.init\n\
    \            }\n            i += 1\n        }\n        lst3.toList", "       \
    \ if (lst.length == 0) return lst\n        var result = ListBuffer[Long]()\n \
    \       var min = lst.min\n        var max = lst.max\n        var minIndex = lst.indexOf(min)\n\
    \        var maxIndex = lst.indexOf(max)\n        var minCount = 0\n        var\
    \ maxCount = 0\n        var lst2 = lst.toBuffer\n        while (lst2.length >\
    \ 0) {\n            if (minCount <= maxCount) {\n                result += min\n\
    \                lst2.remove(minIndex)\n                if (lst2.length > 0) {\n\
    \                    min = lst2.min\n                    minIndex = lst2.indexOf(min)\n\
    \                }\n                minCount += 1\n            } else {\n    \
    \            result += max\n                lst2.remove(maxIndex)\n          \
    \      if (lst2.length > 0) {\n                    max = lst2.max\n          \
    \          maxIndex = lst2.indexOf(max)\n                }\n                maxCount\
    \ += 1\n            }\n        }\n        return result.toList", "        if (lst.length\
    \ == 0) return lst\n        var result = List[Long]()\n        var sorted = lst.sorted\n\
    \        var min = sorted.head\n        var max = sorted.last\n        var minIndex\
    \ = lst.indexOf(min)\n        var maxIndex = lst.indexOf(max)\n        var minFound\
    \ = false\n        var maxFound = false\n        for (i <- 0 until lst.length)\
    \ {\n            if (i == minIndex) {\n                result = result :+ min\n\
    \                minFound = true\n            } else if (i == maxIndex) {\n  \
    \              result = result :+ max\n                maxFound = true\n     \
    \       } else {\n                if (minFound) {\n                    result\
    \ = result :+ lst(i)\n                } else {\n                    result = lst(i)\
    \ +: result\n                }\n            }\n        }\n        result", " \
    \       if (lst.length == 0) return lst\n        var lst2 = lst.sorted\n     \
    \   var lst3 = ListBuffer[Long]()\n        var i = 0\n        while (lst2.length\
    \ > 0) {\n            if (i % 2 == 0) {\n                lst3 += lst2.head\n \
    \               lst2 = lst2.tail\n            } else {\n                lst3 +=\
    \ lst2.last\n                lst2 = lst2.init\n            }\n            i +=\
    \ 1\n        }\n        lst3.toList", "        if (lst.length == 0) return lst\n\
    \        val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = sorted.length - 1\n        while (i <= j)\
    \ {\n            result += sorted(i)\n            if (i != j) result += sorted(j)\n\
    \            i += 1\n            j -= 1\n        }\n        result.toList", " \
    \       val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n \
    \       var i = 0\n        while (i < sorted.length) {\n            result +=\
    \ sorted(i)\n            if (i + 1 < sorted.length) result += sorted(sorted.length\
    \ - i - 1)\n            i += 1\n        }\n        result.toList", "        if\
    \ (lst.length == 0) return lst\n        var min = lst.min\n        var max = lst.max\n\
    \        var lst2 = lst.filter(x => x != min && x != max)\n        var lst3 =\
    \ List[Long]()\n        var i = 0\n        while (lst2.length > 0) {\n       \
    \     if (i % 2 == 0) {\n                lst3 = lst3 :+ min\n                min\
    \ = lst2.min\n                lst2 = lst2.filter(x => x != min)\n            }\
    \ else {\n                lst3 = lst3 :+ max\n                max = lst2.max\n\
    \                lst2 = lst2.filter(x => x != max)\n            }\n          \
    \  i += 1\n        }\n        if (i % 2 == 0) {\n            lst3 = lst3 :+ min\
    \ :+ max\n        } else {\n            lst3 = lst3 :+ max :+ min\n        }\n\
    \        return lst3", "        if (lst.isEmpty) return lst\n        var lst2\
    \ = lst.sorted\n        var lst3 = ListBuffer[Long]()\n        while (lst2.nonEmpty)\
    \ {\n            lst3 += lst2.head\n            lst2 = lst2.tail\n           \
    \ if (lst2.nonEmpty) {\n                lst3 += lst2.last\n                lst2\
    \ = lst2.init\n            }\n        }\n        lst3.toList", "        if (lst.isEmpty)\
    \ return List()\n        var min = lst.min\n        var max = lst.max\n      \
    \  var lst2 = lst.filter(x => x != min && x != max)\n        var lst3 = List(min,\
    \ max)\n        while (!lst2.isEmpty) {\n            min = lst2.min\n        \
    \    max = lst2.max\n            lst3 = lst3 ::: List(min, max)\n            lst2\
    \ = lst2.filter(x => x != min && x != max)\n        }\n        return lst3", " \
    \       if (lst.isEmpty) return lst\n        var lst2 = lst.sorted\n        var\
    \ lst3 = ListBuffer[Long]()\n        while (!lst2.isEmpty) {\n            lst3\
    \ += lst2.head\n            lst2 = lst2.tail\n            if (!lst2.isEmpty) {\n\
    \                lst3 += lst2.last\n                lst2 = lst2.init\n       \
    \     }\n        }\n        lst3.toList", "        if (lst.isEmpty) return lst\n\
    \        val sorted = lst.sorted\n        val n = sorted.length\n        val result\
    \ = new ArrayBuffer[Long]\n        var i = 0\n        while (i < n) {\n      \
    \      result += sorted(i)\n            if (i + 1 < n) result += sorted(n - i\
    \ - 1)\n            i += 1\n        }\n        result.toList", "        if (lst.isEmpty)\
    \ return lst\n        var result = ListBuffer[Long]()\n        var remaining =\
    \ lst.toBuffer\n        while (!remaining.isEmpty) {\n            val min = remaining.min\n\
    \            val max = remaining.max\n            result += min\n            remaining\
    \ -= min\n            if (min != max) {\n                result += max\n     \
    \           remaining -= max\n            }\n        }\n        result.toList",
  "        if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n        val\
    \ min = sorted.head\n        val max = sorted.last\n        val (left, right)\
    \ = sorted.tail.init.partition(_ < max)\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftMin = leftSorted.head\n\
    \        val rightMax = rightSorted.last\n        val leftSortedTail = leftSorted.tail\n\
    \        val rightSortedInit = rightSorted.init\n        val leftSortedTailSorted\
    \ = leftSortedTail.sorted\n        val rightSortedInitSorted = rightSortedInit.sorted\n\
    \        val leftSortedTailSortedMin = leftSortedTailSorted.head\n        val\
    \ rightSortedInitSortedMax = rightSortedInitSorted.last\n        val leftSortedTailSortedMinTail\
    \ = leftSortedTailSorted.tail\n        val rightSortedInitSortedMaxInit = rightSortedInitSorted.init\n\
    \        val leftSortedTailSortedMinTailSorted = leftSortedTailSortedMinTail.sorted\n\
    \        val rightSortedInitSortedMaxInitSorted = rightSortedInitSortedMaxInit.sorted\n\
    \        val leftSortedTailSortedMinTailSortedMin = leftSortedTailSortedMinTailSorted.head\n\
    \        val rightSortedInitSortedMaxInitSortedMax = rightSortedInitSortedMaxInitSorted.last\n\
    \        val leftSortedTailSortedMinTailSortedMinTail = leftSortedTailSortedMinTailSorted.tail\n\
    \        val rightSortedInitSortedMaxInitSortedMaxInit = rightSortedInitSortedMaxInitSorted.init\n\
    \        val leftSortedTailSortedMinTailSortedMinTailSorted = leftSortedTailSortedMinTailSortedMinTail.sorted\n\
    \        val rightSortedInitSortedMaxInitSortedMaxInitSorted = rightSortedInitSortedMaxInitSortedMaxInit.sorted\n\
    \        val leftSortedTailSortedMinTailSortedMinT", "        if (lst.length ==\
    \ 0) return lst\n        val sorted = lst.sorted\n        val min = sorted.head\n\
    \        val max = sorted.last\n        val mid = sorted.slice(1, sorted.length\
    \ - 1)\n        val mid_sorted = mid.sorted\n        val mid_sorted_rev = mid_sorted.reverse\n\
    \        val mid_sorted_rev_zip = mid_sorted_rev.zip(mid_sorted)\n        val\
    \ mid_sorted_rev_zip_flat = mid_sorted_rev_zip.flatMap(x => List(x._1, x._2))\n\
    \        val result = List(min) ++ mid_sorted_rev_zip_flat ++ List(max)\n    \
    \    return result", "        if (lst.isEmpty) return lst\n        var lst2 =\
    \ lst.sorted\n        var lst3 = new ListBuffer[Long]\n        while (!lst2.isEmpty)\
    \ {\n            lst3 += lst2.head\n            lst2 = lst2.tail\n           \
    \ if (!lst2.isEmpty) {\n                lst3 += lst2.last\n                lst2\
    \ = lst2.init\n            }\n        }\n        lst3.toList", "        if (lst.length\
    \ == 0) return lst\n        val sorted = lst.sorted\n        val min = sorted.head\n\
    \        val max = sorted.last\n        val mid = sorted.slice(1, sorted.length\
    \ - 1)\n        val mid_even = mid.slice(0, mid.length / 2)\n        val mid_odd\
    \ = mid.slice(mid.length / 2, mid.length)\n        val result = ListBuffer[Long]()\n\
    \        result += min\n        for (i <- 0 until mid_even.length) {\n       \
    \     result += mid_odd(i)\n            result += mid_even(i)\n        }\n   \
    \     if (mid_odd.length > mid_even.length) result += mid_odd.last\n        result\
    \ += max\n        result.toList", "        if (lst.length == 0) return lst\n \
    \       var result = ListBuffer[Long]()\n        var min = lst.min\n        var\
    \ max = lst.max\n        var lst2 = lst.filter(x => x != min && x != max)\n  \
    \      var min_count = lst.count(x => x == min)\n        var max_count = lst.count(x\
    \ => x == max)\n        var min_max_count = min_count + max_count\n        var\
    \ min_max_count_half = min_max_count / 2\n        var min_max_count_half_remainder\
    \ = min_max_count % 2\n        var min_max_count_half_remainder_count = 0\n  \
    \      var min_max_count_half_remainder_count_max = 0\n        var min_max_count_half_remainder_count_min\
    \ = 0\n        if (min_max_count_half_remainder == 1) {\n            min_max_count_half_remainder_count_max\
    \ = min_max_count_half + 1\n            min_max_count_half_remainder_count_min\
    \ = min_max_count_half\n        } else {\n            min_max_count_half_remainder_count_max\
    \ = min_max_count_half\n            min_max_count_half_remainder_count_min = min_max_count_half\n\
    \        }\n        for (i <- 0 until min_max_count_half_remainder_count_max)\
    \ {\n            result += max\n        }\n        for (i <- 0 until min_max_count_half_remainder_count_min)\
    \ {\n            result += min\n        }\n        var lst3 = strangeSortList(lst2)\n\
    \        for (i <- 0 until lst3.length) {\n            result += lst3(i)\n   \
    \     }\n        return result.toList", "        val sorted = lst.sorted\n   \
    \     val result = new ListBuffer[Long]\n        var i = 0\n        var j = sorted.length\
    \ - 1\n        while (i <= j) {\n            result += sorted(i)\n           \
    \ if (i != j) result += sorted(j)\n            i += 1\n            j -= 1\n  \
    \      }\n        result.toList", "        if (lst.length == 0) return lst\n \
    \       var sorted = lst.sorted\n        var result = List[Long]()\n        var\
    \ i = 0\n        while (i < sorted.length) {\n            if (i % 2 == 0) result\
    \ = result :+ sorted(i)\n            else result = sorted(i) +: result\n     \
    \       i += 1\n        }\n        result", "        if (lst.length == 0) return\
    \ List()\n        val sorted = lst.sorted\n        val min = sorted.head\n   \
    \     val max = sorted.last\n        val (left, right) = sorted.tail.span(_ !=\
    \ max)\n        min :: max :: strangeSortList(left ::: right.tail)", "       \
    \ if (lst.length == 0) return lst\n        var result = ListBuffer[Long]()\n \
    \       var min = lst.min\n        var max = lst.max\n        var lst2 = lst.filter(x\
    \ => x != min && x != max)\n        var min_max = ListBuffer[Long]()\n       \
    \ min_max += min\n        min_max += max\n        var lst3 = lst2.to[ListBuffer]\n\
    \        var lst4 = lst3.to[ListBuffer]\n        while (lst3.length > 0) {\n \
    \           min = lst3.min\n            max = lst3.max\n            min_max +=\
    \ min\n            min_max += max\n            lst3 = lst3.filter(x => x != min\
    \ && x != max)\n        }\n        var i = 0\n        while (i < min_max.length)\
    \ {\n            result += min_max(i)\n            i += 2\n        }\n       \
    \ i = 1\n        while (i < min_max.length) {\n            result += min_max(i)\n\
    \            i += 2\n        }\n        return result.to[List]", "        if (lst.isEmpty)\
    \ return lst\n        val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = sorted.length - 1\n        while (i <= j)\
    \ {\n            result += sorted(i)\n            if (i != j) result += sorted(j)\n\
    \            i += 1\n            j -= 1\n        }\n        result.toList", " \
    \       if (lst.isEmpty) return lst\n        var min = lst.min\n        var max\
    \ = lst.max\n        var lst2 = lst.filter(x => x != min && x != max)\n      \
    \  var result = List(min)\n        var i = 0\n        while (!lst2.isEmpty) {\n\
    \            if (i % 2 == 0) {\n                result = result :+ lst2.max\n\
    \                lst2 = lst2.filter(x => x != lst2.max)\n            } else {\n\
    \                result = result :+ lst2.min\n                lst2 = lst2.filter(x\
    \ => x != lst2.min)\n            }\n            i += 1\n        }\n        if\
    \ (i % 2 == 0) result = result :+ max\n        else result = result :+ min\n \
    \       return result", "        if (lst.length == 0) return lst\n        val\
    \ sorted = lst.sorted\n        val result = new ListBuffer[Long]\n        var\
    \ i = 0\n        var j = sorted.length - 1\n        while (i <= j) {\n       \
    \     result += sorted(i)\n            if (i != j) result += sorted(j)\n     \
    \       i += 1\n            j -= 1\n        }\n        result.toList", "     \
    \   if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n        val\
    \ result = new ListBuffer[Long]\n        var i = 0\n        while (i < sorted.length)\
    \ {\n            result += sorted(i)\n            if (i + 1 < sorted.length) result\
    \ += sorted(sorted.length - i - 1)\n            i += 1\n        }\n        result.toList",
  "        if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n        val\
    \ result = new ListBuffer[Long]\n        var i = 0\n        var j = sorted.length\
    \ - 1\n        while (i <= j) {\n            result += sorted(i)\n           \
    \ if (i != j) result += sorted(j)\n            i += 1\n            j -= 1\n  \
    \      }\n        result.toList", "        val sorted = lst.sorted\n        val\
    \ n = sorted.length\n        val result = new Array[Long](n)\n        for (i <-\
    \ 0 until n) {\n            if (i % 2 == 0) result(i) = sorted(i / 2)\n      \
    \      else result(i) = sorted(n - 1 - i / 2)\n        }\n        result.toList",
  "        if (lst.isEmpty) return List()\n        val sorted = lst.sorted\n     \
    \   val min = sorted.head\n        val max = sorted.last\n        val mid = sorted.slice(1,\
    \ sorted.length - 1)\n        val res = ListBuffer[Long]()\n        var i = 0\n\
    \        while (i < mid.length) {\n            if (i % 2 == 0) res += mid(i)\n\
    \            else res += mid(mid.length - 1 - i)\n            i += 1\n       \
    \ }\n        if (mid.length % 2 == 0) res += max\n        else res += min\n  \
    \      res.toList", "        val sorted = lst.sorted\n        val result = new\
    \ ListBuffer[Long]\n        var i = 0\n        var j = sorted.length - 1\n   \
    \     while (i <= j) {\n            result += sorted(i)\n            if (i !=\
    \ j) result += sorted(j)\n            i += 1\n            j -= 1\n        }\n\
    \        result.toList", "        var lst2 = lst.sorted\n        var lst3 = ListBuffer[Long]()\n\
    \        while (lst2.length > 0) {\n            lst3 += lst2.head\n          \
    \  lst2 = lst2.tail\n            if (lst2.length > 0) {\n                lst3\
    \ += lst2.last\n                lst2 = lst2.init\n            }\n        }\n \
    \       lst3.toList", "        if (lst.isEmpty) return lst\n        var lst2 =\
    \ lst.sorted\n        var lst3 = ListBuffer[Long]()\n        while (!lst2.isEmpty)\
    \ {\n            lst3 += lst2.head\n            lst2 = lst2.tail\n           \
    \ if (!lst2.isEmpty) {\n                lst3 += lst2.last\n                lst2\
    \ = lst2.init\n            }\n        }\n        lst3.toList", "        if (lst.length\
    \ == 0) return lst\n        val sorted = lst.sorted\n        val result = new\
    \ ListBuffer[Long]\n        var i = 0\n        var j = sorted.length - 1\n   \
    \     while (i <= j) {\n            result += sorted(i)\n            if (i !=\
    \ j) result += sorted(j)\n            i += 1\n            j -= 1\n        }\n\
    \        result.toList", "        if (lst.length == 0) return lst\n        val\
    \ sorted = lst.sorted\n        val result = new ListBuffer[Long]\n        var\
    \ i = 0\n        var j = sorted.length - 1\n        while (i <= j) {\n       \
    \     result += sorted(i)\n            if (i != j) result += sorted(j)\n     \
    \       i += 1\n            j -= 1\n        }\n        result.toList", "     \
    \   if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n        val\
    \ min = sorted.head\n        val max = sorted.last\n        val (left, right)\
    \ = sorted.tail.init.partition(_ < max)\n        min :: strangeSortList(right\
    \ ::: List(max) ::: left)", "        if (lst.length == 0) return lst\n       \
    \ val sorted = lst.sorted\n        var result = ListBuffer[Long]()\n        var\
    \ i = 0\n        while (i < sorted.length) {\n            if (i % 2 == 0) result\
    \ += sorted(i)\n            else result += sorted(sorted.length - 1 - i)\n   \
    \         i += 1\n        }\n        result.toList", "        if (lst.length ==\
    \ 0) return lst\n        val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = sorted.length - 1\n        while (i <= j)\
    \ {\n            result += sorted(i)\n            if (i != j) result += sorted(j)\n\
    \            i += 1\n            j -= 1\n        }\n        result.toList", " \
    \       if (lst.isEmpty) return List()\n        val sorted = lst.sorted\n    \
    \    val result = new ListBuffer[Long]\n        var i = 0\n        var j = sorted.length\
    \ - 1\n        while (i <= j) {\n            result += sorted(i)\n           \
    \ if (i != j) result += sorted(j)\n            i += 1\n            j -= 1\n  \
    \      }\n        result.toList", "        if (lst.length == 0) return lst\n \
    \       var lst2 = lst.sortWith(_ < _)\n        var lst3 = ListBuffer[Long]()\n\
    \        while (lst2.length > 0) {\n            lst3 += lst2.head\n          \
    \  lst2 = lst2.tail\n            if (lst2.length > 0) {\n                lst3\
    \ += lst2.last\n                lst2 = lst2.init\n            }\n        }\n \
    \       lst3.toList", "        if (lst.length == 0) return List()\n        val\
    \ sorted = lst.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val min_index = lst.indexOf(min)\n        val max_index = lst.indexOf(max)\n\
    \        val new_lst = lst.updated(min_index, max).updated(max_index, min)\n \
    \       List(min) ::: strangeSortList(new_lst.slice(1, new_lst.length))", "  \
    \      if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n        var\
    \ result = List[Long]()\n        var i = 0\n        while (i < sorted.length)\
    \ {\n            if (i % 2 == 0) result = result :+ sorted(i)\n            else\
    \ result = sorted(i) +: result\n            i += 1\n        }\n        result",
  "        if (lst.isEmpty) return lst\n        var sorted = lst.sorted\n        var\
    \ result = ListBuffer[Long]()\n        while (sorted.nonEmpty) {\n           \
    \ result += sorted.head\n            sorted = sorted.tail\n            if (sorted.nonEmpty)\
    \ {\n                result += sorted.last\n                sorted = sorted.dropRight(1)\n\
    \            }\n        }\n        result.toList", "        if (lst.length ==\
    \ 0) return lst\n        var lst2 = lst.sorted\n        var lst3 = List[Long]()\n\
    \        while (lst2.length > 0) {\n            lst3 = lst3 :+ lst2.head\n   \
    \         lst2 = lst2.tail\n            if (lst2.length > 0) {\n             \
    \   lst3 = lst3 :+ lst2.last\n                lst2 = lst2.init\n            }\n\
    \        }\n        return lst3", "        if (lst.length == 0) return lst\n \
    \       var min = lst.min\n        var max = lst.max\n        var lst2 = lst.filter(x\
    \ => x != min && x != max)\n        var lst3 = List[Long]()\n        var i = 0\n\
    \        while (lst2.length > 0) {\n            if (i % 2 == 0) {\n          \
    \      lst3 = lst3 :+ min\n                min = lst2.min\n                lst2\
    \ = lst2.filter(x => x != min)\n            } else {\n                lst3 = lst3\
    \ :+ max\n                max = lst2.max\n                lst2 = lst2.filter(x\
    \ => x != max)\n            }\n            i += 1\n        }\n        if (i %\
    \ 2 == 0) lst3 = lst3 :+ min :+ max\n        else lst3 = lst3 :+ max :+ min\n\
    \        return lst3", "        if (lst.isEmpty) return lst\n        val sorted\
    \ = lst.sorted\n        val result = new ListBuffer[Long]\n        var i = 0\n\
    \        var j = sorted.length - 1\n        while (i <= j) {\n            result\
    \ += sorted(i)\n            if (i != j) result += sorted(j)\n            i +=\
    \ 1\n            j -= 1\n        }\n        result.toList", "        if (lst.length\
    \ == 0) return lst\n        var lst2 = lst.sorted\n        var lst3 = new ListBuffer[Long]\n\
    \        var i = 0\n        while (lst2.length > 0) {\n            if (i % 2 ==\
    \ 0) {\n                lst3 += lst2.head\n                lst2 = lst2.tail\n\
    \            } else {\n                lst3 += lst2.last\n                lst2\
    \ = lst2.init\n            }\n            i += 1\n        }\n        lst3.toList",
  "        if (lst.isEmpty) return lst\n        var result = List[Long]()\n      \
    \  var min = lst.min\n        var max = lst.max\n        var lst2 = lst.filter(x\
    \ => x != min && x != max)\n        result = result :+ min\n        result = result\
    \ :+ max\n        while (!lst2.isEmpty) {\n            min = lst2.min\n      \
    \      max = lst2.max\n            result = result :+ min\n            result\
    \ = result :+ max\n            lst2 = lst2.filter(x => x != min && x != max)\n\
    \        }\n        return result", "        if (lst.length == 0) return lst\n\
    \        val sorted = lst.sorted\n        val (left, right) = sorted.splitAt(lst.length\
    \ / 2)\n        val (left_min, left_max) = (left.head, left.last)\n        val\
    \ (right_min, right_max) = (right.head, right.last)\n        val left_min_max\
    \ = if (left.length % 2 == 0) left_max else left_min\n        val right_min_max\
    \ = if (right.length % 2 == 0) right_max else right_min\n        List(left_min,\
    \ right_min_max) ::: strangeSortList(left.tail.init ::: right.tail.init) ::: List(left_min_max,\
    \ right_min)", "        if (lst.length == 0) return List()\n        var min =\
    \ lst.min\n        var max = lst.max\n        var lst2 = lst.filter(x => x !=\
    \ min && x != max)\n        var lst3 = List(min, max)\n        while (lst2.length\
    \ > 0) {\n            min = lst2.min\n            max = lst2.max\n           \
    \ lst3 = lst3 :+ min\n            lst3 = lst3 :+ max\n            lst2 = lst2.filter(x\
    \ => x != min && x != max)\n        }\n        return lst3", "        if (lst.isEmpty)\
    \ return lst\n        var lst2 = lst.sorted\n        var lst3 = ListBuffer[Long]()\n\
    \        var i = 0\n        while (lst2.nonEmpty) {\n            if (i % 2 ==\
    \ 0) {\n                lst3 += lst2.head\n                lst2 = lst2.tail\n\
    \            } else {\n                lst3 += lst2.last\n                lst2\
    \ = lst2.init\n            }\n            i += 1\n        }\n        lst3.toList",
  "        if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n        val\
    \ n = lst.length\n        val result = new Array[Long](n)\n        var i = 0\n\
    \        var j = 0\n        while (i < n) {\n            if (i % 2 == 0) {\n \
    \               result(i) = sorted(j)\n                j += 1\n            } else\
    \ {\n                result(i) = sorted(n - j)\n            }\n            i +=\
    \ 1\n        }\n        result.toList", "        val sorted = lst.sorted\n   \
    \     val result = new ListBuffer[Long]\n        var i = 0\n        while (i <\
    \ sorted.length) {\n            if (i % 2 == 0) result += sorted(i)\n        \
    \    else result += sorted(sorted.length - 1 - i)\n            i += 1\n      \
    \  }\n        result.toList", "        val sorted = lst.sorted\n        val result\
    \ = new ListBuffer[Long]\n        var i = 0\n        while (i < sorted.length)\
    \ {\n            if (i % 2 == 0) result += sorted(i)\n            else result\
    \ += sorted(sorted.length - 1 - i)\n            i += 1\n        }\n        result.toList",
  "        if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n        val\
    \ result = new ListBuffer[Long]\n        var i = 0\n        var j = sorted.length\
    \ - 1\n        while (i <= j) {\n            result += sorted(i)\n           \
    \ if (i != j) result += sorted(j)\n            i += 1\n            j -= 1\n  \
    \      }\n        result.toList", "        if (lst.length == 0) return List()\n\
    \        var lst2 = lst.sorted\n        var lst3 = ListBuffer[Long]()\n      \
    \  var i = 0\n        while (lst2.length > 0) {\n            if (i % 2 == 0) {\n\
    \                lst3 += lst2.head\n                lst2 = lst2.tail\n       \
    \     } else {\n                lst3 += lst2.last\n                lst2 = lst2.dropRight(1)\n\
    \            }\n            i += 1\n        }\n        lst3.toList", "       \
    \ val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n       \
    \ var i = 0\n        while (i < sorted.length) {\n            if (i % 2 == 0)\
    \ {\n                result += sorted(i)\n            } else {\n             \
    \   result += sorted(sorted.length - 1 - i)\n            }\n            i += 1\n\
    \        }\n        result.toList", "        if (lst.isEmpty) return lst\n   \
    \     val sorted = lst.sorted\n        var result = ListBuffer[Long]()\n     \
    \   var i = 0\n        var j = sorted.length - 1\n        while (i <= j) {\n \
    \           result += sorted(i)\n            if (i != j) result += sorted(j)\n\
    \            i += 1\n            j -= 1\n        }\n        result.toList", " \
    \       var result = List[Long]()\n        var lst2 = lst.sorted\n        var\
    \ i = 0\n        while (i < lst2.length) {\n            if (i % 2 == 0) result\
    \ = result :+ lst2(i)\n            else result = lst2(i) +: result\n         \
    \   i += 1\n        }\n        result", "        if (lst.length == 0) return lst\n\
    \        var min = lst.min\n        var max = lst.max\n        var lst2 = lst.filter(x\
    \ => x != min && x != max)\n        var lst3 = List[Long]()\n        var i = 0\n\
    \        while (i < lst.length) {\n            if (i % 2 == 0) {\n           \
    \     lst3 = lst3 :+ min\n                min = lst2.min\n                lst2\
    \ = lst2.filter(x => x != min)\n            } else {\n                lst3 = lst3\
    \ :+ max\n                max = lst2.max\n                lst2 = lst2.filter(x\
    \ => x != max)\n            }\n            i += 1\n        }\n        lst3", " \
    \       if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n       \
    \ val n = lst.length\n        val result = new Array[Long](n)\n        var i =\
    \ 0\n        var j = 0\n        var k = n - 1\n        while (i < n) {\n     \
    \       if (i % 2 == 0) {\n                result(i) = sorted(j)\n           \
    \     j += 1\n            } else {\n                result(i) = sorted(k)\n  \
    \              k -= 1\n            }\n            i += 1\n        }\n        result.toList",
  "        if (lst.isEmpty) return lst\n        var lst2 = lst.sorted\n        var\
    \ lst3 = ListBuffer[Long]()\n        var i = 0\n        while (lst2.length > 0)\
    \ {\n            if (i % 2 == 0) {\n                lst3 += lst2.head\n      \
    \          lst2 = lst2.tail\n            } else {\n                lst3 += lst2.last\n\
    \                lst2 = lst2.dropRight(1)\n            }\n            i += 1\n\
    \        }\n        lst3.toList", "        if (lst.isEmpty) return lst\n     \
    \   val sorted = lst.sorted\n        val min = sorted.head\n        val max =\
    \ sorted.last\n        val min_index = lst.indexOf(min)\n        val max_index\
    \ = lst.indexOf(max)\n        val lst_without_min = lst.take(min_index) ++ lst.drop(min_index\
    \ + 1)\n        val lst_without_min_and_max = lst_without_min.take(max_index -\
    \ 1) ++ lst_without_min.drop(max_index)\n        val lst_without_max = lst.take(max_index)\
    \ ++ lst.drop(max_index + 1)\n        val lst_without_max_and_min = lst_without_max.take(min_index)\
    \ ++ lst_without_max.drop(min_index + 1)\n        val lst_without_min_and_max_and_min\
    \ = lst_without_min_and_max.take(min_index) ++ lst_without_min_and_max.drop(min_index\
    \ + 1)\n        val lst_without_min_and_max_and_max = lst_without_min_and_max.take(max_index\
    \ - 1) ++ lst_without_min_and_max.drop(max_index)\n        val lst_without_max_and_min_and_min\
    \ = lst_without_max_and_min.take(min_index) ++ lst_without_max_and_min.drop(min_index\
    \ + 1)\n        val lst_without_max_and_min_and_max = lst_without_max_and_min.take(max_index\
    \ - 1) ++ lst_without_max_and_min.drop(max_index)\n        val lst_without_min_and_max_and_min_and_max\
    \ = lst_without_min_and_max_and_min.take(max_index - 1) ++ lst_without_min_and_max_and_min.drop(max_index)\n\
    \        val lst_without_", "        if (lst.length == 0) return lst\n       \
    \ val sorted = lst.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val mid = sorted.slice(1, sorted.length - 1)\n        val mid_sorted\
    \ = mid.sortWith(_ > _)\n        List(min) ::: mid_sorted ::: List(max)", "  \
    \      val sorted = lst.sorted\n        val (min, max) = (sorted.head, sorted.last)\n\
    \        val (min_lst, max_lst) = (sorted.filter(_ != min), sorted.filter(_ !=\
    \ max))\n        val min_max_lst = (min_lst.zip(max_lst)).flatMap(x => List(x._1,\
    \ x._2))\n        if (min_lst.length == 0) List(min)\n        else if (min_lst.length\
    \ == 1) List(min, max)\n        else List(min) ++ min_max_lst ++ List(max)", " \
    \       if (lst.length == 0) return lst\n        val sorted = lst.sorted\n   \
    \     val result = new ListBuffer[Long]\n        var i = 0\n        while (i <\
    \ sorted.length) {\n            if (i % 2 == 0) result += sorted(i)\n        \
    \    else result += sorted(sorted.length - 1 - i)\n            i += 1\n      \
    \  }\n        result.toList", "        if (lst.length == 0) return lst\n     \
    \   val sorted = lst.sorted\n        val min = sorted.head\n        val max =\
    \ sorted.last\n        val mid = sorted.slice(1, sorted.length - 1)\n        val\
    \ mid_sorted = mid.sortWith(_ > _)\n        val result = min :: max :: mid_sorted\n\
    \        result", "        if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n\
    \        val result = new ListBuffer[Long]\n        var i = 0\n        var j =\
    \ sorted.length - 1\n        while (i <= j) {\n            result += sorted(i)\n\
    \            if (i != j) result += sorted(j)\n            i += 1\n           \
    \ j -= 1\n        }\n        result.toList", "        var result = List[Long]()\n\
    \        var remaining = lst.sorted\n        while (remaining.length > 0) {\n\
    \            result = result :+ remaining.head\n            remaining = remaining.tail\n\
    \            if (remaining.length > 0) {\n                result = result :+ remaining.last\n\
    \                remaining = remaining.init\n            }\n        }\n      \
    \  result", "        val sorted = lst.sorted\n        val min = sorted.head\n\
    \        val max = sorted.last\n        val mid = sorted.slice(1, sorted.length\
    \ - 1)\n        val result = new ListBuffer[Long]\n        result += min\n   \
    \     var i = 0\n        while (i < mid.length) {\n            if (i % 2 == 0)\
    \ result += mid(i)\n            else result += mid(mid.length - 1 - i)\n     \
    \       i += 1\n        }\n        result += max\n        result.toList", "  \
    \      if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n        val\
    \ min = sorted.head\n        val max = sorted.last\n        val (left, right)\
    \ = sorted.tail.init.splitAt(sorted.tail.init.length / 2)\n        val left_sorted\
    \ = left.sorted\n        val right_sorted = right.sorted\n        val left_max\
    \ = left_sorted.last\n        val right_min = right_sorted.head\n        val left_rest\
    \ = left_sorted.init\n        val right_rest = right_sorted.tail\n        List(min)\
    \ ++ strangeSortList(left_rest) ++ List(left_max) ++ strangeSortList(right_rest)\
    \ ++ List(right_min) ++ List(max)", "        if (lst.isEmpty) return List()\n\
    \        val sorted = lst.sorted\n        val min = sorted.head\n        val max\
    \ = sorted.last\n        val mid = sorted.slice(1, sorted.length - 1)\n      \
    \  val mid_min = mid.slice(0, mid.length / 2)\n        val mid_max = mid.slice(mid.length\
    \ / 2, mid.length)\n        val result = ListBuffer[Long]()\n        result +=\
    \ min\n        result ++= mid_max\n        result ++= mid_min\n        result\
    \ += max\n        result.toList", "        if (lst.isEmpty) return lst\n     \
    \   val sorted = lst.sorted\n        val min = sorted.head\n        val max =\
    \ sorted.last\n        val (left, right) = sorted.tail.init.partition(_ < max)\n\
    \        val result = ListBuffer[Long]()\n        result += min\n        while\
    \ (left.nonEmpty && right.nonEmpty) {\n            result += left.last\n     \
    \       result += right.head\n            left.trimEnd(1)\n            right.trimStart(1)\n\
    \        }\n        result += max\n        result.toList", "        val sorted\
    \ = lst.sorted\n        val result = new ListBuffer[Long]\n        var i = 0\n\
    \        var j = sorted.length - 1\n        while (i <= j) {\n            result\
    \ += sorted(i)\n            if (i != j) result += sorted(j)\n            i +=\
    \ 1\n            j -= 1\n        }\n        result.toList", "        if (lst.isEmpty)\
    \ return lst\n        val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        while (i < sorted.length) {\n            if (i % 2\
    \ == 0) result += sorted(i)\n            else result += sorted(sorted.length -\
    \ 1 - i)\n            i += 1\n        }\n        result.toList", "        if (lst.isEmpty)\
    \ return lst\n        var lst2 = lst.sorted\n        var result = ListBuffer[Long]()\n\
    \        while (lst2.nonEmpty) {\n            result += lst2.head\n          \
    \  lst2 = lst2.tail\n            if (lst2.nonEmpty) {\n                result\
    \ += lst2.last\n                lst2 = lst2.init\n            }\n        }\n \
    \       result.toList", "        if (lst.length == 0) return lst\n        var\
    \ result = ListBuffer[Long]()\n        var lst2 = lst.sorted\n        var i =\
    \ 0\n        while (lst2.length > 0) {\n            result += lst2(i)\n      \
    \      lst2 = lst2.slice(0, i) ++ lst2.slice(i + 1, lst2.length)\n           \
    \ i = (i + 1) % 2\n        }\n        return result.toList", "        if (lst.isEmpty)\
    \ return lst\n        var lst2 = lst.sorted\n        var lst3 = ListBuffer[Long]()\n\
    \        var i = 0\n        while (lst2.length > 0) {\n            if (i % 2 ==\
    \ 0) {\n                lst3 += lst2.head\n                lst2 = lst2.tail\n\
    \            } else {\n                lst3 += lst2.last\n                lst2\
    \ = lst2.init\n            }\n            i += 1\n        }\n        lst3.toList",
  "        if (lst.length == 0) return lst\n        var result = new ListBuffer[Long]\n\
    \        var min = lst.min\n        var max = lst.max\n        var lst2 = lst.filter(x\
    \ => x != min && x != max)\n        result += min\n        result += max\n   \
    \     var i = 0\n        while (lst2.length > 0) {\n            if (i % 2 == 0)\
    \ {\n                min = lst2.min\n                result += min\n         \
    \       lst2 = lst2.filter(x => x != min)\n            } else {\n            \
    \    max = lst2.max\n                result += max\n                lst2 = lst2.filter(x\
    \ => x != max)\n            }\n            i += 1\n        }\n        return result.toList",
  "        if (lst.isEmpty) return lst\n        var sorted = lst.sorted\n        var\
    \ result = ListBuffer[Long]()\n        var i = 0\n        while (i < sorted.length)\
    \ {\n            if (i % 2 == 0) result += sorted(i)\n            else result\
    \ += sorted(sorted.length - 1 - i)\n            i += 1\n        }\n        return\
    \ result.toList", "        val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        while (i < sorted.length) {\n            if (i % 2\
    \ == 0) result += sorted(i)\n            else result += sorted(sorted.length -\
    \ 1 - i)\n            i += 1\n        }\n        result.toList", "        val\
    \ sorted = lst.sorted\n        val result = new ListBuffer[Long]\n        var\
    \ i = 0\n        while (i < sorted.length) {\n            if (i % 2 == 0) result\
    \ += sorted(i)\n            else result += sorted(sorted.length - 1 - i)\n   \
    \         i += 1\n        }\n        result.toList", "        if (lst.isEmpty)\
    \ return lst\n        var min = lst.min\n        var max = lst.max\n        var\
    \ lst2 = lst.filter(x => x != min && x != max)\n        var lst3 = List[Long]()\n\
    \        while (lst2.nonEmpty) {\n            min = lst2.min\n            max\
    \ = lst2.max\n            lst3 = lst3 :+ min\n            lst3 = lst3 :+ max\n\
    \            lst2 = lst2.filter(x => x != min && x != max)\n        }\n      \
    \  lst3 :+ min :+ max", "        if (lst.length == 0) return lst\n        var\
    \ min = lst.min\n        var max = lst.max\n        var lst2 = lst.filter(x =>\
    \ x != min && x != max)\n        var lst3 = List[Long]()\n        var i = 0\n\
    \        while (lst2.length > 0) {\n            if (i % 2 == 0) {\n          \
    \      lst3 = lst3 :+ min\n                min = lst2.min\n                lst2\
    \ = lst2.filter(x => x != min)\n            } else {\n                lst3 = lst3\
    \ :+ max\n                max = lst2.max\n                lst2 = lst2.filter(x\
    \ => x != max)\n            }\n            i += 1\n        }\n        if (i %\
    \ 2 == 0) lst3 = lst3 :+ min :+ max\n        else lst3 = lst3 :+ max :+ min\n\
    \        return lst3", "        if (lst.length == 0) return lst\n        var result\
    \ = List[Long]()\n        var min = lst.min\n        var max = lst.max\n     \
    \   var lst2 = lst.filter(x => x != min && x != max)\n        var min_max = List(min,\
    \ max)\n        var min_max_index = 0\n        while (lst2.length > 0) {\n   \
    \         result = result :+ min_max(min_max_index)\n            min_max_index\
    \ = (min_max_index + 1) % 2\n            min = lst2.min\n            max = lst2.max\n\
    \            lst2 = lst2.filter(x => x != min && x != max)\n            min_max\
    \ = List(min, max)\n        }\n        result = result :+ min_max(min_max_index)\n\
    \        return result", "        if (lst.isEmpty) return lst\n        val sorted\
    \ = lst.sorted\n        val result = new ListBuffer[Long]\n        var i = 0\n\
    \        var j = sorted.length - 1\n        while (i <= j) {\n            result\
    \ += sorted(i)\n            if (i != j) result += sorted(j)\n            i +=\
    \ 1\n            j -= 1\n        }\n        result.toList", "        if (lst.isEmpty)\
    \ return lst\n        var result = List[Long]()\n        var min = lst.min\n \
    \       var max = lst.max\n        var lst2 = lst.filter(x => x != min && x !=\
    \ max)\n        result = result :+ min\n        result = result :+ max\n     \
    \   while (!lst2.isEmpty) {\n            min = lst2.min\n            max = lst2.max\n\
    \            result = result :+ min\n            result = result :+ max\n    \
    \        lst2 = lst2.filter(x => x != min && x != max)\n        }\n        return\
    \ result", "        if (lst.length == 0) return List()\n        var result = ListBuffer[Long]()\n\
    \        var remaining = lst.toBuffer\n        while (remaining.length > 0) {\n\
    \            result += remaining.min\n            remaining -= remaining.min\n\
    \            if (remaining.length > 0) {\n                result += remaining.max\n\
    \                remaining -= remaining.max\n            }\n        }\n      \
    \  return result.toList", "        if (lst.length == 0) return lst\n        var\
    \ lst2 = lst.sorted\n        var lst3 = ListBuffer[Long]()\n        var i = 0\n\
    \        while (lst2.length > 0) {\n            if (i % 2 == 0) {\n          \
    \      lst3 += lst2.head\n                lst2 = lst2.tail\n            } else\
    \ {\n                lst3 += lst2.last\n                lst2 = lst2.init\n   \
    \         }\n            i += 1\n        }\n        lst3.toList", "        if\
    \ (lst.isEmpty) return List()\n        var lst2 = lst.sorted\n        var result\
    \ = ListBuffer[Long]()\n        var min = lst2.head\n        var max = lst2.last\n\
    \        var minIndex = 0\n        var maxIndex = lst2.length - 1\n        var\
    \ isMin = true\n        while (minIndex <= maxIndex) {\n            if (isMin)\
    \ {\n                result += lst2(minIndex)\n                minIndex += 1\n\
    \            } else {\n                result += lst2(maxIndex)\n            \
    \    maxIndex -= 1\n            }\n            isMin = !isMin\n        }\n   \
    \     return result.toList", "        if (lst.isEmpty) lst\n        else {\n \
    \           val min = lst.min\n            val max = lst.max\n            val\
    \ minIndex = lst.indexOf(min)\n            val maxIndex = lst.indexOf(max)\n \
    \           val newList = lst.toBuffer\n            newList.remove(minIndex)\n\
    \            newList.remove(maxIndex - 1)\n            min :: max :: strangeSortList(newList.toList)\n\
    \        }", '        lst.sortWith(_ < _).grouped(2).flatMap(x => if (x.length
    == 2) List(x(0), x(1)) else List(x(0))).toList', "        if (lst.isEmpty) return\
    \ lst\n        var lst2 = lst.sorted\n        var lst3 = new ListBuffer[Long]\n\
    \        var i = 0\n        while (lst2.nonEmpty) {\n            if (i % 2 ==\
    \ 0) {\n                lst3 += lst2.head\n                lst2 = lst2.tail\n\
    \            } else {\n                lst3 += lst2.last\n                lst2\
    \ = lst2.init\n            }\n            i += 1\n        }\n        lst3.toList",
  "        if (lst.length == 0) return lst\n        val sorted = lst.sorted\n    \
    \    val min = sorted.head\n        val max = sorted.last\n        val mid = sorted.slice(1,\
    \ sorted.length - 1)\n        val mid_sorted = mid.sorted\n        val mid_sorted_reverse\
    \ = mid_sorted.reverse\n        val result = ListBuffer[Long]()\n        result\
    \ += min\n        for (i <- 0 until mid.length) {\n            if (i % 2 == 0)\
    \ result += mid_sorted(i)\n            else result += mid_sorted_reverse(i)\n\
    \        }\n        result += max\n        result.toList", "        if (lst.isEmpty)\
    \ return lst\n        var lst2 = lst.sorted\n        var lst3 = List[Long]()\n\
    \        while (!lst2.isEmpty) {\n            lst3 = lst3 :+ lst2.head\n     \
    \       lst2 = lst2.tail\n            if (!lst2.isEmpty) {\n                lst3\
    \ = lst3 :+ lst2.last\n                lst2 = lst2.init\n            }\n     \
    \   }\n        lst3", "        if (lst.isEmpty) return lst\n        val sorted\
    \ = lst.sorted\n        val n = sorted.length\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        while (i < n) {\n            result += sorted(i)\n\
    \            if (i + 1 < n) result += sorted(n - i - 1)\n            i += 1\n\
    \        }\n        result.toList", "        if (lst.length == 0) return lst\n\
    \        val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = sorted.length - 1\n        while (i <= j)\
    \ {\n            result += sorted(i)\n            if (i != j) result += sorted(j)\n\
    \            i += 1\n            j -= 1\n        }\n        result.toList", " \
    \       if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n       \
    \ val (min, max) = (sorted.head, sorted.last)\n        val (min_list, max_list)\
    \ = (sorted.filter(_ != min), sorted.filter(_ != max))\n        val min_list_sorted\
    \ = min_list.sorted\n        val max_list_sorted = max_list.sorted\n        val\
    \ min_list_sorted_reversed = min_list_sorted.reverse\n        val max_list_sorted_reversed\
    \ = max_list_sorted.reverse\n        val min_list_sorted_reversed_padded = min_list_sorted_reversed\
    \ :+ 0\n        val max_list_sorted_reversed_padded = max_list_sorted_reversed\
    \ :+ 0\n        val min_list_sorted_reversed_padded_zip = min_list_sorted_reversed_padded.zip(max_list_sorted_reversed_padded)\n\
    \        val min_list_sorted_reversed_padded_zip_flatten = min_list_sorted_reversed_padded_zip.flatten\n\
    \        val min_list_sorted_reversed_padded_zip_flatten_filtered = min_list_sorted_reversed_padded_zip_flatten.filter(_\
    \ != 0)\n        val min_list_sorted_reversed_padded_zip_flatten_filtered_padded\
    \ = min_list_sorted_reversed_padded_zip_flatten_filtered :+ min\n        val min_list_sorted_reversed_padded_zip_flatten_filtered_padded_padded\
    \ = min_list_sorted_reversed_padded_zip_flatten_filtered_padded :+ max\n     \
    \   min_list_sorted_reversed_padded_zip_flatten_filtered_padded_padded", "   \
    \     if (lst.length == 0) return lst\n        val sorted = lst.sorted\n     \
    \   val result = new ListBuffer[Long]\n        var i = 0\n        var j = sorted.length\
    \ - 1\n        while (i <= j) {\n            result += sorted(i)\n           \
    \ if (i != j) result += sorted(j)\n            i += 1\n            j -= 1\n  \
    \      }\n        result.toList", "        if (lst.length == 0) return lst\n \
    \       val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n \
    \       var i = 0\n        var j = sorted.length - 1\n        while (i <= j) {\n\
    \            result += sorted(i)\n            if (i != j) result += sorted(j)\n\
    \            i += 1\n            j -= 1\n        }\n        result.toList", " \
    \       if (lst.length == 0) return lst\n        val sorted = lst.sorted\n   \
    \     val min = sorted.head\n        val max = sorted.last\n        val mid =\
    \ sorted.slice(1, sorted.length - 1)\n        val result = ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < mid.length) {\n            if (i % 2 ==\
    \ 0) {\n                result += mid(i)\n            } else {\n             \
    \   result.insert(0, mid(i))\n            }\n            i += 1\n        }\n \
    \       result.insert(0, min)\n        result += max\n        result.toList",
  "        if (lst.length == 0) return lst\n        var result = List[Long]()\n  \
    \      var sorted = lst.sorted\n        var min = sorted.head\n        var max\
    \ = sorted.last\n        var minIndex = lst.indexOf(min)\n        var maxIndex\
    \ = lst.indexOf(max)\n        var minUsed = false\n        var maxUsed = false\n\
    \        for (i <- 0 until lst.length) {\n            if (i % 2 == 0) {\n    \
    \            if (minIndex == i) {\n                    result = result :+ min\n\
    \                    minUsed = true\n                } else if (maxIndex == i)\
    \ {\n                    result = result :+ max\n                    maxUsed =\
    \ true\n                } else {\n                    if (minUsed) {\n       \
    \                 result = result :+ lst(maxIndex)\n                        maxIndex\
    \ = i\n                    } else {\n                        result = result :+\
    \ lst(minIndex)\n                        minIndex = i\n                    }\n\
    \                }\n            } else {\n                if (maxIndex == i) {\n\
    \                    result = result :+ max\n                    maxUsed = true\n\
    \                } else if (minIndex == i) {\n                    result = result\
    \ :+ min\n                    minUsed = true\n                } else {\n     \
    \               if (maxUsed) {\n                        result = result :+ lst(minIndex)\n\
    \                        minIndex = i\n                    } else {\n        \
    \                result = result :+ lst(maxIndex)\n                        maxIndex\
    \ = i\n                    }\n                }\n            }\n        }\n  \
    \      return result", "        if (lst.isEmpty) return lst\n        val sorted\
    \ = lst.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val (left, right) = sorted.tail.splitAt(sorted.length / 2)\n        val\
    \ left_sorted = left.sorted\n        val right_sorted = right.sorted\n       \
    \ val left_sorted_reversed = left_sorted.reverse\n        val right_sorted_reversed\
    \ = right_sorted.reverse\n        val left_sorted_reversed_with_min = min :: left_sorted_reversed\n\
    \        val right_sorted_reversed_with_max = right_sorted_reversed :+ max\n \
    \       val left_sorted_reversed_with_min_and_right_sorted_reversed_with_max =\
    \ left_sorted_reversed_with_min ::: right_sorted_reversed_with_max\n        left_sorted_reversed_with_min_and_right_sorted_reversed_with_max",
  "        if (lst.isEmpty) return lst\n        val min = lst.min\n        val max\
    \ = lst.max\n        val minIndex = lst.indexOf(min)\n        val maxIndex = lst.indexOf(max)\n\
    \        val lst1 = lst.patch(minIndex, Nil, 1)\n        val lst2 = lst1.patch(maxIndex\
    \ - 1, Nil, 1)\n        val lst3 = lst2.patch(minIndex, List(max), 0)\n      \
    \  val lst4 = lst3.patch(maxIndex - 1, List(min), 0)\n        return List(min)\
    \ ::: strangeSortList(lst4)", "        val sorted = lst.sorted\n        val result\
    \ = new ListBuffer[Long]\n        var i = 0\n        while (i < sorted.length)\
    \ {\n            if (i % 2 == 0) result += sorted(i)\n            else result\
    \ += sorted(sorted.length - 1 - i)\n            i += 1\n        }\n        result.toList",
  "        if (lst.isEmpty) return lst\n        val sorted = lst.sorted\n        val\
    \ min = sorted.head\n        val max = sorted.last\n        val mid = sorted.slice(1,\
    \ sorted.length - 1)\n        val mid_sorted = if (mid.length % 2 == 0) mid.sorted\
    \ else mid.sorted.reverse\n        val mid_sorted_pairs = mid_sorted.grouped(2).toList\n\
    \        val mid_sorted_pairs_flattened = mid_sorted_pairs.flatten\n        val\
    \ mid_sorted_pairs_flattened_reversed = mid_sorted_pairs_flattened.reverse\n \
    \       val result = List(min) ::: mid_sorted_pairs_flattened_reversed ::: List(max)\n\
    \        result", "        if (lst.length == 0) return List()\n        var lst2\
    \ = lst.sorted\n        var lst3 = ListBuffer[Long]()\n        while (lst2.length\
    \ > 0) {\n            lst3 += lst2.head\n            lst2 = lst2.tail\n      \
    \      if (lst2.length > 0) {\n                lst3 += lst2.last\n           \
    \     lst2 = lst2.init\n            }\n        }\n        return lst3.toList",
  "        if (lst.isEmpty) return List[Long]()\n        val sorted = lst.sorted\n\
    \        val (left, right) = sorted.splitAt(sorted.length / 2)\n        val left_min\
    \ = left.head\n        val right_max = right.last\n        val left_remaining\
    \ = left.tail\n        val right_remaining = right.init\n        val left_remaining_sorted\
    \ = left_remaining.sorted\n        val right_remaining_sorted = right_remaining.sorted\n\
    \        val left_remaining_sorted_reversed = left_remaining_sorted.reverse\n\
    \        val right_remaining_sorted_reversed = right_remaining_sorted.reverse\n\
    \        val left_remaining_sorted_reversed_min = left_remaining_sorted_reversed.head\n\
    \        val right_remaining_sorted_reversed_max = right_remaining_sorted_reversed.last\n\
    \        val left_remaining_sorted_reversed_remaining = left_remaining_sorted_reversed.tail\n\
    \        val right_remaining_sorted_reversed_remaining = right_remaining_sorted_reversed.init\n\
    \        val left_remaining_sorted_reversed_remaining_sorted = left_remaining_sorted_reversed_remaining.sorted\n\
    \        val right_remaining_sorted_reversed_remaining_sorted = right_remaining_sorted_reversed_remaining.sorted\n\
    \        val left_remaining_sorted_reversed_remaining_sorted_reversed = left_remaining_sorted_reversed_remaining_sorted.reverse\n\
    \        val right_remaining_sorted_reversed_remaining_sorted_reversed = right_remaining_sorted_reversed_remaining_sorted.reverse\n\
    \        val left_remaining_sorted_reversed_remaining_sorted_reversed_min = left_remaining_sorted_reversed_remaining_sorted_reversed.head\n\
    \        val", "        if (lst.isEmpty) return lst\n        var sorted = lst.sorted\n\
    \        var result = ListBuffer[Long]()\n        var i = 0\n        while (sorted.length\
    \ > 0) {\n            if (i % 2 == 0) {\n                result += sorted.head\n\
    \                sorted = sorted.tail\n            } else {\n                result\
    \ += sorted.last\n                sorted = sorted.init\n            }\n      \
    \      i += 1\n        }\n        result.toList", "        if (lst.length == 0)\
    \ return lst\n        var lst2 = lst.sorted\n        var lst3 = ListBuffer[Long]()\n\
    \        var i = 0\n        while (lst2.length > 0) {\n            if (i % 2 ==\
    \ 0) {\n                lst3 += lst2.head\n                lst2 = lst2.tail\n\
    \            } else {\n                lst3 += lst2.last\n                lst2\
    \ = lst2.init\n            }\n            i += 1\n        }\n        lst3.toList",
  "        val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n  \
    \      var i = 0\n        while (i < sorted.length) {\n            if (i % 2 ==\
    \ 0) result += sorted(i)\n            else result += sorted(sorted.length - 1\
    \ - i)\n            i += 1\n        }\n        result.toList", "        if (lst.length\
    \ == 0) return lst\n        var lst2 = lst.sorted\n        var lst3 = ListBuffer[Long]()\n\
    \        while (lst2.length > 0) {\n            lst3 += lst2.head\n          \
    \  lst2 = lst2.tail\n            if (lst2.length > 0) {\n                lst3\
    \ += lst2.last\n                lst2 = lst2.dropRight(1)\n            }\n    \
    \    }\n        lst3.toList", "        if (lst.length == 0) return lst\n     \
    \   var min = lst.min\n        var max = lst.max\n        var lst2 = lst.filter(x\
    \ => x != min && x != max)\n        var result = List(min)\n        var i = 0\n\
    \        while (lst2.length > 0) {\n            if (i % 2 == 0) {\n          \
    \      min = lst2.min\n                result = result :+ min\n              \
    \  lst2 = lst2.filter(x => x != min)\n            } else {\n                max\
    \ = lst2.max\n                result = result :+ max\n                lst2 = lst2.filter(x\
    \ => x != max)\n            }\n            i += 1\n        }\n        if (lst.length\
    \ % 2 == 0) result = result :+ max\n        return result", "        if (lst.isEmpty)\
    \ return lst\n        val sorted = lst.sorted\n        val n = sorted.length\n\
    \        val result = new ListBuffer[Long]\n        var i = 0\n        while (i\
    \ < n) {\n            result += sorted(i)\n            i += 1\n            if\
    \ (i < n) result += sorted(n - i)\n        }\n        result.toList", "      \
    \  if (lst.isEmpty) return List()\n        val sorted = lst.sorted\n        val\
    \ min = sorted.head\n        val max = sorted.last\n        val min_max = List(min,\
    \ max)\n        val rest = sorted.slice(1, sorted.length - 1)\n        val rest_sorted\
    \ = strangeSortList(rest)\n        val result = min_max ::: rest_sorted\n    \
    \    return result", "        if (lst.isEmpty) return List()\n        var min\
    \ = lst.min\n        var max = lst.max\n        var lst2 = lst.filter(x => x !=\
    \ min && x != max)\n        var lst3 = List(min, max)\n        while (!lst2.isEmpty)\
    \ {\n            min = lst2.min\n            max = lst2.max\n            lst3\
    \ = lst3 ::: List(min, max)\n            lst2 = lst2.filter(x => x != min && x\
    \ != max)\n        }\n        return lst3", "        if (lst.length == 0) return\
    \ lst\n        val sorted = lst.sorted\n        val min = sorted.head\n      \
    \  val max = sorted.last\n        val mid = sorted.slice(1, sorted.length - 1)\n\
    \        val mid_even = mid.slice(0, mid.length / 2)\n        val mid_odd = mid.slice(mid.length\
    \ / 2, mid.length)\n        val mid_even_rev = mid_even.reverse\n        val mid_odd_rev\
    \ = mid_odd.reverse\n        val result = ListBuffer[Long]()\n        result +=\
    \ min\n        for (i <- 0 until mid_even.length) {\n            result += mid_even_rev(i)\n\
    \            result += mid_odd(i)\n        }\n        if (mid_odd.length > mid_even.length)\
    \ result += mid_odd_rev.head\n        result += max\n        result.toList", " \
    \       if (lst.isEmpty) return lst\n        var min = lst.min\n        var max\
    \ = lst.max\n        var lst2 = lst.filter(x => x != min && x != max)\n      \
    \  var result = List[Long]()\n        var flag = true\n        while (!lst2.isEmpty)\
    \ {\n            if (flag) {\n                result = result :+ min\n       \
    \         min = lst2.min\n                lst2 = lst2.filter(x => x != min)\n\
    \            } else {\n                result = result :+ max\n              \
    \  max = lst2.max\n                lst2 = lst2.filter(x => x != max)\n       \
    \     }\n            flag = !flag\n        }\n        if (flag) {\n          \
    \  result = result :+ min :+ max\n        } else {\n            result = result\
    \ :+ max :+ min\n        }\n        return result", "        if (lst.length ==\
    \ 0) return lst\n        var min = lst.min\n        var max = lst.max\n      \
    \  var lst2 = lst.filter(x => x != min && x != max)\n        var lst3 = List[Long]()\n\
    \        var i = 0\n        while (lst2.length > 0) {\n            if (i % 2 ==\
    \ 0) {\n                lst3 = lst3 :+ min\n                min = lst2.min\n \
    \               lst2 = lst2.filter(x => x != min)\n            } else {\n    \
    \            lst3 = lst3 :+ max\n                max = lst2.max\n            \
    \    lst2 = lst2.filter(x => x != max)\n            }\n            i += 1\n  \
    \      }\n        if (i % 2 == 0) lst3 = lst3 :+ min :+ max\n        else lst3\
    \ = lst3 :+ max :+ min\n        return lst3", "        if (lst.length == 0) return\
    \ lst\n        var lst2 = lst.sortWith(_ < _)\n        var result = ListBuffer[Long]()\n\
    \        var i = 0\n        while (lst2.length > 0) {\n            if (i % 2 ==\
    \ 0) {\n                result += lst2.head\n                lst2 = lst2.tail\n\
    \            } else {\n                result += lst2.last\n                lst2\
    \ = lst2.init\n            }\n            i += 1\n        }\n        result.toList",
  "        if (lst.isEmpty) return lst\n        var result = List[Long]()\n      \
    \  var remaining = lst.sorted\n        while (!remaining.isEmpty) {\n        \
    \    result = remaining.head :: result\n            remaining = remaining.tail\n\
    \            if (!remaining.isEmpty) {\n                result = remaining.last\
    \ :: result\n                remaining = remaining.init\n            }\n     \
    \   }\n        result", "        if (lst.length == 0) return List()\n        var\
    \ result = ListBuffer[Long]()\n        var remaining = lst.sorted\n        var\
    \ min = remaining.head\n        var max = remaining.last\n        while (remaining.length\
    \ > 0) {\n            result += min\n            remaining = remaining.filter(_\
    \ != min)\n            if (remaining.length > 0) {\n                result +=\
    \ max\n                remaining = remaining.filter(_ != max)\n            }\n\
    \            if (remaining.length > 0) {\n                min = remaining.head\n\
    \                max = remaining.last\n            }\n        }\n        result.toList",
  "        if (lst.isEmpty) return lst\n        var result = ListBuffer[Long]()\n\
    \        var remaining = lst.toBuffer\n        while (remaining.nonEmpty) {\n\
    \            val min = remaining.min\n            result += min\n            remaining\
    \ -= min\n            if (remaining.nonEmpty) {\n                val max = remaining.max\n\
    \                result += max\n                remaining -= max\n           \
    \ }\n        }\n        result.toList", "        if (lst.length == 0) return lst\n\
    \        var result = List[Long]()\n        var lst2 = lst.sorted\n        var\
    \ i = 0\n        while (i < lst.length) {\n            if (i % 2 == 0) result\
    \ = result :+ lst2.head\n            else result = result :+ lst2.last\n     \
    \       if (i % 2 == 0) lst2 = lst2.tail\n            else lst2 = lst2.init\n\
    \            i += 1\n        }\n        result", "        if (lst.length == 0)\
    \ return lst\n        val sorted = lst.sorted\n        val min = sorted.head\n\
    \        val max = sorted.last\n        val min_index = lst.indexOf(min)\n   \
    \     val max_index = lst.indexOf(max)\n        val min_remaining = lst.slice(min_index\
    \ + 1, max_index + 1)\n        val max_remaining = lst.slice(max_index + 1, lst.length)\n\
    \        val min_remaining_sorted = strangeSortList(min_remaining)\n        val\
    \ max_remaining_sorted = strangeSortList(max_remaining)\n        return min_remaining_sorted\
    \ ::: List(min) ::: max_remaining_sorted ::: List(max)", "        val sorted =\
    \ lst.sorted\n        val result = new ListBuffer[Long]\n        var i = 0\n \
    \       var j = sorted.length - 1\n        while (i <= j) {\n            result\
    \ += sorted(i)\n            if (i != j) result += sorted(j)\n            i +=\
    \ 1\n            j -= 1\n        }\n        result.toList", "        val sorted\
    \ = lst.sorted\n        val (min, max) = (sorted.head, sorted.last)\n        val\
    \ (min_lst, max_lst) = (sorted.tail.filter(_ != max), sorted.init.filter(_ !=\
    \ min))\n        val min_lst_sorted = min_lst.sorted\n        val max_lst_sorted\
    \ = max_lst.sorted\n        val min_lst_sorted_reversed = min_lst_sorted.reverse\n\
    \        val max_lst_sorted_reversed = max_lst_sorted.reverse\n        val (min_lst_sorted_reversed_odd,\
    \ min_lst_sorted_reversed_even) = min_lst_sorted_reversed.zipWithIndex.partition(_._2\
    \ % 2 == 1)\n        val (max_lst_sorted_reversed_odd, max_lst_sorted_reversed_even)\
    \ = max_lst_sorted_reversed.zipWithIndex.partition(_._2 % 2 == 1)\n        val\
    \ min_lst_sorted_reversed_odd_lst = min_lst_sorted_reversed_odd.map(_._1)\n  \
    \      val min_lst_sorted_reversed_even_lst = min_lst_sorted_reversed_even.map(_._1)\n\
    \        val max_lst_sorted_reversed_odd_lst = max_lst_sorted_reversed_odd.map(_._1)\n\
    \        val max_lst_sorted_reversed_even_lst = max_lst_sorted_reversed_even.map(_._1)\n\
    \        val min_lst_sorted_reversed_odd_lst_reversed = min_lst_sorted_reversed_odd_lst.reverse\n\
    \        val min_lst_sorted_reversed_even_lst_reversed = min_lst_sorted_reversed_even_lst.reverse\n\
    \        val max_l", "        if (lst.isEmpty) return lst\n        val sorted\
    \ = lst.sorted\n        val n = sorted.length\n        val result = new ArrayBuffer[Long]\n\
    \        var i = 0\n        while (i < n) {\n            result += sorted(i)\n\
    \            if (i + 1 < n) result += sorted(n - i - 1)\n            i += 1\n\
    \        }\n        result.toList", "        if (lst.length == 0) return lst\n\
    \        var min = lst.min\n        var max = lst.max\n        var result = List[Long]()\n\
    \        var lst2 = lst.toBuffer\n        while (lst2.length > 0) {\n        \
    \    result = result :+ min\n            lst2 -= min\n            if (lst2.length\
    \ > 0) {\n                result = result :+ max\n                lst2 -= max\n\
    \            }\n            min = lst2.min\n            max = lst2.max\n     \
    \   }\n        result", "        if (lst.isEmpty) return lst\n        var result\
    \ = ListBuffer[Long]()\n        var remaining = lst.toBuffer\n        while (remaining.nonEmpty)\
    \ {\n            result += remaining.min\n            remaining -= remaining.min\n\
    \            if (remaining.nonEmpty) {\n                result += remaining.max\n\
    \                remaining -= remaining.max\n            }\n        }\n      \
    \  result.toList", "        if (lst.isEmpty) return lst\n        var min = lst.min\n\
    \        var max = lst.max\n        var lst2 = lst.filter(x => x != min && x !=\
    \ max)\n        var lst3 = List[Long]()\n        while (lst2.nonEmpty) {\n   \
    \         min = lst2.min\n            max = lst2.max\n            lst3 = lst3\
    \ :+ min\n            lst3 = lst3 :+ max\n            lst2 = lst2.filter(x =>\
    \ x != min && x != max)\n        }\n        if (lst.length % 2 == 1) lst3 = lst3\
    \ :+ min\n        return lst3", "        if (lst.length == 0) return lst\n   \
    \     val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n   \
    \     var i = 0\n        var j = sorted.length - 1\n        while (i <= j) {\n\
    \            result += sorted(i)\n            if (i != j) result += sorted(j)\n\
    \            i += 1\n            j -= 1\n        }\n        result.toList", " \
    \       if (lst.length == 0) return lst\n        var lst2 = lst.sorted\n     \
    \   var lst3 = ListBuffer[Long]()\n        var i = 0\n        while (lst2.length\
    \ > 0) {\n            if (i % 2 == 0) {\n                lst3 += lst2.head\n \
    \               lst2 = lst2.tail\n            } else {\n                lst3 +=\
    \ lst2.last\n                lst2 = lst2.init\n            }\n            i +=\
    \ 1\n        }\n        lst3.toList", "        if (lst.length == 0) return lst\n\
    \        var lst2 = lst.sorted\n        var result = ListBuffer[Long]()\n    \
    \    var i = 0\n        while (i < lst2.length) {\n            if (i % 2 == 0)\
    \ result += lst2(i)\n            else result += lst2(lst2.length - 1 - i)\n  \
    \          i += 1\n        }\n        return result.toList", "        if (lst.length\
    \ == 0) return List()\n        var lst2 = lst.sortWith(_ < _)\n        var lst3\
    \ = ListBuffer[Long]()\n        var i = 0\n        while (lst2.length > 0) {\n\
    \            if (i % 2 == 0) {\n                lst3 += lst2.head\n          \
    \      lst2 = lst2.tail\n            } else {\n                lst3 += lst2.last\n\
    \                lst2 = lst2.dropRight(1)\n            }\n            i += 1\n\
    \        }\n        lst3.toList", "        if (lst.isEmpty) return lst\n     \
    \   val sorted = lst.sorted\n        val result = new ListBuffer[Long]\n     \
    \   var i = 0\n        var j = sorted.length - 1\n        while (i <= j) {\n \
    \           result += sorted(i)\n            if (i != j) result += sorted(j)\n\
    \            i += 1\n            j -= 1\n        }\n        result.toList", " \
    \       if (lst.length == 0) return lst\n        var result = ListBuffer[Long]()\n\
    \        var lst2 = lst.sorted\n        var i = 0\n        while (i < lst2.length)\
    \ {\n            if (i % 2 == 0) result += lst2(i)\n            else result +=\
    \ lst2(lst2.length - 1 - i)\n            i += 1\n        }\n        return result.toList",
  "        if (lst.length == 0) return List()\n        val sorted = lst.sorted\n \
    \       val result = ListBuffer[Long]()\n        var i = 0\n        var j = sorted.length\
    \ - 1\n        while (i <= j) {\n            result += sorted(i)\n           \
    \ if (i != j) result += sorted(j)\n            i += 1\n            j -= 1\n  \
    \      }\n        result.toList", "        if (lst.length == 0) return lst\n \
    \       var min = lst.min\n        var max = lst.max\n        var lst2 = lst.filter(x\
    \ => x != min && x != max)\n        var lst3 = List[Long]()\n        var i = 0\n\
    \        while (lst2.length > 0) {\n            if (i % 2 == 0) {\n          \
    \      lst3 = lst3 :+ min\n                min = lst2.min\n                lst2\
    \ = lst2.filter(x => x != min)\n            } else {\n                lst3 = lst3\
    \ :+ max\n                max = lst2.max\n                lst2 = lst2.filter(x\
    \ => x != max)\n            }\n            i += 1\n        }\n        if (i %\
    \ 2 == 0) lst3 = lst3 :+ min :+ max\n        else lst3 = lst3 :+ max :+ min\n\
    \        return lst3"]
stop_tokens:
- "\n    }\n"
