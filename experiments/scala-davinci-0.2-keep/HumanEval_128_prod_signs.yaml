name: HumanEval_128_prod_signs
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given an array arr of integers and you need to return\n    // sum\
  \ of magnitudes of integers multiplied by product of all signs\n    // of each number\
  \ in the array, represented by 1, -1 or 0.\n    // Note: return None for empty arr.\n\
  \    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) == -9\n    // >>> prod_signs([0,\
  \ 1]) == 0\n    // >>> prod_signs([]) == None\n    def prodSigns(arr : List[Long])\
  \ : Option[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
  \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n   \
  \ assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
  \    }\n\n}\n"
completions: ["        if (arr.isEmpty) None\n        else {\n            val signs\
    \ = arr.map(x => if (x > 0) 1 else if (x < 0) -1 else 0)\n            val magnitudes\
    \ = arr.map(x => abs(x))\n            Some(magnitudes.sum * signs.product)\n \
    \       }", "        if (arr.isEmpty) return None\n        var prod = 1\n    \
    \    var sum = 0\n        for (i <- arr) {\n            if (i > 0) prod *= 1\n\
    \            else if (i < 0) prod *= -1\n            else prod *= 0\n        \
    \    sum += abs(i)\n        }\n        return Some(sum * prod)", "        if (arr.isEmpty)\
    \ return None\n        var prod = 1\n        var sum = 0\n        for (i <- arr)\
    \ {\n            if (i > 0) prod *= 1\n            else if (i < 0) prod *= -1\n\
    \            else prod *= 0\n            sum += abs(i)\n        }\n        Some(sum\
    \ * prod)", "        if (arr.isEmpty) return None\n        val signs = arr.map(x\
    \ => if (x > 0) 1 else if (x < 0) -1 else 0)\n        val magnitudes = arr.map(x\
    \ => abs(x))\n        Some(signs.product * magnitudes.sum)", "        if (arr.length\
    \ == 0) {\n            None\n        } else {\n            var sum = 0L\n    \
    \        var prod = 1L\n            for (i <- arr) {\n                if (i >\
    \ 0) {\n                    sum += i\n                    prod *= 1\n        \
    \        } else if (i < 0) {\n                    sum += -i\n                \
    \    prod *= -1\n                } else {\n                    prod *= 0\n   \
    \             }\n            }\n            Some(sum * prod)\n        }", "  \
    \      if (arr.isEmpty) return None\n        var sum = 0L\n        var prod =\
    \ 1L\n        for (i <- arr) {\n            sum += abs(i)\n            prod *=\
    \ i.signum\n        }\n        Some(sum * prod)", "        if (arr.length == 0)\
    \ return None\n        var prod = 1\n        var sum = 0\n        for (x <- arr)\
    \ {\n            if (x > 0) prod *= 1\n            else if (x < 0) prod *= -1\n\
    \            else prod *= 0\n            sum += abs(x)\n        }\n        Some(sum\
    \ * prod)", "        if (arr.length == 0) return None\n        var prod = 1\n\
    \        var sum = 0\n        for (i <- arr) {\n            if (i > 0) prod *=\
    \ 1\n            else if (i < 0) prod *= -1\n            else prod *= 0\n    \
    \        sum += abs(i)\n        }\n        Some(sum * prod)", "        if (arr.length\
    \ == 0) return None\n        var sum = 0L\n        var prod = 1L\n        for\
    \ (i <- arr) {\n            if (i > 0) sum += i\n            else if (i < 0) {\n\
    \                sum += -i\n                prod *= -1\n            }\n      \
    \  }\n        return Some(sum * prod)", "        if (arr.isEmpty) return None\n\
    \        var sum = 0L\n        var prod = 1L\n        for (i <- arr) {\n     \
    \       if (i > 0) sum += i\n            else if (i < 0) {\n                sum\
    \ += -i\n                prod *= -1\n            }\n        }\n        return\
    \ Some(sum * prod)", "        if (arr.isEmpty) None\n        else {\n        \
    \    val signs = arr.map(x => if (x > 0) 1 else if (x < 0) -1 else 0)\n      \
    \      val magnitudes = arr.map(x => abs(x))\n            val prod = signs.product\n\
    \            val sum = magnitudes.sum\n            Some(prod * sum)\n        }",
  "        if (arr.isEmpty) None\n        else {\n            val signs = arr.map(x\
    \ => if (x > 0) 1 else if (x < 0) -1 else 0)\n            val magnitudes = arr.map(x\
    \ => abs(x))\n            Some(magnitudes.sum * signs.product)\n        }", " \
    \       if (arr.isEmpty) return None\n        var sum = 0L\n        var prod =\
    \ 1L\n        for (i <- arr) {\n            sum += abs(i)\n            prod *=\
    \ signum(i)\n        }\n        return Some(sum * prod)", "        if (arr.isEmpty)\
    \ return None\n        val signs = arr.map(x => if (x > 0) 1 else if (x < 0) -1\
    \ else 0)\n        val magnitudes = arr.map(x => abs(x))\n        Some(signs.product\
    \ * magnitudes.sum)", "        if (arr.isEmpty) None\n        else {\n       \
    \     var sum = 0L\n            var prod = 1L\n            for (i <- arr) {\n\
    \                sum += abs(i)\n                if (i != 0) prod *= signum(i)\n\
    \            }\n            Some(sum * prod)\n        }", "        if (arr.isEmpty)\
    \ return None\n        var sum = 0L\n        var prod = 1L\n        for (i <-\
    \ arr) {\n            if (i > 0) sum += i\n            else if (i < 0) {\n   \
    \             sum += -i\n                prod *= -1\n            }\n        }\n\
    \        return Some(sum * prod)", "        if (arr.isEmpty) return None\n   \
    \     var sum = 0L\n        var prod = 1L\n        for (x <- arr) {\n        \
    \    sum += abs(x)\n            prod *= signum(x)\n        }\n        return Some(sum\
    \ * prod)", "        if (arr.isEmpty) None\n        else {\n            val signs\
    \ = arr.map(x => if (x > 0) 1 else if (x < 0) -1 else 0)\n            val magnitudes\
    \ = arr.map(x => abs(x))\n            Some(magnitudes.sum * signs.product)\n \
    \       }", "        if (arr.isEmpty) return None\n        var prod = 1\n    \
    \    var sum = 0\n        for (x <- arr) {\n            prod *= signum(x).toInt\n\
    \            sum += abs(x)\n        }\n        return Some(sum * prod)", "   \
    \     if (arr.isEmpty) return None\n        var prod = 1L\n        var sum = 0L\n\
    \        for (i <- arr) {\n            prod *= i.signum\n            sum += i.abs\n\
    \        }\n        Some(sum * prod)"]
stop_tokens:
- "\n    }\n"
