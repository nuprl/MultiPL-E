language: scala
name: HumanEval_41_car_race_collision
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 0 to n-1.\n        // The left-to-right cars are numbered from 0 to n-1.\n\
    \        // The right-to-left cars are numbered from n-1 to 0.\n        // The\
    \ left-to-right cars are at positions (0, 0), (1, 1), (2, 2), ..., (n-1, n-1).\n\
    \        // The right-to-left cars are at positions (n-1, n-1), (n-2, n-2), ...,\
    \ (0, 0).\n        // The cars move in the same speed.\n        // The left-to-right\
    \ cars move right by 1 unit.\n        // The right-to-left cars move left by 1\
    \ unit.\n        // The left-to-right cars are at positions (0, 0), (1, 1), (2,\
    \ 2), ..., (n-1, n-1).\n        // The right-to-left cars are at positions (n-1,\
    \ n-1), (n-2, n-2), ..., (0, 0).\n        // The left-to-right cars are at positions\
    \ (1, 1), (2, 2), ..., (n-1, n-1), (n, n).\n        // The right-to-left cars\
    \ are at positions (n-1, n-1), (n-2, n-2), ..., (0, 0), (-1, -1).\n        //\
    \ The left-to-right cars are at positions (2, 2), (3, 3), ..., (n-1, n-1), (n,\
    \ n), (n+1, n+1).\n        // The right-to-left cars are at positions (n-1, n-1),\
    \ (n-2, n-2), ..., (0, 0), (-1, -1), (-2, -2).\n        // The left-to-right cars\
    \ are at positions (3, 3), (4, 4), ..., (n-1, n-1), (n, n), (n+1, n+1), (n+2,\
    \ n+2).\n        // The right-to-left cars are at positions (n-1, n-1), (n-\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqqglf44y.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 0 to n-1.\e[0m\n\e[31m14 |\e[0m        \e[34m//\
    \ The left-to-right cars are numbered from 0 to n-1.\e[0m\n\e[31m15 |\e[0m   \
    \     \e[34m// The right-to-left cars are numbered from n-1 to 0.\e[0m\n\e[31m16\
    \ |\e[0m        \e[34m// The left-to-right cars are at positions (0, 0), (1, 1),\
    \ (2, 2), ..., (n-1, n-1).\e[0m\n\e[31m17 |\e[0m        \e[34m// The right-to-left\
    \ cars are at positions (n-1, n-1), (n-2, n-2), ..., (0, 0).\e[0m\n\e[31m18 |\e\
    [0m        \e[34m// The cars move in the same speed.\e[0m\n\e[31m19 |\e[0m   \
    \     \e[34m// The left-to-right cars move right by 1 unit.\e[0m\n\e[31m20 |\e\
    [0m        \e[34m// The right-to-left cars move left by 1 unit.\e[0m\n\e[31m21\
    \ |\e[0m        \e[34m// The left-to-right cars are at positions (0, 0), (1, 1),\
    \ (2, 2), ..., (n-1, n-1).\e[0m\n\e[31m22 |\e[0m        \e[34m// The right-to-left\
    \ cars are at positions (n-1, n-1), (n-2, n-2), ..., (0, 0).\e[0m\n\e[31m23 |\e\
    [0m        \e[34m// The left-to-right cars are at positions (1, 1), (2, 2), ...,\
    \ (n-1, n-1), (n, n).\e[0m\n\e[31m24 |\e[0m        \e[34m// The right-to-left\
    \ cars are at positions (n-1, n-1), (n-2, n-2), ..., (0, 0), (-1, -1).\e[0m\n\e\
    [31m25 |\e[0m        \e[34m// The left-to-right cars are at positions (2, 2),\
    \ (3, 3), ..., (n-1, n-1), (n, n), (n+1, n+1).\e[0m\n\e[31m26 |\e[0m        \e\
    [34m// The right-to-left cars are at positions (n-1, n-1), (n-2, n-2), ..., (0,\
    \ 0), (-1, -1), (-2, -2).\e[0m\n\e[31m27 |\e[0m        \e[34m// The left-to-right\
    \ cars are at positions (3, 3), (4, 4), ..., (n-1, n-1), (n, n), (n+1, n+1), (n+2,\
    \ n+2).\e[0m\n\e[31m28 |\e[0m        \e[34m// The right-to-left cars are at positions\
    \ (n-1, n-1), (n-\e[0m\n\e[31m29 |"
  stdout: ''
  timestamp: 1659792822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars and count how many\n        // cars are moving in the opposite direction.\n\
    \        // The number of collisions is the number of cars moving in the opposite\
    \ direction\n        // times the number of cars moving in the same direction.\n\
    \        // The number of cars moving in the same direction is equal to the number\
    \ of cars\n        // that have already been iterated through.\n        // The\
    \ number of cars moving in the opposite direction is equal to the number of cars\n\
    \        // that have not been iterated through.\n        // The number of cars\
    \ that have not been iterated through is equal to the number of cars\n       \
    \ // minus the number of cars that have been iterated through.\n        // The\
    \ number of cars that have been iterated through is equal to the number of cars\n\
    \        // minus the number of cars that have not been iterated through.\n  \
    \      // The number of cars that have not been iterated through is equal to the\
    \ number of cars\n        // minus the number of cars that have been iterated\
    \ through.\n        // The number of cars that have been iterated through is equal\
    \ to the number of cars\n        // minus the number of cars that have not been\
    \ iterated through.\n        // The number of cars that have not been iterated\
    \ through is equal to the number of cars\n        // minus the number of cars\
    \ that have been iterated through.\n        // The number of cars that have been\
    \ iterated through is equal to the number of cars\n        // minus the number\
    \ of cars that have not been iterated through.\n        // The number of cars\
    \ that have not been iterated through is equal to the number of cars\n       \
    \ // minus the number of cars that have been iterated through.\n        // The\
    \ number of cars that have been iterated through is equal to the number of cars\n\
    \        // minus the number of cars that have not been iterated through.\n  \
    \      // The number of cars that have not been iterated through is equal to the\
    \ number of cars\n        // minus the number of cars that have been iterated\
    \ through.\n        // The number of cars that have been iterated through is equal\
    \ to the number of cars\n        // minus the number of cars that have not been\
    \ iterated through.\n        // The number of cars that have not been iterated\
    \ through is equal to the\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8jlnqkh0.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can just iterate through the cars and count\
    \ how many\e[0m\n\e[31m15 |\e[0m        \e[34m// cars are moving in the opposite\
    \ direction.\e[0m\n\e[31m16 |\e[0m        \e[34m// The number of collisions is\
    \ the number of cars moving in the opposite direction\e[0m\n\e[31m17 |\e[0m  \
    \      \e[34m// times the number of cars moving in the same direction.\e[0m\n\e\
    [31m18 |\e[0m        \e[34m// The number of cars moving in the same direction\
    \ is equal to the number of cars\e[0m\n\e[31m19 |\e[0m        \e[34m// that have\
    \ already been iterated through.\e[0m\n\e[31m20 |\e[0m        \e[34m// The number\
    \ of cars moving in the opposite direction is equal to the number of cars\e[0m\n\
    \e[31m21 |\e[0m        \e[34m// that have not been iterated through.\e[0m\n\e\
    [31m22 |\e[0m        \e[34m// The number of cars that have not been iterated through\
    \ is equal to the number of cars\e[0m\n\e[31m23 |\e[0m        \e[34m// minus the\
    \ number of cars that have been iterated through.\e[0m\n\e[31m24 |\e[0m      \
    \  \e[34m// The number of cars that have been iterated through is equal to the\
    \ number of cars\e[0m\n\e[31m25 |\e[0m        \e[34m// minus the number of cars\
    \ that have not been iterated through.\e[0m\n\e[31m26 |\e[0m        \e[34m// The\
    \ number of cars that have not been iterated through is equal to the number of\
    \ cars\e[0m\n\e[31m27 |\e[0m        \e[34m// minus the number of cars that have\
    \ been iterated through.\e[0m\n\e[31m28 |\e[0m        \e[34m// The number of cars\
    \ that have been iterated through is equal to the number of cars\e[0m\n\e[31m29\
    \ |\e[0m        \e[34m// minus the number of cars "
  stdout: ''
  timestamp: 1659792822
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ the pigeonhole principle.  Imagine the road is divided into\n        // n segments.\
    \  If a car from the left-to-right set is in the ith segment, then\n        //\
    \ the car from the right-to-left set that collides with it must be in the (n -\
    \ i)th\n        // segment.  So, if there are more than n cars in the left-to-right\
    \ set, then there\n        // must be a collision.  Similarly, if there are more\
    \ than n cars in the right-to-left\n        // set, then there must be a collision.\
    \  So, the answer is the maximum of the number\n        // of cars in the left-to-right\
    \ set and the number of cars in the right-to-left set.\n        max(n, n)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf9sv4wv_.scala:23)\n\tat Problem.main(tmpf9sv4wv_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can compute the number\
    \ of collisions by computing\n        // the number of inversions in the sorted\
    \ array.\n        // The number of inversions is the number of pairs (i, j) such\
    \ that\n        // i < j and a[i] > a[j].\n        // The number of inversions\
    \ is equal to the number of collisions.\n        // This is because the cars that\
    \ are moving left to right are the ones\n        // with the smaller starting\
    \ positions, and the cars that are moving\n        // right to left are the ones\
    \ with the larger starting positions.\n        // Therefore, if a car that's moving\
    \ left to right has a smaller starting\n        // position than a car that's\
    \ moving right to left, then they will collide.\n        // The number of inversions\
    \ is equal to the number of collisions.\n        // This is because the cars that\
    \ are moving left to right are the ones\n        // with the smaller starting\
    \ positions, and the cars that are moving\n        // right to left are the ones\
    \ with the larger starting positions.\n        // Therefore, if a car that's moving\
    \ left to right has a smaller starting\n        // position than a car that's\
    \ moving right to left, then they will collide.\n        // The number of inversions\
    \ is equal to the number of collisions.\n        // This is because the cars that\
    \ are moving left to right are the ones\n        // with the smaller starting\
    \ positions, and the cars that are moving\n        // right to left are the ones\
    \ with the larger starting positions.\n        // Therefore, if a car that's moving\
    \ left to right has a smaller starting\n        // position than a car that's\
    \ moving right to left, then they will collide.\n        // The number of inversions\
    \ is equal to the number of collisions.\n        // This is because the cars that\
    \ are moving left to right are the ones\n        // with the smaller starting\
    \ positions, and the cars that are moving\n        // right to left are the ones\
    \ with the larger starting positions.\n        // Therefore, if a car that's moving\
    \ left to right has a smaller starting\n        // position than a car that's\
    \ moving right to left, then they will collide.\n        // The number of inversions\
    \ is equal to the number of collisions.\n        // This is because the cars that\
    \ are moving left to right are the ones\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy77y2mk5.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can compute the number of collisions by computing\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// the number of inversions in the sorted array.\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// The number of inversions is the number of\
    \ pairs (i, j) such that\e[0m\n\e[31m17 |\e[0m        \e[34m// i < j and a[i]\
    \ > a[j].\e[0m\n\e[31m18 |\e[0m        \e[34m// The number of inversions is equal\
    \ to the number of collisions.\e[0m\n\e[31m19 |\e[0m        \e[34m// This is because\
    \ the cars that are moving left to right are the ones\e[0m\n\e[31m20 |\e[0m  \
    \      \e[34m// with the smaller starting positions, and the cars that are moving\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// right to left are the ones with the larger\
    \ starting positions.\e[0m\n\e[31m22 |\e[0m        \e[34m// Therefore, if a car\
    \ that's moving left to right has a smaller starting\e[0m\n\e[31m23 |\e[0m   \
    \     \e[34m// position than a car that's moving right to left, then they will\
    \ collide.\e[0m\n\e[31m24 |\e[0m        \e[34m// The number of inversions is equal\
    \ to the number of collisions.\e[0m\n\e[31m25 |\e[0m        \e[34m// This is because\
    \ the cars that are moving left to right are the ones\e[0m\n\e[31m26 |\e[0m  \
    \      \e[34m// with the smaller starting positions, and the cars that are moving\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// right to left are the ones with the larger\
    \ starting positions.\e[0m\n\e[31m28 |\e[0m        \e[34m// Therefore, if a car\
    \ that's moving left to right has a smaller starting\e[0m\n\e[31m29 |\e[0m   \
    \     \e[34m// position than a car that's moving right to left, then they will\
    \ collide.\e[0m\n\e[31m30 |\e[0m "
  stdout: ''
  timestamp: 1659792821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a Fenwick tree to count the number of cars that are moving\n        // right\
    \ to left at each point.  The number of collisions is the sum of the number\n\
    \        // of cars moving right to left at each point.\n        // The Fenwick\
    \ tree is a binary indexed tree.  It is a tree data structure that\n        //\
    \ allows for efficient querying of the sum of values in a range.\n        // The\
    \ tree is constructed as follows:\n        // 1.  The root node is the sum of\
    \ the values in the range [0, n - 1].\n        // 2.  The left child of a node\
    \ is the sum of the values in the range [0, (n - 1) / 2].\n        // 3.  The\
    \ right child of a node is the sum of the values in the range [(n - 1) / 2 + 1,\
    \ n - 1].\n        // 4.  The parent of a node is the sum of the values in the\
    \ range [0, n - 1].\n        // 5.  The left child of a node is the sum of the\
    \ values in the range [0, (n - 1) / 2].\n        // 6.  The right child of a node\
    \ is the sum of the values in the range [(n - 1) / 2 + 1, n - 1].\n        //\
    \ 7.  The parent of a node is the sum of the values in the range [0, n - 1].\n\
    \        // 8.  The left child of a node is the sum of the values in the range\
    \ [0, (n - 1) / 2].\n        // 9.  The right child of a node is the sum of the\
    \ values in the range [(n - 1) / 2 + 1, n - 1].\n        // 10.  The parent of\
    \ a node is the sum of the values in the range [0, n - 1].\n        // 11.  The\
    \ left child of a node is the sum of the values in the range [0, (n - 1) / 2].\n\
    \        // 12.  The right child of a node is the sum of the values in the range\
    \ [(n - 1) / 2 + 1, n - 1].\n        // 13.  The parent of a node is the sum of\
    \ the values in the range [0, n - 1].\n        // 14.  The left\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeoywakxd.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a Fenwick tree to count the number of cars that are\
    \ moving\e[0m\n\e[31m14 |\e[0m        \e[34m// right to left at each point.  The\
    \ number of collisions is the sum of the number\e[0m\n\e[31m15 |\e[0m        \e\
    [34m// of cars moving right to left at each point.\e[0m\n\e[31m16 |\e[0m     \
    \   \e[34m// The Fenwick tree is a binary indexed tree.  It is a tree data structure\
    \ that\e[0m\n\e[31m17 |\e[0m        \e[34m// allows for efficient querying of\
    \ the sum of values in a range.\e[0m\n\e[31m18 |\e[0m        \e[34m// The tree\
    \ is constructed as follows:\e[0m\n\e[31m19 |\e[0m        \e[34m// 1.  The root\
    \ node is the sum of the values in the range [0, n - 1].\e[0m\n\e[31m20 |\e[0m\
    \        \e[34m// 2.  The left child of a node is the sum of the values in the\
    \ range [0, (n - 1) / 2].\e[0m\n\e[31m21 |\e[0m        \e[34m// 3.  The right\
    \ child of a node is the sum of the values in the range [(n - 1) / 2 + 1, n -\
    \ 1].\e[0m\n\e[31m22 |\e[0m        \e[34m// 4.  The parent of a node is the sum\
    \ of the values in the range [0, n - 1].\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ 5.  The left child of a node is the sum of the values in the range [0, (n -\
    \ 1) / 2].\e[0m\n\e[31m24 |\e[0m        \e[34m// 6.  The right child of a node\
    \ is the sum of the values in the range [(n - 1) / 2 + 1, n - 1].\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// 7.  The parent of a node is the sum of the values in\
    \ the range [0, n - 1].\e[0m\n\e[31m26 |\e[0m        \e[34m// 8.  The left child\
    \ of a node is the sum of the values in the range [0, (n - 1) / 2].\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// 9.  The right child of a node is the sum of the values\
    \ in the range [(n - 1) / 2 + 1, n - 1].\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659792822
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function outputs\
    \ the number of collisions between the ith car\n        // moving left to right\
    \ and the jth car moving right to left.\n        def collision(i : Long, j : Long)\
    \ : Long = {\n            // The ith car moving left to right starts at position\
    \ i.\n            // The jth car moving right to left starts at position -j.\n\
    \            // The ith car moving left to right moves at speed 1.\n         \
    \   // The jth car moving right to left moves at speed 1.\n            // The\
    \ ith car moving left to right will collide with the jth car moving right to left\n\
    \            // if and only if the ith car moving left to right reaches position\
    \ -j.\n            // The ith car moving left to right will reach position -j\
    \ at time i + j.\n            // The jth car moving right to left will reach position\
    \ i at time i + j.\n            // The ith car moving left to right will collide\
    \ with the jth car moving right to left\n            // at time i + j.\n     \
    \       // The ith car moving left to right will collide with the jth car moving\
    \ right to left\n            // if and only if i + j is less than or equal to\
    \ n.\n            if (i + j <= n) 1 else 0\n        }\n        // The number of\
    \ collisions is the sum of the number of collisions between the ith car\n    \
    \    // moving left to right and the jth car moving right to left for all i and\
    \ j.\n        (1 to n.toInt).map(i => (1 to n.toInt).map(j => collision(i, j)).sum).sum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0qva86ty.scala:35)\n\tat Problem.main(tmp0qva86ty.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can count the number\
    \ of collisions by comparing the\n        // cars moving left to right with the\
    \ cars moving right to left.\n        // The cars moving left to right are sorted\
    \ in ascending order,\n        // and the cars moving right to left are sorted\
    \ in descending order.\n        // As a result, the cars moving left to right\
    \ are compared with the\n        // cars moving right to left in ascending order.\n\
    \        // The number of collisions is the number of cars moving left to right\n\
    \        // that are greater than the cars moving right to left.\n        // This\
    \ is the same as the number of cars moving right to left that are\n        //\
    \ less than the cars moving left to right.\n        // This is the same as the\
    \ number of cars moving right to left that are\n        // less than the cars\
    \ moving left to right.\n        // This is the same as the number of cars moving\
    \ right to left that are\n        // less than the cars moving left to right.\n\
    \        // This is the same as the number of cars moving right to left that are\n\
    \        // less than the cars moving left to right.\n        // This is the same\
    \ as the number of cars moving right to left that are\n        // less than the\
    \ cars moving left to right.\n        // This is the same as the number of cars\
    \ moving right to left that are\n        // less than the cars moving left to\
    \ right.\n        // This is the same as the number of cars moving right to left\
    \ that are\n        // less than the cars moving left to right.\n        // This\
    \ is the same as the number of cars moving right to left that are\n        //\
    \ less than the cars moving left to right.\n        // This is the same as the\
    \ number of cars moving right to left that are\n        // less than the cars\
    \ moving left to right.\n        // This is the same as the number of cars moving\
    \ right to left that are\n        // less than the cars moving left to right.\n\
    \        // This is the same as the number of cars moving right to left that are\n\
    \        // less than the cars moving left to right.\n        // This is the same\
    \ as the number of cars moving right to left that are\n        // less than the\
    \ cars moving left to right.\n        // This is the same as the number of cars\
    \ moving right to left\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprc_wiymw.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can count the number of collisions by comparing\
    \ the\e[0m\n\e[31m15 |\e[0m        \e[34m// cars moving left to right with the\
    \ cars moving right to left.\e[0m\n\e[31m16 |\e[0m        \e[34m// The cars moving\
    \ left to right are sorted in ascending order,\e[0m\n\e[31m17 |\e[0m        \e\
    [34m// and the cars moving right to left are sorted in descending order.\e[0m\n\
    \e[31m18 |\e[0m        \e[34m// As a result, the cars moving left to right are\
    \ compared with the\e[0m\n\e[31m19 |\e[0m        \e[34m// cars moving right to\
    \ left in ascending order.\e[0m\n\e[31m20 |\e[0m        \e[34m// The number of\
    \ collisions is the number of cars moving left to right\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// that are greater than the cars moving right to left.\e[0m\n\e\
    [31m22 |\e[0m        \e[34m// This is the same as the number of cars moving right\
    \ to left that are\e[0m\n\e[31m23 |\e[0m        \e[34m// less than the cars moving\
    \ left to right.\e[0m\n\e[31m24 |\e[0m        \e[34m// This is the same as the\
    \ number of cars moving right to left that are\e[0m\n\e[31m25 |\e[0m        \e\
    [34m// less than the cars moving left to right.\e[0m\n\e[31m26 |\e[0m        \e\
    [34m// This is the same as the number of cars moving right to left that are\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// less than the cars moving left to right.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// This is the same as the number of cars moving\
    \ right to left that are\e[0m\n\e[31m29 |\e[0m        \e[34m// less than the cars\
    \ moving left to right.\e[0m\n\e[31m30 |\e[0m        \e[34m// This is the same\
    \ as the number of cars moving right to left that"
  stdout: ''
  timestamp: 1659792821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a simple problem\
    \ that can be solved by brute force.\n        // We can simulate the movement\
    \ of the cars.  For each car moving left to right,\n        // we can check if\
    \ it collides with any car moving right to left.\n        // We can do this in\
    \ O(n^2) time.\n        // However, we can do better.\n        // We can sort\
    \ the cars moving left to right by their starting position.\n        // We can\
    \ sort the cars moving right to left by their starting position.\n        // We\
    \ can then do a merge sort to find the number of collisions.\n        // This\
    \ will take O(n log n) time.\n        // We can do even better.\n        // We\
    \ can use a priority queue to find the number of collisions.\n        // We can\
    \ add all the cars moving left to right to the priority queue.\n        // We\
    \ can then iterate through the cars moving right to left.\n        // For each\
    \ car moving right to left, we can remove cars from the priority queue\n     \
    \   // until we find a car that's moving left to right and is to the left of the\
    \ car\n        // moving right to left.  The number of cars removed from the priority\
    \ queue is the\n        // number of collisions.\n        // This will take O(n\
    \ log n) time.\n        // We can do even better.\n        // We can use a binary\
    \ search tree to find the number of collisions.\n        // We can add all the\
    \ cars moving left to right to the binary search tree.\n        // We can then\
    \ iterate through the cars moving right to left.\n        // For each car moving\
    \ right to left, we can remove cars from the binary search tree\n        // until\
    \ we find a car that's moving left to right and is to the left of the car\n  \
    \      // moving right to left.  The number of cars removed from the binary search\
    \ tree is the\n        // number of collisions.\n        // This will take O(n\
    \ log n) time.\n        // We can do even better.\n        // We can use a segment\
    \ tree to find the number of collisions.\n        // We can add all the cars moving\
    \ left to right to the segment tree.\n        // We can then iterate through the\
    \ cars moving right to left.\n        // For each car moving right to left, we\
    \ can remove cars from the segment tree\n       \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv_y7tqud.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a simple problem that can be solved by brute force.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// We can simulate the movement of the cars.  For each car\
    \ moving left to right,\e[0m\n\e[31m15 |\e[0m        \e[34m// we can check if\
    \ it collides with any car moving right to left.\e[0m\n\e[31m16 |\e[0m       \
    \ \e[34m// We can do this in O(n^2) time.\e[0m\n\e[31m17 |\e[0m        \e[34m//\
    \ However, we can do better.\e[0m\n\e[31m18 |\e[0m        \e[34m// We can sort\
    \ the cars moving left to right by their starting position.\e[0m\n\e[31m19 |\e\
    [0m        \e[34m// We can sort the cars moving right to left by their starting\
    \ position.\e[0m\n\e[31m20 |\e[0m        \e[34m// We can then do a merge sort\
    \ to find the number of collisions.\e[0m\n\e[31m21 |\e[0m        \e[34m// This\
    \ will take O(n log n) time.\e[0m\n\e[31m22 |\e[0m        \e[34m// We can do even\
    \ better.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can use a priority queue to\
    \ find the number of collisions.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can\
    \ add all the cars moving left to right to the priority queue.\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// We can then iterate through the cars moving right to\
    \ left.\e[0m\n\e[31m26 |\e[0m        \e[34m// For each car moving right to left,\
    \ we can remove cars from the priority queue\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ until we find a car that's moving left to right and is to the left of the car\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// moving right to left.  The number of cars\
    \ removed from the priority queue is the\e[0m\n\e[31m29 |\e[0m        \e[34m//\
    \ number of collisions.\e[0m\n\e[31m30 |\e[0m        \e[34m// This will take O(n\
    \ log n) time.\e[0m\n\e[31m31 |\e[0m        \e[34m// We can do even"
  stdout: ''
  timestamp: 1659792821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ 1 to n.  The cars moving left to right are numbered 1 to n.\n        // The\
    \ cars moving right to left are numbered n to 1.\n        // The cars moving left\
    \ to right are at positions 1 to n.\n        // The cars moving right to left\
    \ are at positions n to 1.\n        // The cars moving left to right are at positions\
    \ 1 to n.\n        // The cars moving right to left are at positions n to 1.\n\
    \        // The cars moving left to right are at positions 1 to n.\n        //\
    \ The cars moving right to left are at positions n to 1.\n        // The cars\
    \ moving left to right are at positions 1 to n.\n        // The cars moving right\
    \ to left are at positions n to 1.\n        // The cars moving left to right are\
    \ at positions 1 to n.\n        // The cars moving right to left are at positions\
    \ n to 1.\n        // The cars moving left to right are at positions 1 to n.\n\
    \        // The cars moving right to left are at positions n to 1.\n        //\
    \ The cars moving left to right are at positions 1 to n.\n        // The cars\
    \ moving right to left are at positions n to 1.\n        // The cars moving left\
    \ to right are at positions 1 to n.\n        // The cars moving right to left\
    \ are at positions n to 1.\n        // The cars moving left to right are at positions\
    \ 1 to n.\n        // The cars moving right to left are at positions n to 1.\n\
    \        // The cars moving left to right are at positions 1 to n.\n        //\
    \ The cars moving right to left are at positions n to 1.\n        // The cars\
    \ moving left to right are at positions 1 to n.\n        // The cars moving right\
    \ to left are at positions n to 1.\n        // The cars moving left to right are\
    \ at positions 1 to n.\n        // The cars moving right to left are at positions\
    \ n to 1.\n        // The cars moving left to right are at positions 1 to n.\n\
    \        // The cars moving right to left are at positions n to 1.\n        //\
    \ The cars moving left to right are at positions 1 to n.\n        // The cars\
    \ moving right to left are at positions n to 1.\n        // The cars moving left\
    \ to right are at positions 1 to n.\n        // The cars moving right to left\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp54u8ow_g.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered 1 to n.  The cars moving left to right are numbered\
    \ 1 to n.\e[0m\n\e[31m14 |\e[0m        \e[34m// The cars moving right to left\
    \ are numbered n to 1.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars moving left\
    \ to right are at positions 1 to n.\e[0m\n\e[31m16 |\e[0m        \e[34m// The\
    \ cars moving right to left are at positions n to 1.\e[0m\n\e[31m17 |\e[0m   \
    \     \e[34m// The cars moving left to right are at positions 1 to n.\e[0m\n\e\
    [31m18 |\e[0m        \e[34m// The cars moving right to left are at positions n\
    \ to 1.\e[0m\n\e[31m19 |\e[0m        \e[34m// The cars moving left to right are\
    \ at positions 1 to n.\e[0m\n\e[31m20 |\e[0m        \e[34m// The cars moving right\
    \ to left are at positions n to 1.\e[0m\n\e[31m21 |\e[0m        \e[34m// The cars\
    \ moving left to right are at positions 1 to n.\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// The cars moving right to left are at positions n to 1.\e[0m\n\e[31m23 |\e\
    [0m        \e[34m// The cars moving left to right are at positions 1 to n.\e[0m\n\
    \e[31m24 |\e[0m        \e[34m// The cars moving right to left are at positions\
    \ n to 1.\e[0m\n\e[31m25 |\e[0m        \e[34m// The cars moving left to right\
    \ are at positions 1 to n.\e[0m\n\e[31m26 |\e[0m        \e[34m// The cars moving\
    \ right to left are at positions n to 1.\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ The cars moving left to right are at positions 1 to n.\e[0m\n\e[31m28 |\e[0m\
    \        \e[34m// The cars moving right to left are at positions n to 1.\e[0m\n\
    \e[31m29 |\e[0m        \e[34m// The cars moving left to right are at positions\
    \ 1 to n.\e[0m\n\e[31m30 |\e[0m        \e[34m// The cars moving right to left\
    \ are at positions n to 1.\e[0m\n\e[31m31 |\e[0m        \e[34m"
  stdout: ''
  timestamp: 1659792821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between the cars in the left-to-right\n        // set\
    \ and the cars in the right-to-left set.\n        def collisionCount(leftToRight\
    \ : Array[Long], rightToLeft : Array[Long]) : Long = {\n            // This function\
    \ returns the number of collisions between the cars in the left-to-right\n   \
    \         // set and the cars in the right-to-left set.\n            def collisionCount(leftToRight\
    \ : Array[Long], rightToLeft : Array[Long], leftToRightIndex : Int, rightToLeftIndex\
    \ : Int, collisionCount : Long) : Long = {\n                if (leftToRightIndex\
    \ == leftToRight.length || rightToLeftIndex == rightToLeft.length) collisionCount\n\
    \                else if (leftToRight(leftToRightIndex) < rightToLeft(rightToLeftIndex))\
    \ collisionCount(leftToRight, rightToLeft, leftToRightIndex + 1, rightToLeftIndex,\
    \ collisionCount)\n                else if (leftToRight(leftToRightIndex) > rightToLeft(rightToLeftIndex))\
    \ collisionCount(leftToRight, rightToLeft, leftToRightIndex, rightToLeftIndex\
    \ + 1, collisionCount)\n                else collisionCount(leftToRight, rightToLeft,\
    \ leftToRightIndex + 1, rightToLeftIndex + 1, collisionCount + 1)\n          \
    \  }\n            collisionCount(leftToRight, rightToLeft, 0, 0, 0)\n        }\n\
    \        // This function returns the number of collisions between the cars in\
    \ the left-to-right\n        // set and the cars in the right-to-left set.\n \
    \       def collisionCount(leftToRight : Array[Long], rightToLeft : Array[Long],\
    \ leftToRightIndex : Int, rightToLeftIndex : Int, collisionCount : Long) : Long\
    \ = {\n            if (leftToRightIndex == leftToRight.length || rightToLeftIndex\
    \ == rightToLeft.length) collisionCount\n            else if (leftToRight(leftToRightIndex)\
    \ < rightToLeft(rightToLeftIndex)) collisionCount(leftToRight, rightToLeft, leftToRightIndex\
    \ + 1, rightToLeftIndex, collisionCount)\n            else if (leftToRight(leftToRightIndex)\
    \ > rightToLeft(rightToLeftIndex))\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxl6mxafx.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    'then' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxl6mxafx.scala:42:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m42 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E050] Type\
    \ Error: /tmp/tmpxl6mxafx.scala:20:88 -----------------------------\e[0m\e[0m\n\
    \e[31m20 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (leftToRight(leftToRightIndex)\
    \ < rightToLeft(rightToLeftIndex)) collisionCount(leftToRight, rightToLeft, leftToRightIndex\
    \ + \e[31m1\e[0m, rightToLeftIndex, collisionCount)\n\e[31m\e[31m   |\e[0m   \
    \                                                                            \
    \         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \e[33mparameter\e\
    [0m \e[35mcollisionCount\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E050] Type Error: /tmp/tmpxl6mxafx.scala:21:88 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (leftToRight(leftToRightIndex)\
    \ > rightToLeft(rightToLeftIndex)) collisionCount(leftToRight, rightToLeft, leftToRightIndex,\
    \ rightToLeftIndex + \e[31m1\e[0m, collisionCount)\n\e[31m\e[31m   |\e[0m    \
    \                                                                            \
    \        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \e[33mparameter\e\
    [0m \e[35mcollisionCount\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E050] Type Error: /tmp/tmpxl6mxafx.scala:22:21 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33melse\e[0m collisionCount(leftToRight,\
    \ rightToLeft, leftToRightIndex + \e[31m1\e[0m, rightToLeftIndex + \e[31m1\e[0m,\
    \ collisionCount + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     \e[33mparameter\e[0m \e[35mcoll"
  stdout: ''
  timestamp: 1659792823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars that are moving\
    \ left to right are numbered 1 to n.\n        // The cars that are moving right\
    \ to left are numbered n+1 to 2n.\n        // The cars that are moving left to\
    \ right are at positions 1 to n.\n        // The cars that are moving right to\
    \ left are at positions 2n to n+1.\n        // The cars that are moving left to\
    \ right are moving with speed 1.\n        // The cars that are moving right to\
    \ left are moving with speed -1.\n        // The cars that are moving left to\
    \ right are at positions 1 to n.\n        // The cars that are moving right to\
    \ left are at positions 2n to n+1.\n        // The cars that are moving left to\
    \ right are moving with speed 1.\n        // The cars that are moving right to\
    \ left are moving with speed -1.\n        // The cars that are moving left to\
    \ right are at positions 1 to n.\n        // The cars that are moving right to\
    \ left are at positions 2n to n+1.\n        // The cars that are moving left to\
    \ right are moving with speed 1.\n        // The cars that are moving right to\
    \ left are moving with speed -1.\n        // The cars that are moving left to\
    \ right are at positions 1 to n.\n        // The cars that are moving right to\
    \ left are at positions 2n to n+1.\n        // The cars that are moving left to\
    \ right are moving with speed 1.\n        // The cars that are moving right to\
    \ left are moving with speed -1.\n        // The cars that are moving left to\
    \ right are at positions 1 to n.\n        // The cars that are moving right to\
    \ left are at positions 2n to n+1.\n        // The cars that are moving left to\
    \ right are moving with speed 1.\n        // The cars that are moving right to\
    \ left are moving with speed -1.\n        // The cars that are moving left to\
    \ right are at positions 1 to n.\n        // The cars that are moving right to\
    \ left are at positions 2n to n+1.\n        // The cars that are moving left to\
    \ right are moving with speed 1.\n        // The cars that are moving right to\
    \ left are moving with speed -1.\n        // The cars that are moving left to\
    \ right are at positions 1 to n.\n        // The cars that are moving right to\
    \ left are at\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi_h6imvg.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars that are moving left to right are numbered 1 to n.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// The cars that are moving right to left are numbered n+1\
    \ to 2n.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars that are moving left to\
    \ right are at positions 1 to n.\e[0m\n\e[31m16 |\e[0m        \e[34m// The cars\
    \ that are moving right to left are at positions 2n to n+1.\e[0m\n\e[31m17 |\e\
    [0m        \e[34m// The cars that are moving left to right are moving with speed\
    \ 1.\e[0m\n\e[31m18 |\e[0m        \e[34m// The cars that are moving right to left\
    \ are moving with speed -1.\e[0m\n\e[31m19 |\e[0m        \e[34m// The cars that\
    \ are moving left to right are at positions 1 to n.\e[0m\n\e[31m20 |\e[0m    \
    \    \e[34m// The cars that are moving right to left are at positions 2n to n+1.\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// The cars that are moving left to right are\
    \ moving with speed 1.\e[0m\n\e[31m22 |\e[0m        \e[34m// The cars that are\
    \ moving right to left are moving with speed -1.\e[0m\n\e[31m23 |\e[0m       \
    \ \e[34m// The cars that are moving left to right are at positions 1 to n.\e[0m\n\
    \e[31m24 |\e[0m        \e[34m// The cars that are moving right to left are at\
    \ positions 2n to n+1.\e[0m\n\e[31m25 |\e[0m        \e[34m// The cars that are\
    \ moving left to right are moving with speed 1.\e[0m\n\e[31m26 |\e[0m        \e\
    [34m// The cars that are moving right to left are moving with speed -1.\e[0m\n\
    \e[31m27 |\e[0m        \e[34m// The cars that are moving left to right are at\
    \ positions 1 to n.\e[0m\n\e[31m28 |\e[0m        \e[34m// The cars that are moving\
    \ right to left are at positions 2n to n+1.\e[0m\n\e[31m29 |\e[0m        \e[34m//\
    \ The cars that are moving left to right are"
  stdout: ''
  timestamp: 1659792821
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars that are moving left to right\n        // will collide with\
    \ the cars that are moving right to left in the order\n        // of their positions.\
    \  For example, if the cars moving left to right are\n        // at positions\
    \ 1, 2, 3, 4, 5, and the cars moving right to left are at\n        // positions\
    \ 10, 9, 8, 7, 6, then the collisions will occur in the order\n        // (1,\
    \ 10), (2, 9), (3, 8), (4, 7), (5, 6).\n        // This is because the cars moving\
    \ left to right will collide with the\n        // cars moving right to left in\
    \ the order of their positions.\n        // The number of collisions is therefore\
    \ the sum of the first n positive integers.\n        // This is equal to n * (n\
    \ + 1) / 2.\n        n * (n + 1) / 2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy8mdsejn.scala:26)\n\tat Problem.main(tmpy8mdsejn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is the number\
    \ of pairs of cars that collide.\n        // The number of pairs of cars that\
    \ collide is the same as the number of pairs of cars\n        // that are at the\
    \ same position at the same time.\n        // The number of pairs of cars that\
    \ are at the same position at the same time is the same as\n        // the number\
    \ of pairs of cars that are at the same position at the same time.\n        //\
    \ The number of pairs of cars that are at the same position at the same time is\
    \ the same as\n        // the number of pairs of cars that are at the same position\
    \ at the same time.\n        // The number of pairs of cars that are at the same\
    \ position at the same time is the same as\n        // the number of pairs of\
    \ cars that are at the same position at the same time.\n        // The number\
    \ of pairs of cars that are at the same position at the same time is the same\
    \ as\n        // the number of pairs of cars that are at the same position at\
    \ the same time.\n        // The number of pairs of cars that are at the same\
    \ position at the same time is the same as\n        // the number of pairs of\
    \ cars that are at the same position at the same time.\n        // The number\
    \ of pairs of cars that are at the same position at the same time is the same\
    \ as\n        // the number of pairs of cars that are at the same position at\
    \ the same time.\n        // The number of pairs of cars that are at the same\
    \ position at the same time is the same as\n        // the number of pairs of\
    \ cars that are at the same position at the same time.\n        // The number\
    \ of pairs of cars that are at the same position at the same time is the same\
    \ as\n        // the number of pairs of cars that are at the same position at\
    \ the same time.\n        // The number of pairs of cars that are at the same\
    \ position at the same time is the same as\n        // the number of pairs of\
    \ cars that are at the same position at the same time.\n        // The number\
    \ of pairs of cars that are at the same position at the same time is the same\
    \ as\n        // the number of pairs of cars that are at the same position at\
    \ the same time.\n        // The number of pairs of cars that are at the same\
    \ position at the same time is the same as\n        // the number of pairs of\
    \ cars that\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps_t2tnwg.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is the number of pairs of cars that collide.\e[0m\n\e[31m14 |\e[0m\
    \        \e[34m// The number of pairs of cars that collide is the same as the\
    \ number of pairs of cars\e[0m\n\e[31m15 |\e[0m        \e[34m// that are at the\
    \ same position at the same time.\e[0m\n\e[31m16 |\e[0m        \e[34m// The number\
    \ of pairs of cars that are at the same position at the same time is the same\
    \ as\e[0m\n\e[31m17 |\e[0m        \e[34m// the number of pairs of cars that are\
    \ at the same position at the same time.\e[0m\n\e[31m18 |\e[0m        \e[34m//\
    \ The number of pairs of cars that are at the same position at the same time is\
    \ the same as\e[0m\n\e[31m19 |\e[0m        \e[34m// the number of pairs of cars\
    \ that are at the same position at the same time.\e[0m\n\e[31m20 |\e[0m      \
    \  \e[34m// The number of pairs of cars that are at the same position at the same\
    \ time is the same as\e[0m\n\e[31m21 |\e[0m        \e[34m// the number of pairs\
    \ of cars that are at the same position at the same time.\e[0m\n\e[31m22 |\e[0m\
    \        \e[34m// The number of pairs of cars that are at the same position at\
    \ the same time is the same as\e[0m\n\e[31m23 |\e[0m        \e[34m// the number\
    \ of pairs of cars that are at the same position at the same time.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// The number of pairs of cars that are at the same position\
    \ at the same time is the same as\e[0m\n\e[31m25 |\e[0m        \e[34m// the number\
    \ of pairs of cars that are at the same position at the same time.\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// The number of pairs of cars that are at the same position\
    \ at the same time is the same as\e[0m\n\e[31m27 |\e[0m        \e[34m// the number\
    \ of pairs of cars that are at "
  stdout: ''
  timestamp: 1659792822
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a brute force\
    \ solution.\n        // We can do better.\n        var count = 0\n        for\
    \ (i <- 1 to n.toInt) {\n            for (j <- 1 to n.toInt) {\n             \
    \   if (i < j) {\n                    count += 1\n                }\n        \
    \    }\n        }\n        return count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7l2l7ba5.scala:26)\n\tat Problem.main(tmp7l2l7ba5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792823
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then we can just go through\
    \ the sorted list and count the number of cars\n        // that are moving in\
    \ the opposite direction.\n        // The time complexity is O(n log n).\n   \
    \     val cars = Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt) cars(i)\
    \ = i\n        val sorted = cars.sortWith((a, b) => a < b)\n        var collisions\
    \ = 0L\n        for (i <- 0 until n.toInt) {\n            val car = sorted(i)\n\
    \            if (car < n.toInt) collisions += car\n            else collisions\
    \ += n - car - 1\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7fd0_vtu.scala:29)\n\tat Problem.main(tmp7fd0_vtu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is the number\
    \ of collisions.\n        var collisions = 0L\n        // This is the set of cars\
    \ that are driving left to right.\n        var leftToRight = new HashSet[Long]\n\
    \        // This is the set of cars that are driving right to left.\n        var\
    \ rightToLeft = new HashSet[Long]\n        // This is the set of cars that are\
    \ driving left to right and have collided.\n        var leftToRightCollided =\
    \ new HashSet[Long]\n        // This is the set of cars that are driving right\
    \ to left and have collided.\n        var rightToLeftCollided = new HashSet[Long]\n\
    \        // This is the set of cars that are driving left to right and have collided.\n\
    \        var leftToRightCollided2 = new HashSet[Long]\n        // This is the\
    \ set of cars that are driving right to left and have collided.\n        var rightToLeftCollided2\
    \ = new HashSet[Long]\n        // This is the set of cars that are driving left\
    \ to right and have collided.\n        var leftToRightCollided3 = new HashSet[Long]\n\
    \        // This is the set of cars that are driving right to left and have collided.\n\
    \        var rightToLeftCollided3 = new HashSet[Long]\n        // This is the\
    \ set of cars that are driving left to right and have collided.\n        var leftToRightCollided4\
    \ = new HashSet[Long]\n        // This is the set of cars that are driving right\
    \ to left and have collided.\n        var rightToLeftCollided4 = new HashSet[Long]\n\
    \        // This is the set of cars that are driving left to right and have collided.\n\
    \        var leftToRightCollided5 = new HashSet[Long]\n        // This is the\
    \ set of cars that are driving right to left and have collided.\n        var rightToLeftCollided5\
    \ = new HashSet[Long]\n        // This is the set of cars that are driving left\
    \ to right and have collided.\n        var leftToRightCollided6 = new HashSet[Long]\n\
    \        // This is the set of cars that are driving right to left and have collided.\n\
    \        var rightToLeftCollided6 = new HashSet[Long]\n        // This is the\
    \ set of cars that are driving left to right and have collided.\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4f2wzjhd.scala:44:5\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function outputs\
    \ the number of collisions between the cars that are moving\n        // left to\
    \ right and the cars that are moving right to left.\n        // The cars that\
    \ are moving left to right are numbered from 0 to n - 1.\n        // The cars\
    \ that are moving right to left are numbered from n to 2 * n - 1.\n        //\
    \ The cars that are moving left to right have the following positions:\n     \
    \   // 0, 1, 2, ..., n - 1.\n        // The cars that are moving right to left\
    \ have the following positions:\n        // n - 1, n - 2, n - 3, ..., 0.\n   \
    \     // The cars that are moving left to right have the following speeds:\n \
    \       // 1, 2, 3, ..., n.\n        // The cars that are moving right to left\
    \ have the following speeds:\n        // n, n - 1, n - 2, ..., 1.\n        //\
    \ The cars that are moving left to right have the following times to collision:\n\
    \        // (n - 1) / 1, (n - 2) / 2, (n - 3) / 3, ..., 0 / n.\n        // The\
    \ cars that are moving right to left have the following times to collision:\n\
    \        // (n - 1) / n, (n - 2) / (n - 1), (n - 3) / (n - 2), ..., 0 / 1.\n \
    \       // The cars that are moving left to right have the following times to\
    \ collision:\n        // n - 1, (n - 1) / 2, (n - 1) / 3, ..., (n - 1) / n.\n\
    \        // The cars that are moving right to left have the following times to\
    \ collision:\n        // n - 1, (n - 1) / 2, (n - 1) / 3, ..., (n - 1) / n.\n\
    \        // The cars that are moving left to right have the following times to\
    \ collision:\n        // n - 1, (n - 1) / 2, (n - 1) / 3, ..., (n - 1) / n.\n\
    \        // The cars that are moving right to left have the following times to\
    \ collision:\n        // n - 1, (n - 1) / 2, (n - 1) / 3, ..., (n - 1) /\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcedfty43.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This function outputs the number of collisions between the cars that are\
    \ moving\e[0m\n\e[31m14 |\e[0m        \e[34m// left to right and the cars that\
    \ are moving right to left.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars that\
    \ are moving left to right are numbered from 0 to n - 1.\e[0m\n\e[31m16 |\e[0m\
    \        \e[34m// The cars that are moving right to left are numbered from n to\
    \ 2 * n - 1.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars that are moving left\
    \ to right have the following positions:\e[0m\n\e[31m18 |\e[0m        \e[34m//\
    \ 0, 1, 2, ..., n - 1.\e[0m\n\e[31m19 |\e[0m        \e[34m// The cars that are\
    \ moving right to left have the following positions:\e[0m\n\e[31m20 |\e[0m   \
    \     \e[34m// n - 1, n - 2, n - 3, ..., 0.\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ The cars that are moving left to right have the following speeds:\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// 1, 2, 3, ..., n.\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ The cars that are moving right to left have the following speeds:\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// n, n - 1, n - 2, ..., 1.\e[0m\n\e[31m25 |\e[0m      \
    \  \e[34m// The cars that are moving left to right have the following times to\
    \ collision:\e[0m\n\e[31m26 |\e[0m        \e[34m// (n - 1) / 1, (n - 2) / 2, (n\
    \ - 3) / 3, ..., 0 / n.\e[0m\n\e[31m27 |\e[0m        \e[34m// The cars that are\
    \ moving right to left have the following times to collision:\e[0m\n\e[31m28 |\e\
    [0m        \e[34m// (n - 1) / n, (n - 2) / (n - 1), (n - 3) / (n - 2), ..., 0\
    \ / 1.\e[0m\n\e[31m29 |\e[0m        \e[34m// The cars that are moving left to\
    \ right have the following times to collision:\e[0m\n\e[31m30 |\e[0m        \e\
    [34m// n - 1, (n - 1) / 2, (n - 1) / 3, ..., (n - 1) / n.\e[0"
  stdout: ''
  timestamp: 1659792822
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to consider\
    \ the cars as points on a number line.\n        // The left-to-right cars are\
    \ at positions 0, 1, 2, ..., n - 1.\n        // The right-to-left cars are at\
    \ positions 0, -1, -2, ..., -(n - 1).\n        // The cars are all moving at the\
    \ same speed, so the cars at positions\n        // 0, 1, 2, ..., n - 1 will collide\
    \ with the cars at positions\n        // 0, -1, -2, ..., -(n - 1) respectively.\n\
    \        // So the number of collisions is n.\n        n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0zrnz_de.scala:23)\n\tat Problem.main(tmp0zrnz_de.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is the number\
    \ of collisions.\n        var collisions = 0L\n        // This is the number of\
    \ cars that are driving left to right.\n        var leftToRight = n\n        //\
    \ This is the number of cars that are driving right to left.\n        var rightToLeft\
    \ = n\n        // This is the number of cars that are driving left to right and\
    \ have collided.\n        var leftToRightCollided = 0L\n        // This is the\
    \ number of cars that are driving right to left and have collided.\n        var\
    \ rightToLeftCollided = 0L\n        // This is the number of cars that are driving\
    \ left to right and have not collided.\n        var leftToRightNotCollided = n\n\
    \        // This is the number of cars that are driving right to left and have\
    \ not collided.\n        var rightToLeftNotCollided = n\n        // This is the\
    \ number of cars that are driving left to right and have collided and are driving\
    \ right to left.\n        var leftToRightCollidedRightToLeft = 0L\n        //\
    \ This is the number of cars that are driving right to left and have collided\
    \ and are driving left to right.\n        var rightToLeftCollidedLeftToRight =\
    \ 0L\n        // This is the number of cars that are driving left to right and\
    \ have collided and are driving left to right.\n        var leftToRightCollidedLeftToRight\
    \ = 0L\n        // This is the number of cars that are driving right to left and\
    \ have collided and are driving right to left.\n        var rightToLeftCollidedRightToLeft\
    \ = 0L\n        // This is the number of cars that are driving left to right and\
    \ have not collided and are driving left to right.\n        var leftToRightNotCollidedLeftToRight\
    \ = n\n        // This is the number of cars that are driving right to left and\
    \ have not collided and are driving right to left.\n        var rightToLeftNotCollidedRightToLeft\
    \ = n\n        // This is the number of cars that are driving left to right and\
    \ have not collided and are driving right to left.\n        var leftToRightNotCollidedRightToLeft\
    \ = 0L\n        // This is the number of cars that are driving right to left and\
    \ have not collided and are driving left to right.\n        var rightToLeftNotCollidedLeftToRight\
    \ = 0L\n        // This is the number\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo76boqk2.scala:44:5\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 0 to n-1.\n        // The cars that are moving left to right are numbered\
    \ 0 to n-1.\n        // The cars that are moving right to left are numbered n\
    \ to 2n-1.\n        // The car that's moving left to right with number i starts\
    \ at position i.\n        // The car that's moving right to left with number i\
    \ starts at position 2n-1-i.\n        // The car that's moving left to right with\
    \ number i moves at speed 1.\n        // The car that's moving right to left with\
    \ number i moves at speed 1.\n        // The car that's moving left to right with\
    \ number i collides with the car that's moving right to left\n        // with\
    \ number j if and only if i + j = 2n-1.\n        // The car that's moving left\
    \ to right with number i collides with the car that's moving right to left\n \
    \       // with number j if and only if i < j.\n        // The car that's moving\
    \ left to right with number i collides with the car that's moving right to left\n\
    \        // with number j if and only if i + j < 2n.\n        // The car that's\
    \ moving left to right with number i collides with the car that's moving right\
    \ to left\n        // with number j if and only if i + j < 2n-1.\n        // The\
    \ car that's moving left to right with number i collides with the car that's moving\
    \ right to left\n        // with number j if and only if i + j < 2n-2.\n     \
    \   // The car that's moving left to right with number i collides with the car\
    \ that's moving right to left\n        // with number j if and only if i + j <\
    \ 2n-3.\n        // The car that's moving left to right with number i collides\
    \ with the car that's moving right to left\n        // with number j if and only\
    \ if i + j < 2n-4.\n        // The car that's moving left to right with number\
    \ i collides with the car that's moving right to left\n        // with number\
    \ j if and only if i + j < 2n-5.\n        // The car that's moving left to right\
    \ with number i collides with the car that's moving right to left\n        //\
    \ with number j if and\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplqc1lvcp.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 0 to n-1.\e[0m\n\e[31m14 |\e[0m        \e[34m//\
    \ The cars that are moving left to right are numbered 0 to n-1.\e[0m\n\e[31m15\
    \ |\e[0m        \e[34m// The cars that are moving right to left are numbered n\
    \ to 2n-1.\e[0m\n\e[31m16 |\e[0m        \e[34m// The car that's moving left to\
    \ right with number i starts at position i.\e[0m\n\e[31m17 |\e[0m        \e[34m//\
    \ The car that's moving right to left with number i starts at position 2n-1-i.\e\
    [0m\n\e[31m18 |\e[0m        \e[34m// The car that's moving left to right with\
    \ number i moves at speed 1.\e[0m\n\e[31m19 |\e[0m        \e[34m// The car that's\
    \ moving right to left with number i moves at speed 1.\e[0m\n\e[31m20 |\e[0m \
    \       \e[34m// The car that's moving left to right with number i collides with\
    \ the car that's moving right to left\e[0m\n\e[31m21 |\e[0m        \e[34m// with\
    \ number j if and only if i + j = 2n-1.\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ The car that's moving left to right with number i collides with the car that's\
    \ moving right to left\e[0m\n\e[31m23 |\e[0m        \e[34m// with number j if\
    \ and only if i < j.\e[0m\n\e[31m24 |\e[0m        \e[34m// The car that's moving\
    \ left to right with number i collides with the car that's moving right to left\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// with number j if and only if i + j < 2n.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// The car that's moving left to right with\
    \ number i collides with the car that's moving right to left\e[0m\n\e[31m27 |\e\
    [0m        \e[34m// with number j if and only if i + j < 2n-1.\e[0m\n\e[31m28\
    \ |\e[0m        \e[34m// The car that's moving left to right with number i collides\
    \ with the car that's moving right to left"
  stdout: ''
  timestamp: 1659792820
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can solve it by sorting the cars by their\n        // starting\
    \ positions.  Then, we can simply count the number of cars that are\n        //\
    \ moving in the same direction.\n        // The number of collisions is the number\
    \ of cars that are moving in the same direction\n        // minus 1.\n       \
    \ // The reason why we subtract 1 is because we are counting the number of cars\
    \ that are\n        // moving in the same direction.  However, we are not counting\
    \ the first car.\n        // For example, if there are 3 cars moving in the same\
    \ direction, we are counting\n        // the 2nd and 3rd cars.  However, we are\
    \ not counting the first car.\n        // Therefore, we have to subtract 1.\n\
    \        // The number of cars that are moving in the same direction is the number\
    \ of cars\n        // that are moving in the same direction minus 1.\n       \
    \ // The number of cars that are moving in the same direction is the number of\
    \ cars\n        // that are moving in the same direction minus 1.\n        //\
    \ The number of cars that are moving in the same direction is the number of cars\n\
    \        // that are moving in the same direction minus 1.\n        // The number\
    \ of cars that are moving in the same direction is the number of cars\n      \
    \  // that are moving in the same direction minus 1.\n        // The number of\
    \ cars that are moving in the same direction is the number of cars\n        //\
    \ that are moving in the same direction minus 1.\n        // The number of cars\
    \ that are moving in the same direction is the number of cars\n        // that\
    \ are moving in the same direction minus 1.\n        // The number of cars that\
    \ are moving in the same direction is the number of cars\n        // that are\
    \ moving in the same direction minus 1.\n        // The number of cars that are\
    \ moving in the same direction is the number of cars\n        // that are moving\
    \ in the same direction minus 1.\n        // The number of cars that are moving\
    \ in the same direction is the number of cars\n        // that are moving in the\
    \ same direction minus 1.\n        // The number of cars that are moving in the\
    \ same direction is the number of cars\n        // that are moving in the same\
    \ direction minus 1.\n        // The number of cars that are moving in the same\
    \ direction is the number of cars\n        // that are moving\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd541xlik.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  We can solve it by sorting the cars by\
    \ their\e[0m\n\e[31m14 |\e[0m        \e[34m// starting positions.  Then, we can\
    \ simply count the number of cars that are\e[0m\n\e[31m15 |\e[0m        \e[34m//\
    \ moving in the same direction.\e[0m\n\e[31m16 |\e[0m        \e[34m// The number\
    \ of collisions is the number of cars that are moving in the same direction\e\
    [0m\n\e[31m17 |\e[0m        \e[34m// minus 1.\e[0m\n\e[31m18 |\e[0m        \e\
    [34m// The reason why we subtract 1 is because we are counting the number of cars\
    \ that are\e[0m\n\e[31m19 |\e[0m        \e[34m// moving in the same direction.\
    \  However, we are not counting the first car.\e[0m\n\e[31m20 |\e[0m        \e\
    [34m// For example, if there are 3 cars moving in the same direction, we are counting\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// the 2nd and 3rd cars.  However, we are not\
    \ counting the first car.\e[0m\n\e[31m22 |\e[0m        \e[34m// Therefore, we\
    \ have to subtract 1.\e[0m\n\e[31m23 |\e[0m        \e[34m// The number of cars\
    \ that are moving in the same direction is the number of cars\e[0m\n\e[31m24 |\e\
    [0m        \e[34m// that are moving in the same direction minus 1.\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// The number of cars that are moving in the same direction\
    \ is the number of cars\e[0m\n\e[31m26 |\e[0m        \e[34m// that are moving\
    \ in the same direction minus 1.\e[0m\n\e[31m27 |\e[0m        \e[34m// The number\
    \ of cars that are moving in the same direction is the number of cars\e[0m\n\e\
    [31m28 |\e[0m        \e[34m// that are moving in the same direction minus 1.\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// The number of cars that are moving in the\
    \ same direction is the number of cars\e[0m\n"
  stdout: ''
  timestamp: 1659792822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 1 to n.  The left-to-right cars are numbered from 1 to n,\n        // and\
    \ the right-to-left cars are numbered from n to 1.\n        // The left-to-right\
    \ cars are at positions 1, 2, 3, ..., n.\n        // The right-to-left cars are\
    \ at positions n, n-1, n-2, ..., 1.\n        // The cars move at the same speed.\
    \  The left-to-right cars move 1 unit to the right\n        // per unit of time.\
    \  The right-to-left cars move 1 unit to the left per unit of time.\n        //\
    \ The cars are infinitely sturdy and strong; as a result, they continue moving\n\
    \        // in their trajectory as if they did not collide.\n        // Two cars\
    \ are said to collide when a car that's moving left to right hits a car that's\
    \ moving right to left.\n        // This function outputs the number of such collisions.\n\
    \        //\n        // The left-to-right cars are at positions 1, 2, 3, ...,\
    \ n.\n        // The right-to-left cars are at positions n, n-1, n-2, ..., 1.\n\
    \        // The left-to-right cars move 1 unit to the right per unit of time.\n\
    \        // The right-to-left cars move 1 unit to the left per unit of time.\n\
    \        // The cars are infinitely sturdy and strong; as a result, they continue\
    \ moving\n        // in their trajectory as if they did not collide.\n       \
    \ // Two cars are said to collide when a car that's moving left to right hits\
    \ a car that's moving right to left.\n        // This function outputs the number\
    \ of such collisions.\n        //\n        // The left-to-right cars are at positions\
    \ 1, 2, 3, ..., n.\n        // The right-to-left cars are at positions n, n-1,\
    \ n-2, ..., 1.\n        // The left-to-right cars move 1 unit to the right per\
    \ unit of time.\n        // The right-to-left cars move 1 unit to the left per\
    \ unit of time.\n        // The cars are infinitely sturdy and strong; as a result,\
    \ they continue moving\n        // in their trajectory as if they did not collide.\n\
    \       \n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzunf_slr.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 1 to n.  The left-to-right cars are numbered\
    \ from 1 to n,\e[0m\n\e[31m14 |\e[0m        \e[34m// and the right-to-left cars\
    \ are numbered from n to 1.\e[0m\n\e[31m15 |\e[0m        \e[34m// The left-to-right\
    \ cars are at positions 1, 2, 3, ..., n.\e[0m\n\e[31m16 |\e[0m        \e[34m//\
    \ The right-to-left cars are at positions n, n-1, n-2, ..., 1.\e[0m\n\e[31m17\
    \ |\e[0m        \e[34m// The cars move at the same speed.  The left-to-right cars\
    \ move 1 unit to the right\e[0m\n\e[31m18 |\e[0m        \e[34m// per unit of time.\
    \  The right-to-left cars move 1 unit to the left per unit of time.\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// The cars are infinitely sturdy and strong; as a result,\
    \ they continue moving\e[0m\n\e[31m20 |\e[0m        \e[34m// in their trajectory\
    \ as if they did not collide.\e[0m\n\e[31m21 |\e[0m        \e[34m// Two cars are\
    \ said to collide when a car that's moving left to right hits a car that's moving\
    \ right to left.\e[0m\n\e[31m22 |\e[0m        \e[34m// This function outputs the\
    \ number of such collisions.\e[0m\n\e[31m23 |\e[0m        \e[34m//\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// The left-to-right cars are at positions 1, 2, 3, ...,\
    \ n.\e[0m\n\e[31m25 |\e[0m        \e[34m// The right-to-left cars are at positions\
    \ n, n-1, n-2, ..., 1.\e[0m\n\e[31m26 |\e[0m        \e[34m// The left-to-right\
    \ cars move 1 unit to the right per unit of time.\e[0m\n\e[31m27 |\e[0m      \
    \  \e[34m// The right-to-left cars move 1 unit to the left per unit of time.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// The cars are infinitely sturdy and strong;\
    \ as a result, they continue moving\e[0m\n\e[31m29 |\e[0m        \e[34m// in their\
    \ trajectory as if they did not col"
  stdout: ''
  timestamp: 1659792822
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars and count the number of collisions.\n        // The time complexity\
    \ is O(n log n).\n        val cars = Array.fill(n.toInt)(0)\n        for (i <-\
    \ 0 until n.toInt) cars(i) = i\n        val sortedCars = cars.sortWith(_ < _)\n\
    \        var collisions = 0L\n        for (i <- 0 until n.toInt) {\n         \
    \   collisions += (sortedCars(i) - i)\n        }\n        collisions\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv4xgx2v8.scala:26)\n\tat Problem.main(tmpv4xgx2v8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can easily count\
    \ the number of collisions.\n        // The number of collisions is the number\
    \ of cars that start on the left\n        // minus the number of cars that start\
    \ on the right.\n        // The reason is that the cars that start on the left\
    \ will collide with\n        // the cars that start on the right.\n        //\
    \ The cars that start on the left will not collide with each other,\n        //\
    \ and the cars that start on the right will not collide with each other.\n   \
    \     // This is because the cars that start on the left will all be moving left\
    \ to right,\n        // and the cars that start on the right will all be moving\
    \ right to left.\n        // The cars that start on the left will not collide\
    \ with the cars that start on the left,\n        // and the cars that start on\
    \ the right will not collide with the cars that start on the right.\n        //\
    \ This is because the cars that start on the left will all be moving left to right,\n\
    \        // and the cars that start on the right will all be moving right to left.\n\
    \        // The cars that start on the left will not collide with the cars that\
    \ start on the right,\n        // and the cars that start on the right will not\
    \ collide with the cars that start on the left.\n        // This is because the\
    \ cars that start on the left will all be moving left to right,\n        // and\
    \ the cars that start on the right will all be moving right to left.\n       \
    \ // The cars that start on the left will not collide with the cars that start\
    \ on the right,\n        // and the cars that start on the right will not collide\
    \ with the cars that start on the left.\n        // This is because the cars that\
    \ start on the left will all be moving left to right,\n        // and the cars\
    \ that start on the right will all be moving right to left.\n        // The cars\
    \ that start on the left will not collide with the cars that start on the right,\n\
    \        // and the cars that start on the right will not collide with the cars\
    \ that start on the left.\n        // This is because the cars that start on the\
    \ left will all be moving left to right,\n        // and the cars that start on\
    \ the right will all be moving right to left.\n        // The cars that start\
    \ on the\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7tjv6c4b.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can easily count the number of collisions.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// The number of collisions is the number of\
    \ cars that start on the left\e[0m\n\e[31m16 |\e[0m        \e[34m// minus the\
    \ number of cars that start on the right.\e[0m\n\e[31m17 |\e[0m        \e[34m//\
    \ The reason is that the cars that start on the left will collide with\e[0m\n\e\
    [31m18 |\e[0m        \e[34m// the cars that start on the right.\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// The cars that start on the left will not collide with\
    \ each other,\e[0m\n\e[31m20 |\e[0m        \e[34m// and the cars that start on\
    \ the right will not collide with each other.\e[0m\n\e[31m21 |\e[0m        \e\
    [34m// This is because the cars that start on the left will all be moving left\
    \ to right,\e[0m\n\e[31m22 |\e[0m        \e[34m// and the cars that start on the\
    \ right will all be moving right to left.\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ The cars that start on the left will not collide with the cars that start on\
    \ the left,\e[0m\n\e[31m24 |\e[0m        \e[34m// and the cars that start on the\
    \ right will not collide with the cars that start on the right.\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// This is because the cars that start on the left will\
    \ all be moving left to right,\e[0m\n\e[31m26 |\e[0m        \e[34m// and the cars\
    \ that start on the right will all be moving right to left.\e[0m\n\e[31m27 |\e\
    [0m        \e[34m// The cars that start on the left will not collide with the\
    \ cars that start on the right,\e[0m\n\e[31m28 |\e[0m        \e[34m// and the\
    \ cars that start on the right will not collide with the ca"
  stdout: ''
  timestamp: 1659792832
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between the ith car\n        // moving left to right\
    \ and the jth car moving right to left.\n        def collision(i : Long, j : Long)\
    \ : Long = {\n            // The ith car moving left to right starts at position\
    \ i.\n            // The jth car moving right to left starts at position -j.\n\
    \            // The ith car moving left to right moves at speed 1.\n         \
    \   // The jth car moving right to left moves at speed 1.\n            // The\
    \ collision happens when the ith car moving left to right\n            // reaches\
    \ position -j.\n            // The time it takes for the ith car moving left to\
    \ right to reach\n            // position -j is -j - i.\n            // The time\
    \ it takes for the jth car moving right to left to reach\n            // position\
    \ i is i - (-j).\n            // The two cars collide if and only if -j - i =\
    \ i - (-j),\n            // which is equivalent to i = -j.\n            if (i\
    \ == -j) 1 else 0\n        }\n        // The number of collisions is the sum of\
    \ the number of collisions\n        // between the ith car moving left to right\
    \ and the jth car moving\n        // right to left for all i and j.\n        (1\
    \ to n.toInt).map(i => (1 to n.toInt).map(j => collision(i, j)).sum).sum\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm4d0r4af.scala:36)\n\tat Problem.main(tmpm4d0r4af.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792833
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm to count the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // We start with a line that's infinitely far to the\
    \ left.\n        // We move the line to the right, one unit at a time.\n     \
    \   // As we move the line, we keep track of the number of cars that are to the\
    \ left of the line.\n        // We also keep track of the number of cars that\
    \ are to the right of the line.\n        // When we move the line, we check if\
    \ the number of cars to the left of the line\n        // is equal to the number\
    \ of cars to the right of the line.\n        // If it is, then we have a collision.\n\
    \        // We continue moving the line until we reach the rightmost car.\n  \
    \      // The number of collisions is the number of times the number of cars to\
    \ the left of the line\n        // is equal to the number of cars to the right\
    \ of the line.\n        // The time complexity of this algorithm is O(n log n).\n\
    \        // The space complexity of this algorithm is O(n).\n        val cars\
    \ = new Array[Long](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n     \
    \       cars(i) = i\n            cars(i + n.toInt) = -(i + 1)\n        }\n   \
    \     val sortedCars = cars.sorted\n        var left = 0\n        var right =\
    \ 0\n        var collisions = 0\n        for (i <- 0 until 2 * n.toInt) {\n  \
    \          if (sortedCars(i) >= 0) {\n                left += 1\n            }\
    \ else {\n                right += 1\n            }\n            if (left == right)\
    \ {\n                collisions += 1\n            }\n        }\n        collisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw4uiy0tj.scala:50)\n\tat Problem.main(tmpw4uiy0tj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792834
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just count the\
    \ number of cars that are moving in the same direction.\n        // The number\
    \ of collisions is the number of cars that are moving in the same direction\n\
    \        // minus 1.\n        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = (i, true)\n     \
    \       cars(i + n.toInt) = (i, false)\n        }\n        cars.sortWith((a, b)\
    \ => a._1 < b._1)\n        var count = 0\n        var result = 0\n        for\
    \ (i <- 0 until 2 * n.toInt) {\n            if (cars(i)._2) count += 1\n     \
    \       else {\n                result += count - 1\n                count -=\
    \ 1\n            }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplcjvtuax.scala:35)\n\tat Problem.main(tmplcjvtuax.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792834
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var count = 0L\n     \
    \   for (i <- 1L to n) {\n            for (j <- 1L to n) {\n                if\
    \ (i * j == n) count += 1\n            }\n        }\n        count\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkina9o0m.scala:22)\n\tat Problem.main(tmpkina9o0m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792833
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a priority queue to keep track of the cars that are moving\n        // left\
    \ to right.  The priority queue is ordered by the position of the cars.\n    \
    \    // The cars that are moving right to left are stored in a sorted array.\n\
    \        // We iterate through the cars that are moving right to left.  For each\
    \ car,\n        // we check the priority queue to see if there are any cars that\
    \ are moving left to right\n        // that are in front of the car.  If there\
    \ are, we remove them from the priority queue\n        // and increment the number\
    \ of collisions.\n        val pq = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        val rightToLeft = Array.fill(n.toInt)(0L)\n        for (i <- 0 until\
    \ n.toInt) {\n            val x = scala.io.StdIn.readLine.toLong\n           \
    \ pq.enqueue(x)\n        }\n        for (i <- 0 until n.toInt) {\n           \
    \ val x = scala.io.StdIn.readLine.toLong\n            rightToLeft(i) = x\n   \
    \     }\n        var collisions = 0L\n        for (i <- 0 until n.toInt) {\n \
    \           while (!pq.isEmpty && pq.head > rightToLeft(i)) {\n              \
    \  pq.dequeue\n                collisions += 1\n            }\n        }\n   \
    \     collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: Cannot parse null string\n\tat java.base/java.lang.Long.parseLong(Long.java:674)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\
    \tat Problem$.carRaceCollision$$anonfun$1(tmpwssbtpg0.scala:23)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.carRaceCollision(tmpwssbtpg0.scala:25)\n\
    \tat Problem$.main(tmpwssbtpg0.scala:40)\n\tat Problem.main(tmpwssbtpg0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is the number\
    \ of collisions.\n        var collisionCount = 0L\n        // This is the number\
    \ of cars that are moving left to right.\n        var leftToRightCarCount = n\n\
    \        // This is the number of cars that are moving right to left.\n      \
    \  var rightToLeftCarCount = n\n        // This is the number of cars that are\
    \ moving left to right and have not collided yet.\n        var leftToRightCarCountNotCollided\
    \ = n\n        // This is the number of cars that are moving right to left and\
    \ have not collided yet.\n        var rightToLeftCarCountNotCollided = n\n   \
    \     // This is the number of cars that are moving left to right and have collided.\n\
    \        var leftToRightCarCountCollided = 0L\n        // This is the number of\
    \ cars that are moving right to left and have collided.\n        var rightToLeftCarCountCollided\
    \ = 0L\n        // This is the number of cars that are moving left to right and\
    \ have collided and are moving left to right.\n        var leftToRightCarCountCollidedLeftToRight\
    \ = 0L\n        // This is the number of cars that are moving left to right and\
    \ have collided and are moving right to left.\n        var leftToRightCarCountCollidedRightToLeft\
    \ = 0L\n        // This is the number of cars that are moving right to left and\
    \ have collided and are moving left to right.\n        var rightToLeftCarCountCollidedLeftToRight\
    \ = 0L\n        // This is the number of cars that are moving right to left and\
    \ have collided and are moving right to left.\n        var rightToLeftCarCountCollidedRightToLeft\
    \ = 0L\n        // This is the number of cars that are moving left to right and\
    \ have collided and are moving left to right and have collided.\n        var leftToRightCarCountCollidedLeftToRightCollided\
    \ = 0L\n        // This is the number of cars that are moving left to right and\
    \ have collided and are moving right to left and have collided.\n        var leftToRightCarCountCollidedRightToLeftCollided\
    \ = 0L\n        // This is the number of cars that are moving right to left and\
    \ have collided and are moving left to right and have collided.\n        var rightToLeftCarCountCollidedLeftToRightCollided\
    \ = 0L\n        // This is the number of\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2rp_xefd.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key is to realize that the cars\n        // are moving in the\
    \ same speed.  So, if two cars collide, they will collide\n        // infinitely\
    \ many times.  So, we only need to count the number of collisions\n        //\
    \ at the initial time.\n        // The cars are numbered from 0 to n-1.  The left-to-right\
    \ cars are numbered\n        // 0 to n-1; the right-to-left cars are numbered\
    \ n to 2n-1.\n        // The left-to-right car i starts at position i; the right-to-left\
    \ car i starts\n        // at position 2n-1-i.\n        // So, the left-to-right\
    \ car i collides with the right-to-left car j if and only if\n        // i + j\
    \ = 2n-1.\n        // So, the number of collisions is the number of pairs (i,\
    \ j) such that\n        // i + j = 2n-1.\n        // This is the same as the number\
    \ of pairs (i, j) such that i + j = n-1.\n        // So, the number of collisions\
    \ is the number of pairs (i, j) such that\n        // i + j = n-1, where 0 <=\
    \ i < n and 0 <= j < n.\n        // This is the same as the number of pairs (i,\
    \ j) such that i + j = n-1, where\n        // 0 <= i < n and 0 <= j < n-i.\n \
    \       // This is the same as the number of pairs (i, j) such that i + j = n-1,\
    \ where\n        // 0 <= i < n and 0 <= j <= n-1-i.\n        // This is the same\
    \ as the number of pairs (i, j) such that i + j = n-1, where\n        // 0 <=\
    \ i <= n-1 and 0 <= j <= n-1-i.\n        // This is the same as the number of\
    \ pairs (i, j) such that i + j = n-1, where\n        // 0 <= i <= n-1 and 0 <=\
    \ j <= n-1-i.\n        // This is the same as the number of pairs (i, j) such\
    \ that i + j = n\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjvgm88aj.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  The key is to realize that the cars\e[0m\n\
    \e[31m14 |\e[0m        \e[34m// are moving in the same speed.  So, if two cars\
    \ collide, they will collide\e[0m\n\e[31m15 |\e[0m        \e[34m// infinitely\
    \ many times.  So, we only need to count the number of collisions\e[0m\n\e[31m16\
    \ |\e[0m        \e[34m// at the initial time.\e[0m\n\e[31m17 |\e[0m        \e\
    [34m// The cars are numbered from 0 to n-1.  The left-to-right cars are numbered\e\
    [0m\n\e[31m18 |\e[0m        \e[34m// 0 to n-1; the right-to-left cars are numbered\
    \ n to 2n-1.\e[0m\n\e[31m19 |\e[0m        \e[34m// The left-to-right car i starts\
    \ at position i; the right-to-left car i starts\e[0m\n\e[31m20 |\e[0m        \e\
    [34m// at position 2n-1-i.\e[0m\n\e[31m21 |\e[0m        \e[34m// So, the left-to-right\
    \ car i collides with the right-to-left car j if and only if\e[0m\n\e[31m22 |\e\
    [0m        \e[34m// i + j = 2n-1.\e[0m\n\e[31m23 |\e[0m        \e[34m// So, the\
    \ number of collisions is the number of pairs (i, j) such that\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// i + j = 2n-1.\e[0m\n\e[31m25 |\e[0m        \e[34m// This\
    \ is the same as the number of pairs (i, j) such that i + j = n-1.\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// So, the number of collisions is the number of pairs (i,\
    \ j) such that\e[0m\n\e[31m27 |\e[0m        \e[34m// i + j = n-1, where 0 <= i\
    \ < n and 0 <= j < n.\e[0m\n\e[31m28 |\e[0m        \e[34m// This is the same as\
    \ the number of pairs (i, j) such that i + j = n-1, where\e[0m\n\e[31m29 |\e[0m\
    \        \e[34m// 0 <= i < n and 0 <= j < n-i.\e[0m\n\e[31m30 |\e[0m        \e\
    [34m// This is the same as the number of pairs (i, j) such that i + j = n-1, where\e\
    [0m\n\e[31m31 |\e[0m        \e[34m// "
  stdout: ''
  timestamp: 1659792830
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key is to realize that the cars\n        // moving left to right\
    \ will always collide with the cars moving right to left\n        // in the order\
    \ of their positions.  For example, if the cars moving left to right\n       \
    \ // are at positions 1, 2, 3, 4, and 5, and the cars moving right to left are\
    \ at\n        // positions -1, -2, -3, -4, and -5, then the first collision will\
    \ be between\n        // the car at position 1 and the car at position -1, the\
    \ second collision will be\n        // between the car at position 2 and the car\
    \ at position -2, and so on.\n        // So the answer is simply the sum of the\
    \ first n positive integers.\n        n * (n + 1) / 2\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy4ol3d4q.scala:24)\n\tat Problem.main(tmpy4ol3d4q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a simple problem\
    \ that can be solved by a simple greedy algorithm.\n        // The greedy algorithm\
    \ is as follows:\n        // 1.  Sort the cars by their starting positions.\n\
    \        // 2.  Iterate through the cars from left to right.\n        // 3.  For\
    \ each car, if the car is moving left to right, then we can count\n        //\
    \     the number of cars that are moving right to left that are to the left\n\
    \        //     of the current car.  These cars will collide with the current\
    \ car.\n        // 4.  Return the sum of the number of collisions for each car.\n\
    \        //\n        // The time complexity of this algorithm is O(n log n).\n\
    \        //\n        // The following is a proof of correctness of the algorithm.\n\
    \        //\n        // Let's say that we have a car that's moving left to right.\
    \  Let's say that\n        // this car is at position x and that it's moving at\
    \ speed v.  Let's say that\n        // there are k cars that are moving right\
    \ to left that are to the left of this\n        // car.  Let's say that the ith\
    \ car is at position x_i and that it's moving at\n        // speed v_i.  Let's\
    \ say that the car at position x_i is the jth car that's\n        // moving right\
    \ to left that is to the left of the car at position x.\n        //\n        //\
    \ Let's say that the car at position x_i collides with the car at position x.\n\
    \        // Let's say that the collision occurs at time t.  Let's say that the\
    \ car at\n        // position x_i is at position y_i at time t.  Let's say that\
    \ the car at\n        // position x is at position y at time t.\n        //\n\
    \        // We know that the car at position x_i is moving right to left.  Therefore,\n\
    \        // y_i < x_i.  We know that the car at position x is moving left to right.\n\
    \        // Therefore, y > x.  We know that the car at position x_i collides with\
    \ the\n        // car at position x.  Therefore, y_i = y.  Therefore, x_i = y.\n\
    \        //\n        // We know that the car\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp488bautr.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a simple problem that can be solved by a simple greedy algorithm.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// The greedy algorithm is as follows:\e[0m\n\
    \e[31m15 |\e[0m        \e[34m// 1.  Sort the cars by their starting positions.\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// 2.  Iterate through the cars from left to\
    \ right.\e[0m\n\e[31m17 |\e[0m        \e[34m// 3.  For each car, if the car is\
    \ moving left to right, then we can count\e[0m\n\e[31m18 |\e[0m        \e[34m//\
    \     the number of cars that are moving right to left that are to the left\e\
    [0m\n\e[31m19 |\e[0m        \e[34m//     of the current car.  These cars will\
    \ collide with the current car.\e[0m\n\e[31m20 |\e[0m        \e[34m// 4.  Return\
    \ the sum of the number of collisions for each car.\e[0m\n\e[31m21 |\e[0m    \
    \    \e[34m//\e[0m\n\e[31m22 |\e[0m        \e[34m// The time complexity of this\
    \ algorithm is O(n log n).\e[0m\n\e[31m23 |\e[0m        \e[34m//\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// The following is a proof of correctness of the algorithm.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m//\e[0m\n\e[31m26 |\e[0m        \e[34m// Let's\
    \ say that we have a car that's moving left to right.  Let's say that\e[0m\n\e\
    [31m27 |\e[0m        \e[34m// this car is at position x and that it's moving at\
    \ speed v.  Let's say that\e[0m\n\e[31m28 |\e[0m        \e[34m// there are k cars\
    \ that are moving right to left that are to the left of this\e[0m\n\e[31m29 |\e\
    [0m        \e[34m// car.  Let's say that the ith car is at position x_i and that\
    \ it's moving at\e[0m\n\e[31m30 |\e[0m        \e[34m// speed v_i.  Let's say that\
    \ the car at position x_i is the jth car that's\e[0m\n\e[31m31 |\e[0m        \e\
    [34m// moving right to left that is to the left "
  stdout: ''
  timestamp: 1659792831
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.  We will have a line that sweeps\n        // from left\
    \ to right.  We will keep track of the cars that are moving left to right\n  \
    \      // and the cars that are moving right to left.  We will use a priority\
    \ queue to\n        // keep track of the cars that are moving left to right, and\
    \ we will use a priority\n        // queue to keep track of the cars that are\
    \ moving right to left.  The priority\n        // queue will be sorted by the\
    \ position of the car.  When the sweep line encounters\n        // a car that's\
    \ moving left to right, we will add it to the priority queue.  When\n        //\
    \ the sweep line encounters a car that's moving right to left, we will add it\
    \ to\n        // the priority queue.  When the sweep line encounters a car that's\
    \ moving left to right,\n        // we will remove it from the priority queue.\
    \  When the sweep line encounters a car that's\n        // moving right to left,\
    \ we will remove it from the priority queue.  We will keep track\n        // of\
    \ the number of collisions.  When the sweep line encounters a car that's moving\
    \ left\n        // to right, we will check the priority queue of cars that are\
    \ moving right to left.  If\n        // the car that's moving left to right is\
    \ in front of the car that's moving right to left,\n        // then we will have\
    \ a collision.  We will keep track of the number of collisions.  When\n      \
    \  // the sweep line encounters a car that's moving right to left, we will check\
    \ the priority\n        // queue of cars that are moving left to right.  If the\
    \ car that's moving right to left is\n        // in front of the car that's moving\
    \ left to right, then we will have a collision.  We will\n        // keep track\
    \ of the number of collisions.\n        // We will use a priority queue to keep\
    \ track of the cars that are moving left to right.\n        // We will use a priority\
    \ queue to keep track of the cars that are moving right to left.\n        // The\
    \ priority queue will be sorted by the position of the car.\n        val leftToRight\
    \ = new PriorityQueue[Long]()(Ordering.Long.reverse)\n        val rightToLeft\
    \ = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnxu000bh.scala:38:5\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The key observation\
    \ is that the cars are infinitely strong and sturdy.\n        // As a result,\
    \ the cars that are moving left to right will never collide with\n        // each\
    \ other.  The same is true for the cars that are moving right to left.\n     \
    \   // So, the only collisions that can occur are between a car that's moving\
    \ left to right\n        // and a car that's moving right to left.\n        //\
    \ The key observation is that the cars are infinitely strong and sturdy.\n   \
    \     // As a result, the cars that are moving left to right will never collide\
    \ with\n        // each other.  The same is true for the cars that are moving\
    \ right to left.\n        // So, the only collisions that can occur are between\
    \ a car that's moving left to right\n        // and a car that's moving right\
    \ to left.\n        // The key observation is that the cars are infinitely strong\
    \ and sturdy.\n        // As a result, the cars that are moving left to right\
    \ will never collide with\n        // each other.  The same is true for the cars\
    \ that are moving right to left.\n        // So, the only collisions that can\
    \ occur are between a car that's moving left to right\n        // and a car that's\
    \ moving right to left.\n        // The key observation is that the cars are infinitely\
    \ strong and sturdy.\n        // As a result, the cars that are moving left to\
    \ right will never collide with\n        // each other.  The same is true for\
    \ the cars that are moving right to left.\n        // So, the only collisions\
    \ that can occur are between a car that's moving left to right\n        // and\
    \ a car that's moving right to left.\n        // The key observation is that the\
    \ cars are infinitely strong and sturdy.\n        // As a result, the cars that\
    \ are moving left to right will never collide with\n        // each other.  The\
    \ same is true for the cars that are moving right to left.\n        // So, the\
    \ only collisions that can occur are between a car that's moving left to right\n\
    \        // and a car that's moving right to left.\n        // The key observation\
    \ is that the cars are infinitely strong and sturdy.\n        // As a result,\
    \ the cars that are moving left to right will never collide with\n        // each\
    \ other.  The same is true for the cars that are moving right to left.\n     \
    \   // So, the\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1ep8i0mu.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The key observation is that the cars are infinitely strong and sturdy.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// As a result, the cars that are moving left\
    \ to right will never collide with\e[0m\n\e[31m15 |\e[0m        \e[34m// each\
    \ other.  The same is true for the cars that are moving right to left.\e[0m\n\e\
    [31m16 |\e[0m        \e[34m// So, the only collisions that can occur are between\
    \ a car that's moving left to right\e[0m\n\e[31m17 |\e[0m        \e[34m// and\
    \ a car that's moving right to left.\e[0m\n\e[31m18 |\e[0m        \e[34m// The\
    \ key observation is that the cars are infinitely strong and sturdy.\e[0m\n\e\
    [31m19 |\e[0m        \e[34m// As a result, the cars that are moving left to right\
    \ will never collide with\e[0m\n\e[31m20 |\e[0m        \e[34m// each other.  The\
    \ same is true for the cars that are moving right to left.\e[0m\n\e[31m21 |\e\
    [0m        \e[34m// So, the only collisions that can occur are between a car that's\
    \ moving left to right\e[0m\n\e[31m22 |\e[0m        \e[34m// and a car that's\
    \ moving right to left.\e[0m\n\e[31m23 |\e[0m        \e[34m// The key observation\
    \ is that the cars are infinitely strong and sturdy.\e[0m\n\e[31m24 |\e[0m   \
    \     \e[34m// As a result, the cars that are moving left to right will never\
    \ collide with\e[0m\n\e[31m25 |\e[0m        \e[34m// each other.  The same is\
    \ true for the cars that are moving right to left.\e[0m\n\e[31m26 |\e[0m     \
    \   \e[34m// So, the only collisions that can occur are between a car that's moving\
    \ left to right\e[0m\n\e[31m27 |\e[0m        \e[34m// and a car that's moving\
    \ right to left.\e[0m\n\e[31m28 |\e[0m        \e[34m// The key observation is\
    \ that the cars are infinitely strong and sturdy.\e[0m"
  stdout: ''
  timestamp: 1659792832
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key observation is that the cars that are\n        // moving in\
    \ the same direction never collide.  So, we just need to count the number\n  \
    \      // of cars that are moving in the opposite direction.  This is simply the\
    \ number of\n        // pairs of cars that are moving in opposite directions.\
    \  There are n such pairs.\n        // So, the answer is n.\n        n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpedz52xkl.scala:21)\n\tat Problem.main(tmpedz52xkl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between cars moving left to right\n        // and cars\
    \ moving right to left.\n        // The cars are numbered from 0 to n-1.\n   \
    \     // The cars moving left to right are numbered from 0 to n-1.\n        //\
    \ The cars moving right to left are numbered from n-1 to 0.\n        // The cars\
    \ moving left to right are at positions x1, x2, ..., xn.\n        // The cars\
    \ moving right to left are at positions y1, y2, ..., yn.\n        // The cars\
    \ moving left to right are moving at speeds s1, s2, ..., sn.\n        // The cars\
    \ moving right to left are moving at speeds t1, t2, ..., tn.\n        // The cars\
    \ moving left to right are moving at speeds s1, s2, ..., sn.\n        // The cars\
    \ moving right to left are moving at speeds t1, t2, ..., tn.\n        // The cars\
    \ moving left to right are moving at speeds s1, s2, ..., sn.\n        // The cars\
    \ moving right to left are moving at speeds t1, t2, ..., tn.\n        // The cars\
    \ moving left to right are moving at speeds s1, s2, ..., sn.\n        // The cars\
    \ moving right to left are moving at speeds t1, t2, ..., tn.\n        // The cars\
    \ moving left to right are moving at speeds s1, s2, ..., sn.\n        // The cars\
    \ moving right to left are moving at speeds t1, t2, ..., tn.\n        // The cars\
    \ moving left to right are moving at speeds s1, s2, ..., sn.\n        // The cars\
    \ moving right to left are moving at speeds t1, t2, ..., tn.\n        // The cars\
    \ moving left to right are moving at speeds s1, s2, ..., sn.\n        // The cars\
    \ moving right to left are moving at speeds t1, t2, ..., tn.\n        // The cars\
    \ moving left to right are moving at speeds s1, s2, ..., sn.\n        // The cars\
    \ moving right to left are moving at speeds t1, t2, ..., tn.\n        // The cars\
    \ moving left to right are moving at speeds s\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf0zskh_3.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This function returns the number of collisions between cars moving left\
    \ to right\e[0m\n\e[31m14 |\e[0m        \e[34m// and cars moving right to left.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// The cars are numbered from 0 to n-1.\e[0m\n\
    \e[31m16 |\e[0m        \e[34m// The cars moving left to right are numbered from\
    \ 0 to n-1.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars moving right to left\
    \ are numbered from n-1 to 0.\e[0m\n\e[31m18 |\e[0m        \e[34m// The cars moving\
    \ left to right are at positions x1, x2, ..., xn.\e[0m\n\e[31m19 |\e[0m      \
    \  \e[34m// The cars moving right to left are at positions y1, y2, ..., yn.\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// The cars moving left to right are moving\
    \ at speeds s1, s2, ..., sn.\e[0m\n\e[31m21 |\e[0m        \e[34m// The cars moving\
    \ right to left are moving at speeds t1, t2, ..., tn.\e[0m\n\e[31m22 |\e[0m  \
    \      \e[34m// The cars moving left to right are moving at speeds s1, s2, ...,\
    \ sn.\e[0m\n\e[31m23 |\e[0m        \e[34m// The cars moving right to left are\
    \ moving at speeds t1, t2, ..., tn.\e[0m\n\e[31m24 |\e[0m        \e[34m// The\
    \ cars moving left to right are moving at speeds s1, s2, ..., sn.\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// The cars moving right to left are moving at speeds t1,\
    \ t2, ..., tn.\e[0m\n\e[31m26 |\e[0m        \e[34m// The cars moving left to right\
    \ are moving at speeds s1, s2, ..., sn.\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ The cars moving right to left are moving at speeds t1, t2, ..., tn.\e[0m\n\e\
    [31m28 |\e[0m        \e[34m// The cars moving left to right are moving at speeds\
    \ s1, s2, ..., sn.\e[0m\n\e[31m29 |\e[0m        \e[34m// The cars moving right\
    \ to left are moving at speeds t1, t2, ..., tn.\e[0m"
  stdout: ''
  timestamp: 1659792832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars, and count the number of collisions\n        // that occur.\n     \
    \   // The number of collisions is the number of cars that are moving left to\
    \ right\n        // that are to the left of the current car, plus the number of\
    \ cars that are moving\n        // right to left that are to the right of the\
    \ current car.\n        // The number of cars that are moving left to right that\
    \ are to the left of the current\n        // car is the number of cars that are\
    \ moving left to right that are to the left of the\n        // current car's starting\
    \ position, minus the number of cars that are moving left to right\n        //\
    \ that are to the left of the current car's ending position.\n        // The number\
    \ of cars that are moving right to left that are to the right of the current\n\
    \        // car is the number of cars that are moving right to left that are to\
    \ the right of the\n        // current car's starting position, minus the number\
    \ of cars that are moving right to left\n        // that are to the right of the\
    \ current car's ending position.\n        // The number of cars that are moving\
    \ left to right that are to the left of the current\n        // car's starting\
    \ position is the current car's starting position.\n        // The number of cars\
    \ that are moving left to right that are to the left of the current\n        //\
    \ car's ending position is the current car's ending position.\n        // The\
    \ number of cars that are moving right to left that are to the right of the current\n\
    \        // car's starting position is n - the current car's starting position.\n\
    \        // The number of cars that are moving right to left that are to the right\
    \ of the current\n        // car's ending position is n - the current car's ending\
    \ position.\n        // The number of cars that are moving left to right that\
    \ are to the left of the current\n        // car's starting position is the current\
    \ car's starting position.\n        // The number of cars that are moving left\
    \ to right that are to the left of the current\n        // car's ending position\
    \ is the current car's ending position.\n        // The number of cars that are\
    \ moving right to left that are to the right of the current\n        // car's\
    \ starting position is n - the current car's starting position.\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm04wg2x3.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can just iterate through the cars, and count\
    \ the number of collisions\e[0m\n\e[31m15 |\e[0m        \e[34m// that occur.\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// The number of collisions is the number of\
    \ cars that are moving left to right\e[0m\n\e[31m17 |\e[0m        \e[34m// that\
    \ are to the left of the current car, plus the number of cars that are moving\e\
    [0m\n\e[31m18 |\e[0m        \e[34m// right to left that are to the right of the\
    \ current car.\e[0m\n\e[31m19 |\e[0m        \e[34m// The number of cars that are\
    \ moving left to right that are to the left of the current\e[0m\n\e[31m20 |\e\
    [0m        \e[34m// car is the number of cars that are moving left to right that\
    \ are to the left of the\e[0m\n\e[31m21 |\e[0m        \e[34m// current car's starting\
    \ position, minus the number of cars that are moving left to right\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// that are to the left of the current car's ending position.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// The number of cars that are moving right\
    \ to left that are to the right of the current\e[0m\n\e[31m24 |\e[0m        \e\
    [34m// car is the number of cars that are moving right to left that are to the\
    \ right of the\e[0m\n\e[31m25 |\e[0m        \e[34m// current car's starting position,\
    \ minus the number of cars that are moving right to left\e[0m\n\e[31m26 |\e[0m\
    \        \e[34m// that are to the right of the current car's ending position.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// The number of cars that are moving left to\
    \ right that are to the left of the current\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ car's starting position is "
  stdout: ''
  timestamp: 1659792833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars and count the number of collisions.\n        // The number of collisions\
    \ is the number of cars that are moving left to right\n        // that are to\
    \ the left of a car that's moving right to left.\n        // We can count this\
    \ by keeping track of the number of cars that are moving left to right\n     \
    \   // that are to the left of the current car.\n        var collisions = 0L\n\
    \        var leftCars = 0L\n        var rightCars = 0L\n        var i = 0L\n \
    \       while (i < n) {\n            val car = readLine.split(\" \").map(_.toLong)\n\
    \            if (car(0) < 0) {\n                leftCars += 1\n            } else\
    \ {\n                collisions += leftCars\n                rightCars += 1\n\
    \            }\n            i += 1\n        }\n        collisions\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg9tx_c7y.scala:24:22 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mcar\e[0m = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toLong)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: readLine\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659792828
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 0 to n-1.\n        // The left-to-right cars are numbered from 0 to n-1.\n\
    \        // The right-to-left cars are numbered from n-1 to 0.\n        // The\
    \ left-to-right cars start at position 0.\n        // The right-to-left cars start\
    \ at position 2n.\n        // The cars move at the same speed.\n        // The\
    \ left-to-right cars move at speed 1.\n        // The right-to-left cars move\
    \ at speed -1.\n        // The cars are infinitely strong and sturdy.\n      \
    \  // Two cars collide when they are at the same position.\n        // The cars\
    \ are infinitely long.\n        // The cars are infinitely wide.\n        // The\
    \ cars are infinitely tall.\n        // The cars are infinitely heavy.\n     \
    \   // The cars are infinitely strong.\n        // The cars are infinitely sturdy.\n\
    \        // The cars are infinitely dense.\n        // The cars are infinitely\
    \ massive.\n        // The cars are infinitely large.\n        // The cars are\
    \ infinitely small.\n        // The cars are infinitely fast.\n        // The\
    \ cars are infinitely slow.\n        // The cars are infinitely quick.\n     \
    \   // The cars are infinitely agile.\n        // The cars are infinitely nimble.\n\
    \        // The cars are infinitely dexterous.\n        // The cars are infinitely\
    \ flexible.\n        // The cars are infinitely supple.\n        // The cars are\
    \ infinitely limber.\n        // The cars are infinitely lithe.\n        // The\
    \ cars are infinitely pliable.\n        // The cars are infinitely elastic.\n\
    \        // The cars are infinitely bendable.\n        // The cars are infinitely\
    \ malleable.\n        // The cars are infinitely ductile.\n        // The cars\
    \ are infinitely pliant.\n        // The cars are infinitely resilient.\n    \
    \    // The cars are infinitely tough.\n        // The cars are infinitely strong.\n\
    \        // The cars are infinitely sturdy.\n        // The cars are infinitely\
    \ hard.\n        // The cars are infinitely durable.\n        // The cars are\
    \ infinitely rugged.\n        // The cars are infinitely robust.\n        // The\
    \ cars are infinitely impervious.\n        // The cars are infinitely invulnerable.\n\
    \        // The cars are infinitely resistant.\n        // The cars are infinitely\
    \ immune.\n        // The cars are infinitely\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6kwvjlfi.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 0 to n-1.\e[0m\n\e[31m14 |\e[0m        \e[34m//\
    \ The left-to-right cars are numbered from 0 to n-1.\e[0m\n\e[31m15 |\e[0m   \
    \     \e[34m// The right-to-left cars are numbered from n-1 to 0.\e[0m\n\e[31m16\
    \ |\e[0m        \e[34m// The left-to-right cars start at position 0.\e[0m\n\e\
    [31m17 |\e[0m        \e[34m// The right-to-left cars start at position 2n.\e[0m\n\
    \e[31m18 |\e[0m        \e[34m// The cars move at the same speed.\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// The left-to-right cars move at speed 1.\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// The right-to-left cars move at speed -1.\e[0m\n\e[31m21\
    \ |\e[0m        \e[34m// The cars are infinitely strong and sturdy.\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// Two cars collide when they are at the same position.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// The cars are infinitely long.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// The cars are infinitely wide.\e[0m\n\e[31m25 |\e[0m \
    \       \e[34m// The cars are infinitely tall.\e[0m\n\e[31m26 |\e[0m        \e\
    [34m// The cars are infinitely heavy.\e[0m\n\e[31m27 |\e[0m        \e[34m// The\
    \ cars are infinitely strong.\e[0m\n\e[31m28 |\e[0m        \e[34m// The cars are\
    \ infinitely sturdy.\e[0m\n\e[31m29 |\e[0m        \e[34m// The cars are infinitely\
    \ dense.\e[0m\n\e[31m30 |\e[0m        \e[34m// The cars are infinitely massive.\e\
    [0m\n\e[31m31 |\e[0m        \e[34m// The cars are infinitely large.\e[0m\n\e[31m32\
    \ |\e[0m        \e[34m// The cars are infinitely small.\e[0m\n\e[31m33 |\e[0m\
    \        \e[34m// The cars are infinitely fast.\e[0m\n\e[31m34 |\e[0m        \e\
    [34m// The cars are infinitely slow.\e[0m\n\e[31m35 |\e[0m        \e[34m// The\
    \ cars are infinitely quick.\e[0m\n\e[31m36 |\e[0m        \e[34m// The c"
  stdout: ''
  timestamp: 1659792833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The key observation\
    \ is that two cars will collide if and only if they are at the same\n        //\
    \ position at the same time.  This is because they are infinitely strong and sturdy.\n\
    \        // The cars are moving at the same speed.  So, the only way two cars\
    \ can collide is if\n        // they start at the same position.\n        //\n\
    \        // The cars are moving in opposite directions.  So, the cars that are\
    \ moving left to right\n        // will be at position x at time t if they start\
    \ at position x - t.  Similarly, the cars\n        // that are moving right to\
    \ left will be at position x at time t if they start at position\n        // x\
    \ + t.  So, two cars will collide if and only if there are two cars that start\
    \ at the\n        // same position.\n        //\n        // So, the answer is\
    \ the number of pairs of cars that start at the same position.\n        //\n \
    \       // The number of pairs of cars that start at the same position is the\
    \ number of cars that\n        // start at the same position, multiplied by the\
    \ number of cars that start at the same\n        // position, minus one.  This\
    \ is because we don't want to count the pair of cars that\n        // start at\
    \ the same position twice.\n        //\n        // The number of cars that start\
    \ at the same position is the number of cars that start at\n        // position\
    \ 0, plus the number of cars that start at position 1, plus the number of cars\n\
    \        // that start at position 2, etc.  This is because the cars are starting\
    \ at all possible\n        // positions.\n        //\n        // The number of\
    \ cars that start at position 0 is the number of cars that start at position\n\
    \        // 0, minus one.  This is because we don't want to count the car that\
    \ starts at position 0\n        // twice.\n        //\n        // The number of\
    \ cars that start at position 0 is the number of cars that start at position\n\
    \        // 0, minus one.  This is because we don't want to count the car that\
    \ starts at position 0\n        // twice.\n        //\n        // The number of\
    \ cars that start at position 0 is the number of cars that start at position\n\
    \        // 0, minus one.  This is because we don't want to count the car that\
    \ starts at position 0\n       \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps92z6pja.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The key observation is that two cars will collide if and only if they are\
    \ at the same\e[0m\n\e[31m14 |\e[0m        \e[34m// position at the same time.\
    \  This is because they are infinitely strong and sturdy.\e[0m\n\e[31m15 |\e[0m\
    \        \e[34m// The cars are moving at the same speed.  So, the only way two\
    \ cars can collide is if\e[0m\n\e[31m16 |\e[0m        \e[34m// they start at the\
    \ same position.\e[0m\n\e[31m17 |\e[0m        \e[34m//\e[0m\n\e[31m18 |\e[0m \
    \       \e[34m// The cars are moving in opposite directions.  So, the cars that\
    \ are moving left to right\e[0m\n\e[31m19 |\e[0m        \e[34m// will be at position\
    \ x at time t if they start at position x - t.  Similarly, the cars\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// that are moving right to left will be at position x at\
    \ time t if they start at position\e[0m\n\e[31m21 |\e[0m        \e[34m// x + t.\
    \  So, two cars will collide if and only if there are two cars that start at the\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// same position.\e[0m\n\e[31m23 |\e[0m    \
    \    \e[34m//\e[0m\n\e[31m24 |\e[0m        \e[34m// So, the answer is the number\
    \ of pairs of cars that start at the same position.\e[0m\n\e[31m25 |\e[0m    \
    \    \e[34m//\e[0m\n\e[31m26 |\e[0m        \e[34m// The number of pairs of cars\
    \ that start at the same position is the number of cars that\e[0m\n\e[31m27 |\e\
    [0m        \e[34m// start at the same position, multiplied by the number of cars\
    \ that start at the same\e[0m\n\e[31m28 |\e[0m        \e[34m// position, minus\
    \ one.  This is because we don't want to count the pair of cars that\e[0m\n\e\
    [31m29 |\e[0m        \e[34m// start at the same position twice.\e[0m\n\e[31m30\
    \ |\e[0m        \e[34m//\e[0m\n\e[31m31 |\e[0m        \e["
  stdout: ''
  timestamp: 1659792833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm to count the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // 1.  Sort the cars by their starting position.\n \
    \       // 2.  For each car, we can compute the time at which it will collide\
    \ with the\n        //     car that's closest to it.  We can do this by computing\
    \ the distance between\n        //     the two cars and dividing it by the speed\
    \ of the car.\n        // 3.  We can then sort the cars by their collision time.\n\
    \        // 4.  We can then iterate through the cars in order of collision time.\n\
    \        //     For each car, we can compute the time at which it will collide\
    \ with the\n        //     car that's closest to it.  If this time is less than\
    \ the collision time\n        //     of the current car, then we have a collision.\n\
    \        //     We can then update the collision time of the current car to be\
    \ the new\n        //     collision time.\n        // 5.  We can then repeat step\
    \ 4 until we have iterated through all the cars.\n        // 6.  The number of\
    \ collisions is the number of times we have updated the collision\n        //\
    \     time of a car.\n        // The time complexity of this algorithm is O(n\
    \ log n).\n        // The space complexity of this algorithm is O(n).\n      \
    \  // The following is an implementation of this algorithm.\n        // We use\
    \ a priority queue to store the cars.\n        // Each car is represented by a\
    \ tuple (position, speed, collision time).\n        // The priority queue is sorted\
    \ by collision time.\n        val queue = new PriorityQueue[(Long, Long, Double)]()(Ordering.by(x\
    \ => x._3))\n        // We add the cars to the priority queue.\n        for (i\
    \ <- 1 to n.toInt) {\n            queue.enqueue((i, i, i.toDouble / i))\n    \
    \        queue.enqueue((-i, i, i.toDouble / i))\n        }\n        // We iterate\
    \ through the cars in order of collision time.\n        var collisions = 0\n \
    \       while (!queue.isEmpty) {\n            val (position, speed, collisionTime)\
    \ =\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpipet3uvx.scala:45:50 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            \e[33mval\e[0m (position, speed, collisionTime)\
    \ =\n\e[31m\e[31m   |\e[0m                                                  ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpipet3uvx.scala:56:0 ----------------------------\e[0m\e[0m\n\e[31m56\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpipet3uvx.scala:55:1 ---------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpipet3uvx.scala:47:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m47 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659792834
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key is to realize that the cars that are\n        // moving left\
    \ to right are the same as the cars that are moving right to left.\n        //\
    \ So, we can just consider the cars that are moving left to right.\n        //\
    \ The cars are numbered from 1 to n.  The car with number 1 starts at position\
    \ 1,\n        // the car with number 2 starts at position 2, and so on.\n    \
    \    // The car with number 1 moves at speed 1, the car with number 2 moves at\
    \ speed 2,\n        // and so on.\n        // The car with number 1 will collide\
    \ with the car with number n, because the car\n        // with number n will be\
    \ at position 1 when the car with number 1 is at position n.\n        // The car\
    \ with number 2 will collide with the car with number n - 1, because the car\n\
    \        // with number n - 1 will be at position 2 when the car with number 2\
    \ is at position n.\n        // The car with number 3 will collide with the car\
    \ with number n - 2, because the car\n        // with number n - 2 will be at\
    \ position 3 when the car with number 3 is at position n.\n        // And so on.\n\
    \        // So, the number of collisions is n - 1 + n - 2 + n - 3 + ... + 1.\n\
    \        // This is a well-known formula for the sum of the first n integers.\n\
    \        // The sum of the first n integers is n * (n + 1) / 2.\n        // So,\
    \ the number of collisions is n * (n + 1) / 2 - n = n * (n - 1) / 2.\n       \
    \ n * (n - 1) / 2\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyl7o2y2q.scala:34)\n\tat Problem.main(tmpyl7o2y2q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.\n        // We start with a sweep line that's infinitely\
    \ far to the left.\n        // We then move the sweep line to the right.\n   \
    \     // As we do so, we keep track of the number of cars that are moving right\
    \ to left\n        // that are to the left of the sweep line.  This is the number\
    \ of collisions.\n        // We also keep track of the number of cars that are\
    \ moving left to right\n        // that are to the right of the sweep line.  This\
    \ is the number of cars that\n        // are still moving.\n        // We stop\
    \ when the sweep line reaches the rightmost car.\n        // The number of collisions\
    \ is the sum of the number of collisions at each step.\n        // The number\
    \ of cars that are still moving is the sum of the number of cars\n        // that\
    \ are still moving at each step.\n        // The number of cars that are still\
    \ moving is n.\n        // The number of collisions is the sum of the number of\
    \ collisions at each step.\n        // The sum of the number of collisions at\
    \ each step is the sum of the number of\n        // collisions at each step minus\
    \ the number of cars that are still moving.\n        // The sum of the number\
    \ of collisions at each step minus the number of cars that\n        // are still\
    \ moving is the number of collisions.\n        // The number of collisions is\
    \ the sum of the number of collisions at each step\n        // minus the number\
    \ of cars that are still moving.\n        // The number of cars that are still\
    \ moving is n.\n        // The number of collisions is the sum of the number of\
    \ collisions at each step\n        // minus n.\n        // The sum of the number\
    \ of collisions at each step is the sum of the number of\n        // collisions\
    \ at each step minus n.\n        // The sum of the number of collisions at each\
    \ step minus n is the number of collisions.\n        // The number of collisions\
    \ is the sum of the number of collisions at each step minus n.\n        // The\
    \ number of collisions is the sum of the number of collisions at each step minus\
    \ n.\n        // The number of collisions is the sum of the number of collisions\
    \ at each step minus n.\n        // The number of collisions is the sum of the\
    \ number of collisions at each step minus n.\n        // The number of collisions\
    \ is the sum of\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoqb7hv7_.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a sweep line algorithm.\e[0m\n\e[31m14 |\e[0m      \
    \  \e[34m// We start with a sweep line that's infinitely far to the left.\e[0m\n\
    \e[31m15 |\e[0m        \e[34m// We then move the sweep line to the right.\e[0m\n\
    \e[31m16 |\e[0m        \e[34m// As we do so, we keep track of the number of cars\
    \ that are moving right to left\e[0m\n\e[31m17 |\e[0m        \e[34m// that are\
    \ to the left of the sweep line.  This is the number of collisions.\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// We also keep track of the number of cars that are moving\
    \ left to right\e[0m\n\e[31m19 |\e[0m        \e[34m// that are to the right of\
    \ the sweep line.  This is the number of cars that\e[0m\n\e[31m20 |\e[0m     \
    \   \e[34m// are still moving.\e[0m\n\e[31m21 |\e[0m        \e[34m// We stop when\
    \ the sweep line reaches the rightmost car.\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ The number of collisions is the sum of the number of collisions at each step.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// The number of cars that are still moving\
    \ is the sum of the number of cars\e[0m\n\e[31m24 |\e[0m        \e[34m// that\
    \ are still moving at each step.\e[0m\n\e[31m25 |\e[0m        \e[34m// The number\
    \ of cars that are still moving is n.\e[0m\n\e[31m26 |\e[0m        \e[34m// The\
    \ number of collisions is the sum of the number of collisions at each step.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// The sum of the number of collisions at each\
    \ step is the sum of the number of\e[0m\n\e[31m28 |\e[0m        \e[34m// collisions\
    \ at each step minus the number of cars that are still moving.\e[0m\n\e[31m29\
    \ |\e[0m        \e[34m// The sum of the number of collisions at each step minus\
    \ the number of cars that\e[0m\n\e[31m30 |\e[0"
  stdout: ''
  timestamp: 1659792834
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars that are moving left to right\n        // are numbered 1\
    \ to n.  The cars that are moving right to left are numbered\n        // n+1 to\
    \ 2n.  The car numbered i collides with the car numbered n+i.\n        // So the\
    \ answer is n.\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppnaa2hh9.scala:20)\n\tat Problem.main(tmppnaa2hh9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 1 to n.\n        // The cars moving left to right are numbered from 1 to\
    \ n.\n        // The cars moving right to left are numbered from n to 1.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right start at positions x1, x2, ..., xn.\n \
    \       // The cars moving right to left start at positions y1, y2, ..., yn.\n\
    \        // The cars moving left to right end at positions x1 + n, x2 + n, ...,\
    \ xn + n.\n        // The cars moving right to left end at positions y1 - n, y2\
    \ - n, ..., yn - n.\n        // The cars moving left to right move at speeds 1,\
    \ 2, ..., n.\n        // The cars moving right to left move at speeds n, n - 1,\
    \ ..., 1.\n        // The cars moving left to right are at positions x1 + t, x2\
    \ + 2t, ..., xn + nt.\n        // The cars moving right to left are at positions\
    \ y1 - nt, y2 - (n - 1)t, ..., yn - t.\n        // The cars moving left to right\
    \ are at positions x1 + t, x2 + 2t, ..., xn + nt.\n        // The cars moving\
    \ right to left are at positions y1 - nt, y2 - (n - 1)t, ..., yn - t.\n      \
    \  // The cars moving left to right are at positions x1 + t, x2 + 2t, ..., xn\
    \ + nt.\n        // The cars moving right to left are at positions y1 - nt, y2\
    \ - (n - 1)t, ..., yn - t.\n        // The cars moving left to right are at positions\
    \ x1 + t, x2 + 2t, ..., xn + nt.\n        // The cars moving right to left are\
    \ at positions y1 - nt, y2 - (n - 1)t, ..., yn - t.\n        // The cars moving\
    \ left to right are at positions\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp75ps4s6e.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 1 to n.\e[0m\n\e[31m14 |\e[0m        \e[34m//\
    \ The cars moving left to right are numbered from 1 to n.\e[0m\n\e[31m15 |\e[0m\
    \        \e[34m// The cars moving right to left are numbered from n to 1.\e[0m\n\
    \e[31m16 |\e[0m        \e[34m// The cars moving left to right are at positions\
    \ x1, x2, ..., xn.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars moving right\
    \ to left are at positions y1, y2, ..., yn.\e[0m\n\e[31m18 |\e[0m        \e[34m//\
    \ The cars moving left to right start at positions x1, x2, ..., xn.\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// The cars moving right to left start at positions y1,\
    \ y2, ..., yn.\e[0m\n\e[31m20 |\e[0m        \e[34m// The cars moving left to right\
    \ end at positions x1 + n, x2 + n, ..., xn + n.\e[0m\n\e[31m21 |\e[0m        \e\
    [34m// The cars moving right to left end at positions y1 - n, y2 - n, ..., yn\
    \ - n.\e[0m\n\e[31m22 |\e[0m        \e[34m// The cars moving left to right move\
    \ at speeds 1, 2, ..., n.\e[0m\n\e[31m23 |\e[0m        \e[34m// The cars moving\
    \ right to left move at speeds n, n - 1, ..., 1.\e[0m\n\e[31m24 |\e[0m       \
    \ \e[34m// The cars moving left to right are at positions x1 + t, x2 + 2t, ...,\
    \ xn + nt.\e[0m\n\e[31m25 |\e[0m        \e[34m// The cars moving right to left\
    \ are at positions y1 - nt, y2 - (n - 1)t, ..., yn - t.\e[0m\n\e[31m26 |\e[0m\
    \        \e[34m// The cars moving left to right are at positions x1 + t, x2 +\
    \ 2t, ..., xn + nt.\e[0m\n\e[31m27 |\e[0m        \e[34m// The cars moving right\
    \ to left are at positions y1 - nt, y2 - (n - 1)t, ..., yn - t.\e[0m\n\e[31m28\
    \ |\e[0m        \e[34m// The cars moving left to right are at positions x1 + t,\
    \ x2 + 2t, ..., xn + nt.\e[0m\n\e[31m29 |\e[0m        \e"
  stdout: ''
  timestamp: 1659792834
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can simulate the race\
    \ by iterating through the cars\n        // from left to right.  For each car,\
    \ we check if it collides with\n        // any of the cars that are moving right\
    \ to left.  If it does, we\n        // increment the collision count.\n      \
    \  // The time complexity is O(n log n) because we have to sort the cars.\n  \
    \      // The space complexity is O(n) because we have to store the cars.\n  \
    \      val cars = Array.fill(2 * n.toInt)(0)\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = i + 1\n            cars(i + n.toInt) = -(i + 1)\n \
    \       }\n        val sortedCars = cars.sorted\n        var collisionCount =\
    \ 0\n        var i = 0\n        while (i < 2 * n.toInt) {\n            var j =\
    \ i + 1\n            while (j < 2 * n.toInt && sortedCars(j) < 0) {\n        \
    \        if (sortedCars(i) + sortedCars(j) == 0) collisionCount += 1\n       \
    \         j += 1\n            }\n            i += 1\n        }\n        collisionCount\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmct7ckoo.scala:39)\n\tat Problem.main(tmpmct7ckoo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.\n        // We'll have a line that sweeps from left\
    \ to right.\n        // We'll keep track of the cars that are currently on the\
    \ line.\n        // We'll keep track of the cars that are currently on the line.\n\
    \        // We'll keep track of the cars that are currently on the line.\n   \
    \     // We'll keep track of the cars that are currently on the line.\n      \
    \  // We'll keep track of the cars that are currently on the line.\n        //\
    \ We'll keep track of the cars that are currently on the line.\n        // We'll\
    \ keep track of the cars that are currently on the line.\n        // We'll keep\
    \ track of the cars that are currently on the line.\n        // We'll keep track\
    \ of the cars that are currently on the line.\n        // We'll keep track of\
    \ the cars that are currently on the line.\n        // We'll keep track of the\
    \ cars that are currently on the line.\n        // We'll keep track of the cars\
    \ that are currently on the line.\n        // We'll keep track of the cars that\
    \ are currently on the line.\n        // We'll keep track of the cars that are\
    \ currently on the line.\n        // We'll keep track of the cars that are currently\
    \ on the line.\n        // We'll keep track of the cars that are currently on\
    \ the line.\n        // We'll keep track of the cars that are currently on the\
    \ line.\n        // We'll keep track of the cars that are currently on the line.\n\
    \        // We'll keep track of the cars that are currently on the line.\n   \
    \     // We'll keep track of the cars that are currently on the line.\n      \
    \  // We'll keep track of the cars that are currently on the line.\n        //\
    \ We'll keep track of the cars that are currently on the line.\n        // We'll\
    \ keep track of the cars that are currently on the line.\n        // We'll keep\
    \ track of the cars that are currently on the line.\n        // We'll keep track\
    \ of the cars that are currently on the line.\n        // We'll keep track of\
    \ the cars that are currently on the line.\n        // We'll keep track of the\
    \ cars that are currently on the line.\n        // We'll keep track of the cars\
    \ that are currently on the line.\n        // We'll keep track of\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptnr0ganz.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a sweep line algorithm.\e[0m\n\e[31m14 |\e[0m      \
    \  \e[34m// We'll have a line that sweeps from left to right.\e[0m\n\e[31m15 |\e\
    [0m        \e[34m// We'll keep track of the cars that are currently on the line.\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// We'll keep track of the cars that are currently\
    \ on the line.\e[0m\n\e[31m17 |\e[0m        \e[34m// We'll keep track of the cars\
    \ that are currently on the line.\e[0m\n\e[31m18 |\e[0m        \e[34m// We'll\
    \ keep track of the cars that are currently on the line.\e[0m\n\e[31m19 |\e[0m\
    \        \e[34m// We'll keep track of the cars that are currently on the line.\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// We'll keep track of the cars that are currently\
    \ on the line.\e[0m\n\e[31m21 |\e[0m        \e[34m// We'll keep track of the cars\
    \ that are currently on the line.\e[0m\n\e[31m22 |\e[0m        \e[34m// We'll\
    \ keep track of the cars that are currently on the line.\e[0m\n\e[31m23 |\e[0m\
    \        \e[34m// We'll keep track of the cars that are currently on the line.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// We'll keep track of the cars that are currently\
    \ on the line.\e[0m\n\e[31m25 |\e[0m        \e[34m// We'll keep track of the cars\
    \ that are currently on the line.\e[0m\n\e[31m26 |\e[0m        \e[34m// We'll\
    \ keep track of the cars that are currently on the line.\e[0m\n\e[31m27 |\e[0m\
    \        \e[34m// We'll keep track of the cars that are currently on the line.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// We'll keep track of the cars that are currently\
    \ on the line.\e[0m\n\e[31m29 |\e[0m        \e[34m// We'll keep track of the cars\
    \ that are currently on the line.\e[0m\n\e[31m30 |\e[0m        \e[34m// We'll\
    \ keep track of the cars that a"
  stdout: ''
  timestamp: 1659792841
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key is to realize that the cars\n        // moving left to right\
    \ and right to left are the same cars.  So, we can\n        // just consider the\
    \ cars moving left to right.  The cars are numbered\n        // from 0 to n -\
    \ 1.  The car with number i starts at position i.  The car\n        // with number\
    \ i will collide with the car with number j if and only if\n        // i < j and\
    \ i + j = n - 1.  So, the answer is the number of pairs (i, j)\n        // such\
    \ that i < j and i + j = n - 1.  This is the same as the number of\n        //\
    \ pairs (i, j) such that i < j and i + j < n - 1.  This is the same as\n     \
    \   // the number of pairs (i, j) such that i < j and i < n - 1 - j.  This is\n\
    \        // the same as the number of pairs (i, j) such that i < j and i < n -\
    \ 1 - i.\n        // This is the same as the number of pairs (i, j) such that\
    \ i < j and j < n - 1 - i.\n        // This is the same as the number of pairs\
    \ (i, j) such that i < j and j < n - 1 - i.\n        // This is the same as the\
    \ number of pairs (i, j) such that i < j and j < n - 1 - i.\n        // This is\
    \ the same as the number of pairs (i, j) such that i < j and j < n - 1 - i.\n\
    \        // This is the same as the number of pairs (i, j) such that i < j and\
    \ j < n - 1 - i.\n        // This is the same as the number of pairs (i, j) such\
    \ that i < j and j < n - 1 - i.\n        // This is the same as the number of\
    \ pairs (i, j) such that i < j and j < n - 1 - i.\n        // This is the same\
    \ as the number of pairs (i, j) such that i < j and j < n - 1 - i.\n        //\
    \ This is the same as the number of pairs (i, j) such that i < j\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqkydq73x.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  The key is to realize that the cars\e[0m\n\
    \e[31m14 |\e[0m        \e[34m// moving left to right and right to left are the\
    \ same cars.  So, we can\e[0m\n\e[31m15 |\e[0m        \e[34m// just consider the\
    \ cars moving left to right.  The cars are numbered\e[0m\n\e[31m16 |\e[0m    \
    \    \e[34m// from 0 to n - 1.  The car with number i starts at position i.  The\
    \ car\e[0m\n\e[31m17 |\e[0m        \e[34m// with number i will collide with the\
    \ car with number j if and only if\e[0m\n\e[31m18 |\e[0m        \e[34m// i < j\
    \ and i + j = n - 1.  So, the answer is the number of pairs (i, j)\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// such that i < j and i + j = n - 1.  This is the same\
    \ as the number of\e[0m\n\e[31m20 |\e[0m        \e[34m// pairs (i, j) such that\
    \ i < j and i + j < n - 1.  This is the same as\e[0m\n\e[31m21 |\e[0m        \e\
    [34m// the number of pairs (i, j) such that i < j and i < n - 1 - j.  This is\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// the same as the number of pairs (i, j) such\
    \ that i < j and i < n - 1 - i.\e[0m\n\e[31m23 |\e[0m        \e[34m// This is\
    \ the same as the number of pairs (i, j) such that i < j and j < n - 1 - i.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// This is the same as the number of pairs (i,\
    \ j) such that i < j and j < n - 1 - i.\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ This is the same as the number of pairs (i, j) such that i < j and j < n - 1\
    \ - i.\e[0m\n\e[31m26 |\e[0m        \e[34m// This is the same as the number of\
    \ pairs (i, j) such that i < j and j < n - 1 - i.\e[0m\n\e[31m27 |\e[0m      \
    \  \e[34m// This is the same as the number of pairs (i, j) such that i < j and\
    \ j < n - 1 - i.\e[0m\n\e[31m28 |\e[0m        \e[34m/"
  stdout: ''
  timestamp: 1659792842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the left-to-right\
    \ cars are indexed from 0 to n-1, and the right-to-left cars\n        // are indexed\
    \ from n to 2n-1.  We can represent the positions of the cars as a list of\n \
    \       // 2n numbers, where the first n numbers are the positions of the left-to-right\
    \ cars,\n        // and the second n numbers are the positions of the right-to-left\
    \ cars.\n        // For example, if n = 3, and the left-to-right cars are at positions\
    \ 0, 1, and 2, and\n        // the right-to-left cars are at positions 3, 4, and\
    \ 5, then we can represent this as\n        // the list (0, 1, 2, 3, 4, 5).\n\
    \        // We can represent the cars as a list of 2n numbers, where the first\
    \ n numbers are\n        // the positions of the left-to-right cars, and the second\
    \ n numbers are the positions\n        // of the right-to-left cars.\n       \
    \ // We can represent the cars as a list of 2n numbers, where the first n numbers\
    \ are\n        // the positions of the left-to-right cars, and the second n numbers\
    \ are the positions\n        // of the right-to-left cars.\n        // We can\
    \ represent the cars as a list of 2n numbers, where the first n numbers are\n\
    \        // the positions of the left-to-right cars, and the second n numbers\
    \ are the positions\n        // of the right-to-left cars.\n        // We can\
    \ represent the cars as a list of 2n numbers, where the first n numbers are\n\
    \        // the positions of the left-to-right cars, and the second n numbers\
    \ are the positions\n        // of the right-to-left cars.\n        // We can\
    \ represent the cars as a list of 2n numbers, where the first n numbers are\n\
    \        // the positions of the left-to-right cars, and the second n numbers\
    \ are the positions\n        // of the right-to-left cars.\n        // We can\
    \ represent the cars as a list of 2n numbers, where the first n numbers are\n\
    \        // the positions of the left-to-right cars, and the second n numbers\
    \ are the positions\n        // of the right-to-left cars.\n       \n    }\n \
    \   def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxpf5lw6q.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say the left-to-right cars are indexed from 0 to n-1, and the right-to-left\
    \ cars\e[0m\n\e[31m14 |\e[0m        \e[34m// are indexed from n to 2n-1.  We can\
    \ represent the positions of the cars as a list of\e[0m\n\e[31m15 |\e[0m     \
    \   \e[34m// 2n numbers, where the first n numbers are the positions of the left-to-right\
    \ cars,\e[0m\n\e[31m16 |\e[0m        \e[34m// and the second n numbers are the\
    \ positions of the right-to-left cars.\e[0m\n\e[31m17 |\e[0m        \e[34m// For\
    \ example, if n = 3, and the left-to-right cars are at positions 0, 1, and 2,\
    \ and\e[0m\n\e[31m18 |\e[0m        \e[34m// the right-to-left cars are at positions\
    \ 3, 4, and 5, then we can represent this as\e[0m\n\e[31m19 |\e[0m        \e[34m//\
    \ the list (0, 1, 2, 3, 4, 5).\e[0m\n\e[31m20 |\e[0m        \e[34m// We can represent\
    \ the cars as a list of 2n numbers, where the first n numbers are\e[0m\n\e[31m21\
    \ |\e[0m        \e[34m// the positions of the left-to-right cars, and the second\
    \ n numbers are the positions\e[0m\n\e[31m22 |\e[0m        \e[34m// of the right-to-left\
    \ cars.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can represent the cars as a list\
    \ of 2n numbers, where the first n numbers are\e[0m\n\e[31m24 |\e[0m        \e\
    [34m// the positions of the left-to-right cars, and the second n numbers are the\
    \ positions\e[0m\n\e[31m25 |\e[0m        \e[34m// of the right-to-left cars.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// We can represent the cars as a list of 2n\
    \ numbers, where the first n numbers are\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ the positions of the left-to-right cars, and the second n numbers are the positions\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// of the right-to-left cars.\e[0m\n\e[31m29 "
  stdout: ''
  timestamp: 1659792841
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can model the cars\
    \ as a set of points on the number line.\n        // The cars moving left to right\
    \ are the points {1, 2, ..., n}.\n        // The cars moving right to left are\
    \ the points {-1, -2, ..., -n}.\n        // The number of collisions is the number\
    \ of pairs of points that are equal.\n        // This is the same as the number\
    \ of pairs of points that are equal after\n        // we sort the points.\n  \
    \      // We can sort the points in O(n log n) time.\n        // After sorting,\
    \ we can count the number of collisions in O(n) time.\n        // Therefore, the\
    \ total time is O(n log n).\n        val points = ArrayBuffer[Long]()\n      \
    \  for (i <- 1 to n.toInt) points += i\n        for (i <- 1 to n.toInt) points\
    \ += -i\n        points.sortInPlace()\n        var collisions = 0L\n        for\
    \ (i <- 1 until points.length) {\n            if (points(i) == points(i - 1))\
    \ collisions += 1\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7jvdlakt.scala:33)\n\tat Problem.main(tmp7jvdlakt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792845
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can simulate the\
    \ race by iterating through the cars\n        // and checking whether the car\
    \ is moving left to right or right to left.\n        // If the car is moving left\
    \ to right, then we check whether it collides with\n        // any cars that are\
    \ moving right to left.  If it does, we increment the number\n        // of collisions.\n\
    \        // The time complexity is O(n log n) because we have to sort the cars.\n\
    \        // The space complexity is O(n) because we have to store the cars.\n\
    \        val cars = new Array[(Long, Boolean)](n.toInt)\n        for (i <- 0 until\
    \ n.toInt) {\n            val x = scala.io.StdIn.readLine.toLong\n           \
    \ val dir = scala.io.StdIn.readLine.toBoolean\n            cars(i) = (x, dir)\n\
    \        }\n        val sortedCars = cars.sortWith((a, b) => a._1 < b._1)\n  \
    \      var collisions = 0L\n        for (i <- 0 until n.toInt) {\n           \
    \ val (x, dir) = sortedCars(i)\n            if (dir) {\n                for (j\
    \ <- i + 1 until n.toInt) {\n                    val (y, dir2) = sortedCars(j)\n\
    \                    if (dir2) break\n                    else if (y == x) collisions\
    \ += 1\n                }\n            }\n        }\n        collisions\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcxklsxts.scala:34:30 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                    \e[33mif\e[0m (dir2) break\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                       Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792841
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can solve it by brute force.\n        // Let's say that the cars\
    \ moving left to right are indexed from 0 to n - 1, and\n        // the cars moving\
    \ right to left are indexed from n to 2n - 1.\n        // We can model the position\
    \ of the cars at time t as follows:\n        // car i is at position t * (i +\
    \ 1)\n        // car i is at position t * (2n - i)\n        // We can then compute\
    \ the number of collisions by iterating through all pairs of cars\n        //\
    \ and checking whether they collide.\n        // This is a O(n^2) algorithm.\n\
    \        // We can do better.  We can sort the cars by their position at time\
    \ 0.\n        // Then, we can iterate through the cars moving left to right, and\
    \ for each car,\n        // we can binary search for the first car moving right\
    \ to left that collides with it.\n        // This is a O(n log n) algorithm.\n\
    \        // We can do even better.  We can sort the cars by their position at\
    \ time 0.\n        // Then, we can iterate through the cars moving left to right,\
    \ and for each car,\n        // we can binary search for the first car moving\
    \ right to left that collides with it.\n        // This is a O(n log n) algorithm.\n\
    \        // We can do even better.  We can sort the cars by their position at\
    \ time 0.\n        // Then, we can iterate through the cars moving left to right,\
    \ and for each car,\n        // we can binary search for the first car moving\
    \ right to left that collides with it.\n        // This is a O(n log n) algorithm.\n\
    \        // We can do even better.  We can sort the cars by their position at\
    \ time 0.\n        // Then, we can iterate through the cars moving left to right,\
    \ and for each car,\n        // we can binary search for the first car moving\
    \ right to left that collides with it.\n        // This is a O(n log n) algorithm.\n\
    \        // We can do even better.  We can sort the cars by their position at\
    \ time 0.\n        // Then, we can iterate through the cars moving left to right,\
    \ and for each car,\n       \n    }\n    def main(args: Array[String]) = {\n \
    \   assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp79_t7nm9.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  We can solve it by brute force.\e[0m\n\e\
    [31m14 |\e[0m        \e[34m// Let's say that the cars moving left to right are\
    \ indexed from 0 to n - 1, and\e[0m\n\e[31m15 |\e[0m        \e[34m// the cars\
    \ moving right to left are indexed from n to 2n - 1.\e[0m\n\e[31m16 |\e[0m   \
    \     \e[34m// We can model the position of the cars at time t as follows:\e[0m\n\
    \e[31m17 |\e[0m        \e[34m// car i is at position t * (i + 1)\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// car i is at position t * (2n - i)\e[0m\n\e[31m19 |\e\
    [0m        \e[34m// We can then compute the number of collisions by iterating\
    \ through all pairs of cars\e[0m\n\e[31m20 |\e[0m        \e[34m// and checking\
    \ whether they collide.\e[0m\n\e[31m21 |\e[0m        \e[34m// This is a O(n^2)\
    \ algorithm.\e[0m\n\e[31m22 |\e[0m        \e[34m// We can do better.  We can sort\
    \ the cars by their position at time 0.\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ Then, we can iterate through the cars moving left to right, and for each car,\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// we can binary search for the first car moving\
    \ right to left that collides with it.\e[0m\n\e[31m25 |\e[0m        \e[34m// This\
    \ is a O(n log n) algorithm.\e[0m\n\e[31m26 |\e[0m        \e[34m// We can do even\
    \ better.  We can sort the cars by their position at time 0.\e[0m\n\e[31m27 |\e\
    [0m        \e[34m// Then, we can iterate through the cars moving left to right,\
    \ and for each car,\e[0m\n\e[31m28 |\e[0m        \e[34m// we can binary search\
    \ for the first car moving right to left that collides with it.\e[0m\n\e[31m29\
    \ |\e[0m        \e[34m// This is a O(n log n) algorithm.\e[0m\n\e[31m30 |\e[0m\
    \        \e[34m// We can do even better.  We can sort th"
  stdout: ''
  timestamp: 1659792842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars, and for each car,\n        // we can find the number of cars that\
    \ are to the left of it.\n        // This is the number of collisions that this\
    \ car has.\n        // The total number of collisions is the sum of the number\
    \ of collisions\n        // for each car.\n        // The number of cars to the\
    \ left of a car is the number of cars\n        // that have a smaller starting\
    \ position.\n        // The number of cars that have a smaller starting position\
    \ is\n        // the number of cars that have a starting position that's\n   \
    \     // less than or equal to the current car's starting position.\n        //\
    \ The number of cars that have a starting position that's\n        // less than\
    \ or equal to the current car's starting position\n        // is the number of\
    \ cars that have a starting position that's\n        // less than or equal to\
    \ the current car's starting position\n        // minus the number of cars that\
    \ have a starting position that's\n        // less than the current car's starting\
    \ position.\n        // The number of cars that have a starting position that's\n\
    \        // less than or equal to the current car's starting position\n      \
    \  // is the number of cars that have a starting position that's\n        // less\
    \ than or equal to the current car's starting position\n        // minus the number\
    \ of cars that have a starting position that's\n        // less than the current\
    \ car's starting position\n        // plus the number of cars that have a starting\
    \ position that's\n        // equal to the current car's starting position.\n\
    \        // The number of cars that have a starting position that's\n        //\
    \ less than or equal to the current car's starting position\n        // is the\
    \ number of cars that have a starting position that's\n        // less than or\
    \ equal to the current car's starting position\n        // minus the number of\
    \ cars that have a starting position that's\n        // less than the current\
    \ car's starting position\n        // plus the number of cars that have a starting\
    \ position that's\n        // equal to the current car's starting position\n \
    \       // minus the number of cars that have a starting position that's\n   \
    \     // greater than the current car's starting position.\n        // The number\
    \ of cars that have a starting position that's\n        // less than or equal\
    \ to\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcav0h4dw.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can just iterate through the cars, and for each\
    \ car,\e[0m\n\e[31m15 |\e[0m        \e[34m// we can find the number of cars that\
    \ are to the left of it.\e[0m\n\e[31m16 |\e[0m        \e[34m// This is the number\
    \ of collisions that this car has.\e[0m\n\e[31m17 |\e[0m        \e[34m// The total\
    \ number of collisions is the sum of the number of collisions\e[0m\n\e[31m18 |\e\
    [0m        \e[34m// for each car.\e[0m\n\e[31m19 |\e[0m        \e[34m// The number\
    \ of cars to the left of a car is the number of cars\e[0m\n\e[31m20 |\e[0m   \
    \     \e[34m// that have a smaller starting position.\e[0m\n\e[31m21 |\e[0m  \
    \      \e[34m// The number of cars that have a smaller starting position is\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// the number of cars that have a starting position\
    \ that's\e[0m\n\e[31m23 |\e[0m        \e[34m// less than or equal to the current\
    \ car's starting position.\e[0m\n\e[31m24 |\e[0m        \e[34m// The number of\
    \ cars that have a starting position that's\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ less than or equal to the current car's starting position\e[0m\n\e[31m26 |\e\
    [0m        \e[34m// is the number of cars that have a starting position that's\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// less than or equal to the current car's starting\
    \ position\e[0m\n\e[31m28 |\e[0m        \e[34m// minus the number of cars that\
    \ have a starting position that's\e[0m\n\e[31m29 |\e[0m        \e[34m// less than\
    \ the current car's starting position.\e[0m\n\e[31m30 |\e[0m        \e[34m// The\
    \ number of cars that have a starting position that's\e[0m\n\e[31m31 |\e[0m  \
    \      \e[34m// less than or equal to th"
  stdout: ''
  timestamp: 1659792843
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm to compute the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // We start at the leftmost car.  We move the sweep\
    \ line to the right.\n        // As we move the sweep line, we keep track of the\
    \ number of cars that are to the left\n        // of the sweep line.  We also\
    \ keep track of the number of cars that are to the right\n        // of the sweep\
    \ line.  When we move the sweep line to the right, we can compute the number\n\
    \        // of collisions by multiplying the number of cars to the left of the\
    \ sweep line by the\n        // number of cars to the right of the sweep line.\n\
    \        // We can keep track of the number of cars to the left of the sweep line\
    \ by using a stack.\n        // We can keep track of the number of cars to the\
    \ right of the sweep line by using a queue.\n        // We can use a priority\
    \ queue to sort the cars by their starting position.\n        val pq = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        val stack = new Stack[Long]()\n        val queue = new Queue[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            pq.enqueue(i)\n            pq.enqueue(-i)\n\
    \        }\n        var collisions = 0L\n        while (!pq.isEmpty) {\n     \
    \       val car = pq.dequeue\n            if (car > 0) {\n                // car\
    \ is moving left to right\n                queue.enqueue(car)\n            } else\
    \ {\n                // car is moving right to left\n                stack.push(-car)\n\
    \            }\n            while (!stack.isEmpty && !queue.isEmpty && stack.top\
    \ == queue.front) {\n                // The car at the top of the stack is moving\
    \ right to left and collides with the car\n                // at the front of\
    \ the queue, which is moving left to right.\n                collisions += 1\n\
    \                stack.pop\n                queue.dequeue\n            }\n   \
    \     }\n        collisions\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl56g83mm.scala:53)\n\tat Problem.main(tmpl56g83mm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792845
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a priority queue to simulate the cars.\n        // The priority queue will contain\
    \ the positions of the cars.\n        // The cars moving left to right will have\
    \ positive positions,\n        // and the cars moving right to left will have\
    \ negative positions.\n        // The priority queue will be sorted in ascending\
    \ order.\n        // We will simulate the cars moving in the following way:\n\
    \        // 1.  We will remove the first car from the priority queue.\n      \
    \  // 2.  We will add the position of the next car to the priority queue.\n  \
    \      // 3.  We will repeat step 1 and 2 until the priority queue is empty.\n\
    \        // 4.  We will count the number of collisions.\n        // 5.  We will\
    \ repeat steps 1-4 for the cars moving right to left.\n        // 6.  We will\
    \ return the total number of collisions.\n        // The running time of this\
    \ algorithm is O(n log n).\n        // The space complexity is O(n).\n       \
    \ val pq = new PriorityQueue[Long]()\n        for (i <- 1 to n.toInt) {\n    \
    \        pq.enqueue(i)\n        }\n        var collisions = 0L\n        var prev\
    \ = 0L\n        while (!pq.isEmpty) {\n            val curr = pq.dequeue\n   \
    \         if (curr < prev) collisions += 1\n            prev = curr\n        }\n\
    \        for (i <- 1 to n.toInt) {\n            pq.enqueue(-i)\n        }\n  \
    \      prev = 0L\n        while (!pq.isEmpty) {\n            val curr = pq.dequeue\n\
    \            if (curr > prev) collisions += 1\n            prev = curr\n     \
    \   }\n        collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpswsigai9.scala:50)\n\tat Problem.main(tmpswsigai9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792845
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 0 to n-1.  The cars that are moving left to right\n        // are numbered\
    \ from 0 to n-1.  The cars that are moving right to left are numbered\n      \
    \  // from n-1 to 0.  The cars that are moving left to right start at position\
    \ 0, and\n        // the cars that are moving right to left start at position\
    \ n-1.\n        // The cars are moving at the same speed.  The cars that are moving\
    \ left to right\n        // move at speed 1, and the cars that are moving right\
    \ to left move at speed -1.\n        // The cars are infinitely sturdy and strong;\
    \ as a result, they continue moving\n        // in their trajectory as if they\
    \ did not collide.\n        // This function outputs the number of such collisions.\n\
    \        //\n        // The cars that are moving left to right are numbered from\
    \ 0 to n-1.\n        // The cars that are moving right to left are numbered from\
    \ n-1 to 0.\n        // The cars that are moving left to right start at position\
    \ 0, and\n        // the cars that are moving right to left start at position\
    \ n-1.\n        // The cars are moving at the same speed.  The cars that are moving\
    \ left to right\n        // move at speed 1, and the cars that are moving right\
    \ to left move at speed -1.\n        // The cars are infinitely sturdy and strong;\
    \ as a result, they continue moving\n        // in their trajectory as if they\
    \ did not collide.\n        // This function outputs the number of such collisions.\n\
    \        //\n        // The cars that are moving left to right are numbered from\
    \ 0 to n-1.\n        // The cars that are moving right to left are numbered from\
    \ n-1 to 0.\n        // The cars that are moving left to right start at position\
    \ 0, and\n        // the cars that are moving right to left start at position\
    \ n-1.\n        // The cars are moving at the same speed.  The cars that are moving\
    \ left to right\n        // move at speed 1, and the cars that are moving right\
    \ to left move at speed -1.\n        // The cars are infinitely sturdy and strong;\
    \ as a result, they continue moving\n        // in their trajectory as if they\
    \ did not collide.\n        // This function outputs the number of such collisions.\n\
    \        //\n        //\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptt__4asp.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 0 to n-1.  The cars that are moving left to\
    \ right\e[0m\n\e[31m14 |\e[0m        \e[34m// are numbered from 0 to n-1.  The\
    \ cars that are moving right to left are numbered\e[0m\n\e[31m15 |\e[0m      \
    \  \e[34m// from n-1 to 0.  The cars that are moving left to right start at position\
    \ 0, and\e[0m\n\e[31m16 |\e[0m        \e[34m// the cars that are moving right\
    \ to left start at position n-1.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars\
    \ are moving at the same speed.  The cars that are moving left to right\e[0m\n\
    \e[31m18 |\e[0m        \e[34m// move at speed 1, and the cars that are moving\
    \ right to left move at speed -1.\e[0m\n\e[31m19 |\e[0m        \e[34m// The cars\
    \ are infinitely sturdy and strong; as a result, they continue moving\e[0m\n\e\
    [31m20 |\e[0m        \e[34m// in their trajectory as if they did not collide.\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// This function outputs the number of such\
    \ collisions.\e[0m\n\e[31m22 |\e[0m        \e[34m//\e[0m\n\e[31m23 |\e[0m    \
    \    \e[34m// The cars that are moving left to right are numbered from 0 to n-1.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// The cars that are moving right to left are\
    \ numbered from n-1 to 0.\e[0m\n\e[31m25 |\e[0m        \e[34m// The cars that\
    \ are moving left to right start at position 0, and\e[0m\n\e[31m26 |\e[0m    \
    \    \e[34m// the cars that are moving right to left start at position n-1.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// The cars are moving at the same speed.  The\
    \ cars that are moving left to right\e[0m\n\e[31m28 |\e[0m        \e[34m// move\
    \ at speed 1, and the cars that are moving right to left move at speed -1.\e[0m\n\
    \e[31m29 |\e[0m        \e[34m// The cars are infinitely "
  stdout: ''
  timestamp: 1659792843
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just count the\
    \ number of cars that are moving left to right\n        // and the number of cars\
    \ that are moving right to left.  The number of collisions\n        // is the\
    \ product of these two numbers.\n        // The reason is that each car moving\
    \ left to right will collide with\n        // each car moving right to left.\n\
    \        // We can sort the cars in O(n log n) time.\n        // We can count\
    \ the number of cars moving left to right and right to left\n        // in O(n)\
    \ time.\n        // Therefore, the total time complexity is O(n log n).\n    \
    \    // The space complexity is O(n).\n        val cars = new Array[(Long, Boolean)](2\
    \ * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i) = (i.toLong,\
    \ true)\n            cars(i + n.toInt) = (i.toLong, false)\n        }\n      \
    \  scala.util.Sorting.quickSort(cars)\n        var countLeftToRight = 0\n    \
    \    var countRightToLeft = 0\n        var collisions = 0L\n        for (i <-\
    \ 0 until cars.length) {\n            if (cars(i)._2) countLeftToRight += 1\n\
    \            else {\n                collisions += countLeftToRight\n        \
    \        countRightToLeft += 1\n            }\n        }\n        collisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp48mlwj9g.scala:43)\n\tat Problem.main(tmp48mlwj9g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the cars\
    \ moving left to right are indexed from 0 to n - 1.\n        // Let's say the\
    \ cars moving right to left are indexed from 0 to n - 1.\n        // Let's say\
    \ the car moving left to right with index i starts at position xi.\n        //\
    \ Let's say the car moving right to left with index i starts at position yi.\n\
    \        // Let's say the car moving left to right with index i moves at speed\
    \ si.\n        // Let's say the car moving right to left with index i moves at\
    \ speed ti.\n        // Let's say the car moving left to right with index i collides\
    \ with the car moving right to left with index j.\n        // Then, we have the\
    \ following equation:\n        // xi + si * t = yj - tj * t\n        // where\
    \ t is the time of collision.\n        // We can solve for t:\n        // t =\
    \ (xi - yj) / (si + tj)\n        // We can then check if t is positive.  If so,\
    \ then there is a collision.\n        // We can then check if t is less than 1.\
    \  If so, then there is a collision.\n        // We can then check if t is an\
    \ integer.  If so, then there is a collision.\n        // We can then check if\
    \ t is less than the time of the next collision.  If so, then there is a collision.\n\
    \        // We can then check if t is less than the time of the next collision.\
    \  If so, then there is a collision.\n        // We can then check if t is less\
    \ than the time of the next collision.  If so, then there is a collision.\n  \
    \      // We can then check if t is less than the time of the next collision.\
    \  If so, then there is a collision.\n        // We can then check if t is less\
    \ than the time of the next collision.  If so, then there is a collision.\n  \
    \      // We can then check if t is less than the time of the next collision.\
    \  If so, then there is a collision.\n        // We can then check if t is less\
    \ than the time of the next collision.  If so, then there is a collision.\n  \
    \      // We can then check if t is less than the time of the next collision.\
    \  If so\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmg7o_fuj.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say the cars moving left to right are indexed from 0 to n - 1.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// Let's say the cars moving right to left are\
    \ indexed from 0 to n - 1.\e[0m\n\e[31m15 |\e[0m        \e[34m// Let's say the\
    \ car moving left to right with index i starts at position xi.\e[0m\n\e[31m16\
    \ |\e[0m        \e[34m// Let's say the car moving right to left with index i starts\
    \ at position yi.\e[0m\n\e[31m17 |\e[0m        \e[34m// Let's say the car moving\
    \ left to right with index i moves at speed si.\e[0m\n\e[31m18 |\e[0m        \e\
    [34m// Let's say the car moving right to left with index i moves at speed ti.\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// Let's say the car moving left to right with\
    \ index i collides with the car moving right to left with index j.\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// Then, we have the following equation:\e[0m\n\e[31m21\
    \ |\e[0m        \e[34m// xi + si * t = yj - tj * t\e[0m\n\e[31m22 |\e[0m     \
    \   \e[34m// where t is the time of collision.\e[0m\n\e[31m23 |\e[0m        \e\
    [34m// We can solve for t:\e[0m\n\e[31m24 |\e[0m        \e[34m// t = (xi - yj)\
    \ / (si + tj)\e[0m\n\e[31m25 |\e[0m        \e[34m// We can then check if t is\
    \ positive.  If so, then there is a collision.\e[0m\n\e[31m26 |\e[0m        \e\
    [34m// We can then check if t is less than 1.  If so, then there is a collision.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// We can then check if t is an integer.  If\
    \ so, then there is a collision.\e[0m\n\e[31m28 |\e[0m        \e[34m// We can\
    \ then check if t is less than the time of the next collision.  If so, then there\
    \ is a collision.\e[0m\n\e[31m29 |\e[0m        \e[34m// We can then check if t\
    \ is less than the time of the next collision.  If "
  stdout: ''
  timestamp: 1659792843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can solve this problem\
    \ by first sorting the cars by their starting position.\n        // Then, we can\
    \ iterate through the cars in order, and for each car, we can\n        // find\
    \ the number of cars that are moving in the opposite direction and\n        //\
    \ have a starting position less than the current car.\n        // This can be\
    \ done in O(n log n) time.\n        // However, we can do better.\n        //\
    \ We can solve this problem in O(n) time by using a Fenwick tree.\n        //\
    \ The idea is that we can store the number of cars that are moving in the opposite\n\
    \        // direction and have a starting position less than the current car.\n\
    \        // We can then use a Fenwick tree to find the number of cars that are\
    \ moving in the\n        // opposite direction and have a starting position less\
    \ than the current car.\n        // This can be done in O(log n) time.\n     \
    \   // We can then iterate through the cars in order, and for each car, we can\n\
    \        // find the number of cars that are moving in the opposite direction\
    \ and\n        // have a starting position less than the current car.\n      \
    \  // This can be done in O(n log n) time.\n        // However, we can do better.\n\
    \        // We can solve this problem in O(n) time by using a Fenwick tree.\n\
    \        // The idea is that we can store the number of cars that are moving in\
    \ the opposite\n        // direction and have a starting position less than the\
    \ current car.\n        // We can then use a Fenwick tree to find the number of\
    \ cars that are moving in the\n        // opposite direction and have a starting\
    \ position less than the current car.\n        // This can be done in O(log n)\
    \ time.\n        // We can then iterate through the cars in order, and for each\
    \ car, we can\n        // find the number of cars that are moving in the opposite\
    \ direction and\n        // have a starting position less than the current car.\n\
    \        // This can be done in O(n log n) time.\n        // However, we can do\
    \ better.\n        // We can solve this problem in O(n) time by using a Fenwick\
    \ tree.\n        // The idea is that we can store the number of cars that are\
    \ moving in the opposite\n        // direction and have\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpatwrvtke.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We can solve this problem by first sorting the cars by their starting position.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// Then, we can iterate through the cars in\
    \ order, and for each car, we can\e[0m\n\e[31m15 |\e[0m        \e[34m// find the\
    \ number of cars that are moving in the opposite direction and\e[0m\n\e[31m16\
    \ |\e[0m        \e[34m// have a starting position less than the current car.\e\
    [0m\n\e[31m17 |\e[0m        \e[34m// This can be done in O(n log n) time.\e[0m\n\
    \e[31m18 |\e[0m        \e[34m// However, we can do better.\e[0m\n\e[31m19 |\e\
    [0m        \e[34m// We can solve this problem in O(n) time by using a Fenwick\
    \ tree.\e[0m\n\e[31m20 |\e[0m        \e[34m// The idea is that we can store the\
    \ number of cars that are moving in the opposite\e[0m\n\e[31m21 |\e[0m       \
    \ \e[34m// direction and have a starting position less than the current car.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We can then use a Fenwick tree to find the\
    \ number of cars that are moving in the\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ opposite direction and have a starting position less than the current car.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// This can be done in O(log n) time.\e[0m\n\
    \e[31m25 |\e[0m        \e[34m// We can then iterate through the cars in order,\
    \ and for each car, we can\e[0m\n\e[31m26 |\e[0m        \e[34m// find the number\
    \ of cars that are moving in the opposite direction and\e[0m\n\e[31m27 |\e[0m\
    \        \e[34m// have a starting position less than the current car.\e[0m\n\e\
    [31m28 |\e[0m        \e[34m// This can be done in O(n log n) time.\e[0m\n\e[31m29\
    \ |\e[0m        \e[34m// However, we can do better.\e[0m\n\e[31m30 |\e[0m    \
    \    \e[34m// We can solve this problem in O(n) time by us"
  stdout: ''
  timestamp: 1659792844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a priority queue to simulate the cars.\n        // The priority queue will contain\
    \ the cars that are moving left to right.\n        // The priority queue will\
    \ be sorted by the position of the car.\n        // The priority queue will be\
    \ sorted in ascending order.\n        // The priority queue will contain the cars\
    \ that are moving right to left.\n        // The priority queue will be sorted\
    \ by the position of the car.\n        // The priority queue will be sorted in\
    \ descending order.\n        // The cars that are moving left to right will be\
    \ represented by positive numbers.\n        // The cars that are moving right\
    \ to left will be represented by negative numbers.\n        // The absolute value\
    \ of the number will represent the position of the car.\n        // The sign of\
    \ the number will represent the direction of the car.\n        // The cars will\
    \ be added to the priority queue in the order that they appear.\n        // The\
    \ cars will be removed from the priority queue in the order that they appear.\n\
    \        // The cars will be removed from the priority queue in the order that\
    \ they appear.\n        // The cars will be removed from the priority queue in\
    \ the order that they appear.\n        // The cars will be removed from the priority\
    \ queue in the order that they appear.\n        // The cars will be removed from\
    \ the priority queue in the order that they appear.\n        // The cars will\
    \ be removed from the priority queue in the order that they appear.\n        //\
    \ The cars will be removed from the priority queue in the order that they appear.\n\
    \        // The cars will be removed from the priority queue in the order that\
    \ they appear.\n        // The cars will be removed from the priority queue in\
    \ the order that they appear.\n        // The cars will be removed from the priority\
    \ queue in the order that they appear.\n        // The cars will be removed from\
    \ the priority queue in the order that they appear.\n        // The cars will\
    \ be removed from the priority queue in the order that they appear.\n        //\
    \ The cars will be removed from the priority queue in the order that they appear.\n\
    \        // The cars will be removed from the priority queue in the order that\
    \ they appear.\n        // The cars will be removed from the priority queue in\
    \ the order that they appear.\n        // The cars will be removed from the priority\
    \ queue in the order that they appear.\n        // The cars will be removed from\
    \ the priority queue\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9uf8hx_8.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a priority queue to simulate the cars.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// The priority queue will contain the cars that are moving\
    \ left to right.\e[0m\n\e[31m15 |\e[0m        \e[34m// The priority queue will\
    \ be sorted by the position of the car.\e[0m\n\e[31m16 |\e[0m        \e[34m//\
    \ The priority queue will be sorted in ascending order.\e[0m\n\e[31m17 |\e[0m\
    \        \e[34m// The priority queue will contain the cars that are moving right\
    \ to left.\e[0m\n\e[31m18 |\e[0m        \e[34m// The priority queue will be sorted\
    \ by the position of the car.\e[0m\n\e[31m19 |\e[0m        \e[34m// The priority\
    \ queue will be sorted in descending order.\e[0m\n\e[31m20 |\e[0m        \e[34m//\
    \ The cars that are moving left to right will be represented by positive numbers.\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// The cars that are moving right to left will\
    \ be represented by negative numbers.\e[0m\n\e[31m22 |\e[0m        \e[34m// The\
    \ absolute value of the number will represent the position of the car.\e[0m\n\e\
    [31m23 |\e[0m        \e[34m// The sign of the number will represent the direction\
    \ of the car.\e[0m\n\e[31m24 |\e[0m        \e[34m// The cars will be added to\
    \ the priority queue in the order that they appear.\e[0m\n\e[31m25 |\e[0m    \
    \    \e[34m// The cars will be removed from the priority queue in the order that\
    \ they appear.\e[0m\n\e[31m26 |\e[0m        \e[34m// The cars will be removed\
    \ from the priority queue in the order that they appear.\e[0m\n\e[31m27 |\e[0m\
    \        \e[34m// The cars will be removed from the priority queue in the order\
    \ that they appear.\e[0m\n\e[31m28 |\e[0m        \e[34m// The cars will be removed\
    \ from the priority queue in the order"
  stdout: ''
  timestamp: 1659792844
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just count the\
    \ number of cars that are moving in the same direction\n        // that are in\
    \ the same position.\n        // The number of collisions is the number of cars\
    \ that are moving in the same direction\n        // that are in the same position,\
    \ divided by 2.\n        // The reason why we divide by 2 is because each collision\
    \ is counted twice.\n        // For example, if car 1 and car 2 are moving in\
    \ the same direction and are in the same position,\n        // then car 1 collides\
    \ with car 2 and car 2 collides with car 1.\n        // So, we divide by 2 to\
    \ get the number of collisions.\n        // The reason why we divide by 2 is because\
    \ each collision is counted twice.\n        // For example, if car 1 and car 2\
    \ are moving in the same direction and are in the same position,\n        // then\
    \ car 1 collides with car 2 and car 2 collides with car 1.\n        // So, we\
    \ divide by 2 to get the number of collisions.\n        val cars = Array.ofDim[(Long,\
    \ Boolean)](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i)\
    \ = (i, true)\n            cars(i + n.toInt) = (i, false)\n        }\n       \
    \ cars.sortBy(x => x._1)\n        var count = 0\n        var i = 0\n        while\
    \ (i < cars.length) {\n            var j = i + 1\n            while (j < cars.length\
    \ && cars(i)._1 == cars(j)._1 && cars(i)._2 == cars(j)._2) {\n               \
    \ count += 1\n                j += 1\n            }\n            i = j\n     \
    \   }\n        count / 2\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc9qqi9yp.scala:45)\n\tat Problem.main(tmpc9qqi9yp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792846
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just iterate\
    \ through the cars and count the number of collisions.\n        // The number\
    \ of collisions is the number of cars that are moving right to left\n        //\
    \ that are to the left of the current car.\n        // The time complexity is\
    \ O(n log n)\n        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n   \
    \     for (i <- 0 until n.toInt) {\n            cars(i) = (i, true)\n        \
    \    cars(i + n.toInt) = (i, false)\n        }\n        cars.sortBy(x => x._1)\n\
    \        var collisions = 0L\n        var numLeftToRight = 0\n        for (i <-\
    \ 0 until cars.length) {\n            if (cars(i)._2) numLeftToRight += 1\n  \
    \          else collisions += numLeftToRight\n        }\n        collisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm to count the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // 1.  Sort the cars by their starting position.\n \
    \       // 2.  Start with the leftmost car.  If it's moving left to right, then\
    \ it will\n        //     collide with the next car that's moving right to left.\
    \  If it's moving\n        //     right to left, then it will collide with the\
    \ next car that's moving left to right.\n        //     In either case, we can\
    \ count the number of collisions by counting the number of\n        //     cars\
    \ that are moving in the opposite direction.\n        // 3.  Move the sweep line\
    \ to the next car.\n        // 4.  Repeat step 2.\n        // 5.  Repeat step\
    \ 3 until we reach the end of the road.\n        // 6.  The total number of collisions\
    \ is the sum of the number of collisions at each step.\n        //\n        //\
    \ The time complexity is O(n log n) because we need to sort the cars by their\
    \ starting position.\n        // The space complexity is O(n) because we need\
    \ to store the cars in an array.\n        //\n        // We can improve the time\
    \ complexity to O(n) by using a balanced binary search tree.\n        // The space\
    \ complexity remains O(n).\n        //\n        // We can improve the space complexity\
    \ to O(1) by using a divide and conquer approach.\n        // The time complexity\
    \ is O(n log n).\n        //\n        // We can improve the time complexity to\
    \ O(n) by using a divide and conquer approach.\n        // The space complexity\
    \ remains O(1).\n        //\n        // We can improve the time complexity to\
    \ O(n) by using a divide and conquer approach.\n        // The space complexity\
    \ remains O(1).\n        //\n        // We can improve the time complexity to\
    \ O(n) by using a divide and conquer approach.\n        // The space complexity\
    \ remains O(1).\n        //\n        // We can improve the time complexity to\
    \ O(n) by using a divide and conquer approach.\n        // The space complexity\
    \ remains O(1).\n        //\n        // We can improve the time complexity to\
    \ O(n)\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6twx9jmi.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can use a sweep line algorithm to count the\
    \ number of collisions.\e[0m\n\e[31m15 |\e[0m        \e[34m// The sweep line algorithm\
    \ is as follows:\e[0m\n\e[31m16 |\e[0m        \e[34m// 1.  Sort the cars by their\
    \ starting position.\e[0m\n\e[31m17 |\e[0m        \e[34m// 2.  Start with the\
    \ leftmost car.  If it's moving left to right, then it will\e[0m\n\e[31m18 |\e\
    [0m        \e[34m//     collide with the next car that's moving right to left.\
    \  If it's moving\e[0m\n\e[31m19 |\e[0m        \e[34m//     right to left, then\
    \ it will collide with the next car that's moving left to right.\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m//     In either case, we can count the number of collisions\
    \ by counting the number of\e[0m\n\e[31m21 |\e[0m        \e[34m//     cars that\
    \ are moving in the opposite direction.\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ 3.  Move the sweep line to the next car.\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ 4.  Repeat step 2.\e[0m\n\e[31m24 |\e[0m        \e[34m// 5.  Repeat step 3 until\
    \ we reach the end of the road.\e[0m\n\e[31m25 |\e[0m        \e[34m// 6.  The\
    \ total number of collisions is the sum of the number of collisions at each step.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m//\e[0m\n\e[31m27 |\e[0m        \e[34m// The\
    \ time complexity is O(n log n) because we need to sort the cars by their starting\
    \ position.\e[0m\n\e[31m28 |\e[0m        \e[34m// The space complexity is O(n)\
    \ because we need to store the cars in an array.\e[0m\n\e[31m29 |\e[0m       \
    \ \e[34m//\e[0m\n\e[31m30 |\e[0m        \e[34m// We can improve the time complexity\
    \ to O(n) by using a balanced binary search "
  stdout: ''
  timestamp: 1659792844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 0 to n-1.  The cars moving left to right are\n        // numbered from\
    \ 0 to n-1, and the cars moving right to left are numbered from\n        // n-1\
    \ to 0.  The cars move at the same speed, so the time it takes for a car\n   \
    \     // to move from one end of the road to the other is the same for all cars.\n\
    \        // The time it takes for a car to move from one end of the road to the\
    \ other\n        // is equal to the distance between the two ends of the road\
    \ divided by the\n        // speed of the car.  Since the road is infinitely long,\
    \ the time it takes\n        // for a car to move from one end of the road to\
    \ the other is equal to the\n        // distance between the two ends of the road\
    \ divided by the speed of the car.\n        // The distance between the two ends\
    \ of the road is equal to the sum of the\n        // distances between the two\
    \ ends of the road and the two ends of the road.\n        // The distance between\
    \ the two ends of the road is equal to the sum of the\n        // distances between\
    \ the two ends of the road and the two ends of the road.\n        // The distance\
    \ between the two ends of the road is equal to the sum of the\n        // distances\
    \ between the two ends of the road and the two ends of the road.\n        // The\
    \ distance between the two ends of the road is equal to the sum of the\n     \
    \   // distances between the two ends of the road and the two ends of the road.\n\
    \        // The distance between the two ends of the road is equal to the sum\
    \ of the\n        // distances between the two ends of the road and the two ends\
    \ of the road.\n        // The distance between the two ends of the road is equal\
    \ to the sum of the\n        // distances between the two ends of the road and\
    \ the two ends of the road.\n        // The distance between the two ends of the\
    \ road is equal to the sum of the\n        // distances between the two ends of\
    \ the road and the two ends of the road.\n        // The distance between the\
    \ two ends of the road is equal to the sum of the\n        // distances between\
    \ the two ends of the road and the two ends of the road.\n        // The distance\
    \ between the two ends of the road is equal to the sum of the\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnnqqrhbl.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 0 to n-1.  The cars moving left to right are\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// numbered from 0 to n-1, and the cars moving\
    \ right to left are numbered from\e[0m\n\e[31m15 |\e[0m        \e[34m// n-1 to\
    \ 0.  The cars move at the same speed, so the time it takes for a car\e[0m\n\e\
    [31m16 |\e[0m        \e[34m// to move from one end of the road to the other is\
    \ the same for all cars.\e[0m\n\e[31m17 |\e[0m        \e[34m// The time it takes\
    \ for a car to move from one end of the road to the other\e[0m\n\e[31m18 |\e[0m\
    \        \e[34m// is equal to the distance between the two ends of the road divided\
    \ by the\e[0m\n\e[31m19 |\e[0m        \e[34m// speed of the car.  Since the road\
    \ is infinitely long, the time it takes\e[0m\n\e[31m20 |\e[0m        \e[34m//\
    \ for a car to move from one end of the road to the other is equal to the\e[0m\n\
    \e[31m21 |\e[0m        \e[34m// distance between the two ends of the road divided\
    \ by the speed of the car.\e[0m\n\e[31m22 |\e[0m        \e[34m// The distance\
    \ between the two ends of the road is equal to the sum of the\e[0m\n\e[31m23 |\e\
    [0m        \e[34m// distances between the two ends of the road and the two ends\
    \ of the road.\e[0m\n\e[31m24 |\e[0m        \e[34m// The distance between the\
    \ two ends of the road is equal to the sum of the\e[0m\n\e[31m25 |\e[0m      \
    \  \e[34m// distances between the two ends of the road and the two ends of the\
    \ road.\e[0m\n\e[31m26 |\e[0m        \e[34m// The distance between the two ends\
    \ of the road is equal to the sum of the\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ distances between the two ends of the road and the two ends of the road.\e[0m\n\
    \e[31m28 |\e[0m        \e[34m// The distan"
  stdout: ''
  timestamp: 1659792844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can use a sweep line\
    \ algorithm to find the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // We start with the leftmost car.  We then move the\
    \ sweep line to the right.\n        // As we move the sweep line, we keep track\
    \ of the number of cars that are\n        // moving left to right that are to\
    \ the left of the sweep line.  We also keep\n        // track of the number of\
    \ cars that are moving right to left that are to the\n        // right of the\
    \ sweep line.  When we move the sweep line, we check if the\n        // car that\
    \ we are moving the sweep line to is moving left to right or right\n        //\
    \ to left.  If it's moving left to right, we increment the number of cars\n  \
    \      // moving left to right that are to the left of the sweep line.  If it's\
    \ moving\n        // right to left, we increment the number of cars moving right\
    \ to left that\n        // are to the right of the sweep line.  We also check\
    \ if the number of cars\n        // moving left to right that are to the left\
    \ of the sweep line is greater than\n        // the number of cars moving right\
    \ to left that are to the right of the sweep line.\n        // If so, we increment\
    \ the number of collisions.\n        // We repeat this process until we have moved\
    \ the sweep line to the rightmost\n        // car.\n        // The time complexity\
    \ is O(n log n) because we need to sort the cars by their\n        // starting\
    \ positions.\n        // The space complexity is O(n) because we need to store\
    \ the cars in an array.\n        val cars = Array.fill(n.toInt)((0, 0))\n    \
    \    for (i <- 0 until n.toInt) {\n            val Array(x, y) = readLine.split(\"\
    \ \").map(_.toInt)\n            cars(i) = (x, y)\n        }\n        val sortedCars\
    \ = cars.sortWith((a, b) => a._1 < b._1)\n        var numCollisions = 0\n    \
    \    var numLeftToRight = 0\n        var numRightToLeft = 0\n        for (i <-\
    \ 0 until n.toInt) {\n\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppzlzh7dg.scala:55:0 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppzlzh7dg.scala:36:30\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m\
    \ Array(x, y) = readLine.split(\e[31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m  \
    \ |\e[0m                              ^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                     Not found: readLine\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmppzlzh7dg.scala:36:22 ---------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m            \e[33mval\e[0m Array(x, y) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\
    \e[31m   |\e[0m                      Recursive \e[33mvalue\e[0m \e[35m$1$\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppzlzh7dg.scala:36:25\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e\
    [0m Array(x, y) = readLine.split(\e[31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m\
    \   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m                   \
    \      Recursive \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppzlzh7dg.scala:54:1 ---------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmppzlzh7dg.scala:46:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m46 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659792846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just iterate\
    \ through the cars and count the number of collisions.\n        // The time complexity\
    \ is O(n log n).\n        val cars = Array.fill(n.toInt)((0, 0))\n        for\
    \ (i <- 0 until n.toInt) {\n            val Array(x, v) = readLine.split(\" \"\
    ).map(_.toInt)\n            cars(i) = (x, v)\n        }\n        val sortedCars\
    \ = cars.sortBy(_._1)\n        var collisions = 0\n        for (i <- 0 until n.toInt)\
    \ {\n            val (x, v) = sortedCars(i)\n            val (x2, v2) = sortedCars(n.toInt\
    \ - 1 - i)\n            if (v2 < v) collisions += 1\n        }\n        collisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptbp6xomu.scala:18:30 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m Array(x, v) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                          \
    \    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found: readLine\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptbp6xomu.scala:18:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e\
    [0m Array(x, v) = readLine.split(\e[31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m\
    \   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                      Recursive\
    \ \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmptbp6xomu.scala:18:25 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m Array(x, v) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                         ^\e\
    [0m\n\e[31m   |\e[0m                         Recursive \e[33mvalue\e[0m \e[35m$1$\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659792844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a classic problem\
    \ in combinatorics.\n        // The number of ways to choose k cars from n cars\
    \ is n choose k.\n        // The number of ways to choose k cars from n cars is\
    \ n choose k.\n        // The number of ways to choose k cars from n cars is n\
    \ choose k.\n        // The number of ways to choose k cars from n cars is n choose\
    \ k.\n        // The number of ways to choose k cars from n cars is n choose k.\n\
    \        // The number of ways to choose k cars from n cars is n choose k.\n \
    \       // The number of ways to choose k cars from n cars is n choose k.\n  \
    \      // The number of ways to choose k cars from n cars is n choose k.\n   \
    \     // The number of ways to choose k cars from n cars is n choose k.\n    \
    \    // The number of ways to choose k cars from n cars is n choose k.\n     \
    \   // The number of ways to choose k cars from n cars is n choose k.\n      \
    \  // The number of ways to choose k cars from n cars is n choose k.\n       \
    \ // The number of ways to choose k cars from n cars is n choose k.\n        //\
    \ The number of ways to choose k cars from n cars is n choose k.\n        // The\
    \ number of ways to choose k cars from n cars is n choose k.\n        // The number\
    \ of ways to choose k cars from n cars is n choose k.\n        // The number of\
    \ ways to choose k cars from n cars is n choose k.\n        // The number of ways\
    \ to choose k cars from n cars is n choose k.\n        // The number of ways to\
    \ choose k cars from n cars is n choose k.\n        // The number of ways to choose\
    \ k cars from n cars is n choose k.\n        // The number of ways to choose k\
    \ cars from n cars is n choose k.\n        // The number of ways to choose k cars\
    \ from n cars is n choose k.\n        // The number of ways to choose k cars from\
    \ n cars is n choose k.\n        // The number of ways to choose k cars from n\
    \ cars is n choose k.\n        // The number of ways to choose k cars from n cars\
    \ is n choose k.\n        // The number of ways to choose k cars from n cars is\
    \ n choose k.\n        // The number\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgpx9a5pt.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a classic problem in combinatorics.\e[0m\n\e[31m14 |\e[0m     \
    \   \e[34m// The number of ways to choose k cars from n cars is n choose k.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// The number of ways to choose k cars from\
    \ n cars is n choose k.\e[0m\n\e[31m16 |\e[0m        \e[34m// The number of ways\
    \ to choose k cars from n cars is n choose k.\e[0m\n\e[31m17 |\e[0m        \e\
    [34m// The number of ways to choose k cars from n cars is n choose k.\e[0m\n\e\
    [31m18 |\e[0m        \e[34m// The number of ways to choose k cars from n cars\
    \ is n choose k.\e[0m\n\e[31m19 |\e[0m        \e[34m// The number of ways to choose\
    \ k cars from n cars is n choose k.\e[0m\n\e[31m20 |\e[0m        \e[34m// The\
    \ number of ways to choose k cars from n cars is n choose k.\e[0m\n\e[31m21 |\e\
    [0m        \e[34m// The number of ways to choose k cars from n cars is n choose\
    \ k.\e[0m\n\e[31m22 |\e[0m        \e[34m// The number of ways to choose k cars\
    \ from n cars is n choose k.\e[0m\n\e[31m23 |\e[0m        \e[34m// The number\
    \ of ways to choose k cars from n cars is n choose k.\e[0m\n\e[31m24 |\e[0m  \
    \      \e[34m// The number of ways to choose k cars from n cars is n choose k.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// The number of ways to choose k cars from\
    \ n cars is n choose k.\e[0m\n\e[31m26 |\e[0m        \e[34m// The number of ways\
    \ to choose k cars from n cars is n choose k.\e[0m\n\e[31m27 |\e[0m        \e\
    [34m// The number of ways to choose k cars from n cars is n choose k.\e[0m\n\e\
    [31m28 |\e[0m        \e[34m// The number of ways to choose k cars from n cars\
    \ is n choose k.\e[0m\n\e[31m29 |\e[0m        \e[34m// The number of ways to choose\
    \ k cars from n cars is n choose k.\e[0m\n\e[31m30 |\e[0m       "
  stdout: ''
  timestamp: 1659792845
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a brute force\
    \ solution.  We can do better.\n        // We can use a hash table to store the\
    \ positions of the cars.\n        // We can then iterate through the positions\
    \ of the cars and count the number of collisions.\n        // The time complexity\
    \ is O(n).\n        val positions = new HashMap[Long, Int]\n        for (i <-\
    \ 1 to n.toInt) {\n            positions(i) = i\n            positions(-i) = -i\n\
    \        }\n        var count = 0\n        for (i <- 1 to n.toInt) {\n       \
    \     if (positions.contains(i)) {\n                count += 1\n             \
    \   positions.remove(i)\n            }\n        }\n        count\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwzydugpl.scala:32)\n\tat Problem.main(tmpwzydugpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792847
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a brute force\
    \ solution.  We can do better.\n        // For each car moving left to right,\
    \ we check if it collides with any car moving right to left.\n        // If it\
    \ does, we increment the counter.\n        var counter = 0L\n        for (i <-\
    \ 1L to n) {\n            for (j <- 1L to n) {\n                if (i == j) {\n\
    \                    counter += 1\n                }\n            }\n        }\n\
    \        counter\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaqbxvk1n.scala:27)\n\tat Problem.main(tmpaqbxvk1n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792854
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can solve this problem\
    \ by using a sweep line algorithm.\n        // The sweep line is a vertical line\
    \ that moves from left to right.\n        // We can use a set to keep track of\
    \ all the cars that are currently\n        // to the left of the sweep line. \
    \ The sweep line will move from left to right.\n        // When the sweep line\
    \ moves to the right, it will encounter a car that's moving\n        // left to\
    \ right.  We can add this car to the set.  When the sweep line moves to the right,\n\
    \        // it will encounter a car that's moving right to left.  We can remove\
    \ this car from the set.\n        // If the set is empty, then there is no collision.\
    \  Otherwise, there is a collision.\n        // The sweep line will move from\
    \ left to right.  When it moves to the right, it will encounter\n        // a\
    \ car that's moving left to right.  We can add this car to the set.  When the\
    \ sweep line moves\n        // to the right, it will encounter a car that's moving\
    \ right to left.  We can remove this car from\n        // the set.  If the set\
    \ is empty, then there is no collision.  Otherwise, there is a collision.\n  \
    \      // The sweep line will move from left to right.  When it moves to the right,\
    \ it will encounter\n        // a car that's moving left to right.  We can add\
    \ this car to the set.  When the sweep line moves\n        // to the right, it\
    \ will encounter a car that's moving right to left.  We can remove this car from\n\
    \        // the set.  If the set is empty, then there is no collision.  Otherwise,\
    \ there is a collision.\n        // The sweep line will move from left to right.\
    \  When it moves to the right, it will encounter\n        // a car that's moving\
    \ left to right.  We can add this car to the set.  When the sweep line moves\n\
    \        // to the right, it will encounter a car that's moving right to left.\
    \  We can remove this car from\n        // the set.  If the set is empty, then\
    \ there is no collision.  Otherwise, there is a collision.\n        // The sweep\
    \ line will move from left to right.  When it moves to the right, it will encounter\n\
    \        // a car that\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprujpq78i.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We can solve this problem by using a sweep line algorithm.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// The sweep line is a vertical line that moves from left\
    \ to right.\e[0m\n\e[31m15 |\e[0m        \e[34m// We can use a set to keep track\
    \ of all the cars that are currently\e[0m\n\e[31m16 |\e[0m        \e[34m// to\
    \ the left of the sweep line.  The sweep line will move from left to right.\e\
    [0m\n\e[31m17 |\e[0m        \e[34m// When the sweep line moves to the right, it\
    \ will encounter a car that's moving\e[0m\n\e[31m18 |\e[0m        \e[34m// left\
    \ to right.  We can add this car to the set.  When the sweep line moves to the\
    \ right,\e[0m\n\e[31m19 |\e[0m        \e[34m// it will encounter a car that's\
    \ moving right to left.  We can remove this car from the set.\e[0m\n\e[31m20 |\e\
    [0m        \e[34m// If the set is empty, then there is no collision.  Otherwise,\
    \ there is a collision.\e[0m\n\e[31m21 |\e[0m        \e[34m// The sweep line will\
    \ move from left to right.  When it moves to the right, it will encounter\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// a car that's moving left to right.  We can add\
    \ this car to the set.  When the sweep line moves\e[0m\n\e[31m23 |\e[0m      \
    \  \e[34m// to the right, it will encounter a car that's moving right to left.\
    \  We can remove this car from\e[0m\n\e[31m24 |\e[0m        \e[34m// the set.\
    \  If the set is empty, then there is no collision.  Otherwise, there is a collision.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// The sweep line will move from left to right.\
    \  When it moves to the right, it will encounter\e[0m\n\e[31m26 |\e[0m       \
    \ \e[34m// a car that's moving left to right.  We can add this car to the set.\
    \  When the sweep line moves\e[0m\n"
  stdout: ''
  timestamp: 1659792852
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm to determine the number of collisions.\n        // The sweep line\
    \ algorithm is as follows:\n        // We start with the leftmost car.  We move\
    \ the sweep line to the right,\n        // and as we do so, we keep track of the\
    \ number of cars that are moving left to right.\n        // When we encounter\
    \ a car that's moving right to left, we add the number of cars\n        // that\
    \ are moving left to right to the number of collisions.\n        // We keep doing\
    \ this until we reach the rightmost car.\n        // The time complexity of this\
    \ algorithm is O(n log n).\n        // The space complexity is O(n).\n       \
    \ val cars = Array.fill(2 * n.toInt)(0)\n        for (i <- 0 until n.toInt) {\n\
    \            cars(i) = i + 1\n            cars(i + n.toInt) = -(i + 1)\n     \
    \   }\n        val sortedCars = cars.sorted\n        var numCollisions = 0L\n\
    \        var numCarsMovingLeftToRight = 0\n        for (car <- sortedCars) {\n\
    \            if (car > 0) {\n                numCarsMovingLeftToRight += 1\n \
    \           } else {\n                numCollisions += numCarsMovingLeftToRight\n\
    \            }\n        }\n        numCollisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxsrc6t6b.scala:41)\n\tat Problem.main(tmpxsrc6t6b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792855
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val cars = Array.fill(n.toInt)(0)\n\
    \        for (i <- 0 until n.toInt) cars(i) = i\n        var collisions = 0\n\
    \        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt)\
    \ {\n                if (cars(i) > cars(j)) collisions += 1\n            }\n \
    \       }\n        collisions\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkmcaj_hn.scala:24)\n\tat Problem.main(tmpkmcaj_hn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792856
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is the number\
    \ of collisions.\n        var collisions = 0L\n        // This is the number of\
    \ cars that are moving left to right.\n        var leftToRight = n\n        //\
    \ This is the number of cars that are moving right to left.\n        var rightToLeft\
    \ = n\n        // This is the number of cars that are moving left to right and\
    \ have collided.\n        var leftToRightCollided = 0L\n        // This is the\
    \ number of cars that are moving right to left and have collided.\n        var\
    \ rightToLeftCollided = 0L\n        // This is the number of cars that are moving\
    \ left to right and have not collided.\n        var leftToRightNotCollided = n\n\
    \        // This is the number of cars that are moving right to left and have\
    \ not collided.\n        var rightToLeftNotCollided = n\n        // This is the\
    \ number of cars that are moving left to right and have collided and are moving\
    \ left to right.\n        var leftToRightCollidedLeftToRight = 0L\n        //\
    \ This is the number of cars that are moving left to right and have collided and\
    \ are moving right to left.\n        var leftToRightCollidedRightToLeft = 0L\n\
    \        // This is the number of cars that are moving right to left and have\
    \ collided and are moving left to right.\n        var rightToLeftCollidedLeftToRight\
    \ = 0L\n        // This is the number of cars that are moving right to left and\
    \ have collided and are moving right to left.\n        var rightToLeftCollidedRightToLeft\
    \ = 0L\n        // This is the number of cars that are moving left to right and\
    \ have not collided and are moving left to right.\n        var leftToRightNotCollidedLeftToRight\
    \ = n\n        // This is the number of cars that are moving left to right and\
    \ have not collided and are moving right to left.\n        var leftToRightNotCollidedRightToLeft\
    \ = 0L\n        // This is the number of cars that are moving right to left and\
    \ have not collided and are moving left to right.\n        var rightToLeftNotCollidedLeftToRight\
    \ = 0L\n        // This is the number of cars that are moving right to left and\
    \ have not collided and are moving right to left.\n        var rightToLeftNotCollidedRightToLeft\
    \ = n\n        // This is the number\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmponpb_7jp.scala:44:5\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792852
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is the number\
    \ of collisions.\n        var collisions = 0L\n        // This is the number of\
    \ cars that have already collided.\n        var collided = 0L\n        // This\
    \ is the number of cars that are still moving.\n        var moving = n\n     \
    \   // This is the number of cars that have already reached the end.\n       \
    \ var reached = 0L\n        // This is the number of cars that are still moving.\n\
    \        var moving = n\n        // This is the number of cars that have already\
    \ reached the end.\n        var reached = 0L\n        // This is the number of\
    \ cars that are still moving.\n        var moving = n\n        // This is the\
    \ number of cars that have already reached the end.\n        var reached = 0L\n\
    \        // This is the number of cars that are still moving.\n        var moving\
    \ = n\n        // This is the number of cars that have already reached the end.\n\
    \        var reached = 0L\n        // This is the number of cars that are still\
    \ moving.\n        var moving = n\n        // This is the number of cars that\
    \ have already reached the end.\n        var reached = 0L\n        // This is\
    \ the number of cars that are still moving.\n        var moving = n\n        //\
    \ This is the number of cars that have already reached the end.\n        var reached\
    \ = 0L\n        // This is the number of cars that are still moving.\n       \
    \ var moving = n\n        // This is the number of cars that have already reached\
    \ the end.\n        var reached = 0L\n        // This is the number of cars that\
    \ are still moving.\n        var moving = n\n        // This is the number of\
    \ cars that have already reached the end.\n        var reached = 0L\n        //\
    \ This is the number of cars that are still moving.\n        var moving = n\n\
    \        // This is the number of cars that have already reached the end.\n  \
    \      var reached = 0L\n        // This is the number of cars that are still\
    \ moving.\n        var moving = n\n        // This is the number of cars that\
    \ have already reached the end.\n        var reached = 0L\n        // This is\
    \ the number of cars that are still moving.\n        var moving = n\n        //\
    \ This is the number of cars that have already reached the end.\n        var reached\
    \ = 0L\n\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpizgw_vu3.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mmoving\e[0m = n\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmoving is already defined\
    \ as \e[33mvariable\e[0m \e[35mmoving\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpizgw_vu3.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36mreached\e[0m = \e[31m0L\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mreached\
    \ is already defined as \e[33mvariable\e[0m \e[35mreached\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpizgw_vu3.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mmoving\e[0m = n\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmoving is already defined as \e[33mvariable\e[0m \e[35mmoving\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpizgw_vu3.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mvar\e[0m \e[36mreached\e[0m = \e[31m0L\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mreached is already defined\
    \ as \e[33mvariable\e[0m \e[35mreached\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpizgw_vu3.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mvar\e[0m \e[36mmoving\e[0m = n\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmoving is already defined\
    \ as \e[33mvariable\e[0m \e[35mmoving\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpizgw_vu3.scala:3"
  stdout: ''
  timestamp: 1659792853
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can solve this problem\
    \ by using a sweep line algorithm.\n        // Let's say that the cars are numbered\
    \ from 1 to n.  We will\n        // use a sweep line algorithm to find the number\
    \ of collisions.\n        // We will use a priority queue to store the cars.\n\
    \        // The priority queue will be sorted by the position of the car.\n  \
    \      // The priority queue will also store the direction of the car.\n     \
    \   // The priority queue will also store the number of the car.\n        // We\
    \ will use the priority queue to store the cars that are\n        // currently\
    \ on the road.\n        // We will use a hash map to store the number of collisions\
    \ for\n        // each car.\n        // We will use a hash map to store the number\
    \ of collisions for\n        // each car.\n        // We will use a hash map to\
    \ store the number of collisions for\n        // each car.\n        // We will\
    \ use a hash map to store the number of collisions for\n        // each car.\n\
    \        // We will use a hash map to store the number of collisions for\n   \
    \     // each car.\n        // We will use a hash map to store the number of collisions\
    \ for\n        // each car.\n        // We will use a hash map to store the number\
    \ of collisions for\n        // each car.\n        // We will use a hash map to\
    \ store the number of collisions for\n        // each car.\n        // We will\
    \ use a hash map to store the number of collisions for\n        // each car.\n\
    \        // We will use a hash map to store the number of collisions for\n   \
    \     // each car.\n        // We will use a hash map to store the number of collisions\
    \ for\n        // each car.\n        // We will use a hash map to store the number\
    \ of collisions for\n        // each car.\n        // We will use a hash map to\
    \ store the number of collisions for\n        // each car.\n        // We will\
    \ use a hash map to store the number of collisions for\n        // each car.\n\
    \        // We will use a hash map to store the number of collisions for\n   \
    \     // each car.\n        // We will use a hash map to store the number of collisions\
    \ for\n        // each car.\n        // We will use a hash map to store the number\
    \ of collisions for\n        // each car.\n        // We will use\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmlwyi9h.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We can solve this problem by using a sweep line algorithm.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Let's say that the cars are numbered from 1 to n.  We\
    \ will\e[0m\n\e[31m15 |\e[0m        \e[34m// use a sweep line algorithm to find\
    \ the number of collisions.\e[0m\n\e[31m16 |\e[0m        \e[34m// We will use\
    \ a priority queue to store the cars.\e[0m\n\e[31m17 |\e[0m        \e[34m// The\
    \ priority queue will be sorted by the position of the car.\e[0m\n\e[31m18 |\e\
    [0m        \e[34m// The priority queue will also store the direction of the car.\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// The priority queue will also store the number\
    \ of the car.\e[0m\n\e[31m20 |\e[0m        \e[34m// We will use the priority queue\
    \ to store the cars that are\e[0m\n\e[31m21 |\e[0m        \e[34m// currently on\
    \ the road.\e[0m\n\e[31m22 |\e[0m        \e[34m// We will use a hash map to store\
    \ the number of collisions for\e[0m\n\e[31m23 |\e[0m        \e[34m// each car.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// We will use a hash map to store the number\
    \ of collisions for\e[0m\n\e[31m25 |\e[0m        \e[34m// each car.\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// We will use a hash map to store the number of collisions\
    \ for\e[0m\n\e[31m27 |\e[0m        \e[34m// each car.\e[0m\n\e[31m28 |\e[0m  \
    \      \e[34m// We will use a hash map to store the number of collisions for\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// each car.\e[0m\n\e[31m30 |\e[0m        \e\
    [34m// We will use a hash map to store the number of collisions for\e[0m\n\e[31m31\
    \ |\e[0m        \e[34m// each car.\e[0m\n\e[31m32 |\e[0m        \e[34m// We will\
    \ use a hash map to store the number of collisions for\e[0m\n\e[31m33 |\e[0m \
    \       \e[34m// each car.\e[0m\n\e[31m34 |\e[0m        \e[34"
  stdout: ''
  timestamp: 1659792853
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // For each car that's\
    \ moving left to right, we'll keep track of its position.\n        // For each\
    \ car that's moving right to left, we'll keep track of its position.\n       \
    \ // The cars are numbered from 0 to n-1.\n        // We'll keep track of the\
    \ positions of the cars in two arrays, one for the cars\n        // moving left\
    \ to right, and one for the cars moving right to left.\n        // The positions\
    \ of the cars moving left to right are stored in the array\n        // leftToRightPositions.\
    \  The positions of the cars moving right to left are stored\n        // in the\
    \ array rightToLeftPositions.\n        // The position of the ith car moving left\
    \ to right is stored in leftToRightPositions(i).\n        // The position of the\
    \ ith car moving right to left is stored in rightToLeftPositions(i).\n       \
    \ // Initially, the positions of the cars moving left to right are 0, 1, 2, ...,\
    \ n-1.\n        // Initially, the positions of the cars moving right to left are\
    \ n-1, n-2, n-3, ..., 0.\n        // The cars move at the same speed.  The cars\
    \ move one unit of distance per unit of time.\n        // The cars move left to\
    \ right and right to left simultaneously.\n        // The cars move in a straight\
    \ line.\n        // The cars are infinitely strong and sturdy.  As a result, when\
    \ two cars collide,\n        // they continue moving in their trajectory as if\
    \ they did not collide.\n        // The cars are numbered from 0 to n-1.\n   \
    \     // The cars are numbered from 0 to n-1.\n        // The cars are numbered\
    \ from 0 to n-1.\n        // The cars are numbered from 0 to n-1.\n        //\
    \ The cars are numbered from 0 to n-1.\n        // The cars are numbered from\
    \ 0 to n-1.\n        // The cars are numbered from 0 to n-1.\n        // The cars\
    \ are numbered from 0 to n-1.\n        // The cars are numbered from 0 to n-1.\n\
    \        // The cars are numbered from 0 to n-1.\n        // The cars are numbered\
    \ from 0 to n-1.\n        // The cars are numbered from 0 to n-1.\n        //\
    \ The\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps_svxrwa.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// For each car that's moving left to right, we'll keep track of its position.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// For each car that's moving right to left,\
    \ we'll keep track of its position.\e[0m\n\e[31m15 |\e[0m        \e[34m// The\
    \ cars are numbered from 0 to n-1.\e[0m\n\e[31m16 |\e[0m        \e[34m// We'll\
    \ keep track of the positions of the cars in two arrays, one for the cars\e[0m\n\
    \e[31m17 |\e[0m        \e[34m// moving left to right, and one for the cars moving\
    \ right to left.\e[0m\n\e[31m18 |\e[0m        \e[34m// The positions of the cars\
    \ moving left to right are stored in the array\e[0m\n\e[31m19 |\e[0m        \e\
    [34m// leftToRightPositions.  The positions of the cars moving right to left are\
    \ stored\e[0m\n\e[31m20 |\e[0m        \e[34m// in the array rightToLeftPositions.\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// The position of the ith car moving left to\
    \ right is stored in leftToRightPositions(i).\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// The position of the ith car moving right to left is stored in rightToLeftPositions(i).\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// Initially, the positions of the cars moving\
    \ left to right are 0, 1, 2, ..., n-1.\e[0m\n\e[31m24 |\e[0m        \e[34m// Initially,\
    \ the positions of the cars moving right to left are n-1, n-2, n-3, ..., 0.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// The cars move at the same speed.  The cars\
    \ move one unit of distance per unit of time.\e[0m\n\e[31m26 |\e[0m        \e\
    [34m// The cars move left to right and right to left simultaneously.\e[0m\n\e\
    [31m27 |\e[0m        \e[34m// The cars move in a straight line.\e[0m\n\e[31m28\
    \ |\e[0m        \e[34m// The cars are infinitely strong and sturdy.  As a result,\
    \ when two c"
  stdout: ''
  timestamp: 1659792853
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a segment tree to keep track of the cars.\n        // The segment tree is a\
    \ binary tree.  Each node of the tree represents a range of\n        // cars.\
    \  The root node represents all cars.  The left child of the root node represents\n\
    \        // the left half of the cars, and the right child of the root node represents\
    \ the right\n        // half of the cars.  The left child of the left child of\
    \ the root node represents the\n        // left quarter of the cars, and the right\
    \ child of the left child of the root node\n        // represents the right quarter\
    \ of the cars.  And so on.\n        // Each node of the tree has a value that\
    \ is either 0 or 1.  The value of a node is 1\n        // if and only if the cars\
    \ represented by the node are moving in the same direction.\n        // The value\
    \ of a node is 0 if and only if the cars represented by the node are moving\n\
    \        // in opposite directions.\n        // The value of a node is the sum\
    \ of the values of its children.\n        // The value of a leaf node is 1 if\
    \ and only if the car represented by the leaf node\n        // is moving left\
    \ to right.  The value of a leaf node is 0 if and only if the car\n        //\
    \ represented by the leaf node is moving right to left.\n        // The value\
    \ of the root node is the number of collisions.\n        // The segment tree is\
    \ stored in an array.  The root node is stored in the first\n        // element\
    \ of the array.  The left child of the root node is stored in the second\n   \
    \     // element of the array.  The right child of the root node is stored in\
    \ the third\n        // element of the array.  The left child of the left child\
    \ of the root node is stored\n        // in the fourth element of the array. \
    \ The right child of the left child of the root\n        // node is stored in\
    \ the fifth element of the array.  And so on.\n        // The segment tree is\
    \ constructed in a bottom-up fashion.  The leaf nodes are constructed\n      \
    \  // first.  Then the parent nodes are constructed.  And so on.\n        // The\
    \ segment tree is constructed in O(n) time.\n        // The segment tree is constructed\
    \ in O(n) space.\n        val segmentTree = new Array\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpis8orj6o.scala:39:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msegmentTree\e[0m = \e[33mnew\e\
    [0m \e[35mArray\e[0m\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter _length of \e[33mconstructor\e\
    [0m \e[35mArray\e[0m in \e[33mclass\e[0m \e[35mArray\e[0m: (_length: Int): Array[T]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpis8orj6o.scala:40:5 ---------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792854
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is that we\
    \ can sort the cars by their starting position.\n        // Then, we can iterate\
    \ through the cars from left to right and count\n        // the number of cars\
    \ that are moving right to left that are to the left\n        // of the current\
    \ car.\n        // The number of collisions is the sum of the number of cars that\
    \ are\n        // moving right to left that are to the left of the current car.\n\
    \        // The number of cars that are moving right to left that are to the left\n\
    \        // of the current car is the number of cars that are moving right to\
    \ left\n        // that are to the left of the current car minus the number of\
    \ cars that\n        // are moving left to right that are to the left of the current\
    \ car.\n        // The number of cars that are moving right to left that are to\
    \ the left\n        // of the current car is the number of cars that are moving\
    \ right to left\n        // that are to the left of the current car minus the\
    \ number of cars that\n        // are moving left to right that are to the left\
    \ of the current car.\n        // The number of cars that are moving right to\
    \ left that are to the left\n        // of the current car is the number of cars\
    \ that are moving right to left\n        // that are to the left of the current\
    \ car minus the number of cars that\n        // are moving left to right that\
    \ are to the left of the current car.\n        // The number of cars that are\
    \ moving right to left that are to the left\n        // of the current car is\
    \ the number of cars that are moving right to left\n        // that are to the\
    \ left of the current car minus the number of cars that\n        // are moving\
    \ left to right that are to the left of the current car.\n        // The number\
    \ of cars that are moving right to left that are to the left\n        // of the\
    \ current car is the number of cars that are moving right to left\n        //\
    \ that are to the left of the current car minus the number of cars that\n    \
    \    // are moving left to right that are to the left of the current car.\n  \
    \      // The number of cars that are moving right to left that are to the left\n\
    \        // of the current car is the number of cars that are moving right to\
    \ left\n        // that are to the left of the current car minus the number of\
    \ cars that\n        //\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmjbp_inu.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is that we can sort the cars by their starting position.\e[0m\n\
    \e[31m14 |\e[0m        \e[34m// Then, we can iterate through the cars from left\
    \ to right and count\e[0m\n\e[31m15 |\e[0m        \e[34m// the number of cars\
    \ that are moving right to left that are to the left\e[0m\n\e[31m16 |\e[0m   \
    \     \e[34m// of the current car.\e[0m\n\e[31m17 |\e[0m        \e[34m// The number\
    \ of collisions is the sum of the number of cars that are\e[0m\n\e[31m18 |\e[0m\
    \        \e[34m// moving right to left that are to the left of the current car.\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// The number of cars that are moving right\
    \ to left that are to the left\e[0m\n\e[31m20 |\e[0m        \e[34m// of the current\
    \ car is the number of cars that are moving right to left\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// that are to the left of the current car minus the number of\
    \ cars that\e[0m\n\e[31m22 |\e[0m        \e[34m// are moving left to right that\
    \ are to the left of the current car.\e[0m\n\e[31m23 |\e[0m        \e[34m// The\
    \ number of cars that are moving right to left that are to the left\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// of the current car is the number of cars that are moving\
    \ right to left\e[0m\n\e[31m25 |\e[0m        \e[34m// that are to the left of\
    \ the current car minus the number of cars that\e[0m\n\e[31m26 |\e[0m        \e\
    [34m// are moving left to right that are to the left of the current car.\e[0m\n\
    \e[31m27 |\e[0m        \e[34m// The number of cars that are moving right to left\
    \ that are to the left\e[0m\n\e[31m28 |\e[0m        \e[34m// of the current car\
    \ is the number of cars that are moving right to left\e[0m\n\e[31m29 |\e[0m  \
    \      \e[34m// that are to the left of the c"
  stdout: ''
  timestamp: 1659792854
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.  We will sweep from left to right.\n        // We will\
    \ keep track of the cars that are moving left to right and the cars that\n   \
    \     // are moving right to left.  We will keep track of the cars that are moving\
    \ left to right\n        // in a priority queue, sorted by their position.  We\
    \ will keep track of the cars that are\n        // moving right to left in a priority\
    \ queue, sorted by their position.  When we sweep\n        // to a position, we\
    \ will remove all cars that are moving left to right that are at that\n      \
    \  // position or before.  We will remove all cars that are moving right to left\
    \ that are\n        // at that position or after.  We will add the number of cars\
    \ that are moving left to right\n        // that are removed to the number of\
    \ cars that are moving right to left that are removed.\n        // This will give\
    \ us the number of collisions.\n        val leftToRight = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        val rightToLeft = new PriorityQueue[Long]()\n        var collisions =\
    \ 0L\n        for (i <- 1 to n.toInt) {\n            leftToRight.enqueue(i)\n\
    \            rightToLeft.enqueue(n + 1 - i)\n        }\n        var position =\
    \ 0L\n        while (!leftToRight.isEmpty || !rightToLeft.isEmpty) {\n       \
    \     if (!leftToRight.isEmpty && leftToRight.head <= position) {\n          \
    \      val car = leftToRight.dequeue\n                collisions += rightToLeft.size\n\
    \            }\n            if (!rightToLeft.isEmpty && rightToLeft.head <= position)\
    \ {\n                val car = rightToLeft.dequeue\n            }\n          \
    \  position += 1\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a brute force\
    \ solution.  We can do better.\n        // We can use the fact that the cars are\
    \ moving in the same speed.\n        // If two cars collide, then the two cars\
    \ must have the same speed.\n        // If two cars have the same speed, then\
    \ they will collide at the same time.\n        // If two cars have the same speed,\
    \ then they will collide at the same position.\n        // If two cars have the\
    \ same speed, then they will collide at the same position\n        // if and only\
    \ if the distance between them is a multiple of the speed.\n        // So, we\
    \ can count the number of pairs of cars that have the same speed and\n       \
    \ // whose distance is a multiple of the speed.\n        // We can also use the\
    \ fact that the cars are moving in the same speed.\n        // If two cars collide,\
    \ then the two cars must have the same speed.\n        // If two cars have the\
    \ same speed, then they will collide at the same time.\n        // If two cars\
    \ have the same speed, then they will collide at the same position.\n        //\
    \ If two cars have the same speed, then they will collide at the same position\n\
    \        // if and only if the distance between them is a multiple of the speed.\n\
    \        // So, we can count the number of pairs of cars that have the same speed\
    \ and\n        // whose distance is a multiple of the speed.\n        // We can\
    \ also use the fact that the cars are moving in the same speed.\n        // If\
    \ two cars collide, then the two cars must have the same speed.\n        // If\
    \ two cars have the same speed, then they will collide at the same time.\n   \
    \     // If two cars have the same speed, then they will collide at the same position.\n\
    \        // If two cars have the same speed, then they will collide at the same\
    \ position\n        // if and only if the distance between them is a multiple\
    \ of the speed.\n        // So, we can count the number of pairs of cars that\
    \ have the same speed and\n        // whose distance is a multiple of the speed.\n\
    \        // We can also use the fact that the cars are moving in the same speed.\n\
    \        // If two cars collide, then the two cars must have the same speed.\n\
    \        // If two cars have the same speed, then they will collide at the same\
    \ time.\n       \n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyc47een6.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a brute force solution.  We can do better.\e[0m\n\e[31m14 |\e[0m\
    \        \e[34m// We can use the fact that the cars are moving in the same speed.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// If two cars collide, then the two cars must\
    \ have the same speed.\e[0m\n\e[31m16 |\e[0m        \e[34m// If two cars have\
    \ the same speed, then they will collide at the same time.\e[0m\n\e[31m17 |\e\
    [0m        \e[34m// If two cars have the same speed, then they will collide at\
    \ the same position.\e[0m\n\e[31m18 |\e[0m        \e[34m// If two cars have the\
    \ same speed, then they will collide at the same position\e[0m\n\e[31m19 |\e[0m\
    \        \e[34m// if and only if the distance between them is a multiple of the\
    \ speed.\e[0m\n\e[31m20 |\e[0m        \e[34m// So, we can count the number of\
    \ pairs of cars that have the same speed and\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ whose distance is a multiple of the speed.\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ We can also use the fact that the cars are moving in the same speed.\e[0m\n\e\
    [31m23 |\e[0m        \e[34m// If two cars collide, then the two cars must have\
    \ the same speed.\e[0m\n\e[31m24 |\e[0m        \e[34m// If two cars have the same\
    \ speed, then they will collide at the same time.\e[0m\n\e[31m25 |\e[0m      \
    \  \e[34m// If two cars have the same speed, then they will collide at the same\
    \ position.\e[0m\n\e[31m26 |\e[0m        \e[34m// If two cars have the same speed,\
    \ then they will collide at the same position\e[0m\n\e[31m27 |\e[0m        \e\
    [34m// if and only if the distance between them is a multiple of the speed.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// So, we can count the number of pairs of cars\
    \ that have the same speed and\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659792855
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a brute force\
    \ solution.\n        // We have n cars moving left to right, and n cars moving\
    \ right to left.\n        // We can represent each car as a point on the line.\
    \  The left-to-right cars\n        // are represented by the points (0, 0), (1,\
    \ 0), (2, 0), ..., (n - 1, 0).\n        // The right-to-left cars are represented\
    \ by the points (0, 1), (1, 1), (2, 1), ..., (n - 1, 1).\n        // We can then\
    \ calculate the number of collisions by checking the number of pairs of points\n\
    \        // that are equal.\n        // We can use the formula for the number\
    \ of pairs of points that are equal:\n        // (n * (n - 1)) / 2\n        //\
    \ This is the same as the formula for the sum of the first n integers.\n     \
    \   // This is the same as the formula for the sum of the first n odd integers.\n\
    \        // This is the same as the formula for the sum of the first n even integers.\n\
    \        // This is the same as the formula for the sum of the first n squares.\n\
    \        // This is the same as the formula for the sum of the first n cubes.\n\
    \        // This is the same as the formula for the sum of the first n powers\
    \ of 4.\n        // This is the same as the formula for the sum of the first n\
    \ powers of 5.\n        // This is the same as the formula for the sum of the\
    \ first n powers of 6.\n        // This is the same as the formula for the sum\
    \ of the first n powers of 7.\n        // This is the same as the formula for\
    \ the sum of the first n powers of 8.\n        // This is the same as the formula\
    \ for the sum of the first n powers of 9.\n        // This is the same as the\
    \ formula for the sum of the first n powers of 10.\n        // This is the same\
    \ as the formula for the sum of the first n powers of 11.\n        // This is\
    \ the same as the formula for the sum of the first n powers of 12.\n        //\
    \ This is the same as the formula for the sum of the first n powers of 13.\n \
    \       // This is the same as the formula for the sum of the first n powers of\
    \ 14.\n       \n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6fdfw_3b.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a brute force solution.\e[0m\n\e[31m14 |\e[0m        \e[34m// We\
    \ have n cars moving left to right, and n cars moving right to left.\e[0m\n\e\
    [31m15 |\e[0m        \e[34m// We can represent each car as a point on the line.\
    \  The left-to-right cars\e[0m\n\e[31m16 |\e[0m        \e[34m// are represented\
    \ by the points (0, 0), (1, 0), (2, 0), ..., (n - 1, 0).\e[0m\n\e[31m17 |\e[0m\
    \        \e[34m// The right-to-left cars are represented by the points (0, 1),\
    \ (1, 1), (2, 1), ..., (n - 1, 1).\e[0m\n\e[31m18 |\e[0m        \e[34m// We can\
    \ then calculate the number of collisions by checking the number of pairs of points\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// that are equal.\e[0m\n\e[31m20 |\e[0m   \
    \     \e[34m// We can use the formula for the number of pairs of points that are\
    \ equal:\e[0m\n\e[31m21 |\e[0m        \e[34m// (n * (n - 1)) / 2\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// This is the same as the formula for the sum of the first\
    \ n integers.\e[0m\n\e[31m23 |\e[0m        \e[34m// This is the same as the formula\
    \ for the sum of the first n odd integers.\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ This is the same as the formula for the sum of the first n even integers.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// This is the same as the formula for the sum\
    \ of the first n squares.\e[0m\n\e[31m26 |\e[0m        \e[34m// This is the same\
    \ as the formula for the sum of the first n cubes.\e[0m\n\e[31m27 |\e[0m     \
    \   \e[34m// This is the same as the formula for the sum of the first n powers\
    \ of 4.\e[0m\n\e[31m28 |\e[0m        \e[34m// This is the same as the formula\
    \ for the sum of the first n powers of 5.\e[0m\n\e[31m29 |\e[0m        \e[34m//\
    \ This is the same as the formula for the sum o"
  stdout: ''
  timestamp: 1659792855
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between the left-to-right cars\n        // and the\
    \ right-to-left cars.\n        // The left-to-right cars are indexed from 0 to\
    \ n - 1.\n        // The right-to-left cars are indexed from 0 to n - 1.\n   \
    \     // The left-to-right cars are at positions x(0), x(1), ..., x(n - 1).\n\
    \        // The right-to-left cars are at positions y(0), y(1), ..., y(n - 1).\n\
    \        // The left-to-right cars are moving at speeds s(0), s(1), ..., s(n -\
    \ 1).\n        // The right-to-left cars are moving at speeds t(0), t(1), ...,\
    \ t(n - 1).\n        // The left-to-right cars are moving from left to right,\
    \ so x(i) < x(j) for i < j.\n        // The right-to-left cars are moving from\
    \ right to left, so y(i) > y(j) for i < j.\n        // The left-to-right cars\
    \ are moving at speeds s(i) > 0 for all i.\n        // The right-to-left cars\
    \ are moving at speeds t(i) < 0 for all i.\n        // The left-to-right cars\
    \ are moving at speeds s(i) < s(j) for i < j.\n        // The right-to-left cars\
    \ are moving at speeds t(i) > t(j) for i < j.\n        // The left-to-right cars\
    \ are at positions x(i) > y(j) for all i, j.\n        // The right-to-left cars\
    \ are at positions y(i) < x(j) for all i, j.\n        // The left-to-right cars\
    \ are at positions x(i) - s(i) * t > y(j) - t(j) * t for all i, j.\n        //\
    \ The right-to-left cars are at positions y(i) - t(i) * t < x(j) - s(j) * t for\
    \ all i, j.\n        // The left-to-right cars are at positions x(i) -\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg33odidz.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This function returns the number of collisions between the left-to-right\
    \ cars\e[0m\n\e[31m14 |\e[0m        \e[34m// and the right-to-left cars.\e[0m\n\
    \e[31m15 |\e[0m        \e[34m// The left-to-right cars are indexed from 0 to n\
    \ - 1.\e[0m\n\e[31m16 |\e[0m        \e[34m// The right-to-left cars are indexed\
    \ from 0 to n - 1.\e[0m\n\e[31m17 |\e[0m        \e[34m// The left-to-right cars\
    \ are at positions x(0), x(1), ..., x(n - 1).\e[0m\n\e[31m18 |\e[0m        \e\
    [34m// The right-to-left cars are at positions y(0), y(1), ..., y(n - 1).\e[0m\n\
    \e[31m19 |\e[0m        \e[34m// The left-to-right cars are moving at speeds s(0),\
    \ s(1), ..., s(n - 1).\e[0m\n\e[31m20 |\e[0m        \e[34m// The right-to-left\
    \ cars are moving at speeds t(0), t(1), ..., t(n - 1).\e[0m\n\e[31m21 |\e[0m \
    \       \e[34m// The left-to-right cars are moving from left to right, so x(i)\
    \ < x(j) for i < j.\e[0m\n\e[31m22 |\e[0m        \e[34m// The right-to-left cars\
    \ are moving from right to left, so y(i) > y(j) for i < j.\e[0m\n\e[31m23 |\e\
    [0m        \e[34m// The left-to-right cars are moving at speeds s(i) > 0 for all\
    \ i.\e[0m\n\e[31m24 |\e[0m        \e[34m// The right-to-left cars are moving at\
    \ speeds t(i) < 0 for all i.\e[0m\n\e[31m25 |\e[0m        \e[34m// The left-to-right\
    \ cars are moving at speeds s(i) < s(j) for i < j.\e[0m\n\e[31m26 |\e[0m     \
    \   \e[34m// The right-to-left cars are moving at speeds t(i) > t(j) for i < j.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// The left-to-right cars are at positions x(i)\
    \ > y(j) for all i, j.\e[0m\n\e[31m28 |\e[0m        \e[34m// The right-to-left\
    \ cars are at positions y(i) < x(j) for all i, j.\e[0m\n\e[31m29 |\e[0m      \
    \  \e[34m// The left-to-right cars are at positi"
  stdout: ''
  timestamp: 1659792855
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can use a sweep line\
    \ algorithm to count the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // We start at the leftmost car.  We keep a counter\
    \ of how many cars are moving\n        // right to left.  We keep moving right\
    \ until we reach the rightmost car.\n        // As we move right, we keep updating\
    \ the counter.  For example, if we encounter\n        // a car that's moving left\
    \ to right, we increment the counter.  If we encounter\n        // a car that's\
    \ moving right to left, we decrement the counter.  The number of\n        // collisions\
    \ is the number of times the counter is greater than 1.\n        // The time complexity\
    \ is O(n log n) and the space complexity is O(n).\n        val cars = Array.fill(2\
    \ * n.toInt)(0)\n        for (i <- 0 until n.toInt) {\n            cars(i) = i\
    \ + 1\n            cars(i + n.toInt) = -(i + 1)\n        }\n        val sortedCars\
    \ = cars.sorted\n        var collisions = 0\n        var counter = 0\n       \
    \ for (i <- 0 until 2 * n.toInt) {\n            if (sortedCars(i) > 0) counter\
    \ += 1\n            else counter -= 1\n            if (counter > 1) collisions\
    \ += 1\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8ktwowzp.scala:39)\n\tat Problem.main(tmp8ktwowzp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is that the\
    \ cars that are moving left to right are numbered from 1 to n,\n        // and\
    \ the cars that are moving right to left are numbered from n to 1.\n        //\
    \ The cars that are moving left to right are at positions 1 to n, and the cars\
    \ that\n        // are moving right to left are at positions -n to -1.\n     \
    \   // The cars that are moving left to right have speeds 1 to n, and the cars\
    \ that are\n        // moving right to left have speeds -n to -1.\n        //\
    \ The cars that are moving left to right are at positions 1 to n at time 0, and\
    \ the cars\n        // that are moving right to left are at positions -n to -1\
    \ at time 0.\n        // The cars that are moving left to right are at positions\
    \ 1 to n at time 1, and the cars\n        // that are moving right to left are\
    \ at positions -n to -1 at time 1.\n        // The cars that are moving left to\
    \ right are at positions 2 to n + 1 at time 2, and the cars\n        // that are\
    \ moving right to left are at positions -n to -2 at time 2.\n        // The cars\
    \ that are moving left to right are at positions 3 to n + 2 at time 3, and the\
    \ cars\n        // that are moving right to left are at positions -n to -3 at\
    \ time 3.\n        // The cars that are moving left to right are at positions\
    \ 4 to n + 3 at time 4, and the cars\n        // that are moving right to left\
    \ are at positions -n to -4 at time 4.\n        // The cars that are moving left\
    \ to right are at positions 5 to n + 4 at time 5, and the cars\n        // that\
    \ are moving right to left are at positions -n to -5 at time 5.\n        // The\
    \ cars that are moving left to right are at positions 6 to n + 5 at time 6, and\
    \ the cars\n        // that are moving right to left are at positions -n to -6\
    \ at time 6.\n        // The cars that are moving left to right are at positions\
    \ 7 to n + 6 at time 7, and the cars\n        // that are moving right to left\
    \ are at positions -n to -7 at time 7.\n        // The cars that are moving left\
    \ to right are at positions 8 to n + 7 at time 8,\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx_j6t52s.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is that the cars that are moving left to right are numbered from\
    \ 1 to n,\e[0m\n\e[31m14 |\e[0m        \e[34m// and the cars that are moving right\
    \ to left are numbered from n to 1.\e[0m\n\e[31m15 |\e[0m        \e[34m// The\
    \ cars that are moving left to right are at positions 1 to n, and the cars that\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// are moving right to left are at positions\
    \ -n to -1.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars that are moving left\
    \ to right have speeds 1 to n, and the cars that are\e[0m\n\e[31m18 |\e[0m   \
    \     \e[34m// moving right to left have speeds -n to -1.\e[0m\n\e[31m19 |\e[0m\
    \        \e[34m// The cars that are moving left to right are at positions 1 to\
    \ n at time 0, and the cars\e[0m\n\e[31m20 |\e[0m        \e[34m// that are moving\
    \ right to left are at positions -n to -1 at time 0.\e[0m\n\e[31m21 |\e[0m   \
    \     \e[34m// The cars that are moving left to right are at positions 1 to n\
    \ at time 1, and the cars\e[0m\n\e[31m22 |\e[0m        \e[34m// that are moving\
    \ right to left are at positions -n to -1 at time 1.\e[0m\n\e[31m23 |\e[0m   \
    \     \e[34m// The cars that are moving left to right are at positions 2 to n\
    \ + 1 at time 2, and the cars\e[0m\n\e[31m24 |\e[0m        \e[34m// that are moving\
    \ right to left are at positions -n to -2 at time 2.\e[0m\n\e[31m25 |\e[0m   \
    \     \e[34m// The cars that are moving left to right are at positions 3 to n\
    \ + 2 at time 3, and the cars\e[0m\n\e[31m26 |\e[0m        \e[34m// that are moving\
    \ right to left are at positions -n to -3 at time 3.\e[0m\n\e[31m27 |\e[0m   \
    \     \e[34m// The cars that are moving left to right are at positions 4 to n\
    \ + 3 at time 4, and the cars\e[0m\n\e[31m28 |\e[0m "
  stdout: ''
  timestamp: 1659792855
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ the fact that the cars are infinitely sturdy and strong.\n        // We can\
    \ imagine that the cars are actually points on a line.  The cars moving\n    \
    \    // left to right are points on the line with positive coordinates, and the\
    \ cars\n        // moving right to left are points on the line with negative coordinates.\n\
    \        // We can then sort the points by their coordinates, and count the number\
    \ of\n        // pairs of points that are next to each other.\n        // The\
    \ number of pairs of points that are next to each other is the number of\n   \
    \     // collisions.\n        val points = new Array[Long](2 * n.toInt)\n    \
    \    for (i <- 0 until n.toInt) points(i) = i + 1\n        for (i <- n.toInt until\
    \ 2 * n.toInt) points(i) = -(i - n.toInt + 1)\n        points.sorted.sliding(2).count(x\
    \ => x(0) + 1 == x(1))\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk5q0nqp5.scala:27)\n\tat Problem.main(tmpk5q0nqp5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792858
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can simulate the race\
    \ by iterating through the cars\n        // in order of their starting position.\
    \  We keep track of the\n        // number of cars that are moving right to left\
    \ that are ahead\n        // of the current car.  This is the number of collisions\
    \ that\n        // the current car will have.\n        val cars = new Array[Long](2\
    \ * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i) = i +\
    \ 1\n            cars(i + n.toInt) = -(i + 1)\n        }\n        scala.util.Sorting.quickSort(cars)\n\
    \        var collisions = 0L\n        var rightToLeftCars = 0\n        for (i\
    \ <- 0 until 2 * n.toInt) {\n            if (cars(i) > 0) {\n                collisions\
    \ += rightToLeftCars\n            } else {\n                rightToLeftCars +=\
    \ 1\n            }\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We use a priority queue\
    \ to keep track of the cars.\n        // The priority queue is sorted by the position\
    \ of the car.\n        // The priority queue has two types of elements:\n    \
    \    // 1.  A car moving left to right.  This is represented by a positive number.\n\
    \        // 2.  A car moving right to left.  This is represented by a negative\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the absolute value of the\
    \ number.\n        // The priority queue is sorted by the\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpslofi7qh.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We use a priority queue to keep track of the cars.\e[0m\n\e[31m14 |\e[0m\
    \        \e[34m// The priority queue is sorted by the position of the car.\e[0m\n\
    \e[31m15 |\e[0m        \e[34m// The priority queue has two types of elements:\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// 1.  A car moving left to right.  This is\
    \ represented by a positive number.\e[0m\n\e[31m17 |\e[0m        \e[34m// 2. \
    \ A car moving right to left.  This is represented by a negative number.\e[0m\n\
    \e[31m18 |\e[0m        \e[34m// The priority queue is sorted by the absolute value\
    \ of the number.\e[0m\n\e[31m19 |\e[0m        \e[34m// The priority queue is sorted\
    \ by the absolute value of the number.\e[0m\n\e[31m20 |\e[0m        \e[34m// The\
    \ priority queue is sorted by the absolute value of the number.\e[0m\n\e[31m21\
    \ |\e[0m        \e[34m// The priority queue is sorted by the absolute value of\
    \ the number.\e[0m\n\e[31m22 |\e[0m        \e[34m// The priority queue is sorted\
    \ by the absolute value of the number.\e[0m\n\e[31m23 |\e[0m        \e[34m// The\
    \ priority queue is sorted by the absolute value of the number.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// The priority queue is sorted by the absolute value of\
    \ the number.\e[0m\n\e[31m25 |\e[0m        \e[34m// The priority queue is sorted\
    \ by the absolute value of the number.\e[0m\n\e[31m26 |\e[0m        \e[34m// The\
    \ priority queue is sorted by the absolute value of the number.\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// The priority queue is sorted by the absolute value of\
    \ the number.\e[0m\n\e[31m28 |\e[0m        \e[34m// The priority queue is sorted\
    \ by the absolute value of the number.\e[0m\n\e[31m29 |\e[0m        \e[34m// The\
    \ priority queue is sorted by the absolute v"
  stdout: ''
  timestamp: 1659792857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can solve it by brute force.\n        // We can simulate the movement\
    \ of the cars.  For each car, we can keep track of\n        // its position and\
    \ direction.  We can simulate the movement of the cars by\n        // moving each\
    \ car one step at a time.  Each time we move a car, we check if\n        // it\
    \ collides with any other car.  If it does, we increment the collision count.\n\
    \        // We can do this by using a hash table.  We can use the position of\
    \ the car as\n        // the key, and the value is a list of cars that are at\
    \ that position.\n        // We can use a hash table to keep track of the cars.\
    \  The key is the position\n        // of the car, and the value is a list of\
    \ cars that are at that position.\n        // We can use a hash table to keep\
    \ track of the cars.  The key is the position\n        // of the car, and the\
    \ value is a list of cars that are at that position.\n        // We can use a\
    \ hash table to keep track of the cars.  The key is the position\n        // of\
    \ the car, and the value is a list of cars that are at that position.\n      \
    \  // We can use a hash table to keep track of the cars.  The key is the position\n\
    \        // of the car, and the value is a list of cars that are at that position.\n\
    \        // We can use a hash table to keep track of the cars.  The key is the\
    \ position\n        // of the car, and the value is a list of cars that are at\
    \ that position.\n        // We can use a hash table to keep track of the cars.\
    \  The key is the position\n        // of the car, and the value is a list of\
    \ cars that are at that position.\n        // We can use a hash table to keep\
    \ track of the cars.  The key is the position\n        // of the car, and the\
    \ value is a list of cars that are at that position.\n        // We can use a\
    \ hash table to keep track of the cars.  The key is the position\n        // of\
    \ the car, and the value is a list of cars that are at that position.\n      \
    \  // We can use a hash table to keep track of the cars.  The key is the\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz3s75vkd.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  We can solve it by brute force.\e[0m\n\e\
    [31m14 |\e[0m        \e[34m// We can simulate the movement of the cars.  For each\
    \ car, we can keep track of\e[0m\n\e[31m15 |\e[0m        \e[34m// its position\
    \ and direction.  We can simulate the movement of the cars by\e[0m\n\e[31m16 |\e\
    [0m        \e[34m// moving each car one step at a time.  Each time we move a car,\
    \ we check if\e[0m\n\e[31m17 |\e[0m        \e[34m// it collides with any other\
    \ car.  If it does, we increment the collision count.\e[0m\n\e[31m18 |\e[0m  \
    \      \e[34m// We can do this by using a hash table.  We can use the position\
    \ of the car as\e[0m\n\e[31m19 |\e[0m        \e[34m// the key, and the value is\
    \ a list of cars that are at that position.\e[0m\n\e[31m20 |\e[0m        \e[34m//\
    \ We can use a hash table to keep track of the cars.  The key is the position\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// of the car, and the value is a list of cars\
    \ that are at that position.\e[0m\n\e[31m22 |\e[0m        \e[34m// We can use\
    \ a hash table to keep track of the cars.  The key is the position\e[0m\n\e[31m23\
    \ |\e[0m        \e[34m// of the car, and the value is a list of cars that are\
    \ at that position.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can use a hash table\
    \ to keep track of the cars.  The key is the position\e[0m\n\e[31m25 |\e[0m  \
    \      \e[34m// of the car, and the value is a list of cars that are at that position.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// We can use a hash table to keep track of\
    \ the cars.  The key is the position\e[0m\n\e[31m27 |\e[0m        \e[34m// of\
    \ the car, and the value is a list of cars that are at that position.\e[0m\n\e\
    [31m28 |\e[0m        \e[34m// We can u"
  stdout: ''
  timestamp: 1659792857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can just simulate the cars moving.\n        // The cars that are\
    \ moving left to right are indexed from 0 to n - 1.\n        // The cars that\
    \ are moving right to left are indexed from n to 2n - 1.\n        // We can represent\
    \ the position of each car as a number between 0 and 2n - 1.\n        // The cars\
    \ that are moving left to right start at position 0, and the cars that\n     \
    \   // are moving right to left start at position 2n - 1.\n        // We can represent\
    \ the position of each car as a number between 0 and 2n - 1.\n        // The cars\
    \ that are moving left to right start at position 0, and the cars that\n     \
    \   // are moving right to left start at position 2n - 1.\n        // We can represent\
    \ the position of each car as a number between 0 and 2n - 1.\n        // The cars\
    \ that are moving left to right start at position 0, and the cars that\n     \
    \   // are moving right to left start at position 2n - 1.\n        // We can represent\
    \ the position of each car as a number between 0 and 2n - 1.\n        // The cars\
    \ that are moving left to right start at position 0, and the cars that\n     \
    \   // are moving right to left start at position 2n - 1.\n        // We can represent\
    \ the position of each car as a number between 0 and 2n - 1.\n        // The cars\
    \ that are moving left to right start at position 0, and the cars that\n     \
    \   // are moving right to left start at position 2n - 1.\n        // We can represent\
    \ the position of each car as a number between 0 and 2n - 1.\n        // The cars\
    \ that are moving left to right start at position 0, and the cars that\n     \
    \   // are moving right to left start at position 2n - 1.\n        // We can represent\
    \ the position of each car as a number between 0 and 2n - 1.\n        // The cars\
    \ that are moving left to right start at position 0, and the cars that\n     \
    \   // are moving right to left start at position 2n - 1.\n        // We can represent\
    \ the position of each car as a number between 0 and 2n - 1.\n        // The cars\
    \ that are moving left to right start at position 0, and the cars that\n     \
    \   // are\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuc1dzas_.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  We can just simulate the cars moving.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// The cars that are moving left to right are\
    \ indexed from 0 to n - 1.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars that\
    \ are moving right to left are indexed from n to 2n - 1.\e[0m\n\e[31m16 |\e[0m\
    \        \e[34m// We can represent the position of each car as a number between\
    \ 0 and 2n - 1.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars that are moving\
    \ left to right start at position 0, and the cars that\e[0m\n\e[31m18 |\e[0m \
    \       \e[34m// are moving right to left start at position 2n - 1.\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// We can represent the position of each car as a number\
    \ between 0 and 2n - 1.\e[0m\n\e[31m20 |\e[0m        \e[34m// The cars that are\
    \ moving left to right start at position 0, and the cars that\e[0m\n\e[31m21 |\e\
    [0m        \e[34m// are moving right to left start at position 2n - 1.\e[0m\n\e\
    [31m22 |\e[0m        \e[34m// We can represent the position of each car as a number\
    \ between 0 and 2n - 1.\e[0m\n\e[31m23 |\e[0m        \e[34m// The cars that are\
    \ moving left to right start at position 0, and the cars that\e[0m\n\e[31m24 |\e\
    [0m        \e[34m// are moving right to left start at position 2n - 1.\e[0m\n\e\
    [31m25 |\e[0m        \e[34m// We can represent the position of each car as a number\
    \ between 0 and 2n - 1.\e[0m\n\e[31m26 |\e[0m        \e[34m// The cars that are\
    \ moving left to right start at position 0, and the cars that\e[0m\n\e[31m27 |\e\
    [0m        \e[34m// are moving right to left start at position 2n - 1.\e[0m\n\e\
    [31m28 |\e[0m        \e[34m// We can represent the position of each car as a number\
    \ between 0 and 2n - 1.\e[0m\n\e["
  stdout: ''
  timestamp: 1659792857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, the cars that start\
    \ at the same position will collide.\n        // The number of collisions is the\
    \ number of cars that start at the same position.\n        // This number is the\
    \ sum of the number of cars that start at position 1, 2, 3, ..., n.\n        //\
    \ This number is the sum of the divisors of n.\n        // The sum of the divisors\
    \ of n is the sum of the divisors of n/2, if n is even.\n        // The sum of\
    \ the divisors of n is the sum of the divisors of (n-1)/2, if n is odd.\n    \
    \    // The sum of the divisors of n is the sum of the divisors of n/2, if n is\
    \ even.\n        // The sum of the divisors of n is the sum of the divisors of\
    \ (n-1)/2, if n is odd.\n        // The sum of the divisors of n is the sum of\
    \ the divisors of n/2, if n is even.\n        // The sum of the divisors of n\
    \ is the sum of the divisors of (n-1)/2, if n is odd.\n        // The sum of the\
    \ divisors of n is the sum of the divisors of n/2, if n is even.\n        // The\
    \ sum of the divisors of n is the sum of the divisors of (n-1)/2, if n is odd.\n\
    \        // The sum of the divisors of n is the sum of the divisors of n/2, if\
    \ n is even.\n        // The sum of the divisors of n is the sum of the divisors\
    \ of (n-1)/2, if n is odd.\n        // The sum of the divisors of n is the sum\
    \ of the divisors of n/2, if n is even.\n        // The sum of the divisors of\
    \ n is the sum of the divisors of (n-1)/2, if n is odd.\n        // The sum of\
    \ the divisors of n is the sum of the divisors of n/2, if n is even.\n       \
    \ // The sum of the divisors of\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdhrhakfk.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, the cars that start at the same position will collide.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// The number of collisions is the number of\
    \ cars that start at the same position.\e[0m\n\e[31m16 |\e[0m        \e[34m//\
    \ This number is the sum of the number of cars that start at position 1, 2, 3,\
    \ ..., n.\e[0m\n\e[31m17 |\e[0m        \e[34m// This number is the sum of the\
    \ divisors of n.\e[0m\n\e[31m18 |\e[0m        \e[34m// The sum of the divisors\
    \ of n is the sum of the divisors of n/2, if n is even.\e[0m\n\e[31m19 |\e[0m\
    \        \e[34m// The sum of the divisors of n is the sum of the divisors of (n-1)/2,\
    \ if n is odd.\e[0m\n\e[31m20 |\e[0m        \e[34m// The sum of the divisors of\
    \ n is the sum of the divisors of n/2, if n is even.\e[0m\n\e[31m21 |\e[0m   \
    \     \e[34m// The sum of the divisors of n is the sum of the divisors of (n-1)/2,\
    \ if n is odd.\e[0m\n\e[31m22 |\e[0m        \e[34m// The sum of the divisors of\
    \ n is the sum of the divisors of n/2, if n is even.\e[0m\n\e[31m23 |\e[0m   \
    \     \e[34m// The sum of the divisors of n is the sum of the divisors of (n-1)/2,\
    \ if n is odd.\e[0m\n\e[31m24 |\e[0m        \e[34m// The sum of the divisors of\
    \ n is the sum of the divisors of n/2, if n is even.\e[0m\n\e[31m25 |\e[0m   \
    \     \e[34m// The sum of the divisors of n is the sum of the divisors of (n-1)/2,\
    \ if n is odd.\e[0m\n\e[31m26 |\e[0m        \e[34m// The sum of the divisors of\
    \ n is the sum of the divisors of n/2, if n is even.\e[0m\n\e[31m27 |\e[0m   \
    \     \e[34m// The sum of the divisors of n is the sum of the divisors of (n-1)/2,\
    \ if n is odd.\e[0m\n\e[31m28 |\e[0m "
  stdout: ''
  timestamp: 1659792858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just iterate\
    \ through the sorted list and count the number of\n        // cars that are moving\
    \ in the opposite direction.\n        // The time complexity is O(n log n)\n \
    \       val leftToRight = (1 to n).map(x => (x, true)).toList\n        val rightToLeft\
    \ = (1 to n).map(x => (x, false)).toList\n        val cars = leftToRight ::: rightToLeft\n\
    \        val sortedCars = cars.sortBy(x => x._1)\n        var count = 0\n    \
    \    for (i <- 0 until sortedCars.length) {\n            if (sortedCars(i)._2)\
    \ {\n                for (j <- i + 1 until sortedCars.length) {\n            \
    \        if (!sortedCars(j)._2) {\n                        count += 1\n      \
    \              }\n                }\n            }\n        }\n        count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbgwfeanh.scala:17:32\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mleftToRight\e\
    [0m = (\e[31m1\e[0m to n).map(\e[36mx\e[0m => (x, \e[31mtrue\e[0m)).toList\n\e\
    [31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m   \
    \                             Found:    (n : Long)\n\e[31m   |\e[0m          \
    \                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpbgwfeanh.scala:18:32 --------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mrightToLeft\e[0m = (\e[31m1\e\
    [0m to n).map(\e[36mx\e[0m => (x, \e[31mfalse\e[0m)).toList\n\e[31m\e[31m   |\e\
    [0m                                ^\e[0m\n\e[31m   |\e[0m                   \
    \             Found:    (n : Long)\n\e[31m   |\e[0m                          \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 0 to n-1.  The cars moving left to right are\n        // numbered from\
    \ 0 to n-1, and the cars moving right to left are numbered from\n        // n-1\
    \ to 0.  The car moving left to right with number i starts at position i.\n  \
    \      // The car moving right to left with number i starts at position n-1-i.\n\
    \        // The cars move at the same speed.  The car moving left to right with\
    \ number i\n        // moves at speed i.  The car moving right to left with number\
    \ i moves at speed n-1-i.\n        // The cars move at the same speed.  The car\
    \ moving left to right with number i\n        // moves at speed i.  The car moving\
    \ right to left with number i moves at speed n-1-i.\n        // The car moving\
    \ left to right with number i will collide with the car moving right to left\n\
    \        // with number j if and only if i+j = n-1.\n        // The car moving\
    \ left to right with number i will collide with the car moving right to left\n\
    \        // with number j if and only if i+j = n-1.\n        // The car moving\
    \ left to right with number i will collide with the car moving right to left\n\
    \        // with number j if and only if i+j = n-1.\n        // The car moving\
    \ left to right with number i will collide with the car moving right to left\n\
    \        // with number j if and only if i+j = n-1.\n        // The car moving\
    \ left to right with number i will collide with the car moving right to left\n\
    \        // with number j if and only if i+j = n-1.\n        // The car moving\
    \ left to right with number i will collide with the car moving right to left\n\
    \        // with number j if and only if i+j = n-1.\n        // The car moving\
    \ left to right with number i will collide with the car moving right to left\n\
    \        // with number j if and only if i+j = n-1.\n        // The car moving\
    \ left to right with number i will collide with the car moving right to left\n\
    \        // with number j if and only if i+j = n-1.\n        // The car moving\
    \ left to right with number i will collide with the\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpirhugp4q.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 0 to n-1.  The cars moving left to right are\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// numbered from 0 to n-1, and the cars moving\
    \ right to left are numbered from\e[0m\n\e[31m15 |\e[0m        \e[34m// n-1 to\
    \ 0.  The car moving left to right with number i starts at position i.\e[0m\n\e\
    [31m16 |\e[0m        \e[34m// The car moving right to left with number i starts\
    \ at position n-1-i.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars move at the\
    \ same speed.  The car moving left to right with number i\e[0m\n\e[31m18 |\e[0m\
    \        \e[34m// moves at speed i.  The car moving right to left with number\
    \ i moves at speed n-1-i.\e[0m\n\e[31m19 |\e[0m        \e[34m// The cars move\
    \ at the same speed.  The car moving left to right with number i\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// moves at speed i.  The car moving right to left with\
    \ number i moves at speed n-1-i.\e[0m\n\e[31m21 |\e[0m        \e[34m// The car\
    \ moving left to right with number i will collide with the car moving right to\
    \ left\e[0m\n\e[31m22 |\e[0m        \e[34m// with number j if and only if i+j\
    \ = n-1.\e[0m\n\e[31m23 |\e[0m        \e[34m// The car moving left to right with\
    \ number i will collide with the car moving right to left\e[0m\n\e[31m24 |\e[0m\
    \        \e[34m// with number j if and only if i+j = n-1.\e[0m\n\e[31m25 |\e[0m\
    \        \e[34m// The car moving left to right with number i will collide with\
    \ the car moving right to left\e[0m\n\e[31m26 |\e[0m        \e[34m// with number\
    \ j if and only if i+j = n-1.\e[0m\n\e[31m27 |\e[0m        \e[34m// The car moving\
    \ left to right with number i will collide with the car moving right to left\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// with number j "
  stdout: ''
  timestamp: 1659792863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can solve this problem\
    \ by first sorting the cars by their starting position.\n        // Then, we can\
    \ iterate through the cars from left to right, and for each car,\n        // we\
    \ can find the number of cars that are to the right of it and moving left to right.\n\
    \        // This can be done by using a binary search.\n        // The total number\
    \ of collisions is the sum of the number of cars that are to the right\n     \
    \   // of each car and moving left to right.\n        // This is O(n log n) time.\n\
    \        val cars = new Array[Long](2 * n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = i + 1\n            cars(i + n.toInt) = -(i + 1)\n \
    \       }\n        // Sort the cars by their starting position.\n        scala.util.Sorting.quickSort(cars)\n\
    \        var collisions = 0L\n        for (i <- 0 until 2 * n.toInt) {\n     \
    \       val car = cars(i)\n            if (car > 0) {\n                // Find\
    \ the number of cars that are to the right of this car and moving left to right.\n\
    \                val index = binarySearch(cars, -car)\n                collisions\
    \ += (2 * n.toInt - index - 1)\n            }\n        }\n        collisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpergcz3in.scala:32:28 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                \e[33mval\e[0m \e[36mindex\e[0m = binarySearch(cars,\
    \ -car)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                            Not found: binarySearch\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659792860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can easily determine\
    \ the number of collisions by\n        // counting the number of cars that are\
    \ moving in the same direction\n        // and are starting at the same position.\n\
    \        // The number of collisions is the number of cars moving in the same\
    \ direction\n        // at the same starting position, divided by 2.\n       \
    \ // The reason is that if there are 2 cars moving in the same direction at the\
    \ same\n        // starting position, then they will collide with each other.\
    \  If there are 4 cars\n        // moving in the same direction at the same starting\
    \ position, then they will\n        // collide with each other in pairs.  If there\
    \ are 6 cars moving in the same direction\n        // at the same starting position,\
    \ then they will collide with each other in pairs.\n        // And so on.\n  \
    \      // The number of collisions is the number of cars moving in the same direction\n\
    \        // at the same starting position, divided by 2.\n        // The reason\
    \ is that if there are 2 cars moving in the same direction at the same\n     \
    \   // starting position, then they will collide with each other.  If there are\
    \ 4 cars\n        // moving in the same direction at the same starting position,\
    \ then they will\n        // collide with each other in pairs.  If there are 6\
    \ cars moving in the same direction\n        // at the same starting position,\
    \ then they will collide with each other in pairs.\n        // And so on.\n  \
    \      // The number of collisions is the number of cars moving in the same direction\n\
    \        // at the same starting position, divided by 2.\n        // The reason\
    \ is that if there are 2 cars moving in the same direction at the same\n     \
    \   // starting position, then they will collide with each other.  If there are\
    \ 4 cars\n        // moving in the same direction at the same starting position,\
    \ then they will\n        // collide with each other in pairs.  If there are 6\
    \ cars moving in the same direction\n        // at the same starting position,\
    \ then they will collide with each other in pairs.\n        // And so on.\n  \
    \      // The number of collisions is the number of cars moving in the same direction\n\
    \        // at the same starting position, divided by 2.\n        // The reason\
    \ is that if there are 2 cars moving in the same direction at the same\n     \
    \   // starting position\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprzpscl1a.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can easily determine the number of collisions\
    \ by\e[0m\n\e[31m15 |\e[0m        \e[34m// counting the number of cars that are\
    \ moving in the same direction\e[0m\n\e[31m16 |\e[0m        \e[34m// and are starting\
    \ at the same position.\e[0m\n\e[31m17 |\e[0m        \e[34m// The number of collisions\
    \ is the number of cars moving in the same direction\e[0m\n\e[31m18 |\e[0m   \
    \     \e[34m// at the same starting position, divided by 2.\e[0m\n\e[31m19 |\e\
    [0m        \e[34m// The reason is that if there are 2 cars moving in the same\
    \ direction at the same\e[0m\n\e[31m20 |\e[0m        \e[34m// starting position,\
    \ then they will collide with each other.  If there are 4 cars\e[0m\n\e[31m21\
    \ |\e[0m        \e[34m// moving in the same direction at the same starting position,\
    \ then they will\e[0m\n\e[31m22 |\e[0m        \e[34m// collide with each other\
    \ in pairs.  If there are 6 cars moving in the same direction\e[0m\n\e[31m23 |\e\
    [0m        \e[34m// at the same starting position, then they will collide with\
    \ each other in pairs.\e[0m\n\e[31m24 |\e[0m        \e[34m// And so on.\e[0m\n\
    \e[31m25 |\e[0m        \e[34m// The number of collisions is the number of cars\
    \ moving in the same direction\e[0m\n\e[31m26 |\e[0m        \e[34m// at the same\
    \ starting position, divided by 2.\e[0m\n\e[31m27 |\e[0m        \e[34m// The reason\
    \ is that if there are 2 cars moving in the same direction at the same\e[0m\n\e\
    [31m28 |\e[0m        \e[34m// starting position, then they will collide with each\
    \ other.  If there are 4 cars\e[0m\n\e[31m29 |\e[0m        \e[34m// moving in\
    \ the same direction at the same st"
  stdout: ''
  timestamp: 1659792863
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars are moving at the same speed.\n        // So, the cars that\
    \ are closest to each other will collide first.\n        // The cars that are\
    \ closest to each other are the ones that are at the same\n        // distance\
    \ from the origin.  So, the number of collisions is the number of\n        //\
    \ pairs of cars that are at the same distance from the origin.\n        // The\
    \ number of cars at a given distance from the origin is the number of\n      \
    \  // ways to choose two cars from n cars.  So, the number of collisions is\n\
    \        // n choose 2.\n        // n choose 2 = n! / (2! * (n - 2)!) = n * (n\
    \ - 1) / 2\n        n * (n - 1) / 2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqtxmgzyr.scala:25)\n\tat Problem.main(tmpqtxmgzyr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.  Then, we can\n        // iterate through\
    \ the cars and count the number of cars that are moving\n        // in the opposite\
    \ direction.  The number of collisions is the number of\n        // cars moving\
    \ in the opposite direction times the number of cars moving\n        // in the\
    \ same direction.\n        // The number of cars moving in the same direction\
    \ is the number of cars\n        // that are in front of the current car.\n  \
    \      // The number of cars moving in the opposite direction is the number of\
    \ cars\n        // that are behind the current car.\n        // We can use a binary\
    \ search to find the number of cars that are in front\n        // of the current\
    \ car.\n        // We can use a binary search to find the number of cars that\
    \ are behind\n        // the current car.\n        // We can use a binary search\
    \ to find the number of cars that are in front\n        // of the current car.\n\
    \        // We can use a binary search to find the number of cars that are behind\n\
    \        // the current car.\n        // We can use a binary search to find the\
    \ number of cars that are in front\n        // of the current car.\n        //\
    \ We can use a binary search to find the number of cars that are behind\n    \
    \    // the current car.\n        // We can use a binary search to find the number\
    \ of cars that are in front\n        // of the current car.\n        // We can\
    \ use a binary search to find the number of cars that are behind\n        // the\
    \ current car.\n        // We can use a binary search to find the number of cars\
    \ that are in front\n        // of the current car.\n        // We can use a binary\
    \ search to find the number of cars that are behind\n        // the current car.\n\
    \        // We can use a binary search to find the number of cars that are in\
    \ front\n        // of the current car.\n        // We can use a binary search\
    \ to find the number of cars that are behind\n        // the current car.\n  \
    \      // We can use a binary search to find the number of cars that are in front\n\
    \        // of the current car.\n        // We can use a binary search to find\
    \ the number of cars that are behind\n        // the current car.\n        //\
    \ We can use a binary search to find the number of cars\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjbwxr9p5.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.  Then, we can\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// iterate through the cars and count the number\
    \ of cars that are moving\e[0m\n\e[31m15 |\e[0m        \e[34m// in the opposite\
    \ direction.  The number of collisions is the number of\e[0m\n\e[31m16 |\e[0m\
    \        \e[34m// cars moving in the opposite direction times the number of cars\
    \ moving\e[0m\n\e[31m17 |\e[0m        \e[34m// in the same direction.\e[0m\n\e\
    [31m18 |\e[0m        \e[34m// The number of cars moving in the same direction\
    \ is the number of cars\e[0m\n\e[31m19 |\e[0m        \e[34m// that are in front\
    \ of the current car.\e[0m\n\e[31m20 |\e[0m        \e[34m// The number of cars\
    \ moving in the opposite direction is the number of cars\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// that are behind the current car.\e[0m\n\e[31m22 |\e[0m     \
    \   \e[34m// We can use a binary search to find the number of cars that are in\
    \ front\e[0m\n\e[31m23 |\e[0m        \e[34m// of the current car.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// We can use a binary search to find the number of cars\
    \ that are behind\e[0m\n\e[31m25 |\e[0m        \e[34m// the current car.\e[0m\n\
    \e[31m26 |\e[0m        \e[34m// We can use a binary search to find the number\
    \ of cars that are in front\e[0m\n\e[31m27 |\e[0m        \e[34m// of the current\
    \ car.\e[0m\n\e[31m28 |\e[0m        \e[34m// We can use a binary search to find\
    \ the number of cars that are behind\e[0m\n\e[31m29 |\e[0m        \e[34m// the\
    \ current car.\e[0m\n\e[31m30 |\e[0m        \e[34m// We can use a binary search\
    \ to find the number of cars that are in front\e[0m\n\e[31m31 |\e[0m        \e\
    [34m// of the current car.\e[0m\n\e[31m32 |\e[0m        \e[34m// We can u"
  stdout: ''
  timestamp: 1659792863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can think of the\
    \ cars as points on the real line.  The cars moving left to right\n        //\
    \ are at positions 1, 2, 3, ..., n.  The cars moving right to left are at positions\n\
    \        // -1, -2, -3, ..., -n.  The cars moving left to right are at positions\
    \ 1, 2, 3, ..., n.\n        // The cars moving right to left are at positions\
    \ -1, -2, -3, ..., -n.\n        // The cars moving left to right are at positions\
    \ 1, 2, 3, ..., n.\n        // The cars moving right to left are at positions\
    \ -1, -2, -3, ..., -n.\n        // The cars moving left to right are at positions\
    \ 1, 2, 3, ..., n.\n        // The cars moving right to left are at positions\
    \ -1, -2, -3, ..., -n.\n        // The cars moving left to right are at positions\
    \ 1, 2, 3, ..., n.\n        // The cars moving right to left are at positions\
    \ -1, -2, -3, ..., -n.\n        // The cars moving left to right are at positions\
    \ 1, 2, 3, ..., n.\n        // The cars moving right to left are at positions\
    \ -1, -2, -3, ..., -n.\n        // The cars moving left to right are at positions\
    \ 1, 2, 3, ..., n.\n        // The cars moving right to left are at positions\
    \ -1, -2, -3, ..., -n.\n        // The cars moving left to right are at positions\
    \ 1, 2, 3, ..., n.\n        // The cars moving right to left are at positions\
    \ -1, -2, -3, ..., -n.\n        // The cars moving left to right are at positions\
    \ 1, 2, 3, ..., n.\n        // The cars moving right to left are at positions\
    \ -1, -2, -3, ..., -n.\n        // The cars moving left to right are at positions\
    \ 1, 2, 3, ..., n.\n        // The cars moving right to left are at positions\
    \ -1, -2, -3, ..., -n.\n        // The cars moving left to right are at positions\
    \ 1, 2,\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcer0d3r0.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We can think of the cars as points on the real line.  The cars moving left\
    \ to right\e[0m\n\e[31m14 |\e[0m        \e[34m// are at positions 1, 2, 3, ...,\
    \ n.  The cars moving right to left are at positions\e[0m\n\e[31m15 |\e[0m   \
    \     \e[34m// -1, -2, -3, ..., -n.  The cars moving left to right are at positions\
    \ 1, 2, 3, ..., n.\e[0m\n\e[31m16 |\e[0m        \e[34m// The cars moving right\
    \ to left are at positions -1, -2, -3, ..., -n.\e[0m\n\e[31m17 |\e[0m        \e\
    [34m// The cars moving left to right are at positions 1, 2, 3, ..., n.\e[0m\n\e\
    [31m18 |\e[0m        \e[34m// The cars moving right to left are at positions -1,\
    \ -2, -3, ..., -n.\e[0m\n\e[31m19 |\e[0m        \e[34m// The cars moving left\
    \ to right are at positions 1, 2, 3, ..., n.\e[0m\n\e[31m20 |\e[0m        \e[34m//\
    \ The cars moving right to left are at positions -1, -2, -3, ..., -n.\e[0m\n\e\
    [31m21 |\e[0m        \e[34m// The cars moving left to right are at positions 1,\
    \ 2, 3, ..., n.\e[0m\n\e[31m22 |\e[0m        \e[34m// The cars moving right to\
    \ left are at positions -1, -2, -3, ..., -n.\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ The cars moving left to right are at positions 1, 2, 3, ..., n.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// The cars moving right to left are at positions -1, -2,\
    \ -3, ..., -n.\e[0m\n\e[31m25 |\e[0m        \e[34m// The cars moving left to right\
    \ are at positions 1, 2, 3, ..., n.\e[0m\n\e[31m26 |\e[0m        \e[34m// The\
    \ cars moving right to left are at positions -1, -2, -3, ..., -n.\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// The cars moving left to right are at positions 1, 2,\
    \ 3, ..., n.\e[0m\n\e[31m28 |\e[0m        \e[34m// The cars moving right to left\
    \ are at positions -1, -2, -3, ..., -"
  stdout: ''
  timestamp: 1659792864
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just count the\
    \ number of collisions by counting the number of pairs\n        // of cars that\
    \ start in the same position.\n        // The number of such pairs is n * (n -\
    \ 1) / 2.\n        // However, we have to be careful because the cars are infinitely\
    \ strong.\n        // If two cars start in the same position, they will collide\
    \ infinitely many times.\n        // So, we have to divide by 2.\n        n *\
    \ (n - 1) / 4\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyf5k00ea.scala:23)\n\tat Problem.main(tmpyf5k00ea.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792864
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the left-to-right cars and the right-to-left cars by their\n        // starting\
    \ positions.  Then, we can iterate through the left-to-right cars and\n      \
    \  // the right-to-left cars simultaneously.  If the left-to-right car is to the\
    \ left\n        // of the right-to-left car, then there is no collision.  Otherwise,\
    \ there is a collision.\n        // The number of collisions is the number of\
    \ times we find a collision.\n        // The time complexity is O(n log n) because\
    \ we need to sort the cars.\n        val leftToRightCars = (0 until n.toInt).map(i\
    \ => (i, i)).toList\n        val rightToLeftCars = (0 until n.toInt).map(i =>\
    \ (i, -i)).toList\n        val sortedLeftToRightCars = leftToRightCars.sortBy(_._2)\n\
    \        val sortedRightToLeftCars = rightToLeftCars.sortBy(_._2)\n        var\
    \ collisions = 0\n        var i = 0\n        var j = 0\n        while (i < n.toInt\
    \ && j < n.toInt) {\n            if (sortedLeftToRightCars(i)._2 < sortedRightToLeftCars(j)._2)\
    \ i += 1\n            else {\n                collisions += 1\n              \
    \  i += 1\n                j += 1\n            }\n        }\n        collisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0ae3ii1f.scala:37)\n\tat Problem.main(tmp0ae3ii1f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just count the\
    \ number of cars that are moving in the same direction.\n        // For example,\
    \ if we have the following cars:\n        // (1, left), (2, left), (3, right),\
    \ (4, right), (5, right), (6, left)\n        // Then, we can see that there are\
    \ 2 collisions.\n        // This is because the cars at positions 1 and 2 are\
    \ moving left, and the cars at positions 3, 4, and 5 are moving right.\n     \
    \   // The car at position 6 is moving left, but it doesn't collide with any car\
    \ since it's the last car.\n        // We can see that the number of collisions\
    \ is the number of cars that are moving in the same direction.\n        // In\
    \ this case, there are 3 cars moving right, and 2 cars moving left.\n        //\
    \ The number of collisions is the minimum of these two numbers.\n        // The\
    \ number of cars moving right is the number of cars that are moving right and\
    \ have a smaller starting position.\n        // The number of cars moving left\
    \ is the number of cars that are moving left and have a larger starting position.\n\
    \        // We can use binary search to find the number of cars that are moving\
    \ right and have a smaller starting position.\n        // We can use binary search\
    \ to find the number of cars that are moving left and have a larger starting position.\n\
    \        // We can use binary search to find the number of cars that are moving\
    \ right and have a smaller starting position.\n        // We can use binary search\
    \ to find the number of cars that are moving left and have a larger starting position.\n\
    \        // We can use binary search to find the number of cars that are moving\
    \ right and have a smaller starting position.\n        // We can use binary search\
    \ to find the number of cars that are moving left and have a larger starting position.\n\
    \        // We can use binary search to find the number of cars that are moving\
    \ right and have a smaller starting position.\n        // We can use binary search\
    \ to find the number of cars that are moving left and have a larger starting position.\n\
    \        // We can use binary search to find the number of cars that are moving\
    \ right and have a smaller starting position.\n        // We can use binary search\
    \ to find the number of cars that are moving left and have a larger starting\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi1tyh4ac.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can just count the number of cars that are moving\
    \ in the same direction.\e[0m\n\e[31m15 |\e[0m        \e[34m// For example, if\
    \ we have the following cars:\e[0m\n\e[31m16 |\e[0m        \e[34m// (1, left),\
    \ (2, left), (3, right), (4, right), (5, right), (6, left)\e[0m\n\e[31m17 |\e\
    [0m        \e[34m// Then, we can see that there are 2 collisions.\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// This is because the cars at positions 1 and 2 are moving\
    \ left, and the cars at positions 3, 4, and 5 are moving right.\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// The car at position 6 is moving left, but it doesn't\
    \ collide with any car since it's the last car.\e[0m\n\e[31m20 |\e[0m        \e\
    [34m// We can see that the number of collisions is the number of cars that are\
    \ moving in the same direction.\e[0m\n\e[31m21 |\e[0m        \e[34m// In this\
    \ case, there are 3 cars moving right, and 2 cars moving left.\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// The number of collisions is the minimum of these two\
    \ numbers.\e[0m\n\e[31m23 |\e[0m        \e[34m// The number of cars moving right\
    \ is the number of cars that are moving right and have a smaller starting position.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// The number of cars moving left is the number\
    \ of cars that are moving left and have a larger starting position.\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// We can use binary search to find the number of cars that\
    \ are moving right and have a smaller starting position.\e[0m\n\e[31m26 |\e[0m\
    \        \e[34m// We can use binary search to find the number of cars that are\
    \ moving left and have a larger"
  stdout: ''
  timestamp: 1659792865
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can simulate the race\
    \ by moving the cars one by one.\n        // If a car moves left to right, we\
    \ can check if it collides with any\n        // car that moves right to left.\
    \  If a car moves right to left, we can\n        // check if it collides with\
    \ any car that moves left to right.\n        // This is O(n^2) time.\n       \
    \ // We can improve this to O(n log n) time by using a priority queue.\n     \
    \   // We can use a priority queue to store the cars that move left to right.\n\
    \        // We can use a priority queue to store the cars that move right to left.\n\
    \        // We can then simulate the race by moving the cars one by one.\n   \
    \     // If a car moves left to right, we can check if it collides with any\n\
    \        // car that moves right to left.  If a car moves right to left, we can\n\
    \        // check if it collides with any car that moves left to right.\n    \
    \    // This is O(n log n) time.\n        // We can improve this to O(n) time\
    \ by using a stack.\n        // We can use a stack to store the cars that move\
    \ left to right.\n        // We can use a stack to store the cars that move right\
    \ to left.\n        // We can then simulate the race by moving the cars one by\
    \ one.\n        // If a car moves left to right, we can check if it collides with\
    \ any\n        // car that moves right to left.  If a car moves right to left,\
    \ we can\n        // check if it collides with any car that moves left to right.\n\
    \        // This is O(n) time.\n        // We can improve this to O(1) time by\
    \ using a formula.\n        // We can use a formula to calculate the number of\
    \ collisions.\n        // This is O(1) time.\n        // We can improve this to\
    \ O(1) time by using a formula.\n        // We can use a formula to calculate\
    \ the number of collisions.\n        // This is O(1) time.\n        // We can\
    \ improve this to O(1) time by using a formula.\n        // We can use a formula\
    \ to calculate the number of collisions.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2degglhv.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can simulate the race by moving the cars one\
    \ by one.\e[0m\n\e[31m15 |\e[0m        \e[34m// If a car moves left to right,\
    \ we can check if it collides with any\e[0m\n\e[31m16 |\e[0m        \e[34m// car\
    \ that moves right to left.  If a car moves right to left, we can\e[0m\n\e[31m17\
    \ |\e[0m        \e[34m// check if it collides with any car that moves left to\
    \ right.\e[0m\n\e[31m18 |\e[0m        \e[34m// This is O(n^2) time.\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// We can improve this to O(n log n) time by using a priority\
    \ queue.\e[0m\n\e[31m20 |\e[0m        \e[34m// We can use a priority queue to\
    \ store the cars that move left to right.\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ We can use a priority queue to store the cars that move right to left.\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// We can then simulate the race by moving the cars\
    \ one by one.\e[0m\n\e[31m23 |\e[0m        \e[34m// If a car moves left to right,\
    \ we can check if it collides with any\e[0m\n\e[31m24 |\e[0m        \e[34m// car\
    \ that moves right to left.  If a car moves right to left, we can\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// check if it collides with any car that moves left to\
    \ right.\e[0m\n\e[31m26 |\e[0m        \e[34m// This is O(n log n) time.\e[0m\n\
    \e[31m27 |\e[0m        \e[34m// We can improve this to O(n) time by using a stack.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// We can use a stack to store the cars that\
    \ move left to right.\e[0m\n\e[31m29 |\e[0m        \e[34m// We can use a stack\
    \ to store the cars that move right to left.\e[0m\n\e[31m30 |\e[0m        \e[34m//\
    \ We can then simulate the race by moving the "
  stdout: ''
  timestamp: 1659792866
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a simple problem,\
    \ but it's a good example of how to use the\n        // Scala collection library.\n\
    \        // The idea is to use a priority queue to keep track of the cars.\n \
    \       // The priority queue is ordered by the position of the cars.\n      \
    \  // The cars are represented as a pair (x, y) where x is the position of the\
    \ car\n        // and y is the direction of the car.  If y is 1, the car is moving\
    \ left to right.\n        // If y is -1, the car is moving right to left.\n  \
    \      // The priority queue is ordered by the x coordinate.\n        // We start\
    \ by putting all the left to right cars in the priority queue.\n        // Then\
    \ we start removing the cars from the priority queue.  For each car, we\n    \
    \    // check if there are any right to left cars that are in front of it.  If\
    \ so,\n        // we increment the number of collisions.  We then add the car\
    \ to the priority queue\n        // if it's a right to left car.\n        // The\
    \ time complexity is O(n log n) since we do n insertions and n deletions\n   \
    \     // from the priority queue.\n        val pq = new PriorityQueue[(Long, Int)]()(Ordering.by((_\
    \ : (Long, Int))._1))\n        for (i <- 0L until n) pq.enqueue((i, 1))\n    \
    \    var collisions = 0L\n        while (!pq.isEmpty) {\n            val (x, y)\
    \ = pq.dequeue\n            if (y == -1) collisions += pq.size\n            else\
    \ pq.enqueue((x, -1))\n        }\n        collisions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc0c2e5as.scala:39)\n\tat Problem.main(tmpc0c2e5as.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can solve it by sorting the cars\n        // by their starting\
    \ position.  Then, we can just iterate through the cars\n        // and count\
    \ the number of collisions.\n        // The time complexity is O(n log n).\n \
    \       val cars = Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt)\
    \ cars(i) = i\n        val sortedCars = cars.sortWith(_ < _)\n        var collisions\
    \ = 0L\n        for (i <- 0 until n.toInt) {\n            if (sortedCars(i) >\
    \ i) collisions += sortedCars(i) - i\n        }\n        collisions\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ejgwwie.scala:27)\n\tat Problem.main(tmp2ejgwwie.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792867
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val cars = new Array[Long](n.toInt)\n\
    \        for (i <- 0 until n.toInt) cars(i) = i\n        cars.sortWith(_ < _)\n\
    \        var collisions = 0L\n        for (i <- 0 until n.toInt) {\n         \
    \   collisions += cars(i) - i\n        }\n        collisions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt7dxkjgc.scala:23)\n\tat Problem.main(tmpt7dxkjgc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // The cars that start out on\
    \ the left will be sorted in ascending order,\n        // and the cars that start\
    \ out on the right will be sorted in descending order.\n        // Then, we can\
    \ just iterate through the sorted list and count the number of collisions.\n \
    \       // The time complexity is O(n log n).\n        val leftCars = (1 to n.toInt).map(i\
    \ => (i, 1)).toList\n        val rightCars = (1 to n.toInt).map(i => (i, -1)).toList\n\
    \        val cars = (leftCars ::: rightCars).sortBy(x => x._1)\n        var collisions\
    \ = 0\n        for (i <- 0 until cars.length - 1) {\n            if (cars(i)._2\
    \ == 1 && cars(i + 1)._2 == -1) collisions += 1\n        }\n        collisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuqv2_3ix.scala:28)\n\tat Problem.main(tmpuqv2_3ix.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792869
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can solve this problem\
    \ by considering the cars as points on a number line.\n        // The left-to-right\
    \ cars are at positions 1, 2, 3, ..., n.\n        // The right-to-left cars are\
    \ at positions -1, -2, -3, ..., -n.\n        // The cars are moving at a speed\
    \ of 1.\n        // The cars are infinitely strong and sturdy.\n        // The\
    \ cars are infinitely long.\n        // The cars are infinitely thin.\n      \
    \  // The cars are infinitely wide.\n        // The cars are infinitely tall.\n\
    \        // The cars are infinitely heavy.\n        // The cars are infinitely\
    \ light.\n        // The cars are infinitely fast.\n        // The cars are infinitely\
    \ slow.\n        // The cars are infinitely big.\n        // The cars are infinitely\
    \ small.\n        // The cars are infinitely large.\n        // The cars are infinitely\
    \ tiny.\n        // The cars are infinitely huge.\n        // The cars are infinitely\
    \ minuscule.\n        // The cars are infinitely massive.\n        // The cars\
    \ are infinitely miniscule.\n        // The cars are infinitely minute.\n    \
    \    // The cars are infinitely minuscule.\n        // The cars are infinitely\
    \ minutest.\n        // The cars are infinitely minuscule.\n        // The cars\
    \ are infinitely minutest.\n        // The cars are infinitely minuscule.\n  \
    \      // The cars are infinitely minutest.\n        // The cars are infinitely\
    \ minuscule.\n        // The cars are infinitely minutest.\n        // The cars\
    \ are infinitely minuscule.\n        // The cars are infinitely minutest.\n  \
    \      // The cars are infinitely minuscule.\n        // The cars are infinitely\
    \ minutest.\n        // The cars are infinitely minuscule.\n        // The cars\
    \ are infinitely minutest.\n        // The cars are infinitely minuscule.\n  \
    \      // The cars are infinitely minutest.\n        // The cars are infinitely\
    \ minuscule.\n        // The cars are infinitely minutest.\n        // The cars\
    \ are infinitely minuscule.\n        // The cars are infinitely minutest.\n  \
    \      // The cars are infinitely minuscule.\n        // The cars are infinitely\
    \ minutest.\n        // The cars are infinitely minuscule.\n        // The cars\
    \ are infinitely minut\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp88ugke4x.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We can solve this problem by considering the cars as points on a number\
    \ line.\e[0m\n\e[31m14 |\e[0m        \e[34m// The left-to-right cars are at positions\
    \ 1, 2, 3, ..., n.\e[0m\n\e[31m15 |\e[0m        \e[34m// The right-to-left cars\
    \ are at positions -1, -2, -3, ..., -n.\e[0m\n\e[31m16 |\e[0m        \e[34m//\
    \ The cars are moving at a speed of 1.\e[0m\n\e[31m17 |\e[0m        \e[34m// The\
    \ cars are infinitely strong and sturdy.\e[0m\n\e[31m18 |\e[0m        \e[34m//\
    \ The cars are infinitely long.\e[0m\n\e[31m19 |\e[0m        \e[34m// The cars\
    \ are infinitely thin.\e[0m\n\e[31m20 |\e[0m        \e[34m// The cars are infinitely\
    \ wide.\e[0m\n\e[31m21 |\e[0m        \e[34m// The cars are infinitely tall.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// The cars are infinitely heavy.\e[0m\n\e[31m23\
    \ |\e[0m        \e[34m// The cars are infinitely light.\e[0m\n\e[31m24 |\e[0m\
    \        \e[34m// The cars are infinitely fast.\e[0m\n\e[31m25 |\e[0m        \e\
    [34m// The cars are infinitely slow.\e[0m\n\e[31m26 |\e[0m        \e[34m// The\
    \ cars are infinitely big.\e[0m\n\e[31m27 |\e[0m        \e[34m// The cars are\
    \ infinitely small.\e[0m\n\e[31m28 |\e[0m        \e[34m// The cars are infinitely\
    \ large.\e[0m\n\e[31m29 |\e[0m        \e[34m// The cars are infinitely tiny.\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// The cars are infinitely huge.\e[0m\n\e[31m31\
    \ |\e[0m        \e[34m// The cars are infinitely minuscule.\e[0m\n\e[31m32 |\e\
    [0m        \e[34m// The cars are infinitely massive.\e[0m\n\e[31m33 |\e[0m   \
    \     \e[34m// The cars are infinitely miniscule.\e[0m\n\e[31m34 |\e[0m      \
    \  \e[34m// The cars are infinitely minute.\e[0m\n\e[31m35 |\e[0m        \e[34m//\
    \ The cars are infinitely minuscule.\e[0m\n\e[31m36 |\e[0m        \e[34m// The\
    \ ca"
  stdout: ''
  timestamp: 1659792867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say that the\
    \ cars moving left to right are numbered 1 to n, and the cars\n        // moving\
    \ right to left are numbered n + 1 to 2n.\n        // Let's say that the cars\
    \ moving left to right are numbered 1 to n, and the cars\n        // moving right\
    \ to left are numbered n + 1 to 2n.\n        // Let's say that the cars moving\
    \ left to right are numbered 1 to n, and the cars\n        // moving right to\
    \ left are numbered n + 1 to 2n.\n        // Let's say that the cars moving left\
    \ to right are numbered 1 to n, and the cars\n        // moving right to left\
    \ are numbered n + 1 to 2n.\n        // Let's say that the cars moving left to\
    \ right are numbered 1 to n, and the cars\n        // moving right to left are\
    \ numbered n + 1 to 2n.\n        // Let's say that the cars moving left to right\
    \ are numbered 1 to n, and the cars\n        // moving right to left are numbered\
    \ n + 1 to 2n.\n        // Let's say that the cars moving left to right are numbered\
    \ 1 to n, and the cars\n        // moving right to left are numbered n + 1 to\
    \ 2n.\n        // Let's say that the cars moving left to right are numbered 1\
    \ to n, and the cars\n        // moving right to left are numbered n + 1 to 2n.\n\
    \        // Let's say that the cars moving left to right are numbered 1 to n,\
    \ and the cars\n        // moving right to left are numbered n + 1 to 2n.\n  \
    \      // Let's say that the cars moving left to right are numbered 1 to n, and\
    \ the cars\n        // moving right to left are numbered n + 1 to 2n.\n      \
    \  // Let's say that the cars moving left to right are numbered 1 to n, and the\
    \ cars\n        // moving right to left are numbered n + 1 to 2n.\n        //\
    \ Let's say that the cars moving left to right are numbered 1 to n, and the cars\n\
    \        // moving right to left are numbered n + 1 to 2n.\n        // Let's say\
    \ that the cars moving left to right are numbered 1 to n, and the cars\n     \
    \   // moving right to left are numbered n + 1 to 2n.\n        // Let's say that\
    \ the cars moving left to right are numbered 1 to n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7mx2ekxh.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say that the cars moving left to right are numbered 1 to n, and the\
    \ cars\e[0m\n\e[31m14 |\e[0m        \e[34m// moving right to left are numbered\
    \ n + 1 to 2n.\e[0m\n\e[31m15 |\e[0m        \e[34m// Let's say that the cars moving\
    \ left to right are numbered 1 to n, and the cars\e[0m\n\e[31m16 |\e[0m      \
    \  \e[34m// moving right to left are numbered n + 1 to 2n.\e[0m\n\e[31m17 |\e\
    [0m        \e[34m// Let's say that the cars moving left to right are numbered\
    \ 1 to n, and the cars\e[0m\n\e[31m18 |\e[0m        \e[34m// moving right to left\
    \ are numbered n + 1 to 2n.\e[0m\n\e[31m19 |\e[0m        \e[34m// Let's say that\
    \ the cars moving left to right are numbered 1 to n, and the cars\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// moving right to left are numbered n + 1 to 2n.\e[0m\n\
    \e[31m21 |\e[0m        \e[34m// Let's say that the cars moving left to right are\
    \ numbered 1 to n, and the cars\e[0m\n\e[31m22 |\e[0m        \e[34m// moving right\
    \ to left are numbered n + 1 to 2n.\e[0m\n\e[31m23 |\e[0m        \e[34m// Let's\
    \ say that the cars moving left to right are numbered 1 to n, and the cars\e[0m\n\
    \e[31m24 |\e[0m        \e[34m// moving right to left are numbered n + 1 to 2n.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// Let's say that the cars moving left to right\
    \ are numbered 1 to n, and the cars\e[0m\n\e[31m26 |\e[0m        \e[34m// moving\
    \ right to left are numbered n + 1 to 2n.\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ Let's say that the cars moving left to right are numbered 1 to n, and the cars\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// moving right to left are numbered n + 1 to\
    \ 2n.\e[0m\n\e[31m29 |\e[0m        \e[34m// Let's say that the cars moving left\
    \ to right are numbered 1 to n, an"
  stdout: ''
  timestamp: 1659792867
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can use a sweep line\
    \ algorithm.\n        // We start at the leftmost car.  We keep moving right until\
    \ we hit the first car\n        // that's moving right to left.  We then move\
    \ right until we hit the next car\n        // that's moving left to right.  We\
    \ keep doing this until we reach the rightmost car.\n        // The number of\
    \ collisions is the number of times we move right to left.\n        // The time\
    \ complexity is O(n log n) because of the sorting.\n        val leftToRight =\
    \ new Array[Long](n.toInt)\n        val rightToLeft = new Array[Long](n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            leftToRight(i) = i\n      \
    \      rightToLeft(i) = n - 1 - i\n        }\n        leftToRight.sortInPlace\n\
    \        rightToLeft.sortInPlace\n        var collisions = 0\n        var i =\
    \ 0\n        var j = 0\n        while (i < n.toInt && j < n.toInt) {\n       \
    \     if (leftToRight(i) < rightToLeft(j)) {\n                i += 1\n       \
    \     } else {\n                collisions += 1\n                j += 1\n    \
    \        }\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxb4ay6vk.scala:42)\n\tat Problem.main(tmpxb4ay6vk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792870
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their position.  The cars that are moving left to right\n      \
    \  // will be sorted in increasing order; the cars that are moving right to left\
    \ will be sorted\n        // in decreasing order.  Then we can just go through\
    \ the sorted list and count the number of\n        // collisions.\n        //\
    \ The time complexity is O(n log n).\n        val cars = new Array[Long](2 * n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = i + 1\n         \
    \   cars(i + n.toInt) = -(i + 1)\n        }\n        val sortedCars = cars.sorted\n\
    \        var collisions = 0L\n        for (i <- 0 until 2 * n.toInt - 1) {\n \
    \           if (sortedCars(i) > 0 && sortedCars(i + 1) < 0) collisions += 1\n\
    \        }\n        collisions\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0fxwd2dd.scala:31)\n\tat Problem.main(tmp0fxwd2dd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792869
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is that we\
    \ can use a sweep line algorithm.\n        // We will use a set to keep track\
    \ of the cars that are moving right to left.\n        // We will use a priority\
    \ queue to keep track of the cars that are moving left to right.\n        // The\
    \ priority queue will be sorted by the car's position.\n        // We will use\
    \ a sweep line that moves from left to right.\n        // When the sweep line\
    \ encounters a car that's moving left to right, we will add it to the priority\
    \ queue.\n        // When the sweep line encounters a car that's moving right\
    \ to left, we will add it to the set.\n        // When the sweep line encounters\
    \ a car that's moving left to right, we will remove it from the priority queue.\n\
    \        // When the sweep line encounters a car that's moving right to left,\
    \ we will remove it from the set.\n        // When the sweep line encounters a\
    \ car that's moving left to right, we will check if there is a car that's moving\
    \ right to left\n        // that's within the same position.  If so, we will increment\
    \ the number of collisions.\n        // We will continue this process until the\
    \ priority queue is empty.\n        // The time complexity is O(n log n) because\
    \ we will have to sort the cars that are moving left to right.\n        // The\
    \ space complexity is O(n) because we will have to store all the cars that are\
    \ moving right to left.\n        val leftToRight = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        val rightToLeft = new HashSet[Long]()\n        var collisions = 0L\n\
    \        for (i <- 1L to n) {\n            leftToRight.enqueue(i)\n          \
    \  rightToLeft.add(n + i)\n        }\n        while (!leftToRight.isEmpty) {\n\
    \            val car = leftToRight.dequeue\n            if (rightToLeft.contains(car))\
    \ collisions += 1\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkwgal37y.scala:41)\n\tat Problem.main(tmpkwgal37y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792871
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their position.  Then, we can iterate through the\n        // cars\
    \ and count the number of cars that are moving in the opposite direction.\n  \
    \      // For example, if the cars are at positions [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10],\n        // and the cars are moving at speeds [1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10], then the\n        // cars that are moving in the opposite direction\
    \ are at positions [1, 3, 6, 10].\n        // Thus, the number of collisions is\
    \ 4.\n        //\n        // The key observation is that the number of collisions\
    \ is the same as the number\n        // of inversions in the array of positions.\
    \  The number of inversions can be computed\n        // in O(n log n) time using\
    \ a merge sort.\n        //\n        // The number of inversions is also equal\
    \ to the number of pairs of cars that are\n        // moving in the opposite direction.\
    \  This is because each pair of cars that are\n        // moving in the opposite\
    \ direction contributes one inversion.\n        //\n        // Thus, the number\
    \ of collisions is equal to the number of pairs of cars that are\n        // moving\
    \ in the opposite direction.\n        //\n        // The number of pairs of cars\
    \ that are moving in the opposite direction is equal to\n        // the number\
    \ of pairs of cars that are moving in the same direction.  This is because\n \
    \       // there are n cars moving in each direction.\n        //\n        //\
    \ The number of pairs of cars that are moving in the same direction is equal to\n\
    \        // n * (n - 1) / 2.\n        n * (n - 1) / 2\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkr2akrix.scala:40)\n\tat Problem.main(tmpkr2akrix.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the left-to-right\
    \ cars are at positions x1, x2, ..., xn.\n        // Let's say the right-to-left\
    \ cars are at positions y1, y2, ..., yn.\n        // We want to find the number\
    \ of pairs (i, j) such that xi > yj.\n        // This is equal to the number of\
    \ pairs (i, j) such that yj < xi.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi - yj > 0.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi - yj > 0.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi - yj > 0.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi - yj > 0.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi - yj > 0.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi - yj > 0.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi - yj > 0.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi - yj > 0.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi - yj > 0.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi - yj > 0.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi - yj > 0.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi - yj > 0.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi - yj > 0.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi - yj > 0.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi - yj > 0.\n        // This is equal to the number of pairs\
    \ (i, j) such that xi\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg6fnxx0o.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say the left-to-right cars are at positions x1, x2, ..., xn.\e[0m\n\
    \e[31m14 |\e[0m        \e[34m// Let's say the right-to-left cars are at positions\
    \ y1, y2, ..., yn.\e[0m\n\e[31m15 |\e[0m        \e[34m// We want to find the number\
    \ of pairs (i, j) such that xi > yj.\e[0m\n\e[31m16 |\e[0m        \e[34m// This\
    \ is equal to the number of pairs (i, j) such that yj < xi.\e[0m\n\e[31m17 |\e\
    [0m        \e[34m// This is equal to the number of pairs (i, j) such that xi -\
    \ yj > 0.\e[0m\n\e[31m18 |\e[0m        \e[34m// This is equal to the number of\
    \ pairs (i, j) such that xi - yj > 0.\e[0m\n\e[31m19 |\e[0m        \e[34m// This\
    \ is equal to the number of pairs (i, j) such that xi - yj > 0.\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// This is equal to the number of pairs (i, j) such that\
    \ xi - yj > 0.\e[0m\n\e[31m21 |\e[0m        \e[34m// This is equal to the number\
    \ of pairs (i, j) such that xi - yj > 0.\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ This is equal to the number of pairs (i, j) such that xi - yj > 0.\e[0m\n\e\
    [31m23 |\e[0m        \e[34m// This is equal to the number of pairs (i, j) such\
    \ that xi - yj > 0.\e[0m\n\e[31m24 |\e[0m        \e[34m// This is equal to the\
    \ number of pairs (i, j) such that xi - yj > 0.\e[0m\n\e[31m25 |\e[0m        \e\
    [34m// This is equal to the number of pairs (i, j) such that xi - yj > 0.\e[0m\n\
    \e[31m26 |\e[0m        \e[34m// This is equal to the number of pairs (i, j) such\
    \ that xi - yj > 0.\e[0m\n\e[31m27 |\e[0m        \e[34m// This is equal to the\
    \ number of pairs (i, j) such that xi - yj > 0.\e[0m\n\e[31m28 |\e[0m        \e\
    [34m// This is equal to the number of pairs (i, j) such that xi - yj > 0.\e[0m\n\
    \e[31m29 |\e[0m        \e[34m// This is equal"
  stdout: ''
  timestamp: 1659792868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their position.  Then, we can just iterate through\n        // the\
    \ sorted list and count the number of cars that are moving in the opposite direction.\n\
    \        // The time complexity is O(n log n).\n        var cars = ArrayBuffer[(Long,\
    \ Boolean)]()\n        for (i <- 1 to n.toInt) {\n            cars += ((i, true))\n\
    \            cars += ((i, false))\n        }\n        cars = cars.sortWith((a,\
    \ b) => a._1 < b._1)\n        var count = 0L\n        for (i <- 0 until cars.length)\
    \ {\n            if (cars(i)._2) count += cars.length - i - 1\n        }\n   \
    \     count\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The key observation\
    \ is that the number of collisions is the same as the number of\n        // inversions\
    \ in the array of n integers.  The reason is that if the ith car from the left\n\
    \        // collides with the jth car from the right, then the ith car from the\
    \ left must be\n        // greater than the jth car from the right.\n        //\
    \ The number of inversions in an array of n integers can be computed in O(n log\
    \ n) time\n        // using a divide-and-conquer algorithm.\n        // The number\
    \ of inversions in an array of n integers can also be computed in O(n^2) time\n\
    \        // using a brute-force algorithm.\n        // The brute-force algorithm\
    \ is implemented below.\n        var count = 0L\n        for (i <- 1 to n.toInt)\
    \ {\n            for (j <- 1 to n.toInt) {\n                if (i > j) count +=\
    \ 1\n            }\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdigek4t9.scala:31)\n\tat Problem.main(tmpdigek4t9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 1 to n.\n        // The cars moving left to right are numbered from 1 to\
    \ n.\n        // The cars moving right to left are numbered from n to 1.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpin9sq8g4.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 1 to n.\e[0m\n\e[31m14 |\e[0m        \e[34m//\
    \ The cars moving left to right are numbered from 1 to n.\e[0m\n\e[31m15 |\e[0m\
    \        \e[34m// The cars moving right to left are numbered from n to 1.\e[0m\n\
    \e[31m16 |\e[0m        \e[34m// The cars moving left to right are at positions\
    \ x1, x2, ..., xn.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars moving right\
    \ to left are at positions y1, y2, ..., yn.\e[0m\n\e[31m18 |\e[0m        \e[34m//\
    \ The cars moving left to right are at positions x1, x2, ..., xn.\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// The cars moving right to left are at positions y1, y2,\
    \ ..., yn.\e[0m\n\e[31m20 |\e[0m        \e[34m// The cars moving left to right\
    \ are at positions x1, x2, ..., xn.\e[0m\n\e[31m21 |\e[0m        \e[34m// The\
    \ cars moving right to left are at positions y1, y2, ..., yn.\e[0m\n\e[31m22 |\e\
    [0m        \e[34m// The cars moving left to right are at positions x1, x2, ...,\
    \ xn.\e[0m\n\e[31m23 |\e[0m        \e[34m// The cars moving right to left are\
    \ at positions y1, y2, ..., yn.\e[0m\n\e[31m24 |\e[0m        \e[34m// The cars\
    \ moving left to right are at positions x1, x2, ..., xn.\e[0m\n\e[31m25 |\e[0m\
    \        \e[34m// The cars moving right to left are at positions y1, y2, ...,\
    \ yn.\e[0m\n\e[31m26 |\e[0m        \e[34m// The cars moving left to right are\
    \ at positions x1, x2, ..., xn.\e[0m\n\e[31m27 |\e[0m        \e[34m// The cars\
    \ moving right to left are at positions y1, y2, ..., yn.\e[0m\n\e[31m28 |\e[0m\
    \        \e[34m// The cars moving left to right are at positions x1, x2, ...,\
    \ xn.\e[0m\n\e[31m29 |\e[0m        \e[34m// The cars moving right to left are\
    \ at positions y1, y2, ..., yn.\e[0m\n\e[31m30 |\e[0m        \e[34m// "
  stdout: ''
  timestamp: 1659792738
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.\n        // We will use a set of points to represent\
    \ the cars.\n        // Each car is represented by a point (x, y), where x is\
    \ the position of the car\n        // and y is the direction of the car.  If y\
    \ is positive, the car is moving right to left.\n        // If y is negative,\
    \ the car is moving left to right.\n        // We will sort the points by x.\n\
    \        // We will then sweep the line from left to right.\n        // When we\
    \ sweep a point, we will add it to the set.\n        // When we sweep a point,\
    \ we will remove it from the set.\n        // When we sweep a point, we will count\
    \ the number of points in the set that have the same x value.\n        // The\
    \ number of points in the set that have the same x value is the number of collisions.\n\
    \        // We will add the number of collisions to the total number of collisions.\n\
    \        // The total number of collisions is the output.\n        val points\
    \ = new Array[(Long, Long)](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n\
    \            points(i) = (i.toLong, 1)\n            points(i + n.toInt) = (i.toLong,\
    \ -1)\n        }\n        val sortedPoints = points.sortWith((a, b) => a._1 <\
    \ b._1)\n        var collisions = 0\n        val set = new TreeSet[(Long, Long)]()(Ordering.by((a\
    \ : (Long, Long)) => a._1))\n        for (point <- sortedPoints) {\n         \
    \   if (point._2 == 1) {\n                set.add(point)\n                collisions\
    \ += set.count(_._1 == point._1)\n            } else {\n                set.remove(point)\n\
    \            }\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp__cuphur.scala:45)\n\tat Problem.main(tmp__cuphur.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792874
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just count the\
    \ number of cars that are moving left to right\n        // that are to the left\
    \ of a car that's moving right to left.\n        // This is the same as the number\
    \ of cars that are moving right to left\n        // that are to the right of a\
    \ car that's moving left to right.\n        // This is the same as the number\
    \ of cars that are moving right to left\n        // that are to the left of a\
    \ car that's moving left to right.\n        // This is the same as the number\
    \ of cars that are moving left to right\n        // that are to the right of a\
    \ car that's moving right to left.\n        // This is the same as the number\
    \ of cars that are moving left to right\n        // that are to the left of a\
    \ car that's moving right to left.\n        // This is the same as the number\
    \ of cars that are moving right to left\n        // that are to the right of a\
    \ car that's moving left to right.\n        // This is the same as the number\
    \ of cars that are moving right to left\n        // that are to the left of a\
    \ car that's moving left to right.\n        // This is the same as the number\
    \ of cars that are moving left to right\n        // that are to the right of a\
    \ car that's moving right to left.\n        // This is the same as the number\
    \ of cars that are moving left to right\n        // that are to the left of a\
    \ car that's moving right to left.\n        // This is the same as the number\
    \ of cars that are moving right to left\n        // that are to the right of a\
    \ car that's moving left to right.\n        // This is the same as the number\
    \ of cars that are moving right to left\n        // that are to the left of a\
    \ car that's moving left to right.\n        // This is the same as the number\
    \ of cars that are moving left to right\n        // that are to the right of a\
    \ car that's moving right to left.\n        // This is the same as the number\
    \ of cars that are moving left to right\n        // that are to the left of a\
    \ car that's moving right to left.\n        // This is the same as the number\
    \ of cars that are moving right to left\n        // that are to the right of a\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjgu0fv_1.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can just count the number of cars that are moving\
    \ left to right\e[0m\n\e[31m15 |\e[0m        \e[34m// that are to the left of\
    \ a car that's moving right to left.\e[0m\n\e[31m16 |\e[0m        \e[34m// This\
    \ is the same as the number of cars that are moving right to left\e[0m\n\e[31m17\
    \ |\e[0m        \e[34m// that are to the right of a car that's moving left to\
    \ right.\e[0m\n\e[31m18 |\e[0m        \e[34m// This is the same as the number\
    \ of cars that are moving right to left\e[0m\n\e[31m19 |\e[0m        \e[34m//\
    \ that are to the left of a car that's moving left to right.\e[0m\n\e[31m20 |\e\
    [0m        \e[34m// This is the same as the number of cars that are moving left\
    \ to right\e[0m\n\e[31m21 |\e[0m        \e[34m// that are to the right of a car\
    \ that's moving right to left.\e[0m\n\e[31m22 |\e[0m        \e[34m// This is the\
    \ same as the number of cars that are moving left to right\e[0m\n\e[31m23 |\e\
    [0m        \e[34m// that are to the left of a car that's moving right to left.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// This is the same as the number of cars that\
    \ are moving right to left\e[0m\n\e[31m25 |\e[0m        \e[34m// that are to the\
    \ right of a car that's moving left to right.\e[0m\n\e[31m26 |\e[0m        \e\
    [34m// This is the same as the number of cars that are moving right to left\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// that are to the left of a car that's moving\
    \ left to right.\e[0m\n\e[31m28 |\e[0m        \e[34m// This is the same as the\
    \ number of cars that are moving left to right\e[0m\n\e[31m29 |\e[0m        \e\
    [34m// that are to the right of a car that's moving ri"
  stdout: ''
  timestamp: 1659792872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars and count the number of collisions.\n        // The number of collisions\
    \ is the number of cars that are moving left to right\n        // and have a car\
    \ moving right to left to their left.\n        // The time complexity is O(n log\
    \ n) because of the sorting.\n        // The space complexity is O(n) because\
    \ of the sorting.\n        val leftToRight = new Array[Long](n.toInt)\n      \
    \  val rightToLeft = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            leftToRight(i) = i\n            rightToLeft(i) = n - 1 - i\n\
    \        }\n        leftToRight.sortInPlaceWith((a, b) => a < b)\n        rightToLeft.sortInPlaceWith((a,\
    \ b) => a < b)\n        var count = 0\n        var i = 0\n        var j = 0\n\
    \        while (i < n.toInt && j < n.toInt) {\n            if (leftToRight(i)\
    \ < rightToLeft(j)) {\n                count += j\n                i += 1\n  \
    \          } else {\n                j += 1\n            }\n        }\n      \
    \  count\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqjvtu7dq.scala:41)\n\tat Problem.main(tmpqjvtu7dq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792875
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say that the\
    \ left-to-right cars are indexed from 0 to n-1, and the\n        // right-to-left\
    \ cars are indexed from n to 2n-1.\n        // The left-to-right cars are at positions\
    \ 0, 1, 2, ..., n-1.\n        // The right-to-left cars are at positions n, n-1,\
    \ n-2, ..., 1.\n        // The left-to-right cars are moving at speeds 1, 2, 3,\
    \ ..., n.\n        // The right-to-left cars are moving at speeds n, n-1, n-2,\
    \ ..., 1.\n        // The left-to-right cars are moving at speeds 1, 2, 3, ...,\
    \ n.\n        // The right-to-left cars are moving at speeds n, n-1, n-2, ...,\
    \ 1.\n        // The left-to-right cars are moving at speeds 1, 2, 3, ..., n.\n\
    \        // The right-to-left cars are moving at speeds n, n-1, n-2, ..., 1.\n\
    \        // The left-to-right cars are moving at speeds 1, 2, 3, ..., n.\n   \
    \     // The right-to-left cars are moving at speeds n, n-1, n-2, ..., 1.\n  \
    \      // The left-to-right cars are moving at speeds 1, 2, 3, ..., n.\n     \
    \   // The right-to-left cars are moving at speeds n, n-1, n-2, ..., 1.\n    \
    \    // The left-to-right cars are moving at speeds 1, 2, 3, ..., n.\n       \
    \ // The right-to-left cars are moving at speeds n, n-1, n-2, ..., 1.\n      \
    \  // The left-to-right cars are moving at speeds 1, 2, 3, ..., n.\n        //\
    \ The right-to-left cars are moving at speeds n, n-1, n-2, ..., 1.\n        //\
    \ The left-to-right cars are moving at speeds 1, 2, 3, ..., n.\n        // The\
    \ right-to-left cars are moving at speeds n, n-1, n-2, ..., 1.\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeo0pxk8b.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say that the left-to-right cars are indexed from 0 to n-1, and the\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// right-to-left cars are indexed from n to\
    \ 2n-1.\e[0m\n\e[31m15 |\e[0m        \e[34m// The left-to-right cars are at positions\
    \ 0, 1, 2, ..., n-1.\e[0m\n\e[31m16 |\e[0m        \e[34m// The right-to-left cars\
    \ are at positions n, n-1, n-2, ..., 1.\e[0m\n\e[31m17 |\e[0m        \e[34m//\
    \ The left-to-right cars are moving at speeds 1, 2, 3, ..., n.\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// The right-to-left cars are moving at speeds n, n-1, n-2,\
    \ ..., 1.\e[0m\n\e[31m19 |\e[0m        \e[34m// The left-to-right cars are moving\
    \ at speeds 1, 2, 3, ..., n.\e[0m\n\e[31m20 |\e[0m        \e[34m// The right-to-left\
    \ cars are moving at speeds n, n-1, n-2, ..., 1.\e[0m\n\e[31m21 |\e[0m       \
    \ \e[34m// The left-to-right cars are moving at speeds 1, 2, 3, ..., n.\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// The right-to-left cars are moving at speeds n,\
    \ n-1, n-2, ..., 1.\e[0m\n\e[31m23 |\e[0m        \e[34m// The left-to-right cars\
    \ are moving at speeds 1, 2, 3, ..., n.\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ The right-to-left cars are moving at speeds n, n-1, n-2, ..., 1.\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// The left-to-right cars are moving at speeds 1, 2, 3,\
    \ ..., n.\e[0m\n\e[31m26 |\e[0m        \e[34m// The right-to-left cars are moving\
    \ at speeds n, n-1, n-2, ..., 1.\e[0m\n\e[31m27 |\e[0m        \e[34m// The left-to-right\
    \ cars are moving at speeds 1, 2, 3, ..., n.\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ The right-to-left cars are moving at speeds n, n-1, n-2, ..., 1.\e[0m\n\e[31m29\
    \ |\e[0m        \e[34m// The left-to-right cars are moving at speeds 1, 2, 3,\
    \ ..., n.\e[0m\n\e[31m30 |\e[0m  "
  stdout: ''
  timestamp: 1659792873
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This problem is equivalent\
    \ to the following:\n        // Given n points on a line, how many pairs of points\
    \ are such that\n        // the first point is to the left of the second point.\n\
    \        // This is equivalent to the number of pairs of points such that\n  \
    \      // the first point is to the right of the second point.\n        // This\
    \ is equivalent to the number of pairs of points such that\n        // the first\
    \ point is to the left of the second point.\n        // This is equivalent to\
    \ the number of pairs of points such that\n        // the first point is to the\
    \ right of the second point.\n        // This is equivalent to the number of pairs\
    \ of points such that\n        // the first point is to the left of the second\
    \ point.\n        // This is equivalent to the number of pairs of points such\
    \ that\n        // the first point is to the right of the second point.\n    \
    \    // This is equivalent to the number of pairs of points such that\n      \
    \  // the first point is to the left of the second point.\n        // This is\
    \ equivalent to the number of pairs of points such that\n        // the first\
    \ point is to the right of the second point.\n        // This is equivalent to\
    \ the number of pairs of points such that\n        // the first point is to the\
    \ left of the second point.\n        // This is equivalent to the number of pairs\
    \ of points such that\n        // the first point is to the right of the second\
    \ point.\n        // This is equivalent to the number of pairs of points such\
    \ that\n        // the first point is to the left of the second point.\n     \
    \   // This is equivalent to the number of pairs of points such that\n       \
    \ // the first point is to the right of the second point.\n        // This is\
    \ equivalent to the number of pairs of points such that\n        // the first\
    \ point is to the left of the second point.\n        // This is equivalent to\
    \ the number of pairs of points such that\n        // the first point is to the\
    \ right of the second point.\n        // This is equivalent to the number of pairs\
    \ of points such that\n        // the first point is to the left of the second\
    \ point.\n        // This is equivalent to the number of pairs of points such\
    \ that\n        // the first point is to the right of the second point.\n    \
    \    // This is equivalent to the number of pairs of points such that\n      \
    \  //\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz1dikogl.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This problem is equivalent to the following:\e[0m\n\e[31m14 |\e[0m    \
    \    \e[34m// Given n points on a line, how many pairs of points are such that\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// the first point is to the left of the second\
    \ point.\e[0m\n\e[31m16 |\e[0m        \e[34m// This is equivalent to the number\
    \ of pairs of points such that\e[0m\n\e[31m17 |\e[0m        \e[34m// the first\
    \ point is to the right of the second point.\e[0m\n\e[31m18 |\e[0m        \e[34m//\
    \ This is equivalent to the number of pairs of points such that\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// the first point is to the left of the second point.\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// This is equivalent to the number of pairs\
    \ of points such that\e[0m\n\e[31m21 |\e[0m        \e[34m// the first point is\
    \ to the right of the second point.\e[0m\n\e[31m22 |\e[0m        \e[34m// This\
    \ is equivalent to the number of pairs of points such that\e[0m\n\e[31m23 |\e\
    [0m        \e[34m// the first point is to the left of the second point.\e[0m\n\
    \e[31m24 |\e[0m        \e[34m// This is equivalent to the number of pairs of points\
    \ such that\e[0m\n\e[31m25 |\e[0m        \e[34m// the first point is to the right\
    \ of the second point.\e[0m\n\e[31m26 |\e[0m        \e[34m// This is equivalent\
    \ to the number of pairs of points such that\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ the first point is to the left of the second point.\e[0m\n\e[31m28 |\e[0m  \
    \      \e[34m// This is equivalent to the number of pairs of points such that\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// the first point is to the right of the second\
    \ point.\e[0m\n\e[31m30 |\e[0m        \e[34m// This is equivalent to the number\
    \ of pairs of points such that\e[0m\n\e[31m31 |\e[0m"
  stdout: ''
  timestamp: 1659792873
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the cars\
    \ moving left to right are indexed from 1 to n, and the cars\n        // moving\
    \ right to left are indexed from n+1 to 2n.  We can represent the cars\n     \
    \   // as a vector of pairs (x, y), where x is the x-coordinate of the car, and\
    \ y is\n        // the index of the car.  The cars moving left to right have y\
    \ from 1 to n, and\n        // the cars moving right to left have y from n+1 to\
    \ 2n.\n        // The cars move at the same speed, so the cars moving left to\
    \ right will always\n        // have x-coordinates that are increasing, and the\
    \ cars moving right to left will\n        // always have x-coordinates that are\
    \ decreasing.\n        // We can sort the cars by their x-coordinates, and then\
    \ we can iterate through\n        // the cars in order of increasing x-coordinates.\
    \  If we encounter a car moving\n        // left to right, we can add it to a\
    \ set.  If we encounter a car moving right to left,\n        // we can remove\
    \ it from the set.  If the set is non-empty, then we know that the\n        //\
    \ car moving right to left collided with some car moving left to right.\n    \
    \    // We can use a balanced binary search tree to implement the set.\n     \
    \   // The total time complexity is O(n log n).\n        val cars = new Array[(Long,\
    \ Long)](2 * n.toInt)\n        for (i <- 1 to n.toInt) cars(i - 1) = (i, i)\n\
    \        for (i <- n.toInt + 1 to 2 * n.toInt) cars(i - 1) = (i, i)\n        val\
    \ sortedCars = cars.sortWith((a, b) => a._1 < b._1)\n        val set = new TreeSet[Long]()\n\
    \        var collisions = 0L\n        for (car <- sortedCars) {\n            if\
    \ (car._2 <= n) set.add(car._2)\n            else {\n                if (set.contains(car._2\
    \ - n)) collisions += 1\n                set.remove(car._2 - n)\n            }\n\
    \        }\n        collisions\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv0dm6aou.scala:44)\n\tat Problem.main(tmpv0dm6aou.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792877
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key observation is that if two cars collide,\n        // then\
    \ the car that's moving left to right must be the ith car, and the car that's\n\
    \        // moving right to left must be the (n - i + 1)th car.  This is because\
    \ the ith car\n        // is the first car that's moving left to right, and the\
    \ (n - i + 1)th car is the\n        // first car that's moving right to left.\n\
    \        // As a result, the number of collisions is the number of pairs (i, j)\
    \ such that\n        // 1 <= i <= n and 1 <= j <= n and i + j - 1 = n.  This is\
    \ the same as the number\n        // of pairs (i, j) such that 1 <= i <= n and\
    \ 1 <= j <= n and i + j = n + 1.\n        // This is the same as the number of\
    \ pairs (i, j) such that 1 <= i <= n and 1 <= j <= n and i + j = n + 1.\n    \
    \    // This is the same as the number of pairs (i, j) such that 1 <= i <= n and\
    \ 1 <= j <= n and i + j = n + 1.\n        // This is the same as the number of\
    \ pairs (i, j) such that 1 <= i <= n and 1 <= j <= n and i + j = n + 1.\n    \
    \    // This is the same as the number of pairs (i, j) such that 1 <= i <= n and\
    \ 1 <= j <= n and i + j = n + 1.\n        // This is the same as the number of\
    \ pairs (i, j) such that 1 <= i <= n and 1 <= j <= n and i + j = n + 1.\n    \
    \    // This is the same as the number of pairs (i, j) such that 1 <= i <= n and\
    \ 1 <= j <= n and i + j = n + 1.\n        // This is the same as the number of\
    \ pairs (i, j) such that 1 <= i <= n and 1 <= j <= n and i + j = n + 1.\n    \
    \    // This is the same as the number of pairs (i, j) such that 1 <= i <= n and\
    \ 1 <= j <= n and i + j = n + 1.\n       \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzmd1f0nm.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  The key observation is that if two cars\
    \ collide,\e[0m\n\e[31m14 |\e[0m        \e[34m// then the car that's moving left\
    \ to right must be the ith car, and the car that's\e[0m\n\e[31m15 |\e[0m     \
    \   \e[34m// moving right to left must be the (n - i + 1)th car.  This is because\
    \ the ith car\e[0m\n\e[31m16 |\e[0m        \e[34m// is the first car that's moving\
    \ left to right, and the (n - i + 1)th car is the\e[0m\n\e[31m17 |\e[0m      \
    \  \e[34m// first car that's moving right to left.\e[0m\n\e[31m18 |\e[0m     \
    \   \e[34m// As a result, the number of collisions is the number of pairs (i,\
    \ j) such that\e[0m\n\e[31m19 |\e[0m        \e[34m// 1 <= i <= n and 1 <= j <=\
    \ n and i + j - 1 = n.  This is the same as the number\e[0m\n\e[31m20 |\e[0m \
    \       \e[34m// of pairs (i, j) such that 1 <= i <= n and 1 <= j <= n and i +\
    \ j = n + 1.\e[0m\n\e[31m21 |\e[0m        \e[34m// This is the same as the number\
    \ of pairs (i, j) such that 1 <= i <= n and 1 <= j <= n and i + j = n + 1.\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// This is the same as the number of pairs (i, j)\
    \ such that 1 <= i <= n and 1 <= j <= n and i + j = n + 1.\e[0m\n\e[31m23 |\e\
    [0m        \e[34m// This is the same as the number of pairs (i, j) such that 1\
    \ <= i <= n and 1 <= j <= n and i + j = n + 1.\e[0m\n\e[31m24 |\e[0m        \e\
    [34m// This is the same as the number of pairs (i, j) such that 1 <= i <= n and\
    \ 1 <= j <= n and i + j = n + 1.\e[0m\n\e[31m25 |\e[0m        \e[34m// This is\
    \ the same as the number of pairs (i, j) such that 1 <= i <= n and 1 <= j <= n\
    \ and i + j = n + 1.\e[0m\n\e[31m26 |\e[0m        \e[34m// This is the same as\
    \ the number of pairs (i, j) such that 1 <= i "
  stdout: ''
  timestamp: 1659792874
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars that move left to right are\n        // numbered 1 to n.\
    \  The cars that move right to left are numbered n+1 to 2n.\n        // The cars\
    \ that move left to right have a speed of 1, and the cars that move\n        //\
    \ right to left have a speed of -1.  The car that moves left to right with\n \
    \       // speed 1 and the car that moves right to left with speed -1 will collide\n\
    \        // when the distance between them is 0.  The distance between the two\
    \ cars\n        // is the difference between their positions.  The position of\
    \ the car that\n        // moves left to right is the same as its number.  The\
    \ position of the car\n        // that moves right to left is 2n - its number.\
    \  The distance between the\n        // two cars is 2n - 2 * its number.  The\
    \ two cars collide when the distance\n        // between them is 0.  This happens\
    \ when 2n - 2 * its number is 0.  This happens\n        // when its number is\
    \ n.  The number of cars that move left to right is n.\n        // The number\
    \ of cars that move right to left is n.  The number of collisions\n        //\
    \ is the number of cars that move left to right.  This is n.\n        n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0s49rmc6.scala:30)\n\tat Problem.main(tmp0s49rmc6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792875
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can easily count the\
    \ number of collisions.\n        // For example, if the cars are at positions\n\
    \        // -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10\n        // then the number of collisions is 10.\n        // The reason\
    \ is that the cars at positions -10, -9, -8, -7, -6, -5, -4, -3, -2, -1\n    \
    \    // will collide with the cars at positions 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.\n\
    \        // The cars at positions 0 and 0 will not collide with any other cars.\n\
    \        // The cars at positions -1 and 1 will collide with each other.\n   \
    \     // The cars at positions -2 and 2 will collide with each other.\n      \
    \  // ...\n        // The cars at positions -10 and 10 will collide with each\
    \ other.\n        // The total number of collisions is 10.\n        // The number\
    \ of collisions is equal to the number of pairs of cars that are\n        // at\
    \ the same distance from the origin.\n        // The number of pairs of cars that\
    \ are at the same distance from the origin\n        // is equal to the number\
    \ of cars that are at the same distance from the origin.\n        // The number\
    \ of cars that are at the same distance from the origin is equal to\n        //\
    \ the number of cars that are at the same distance from the origin, but\n    \
    \    // with the distance being positive.\n        // The number of cars that\
    \ are at the same distance from the origin, but\n        // with the distance\
    \ being positive, is equal to the number of cars that are\n        // at the same\
    \ distance from the origin, but with the distance being positive,\n        //\
    \ and with the distance being less than or equal to n.\n        // The number\
    \ of cars that are at the same distance from the origin, but\n        // with\
    \ the distance being positive, and with the distance being less than or equal\
    \ to n,\n        // is equal to the number of cars that are at the same distance\
    \ from the origin, but\n        // with the distance being positive, and\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiu332zg5.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can easily count the number of collisions.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// For example, if the cars are at positions\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// -10, -9, -8, -7, -6, -5, -4, -3, -2, -1,\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\e[0m\n\e[31m17 |\e[0m        \e[34m// then\
    \ the number of collisions is 10.\e[0m\n\e[31m18 |\e[0m        \e[34m// The reason\
    \ is that the cars at positions -10, -9, -8, -7, -6, -5, -4, -3, -2, -1\e[0m\n\
    \e[31m19 |\e[0m        \e[34m// will collide with the cars at positions 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 10.\e[0m\n\e[31m20 |\e[0m        \e[34m// The cars at positions\
    \ 0 and 0 will not collide with any other cars.\e[0m\n\e[31m21 |\e[0m        \e\
    [34m// The cars at positions -1 and 1 will collide with each other.\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// The cars at positions -2 and 2 will collide with each\
    \ other.\e[0m\n\e[31m23 |\e[0m        \e[34m// ...\e[0m\n\e[31m24 |\e[0m     \
    \   \e[34m// The cars at positions -10 and 10 will collide with each other.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// The total number of collisions is 10.\e[0m\n\
    \e[31m26 |\e[0m        \e[34m// The number of collisions is equal to the number\
    \ of pairs of cars that are\e[0m\n\e[31m27 |\e[0m        \e[34m// at the same\
    \ distance from the origin.\e[0m\n\e[31m28 |\e[0m        \e[34m// The number of\
    \ pairs of cars that are at the same distance from the origin\e[0m\n\e[31m29 |\e\
    [0m        \e[34m// is equal to the number of cars that are at the same distance\
    \ from the origin.\e[0m\n\e[31m30 |\e[0m        \e[34m// The number of cars that\
    \ are at the same distance from the origin is eq"
  stdout: ''
  timestamp: 1659792875
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can easily count the\
    \ number of collisions.\n        // The number of collisions is the number of\
    \ cars that start out\n        // to the left of the origin, plus the number of\
    \ cars that start out\n        // to the right of the origin.\n        // The\
    \ number of cars that start out to the left of the origin is\n        // the number\
    \ of cars that start out to the right of the origin.\n        // The number of\
    \ cars that start out to the right of the origin is\n        // the number of\
    \ cars that start out to the left of the origin.\n        // Therefore, the number\
    \ of collisions is 2 * the number of cars that start out\n        // to the left\
    \ of the origin.\n        // The number of cars that start out to the left of\
    \ the origin is\n        // the number of cars that start out to the right of\
    \ the origin.\n        // The number of cars that start out to the right of the\
    \ origin is\n        // the number of cars that start out to the left of the origin.\n\
    \        // Therefore, the number of collisions is 2 * the number of cars that\
    \ start out\n        // to the left of the origin.\n        // The number of cars\
    \ that start out to the left of the origin is\n        // the number of cars that\
    \ start out to the right of the origin.\n        // The number of cars that start\
    \ out to the right of the origin is\n        // the number of cars that start\
    \ out to the left of the origin.\n        // Therefore, the number of collisions\
    \ is 2 * the number of cars that start out\n        // to the left of the origin.\n\
    \        // The number of cars that start out to the left of the origin is\n \
    \       // the number of cars that start out to the right of the origin.\n   \
    \     // The number of cars that start out to the right of the origin is\n   \
    \     // the number of cars that start out to the left of the origin.\n      \
    \  // Therefore, the number of collisions is 2 * the number of cars that start\
    \ out\n        // to the left of the origin.\n        // The number of cars that\
    \ start out to the left of the origin is\n        // the number of cars that start\
    \ out to the right of the origin.\n        // The number of cars that start out\
    \ to the right of the origin is\n\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_dybnanb.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can easily count the number of collisions.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// The number of collisions is the number of\
    \ cars that start out\e[0m\n\e[31m16 |\e[0m        \e[34m// to the left of the\
    \ origin, plus the number of cars that start out\e[0m\n\e[31m17 |\e[0m       \
    \ \e[34m// to the right of the origin.\e[0m\n\e[31m18 |\e[0m        \e[34m// The\
    \ number of cars that start out to the left of the origin is\e[0m\n\e[31m19 |\e\
    [0m        \e[34m// the number of cars that start out to the right of the origin.\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// The number of cars that start out to the\
    \ right of the origin is\e[0m\n\e[31m21 |\e[0m        \e[34m// the number of cars\
    \ that start out to the left of the origin.\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ Therefore, the number of collisions is 2 * the number of cars that start out\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// to the left of the origin.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// The number of cars that start out to the left of the\
    \ origin is\e[0m\n\e[31m25 |\e[0m        \e[34m// the number of cars that start\
    \ out to the right of the origin.\e[0m\n\e[31m26 |\e[0m        \e[34m// The number\
    \ of cars that start out to the right of the origin is\e[0m\n\e[31m27 |\e[0m \
    \       \e[34m// the number of cars that start out to the left of the origin.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// Therefore, the number of collisions is 2\
    \ * the number of cars that start out\e[0m\n\e[31m29 |\e[0m        \e[34m// to\
    \ the left of the origin.\e[0m\n\e[31m30 |\e[0m        \e[34m// The number of\
    \ cars that start out to the left of the origin is\e[0m\n\e[3"
  stdout: ''
  timestamp: 1659792876
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm to count the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // 1.  Sort the cars by their starting position.\n \
    \       // 2.  Start with the leftmost car.\n        // 3.  If the car is moving\
    \ left to right, then it will collide with the next car\n        //     that's\
    \ moving right to left.  So, we can count the number of collisions\n        //\
    \     by counting the number of cars that are moving right to left that are\n\
    \        //     to the right of the car.\n        // 4.  If the car is moving\
    \ right to left, then it will collide with the next car\n        //     that's\
    \ moving left to right.  So, we can count the number of collisions\n        //\
    \     by counting the number of cars that are moving left to right that are\n\
    \        //     to the left of the car.\n        // 5.  Repeat steps 2-4 until\
    \ we've processed all the cars.\n        // 6.  The total number of collisions\
    \ is the sum of the number of collisions\n        //     for each car.\n     \
    \   //\n        // The time complexity of this algorithm is O(n log n).\n    \
    \    // The space complexity of this algorithm is O(n).\n        //\n        //\
    \ We can improve the space complexity to O(1) by using a two pointer approach.\n\
    \        // The idea is to use two pointers to keep track of the leftmost car\
    \ that's moving\n        // left to right and the rightmost car that's moving\
    \ right to left.\n        // Then, we can count the number of collisions by counting\
    \ the number of cars that\n        // are moving right to left that are to the\
    \ right of the leftmost car and the number\n        // of cars that are moving\
    \ left to right that are to the left of the rightmost car.\n        // We can\
    \ then move the leftmost car to the next car that's moving left to right\n   \
    \     // and the rightmost car to the next car that's moving right to left.\n\
    \        // We repeat this process until we've processed all the cars.\n     \
    \   // The total number of collisions is the sum of the number of collisions\n\
    \        // for each car.\n        //\n        // The time complexity of this\
    \ algorithm\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpml20v59u.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can use a sweep line algorithm to count the\
    \ number of collisions.\e[0m\n\e[31m15 |\e[0m        \e[34m// The sweep line algorithm\
    \ is as follows:\e[0m\n\e[31m16 |\e[0m        \e[34m// 1.  Sort the cars by their\
    \ starting position.\e[0m\n\e[31m17 |\e[0m        \e[34m// 2.  Start with the\
    \ leftmost car.\e[0m\n\e[31m18 |\e[0m        \e[34m// 3.  If the car is moving\
    \ left to right, then it will collide with the next car\e[0m\n\e[31m19 |\e[0m\
    \        \e[34m//     that's moving right to left.  So, we can count the number\
    \ of collisions\e[0m\n\e[31m20 |\e[0m        \e[34m//     by counting the number\
    \ of cars that are moving right to left that are\e[0m\n\e[31m21 |\e[0m       \
    \ \e[34m//     to the right of the car.\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ 4.  If the car is moving right to left, then it will collide with the next car\e\
    [0m\n\e[31m23 |\e[0m        \e[34m//     that's moving left to right.  So, we\
    \ can count the number of collisions\e[0m\n\e[31m24 |\e[0m        \e[34m//   \
    \  by counting the number of cars that are moving left to right that are\e[0m\n\
    \e[31m25 |\e[0m        \e[34m//     to the left of the car.\e[0m\n\e[31m26 |\e\
    [0m        \e[34m// 5.  Repeat steps 2-4 until we've processed all the cars.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// 6.  The total number of collisions is the\
    \ sum of the number of collisions\e[0m\n\e[31m28 |\e[0m        \e[34m//     for\
    \ each car.\e[0m\n\e[31m29 |\e[0m        \e[34m//\e[0m\n\e[31m30 |\e[0m      \
    \  \e[34m// The time complexity of this algorithm is O(n log n).\e[0m\n\e[31m31\
    \ |\e[0m        \e[34m// The space complexity of this algorithm is "
  stdout: ''
  timestamp: 1659792876
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars and count the number of cars\n        // that are moving left to right\
    \ and have a starting position that's less than\n        // the starting position\
    \ of the car we're currently looking at.\n        // This is O(n log n)\n    \
    \    val cars = Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt) {\n\
    \            cars(i) = i\n        }\n        val sortedCars = cars.sortWith((a,\
    \ b) => (a < b))\n        var count = 0L\n        for (i <- 0 until n.toInt) {\n\
    \            count += sortedCars(i)\n        }\n        count\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf4ald04n.scala:30)\n\tat Problem.main(tmpf4ald04n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792878
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val cars = new Array[Long](n.toInt)\n\
    \        for (i <- 0 until n.toInt) cars(i) = i\n        cars.combinations(2).count(x\
    \ => x(0) > x(1))\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4qsledh4.scala:18)\n\tat Problem.main(tmp4qsledh4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can simulate the\
    \ race by going through the cars in order.\n        // If a car is moving left\
    \ to right, we increment the number of collisions by the number of cars\n    \
    \    // that are moving right to left and have already passed it.\n        //\
    \ If a car is moving right to left, we decrement the number of collisions by the\
    \ number of cars\n        // that are moving left to right and have already passed\
    \ it.\n        // We can keep track of the number of cars that have already passed\
    \ by using a binary indexed tree.\n        // The total number of collisions is\
    \ the sum of the number of collisions for each car.\n        val cars = Array.fill(2\
    \ * n.toInt)(0L)\n        for (i <- 0 until n.toInt) {\n            cars(i) =\
    \ i + 1\n            cars(i + n.toInt) = -(i + 1)\n        }\n        val sortedCars\
    \ = cars.sorted\n        val bit = new BinaryIndexedTree(2 * n.toInt)\n      \
    \  var collisions = 0L\n        for (i <- 0 until 2 * n.toInt) {\n           \
    \ if (sortedCars(i) > 0) {\n                collisions += bit.sum(i)\n       \
    \         bit.add(i, 1)\n            } else {\n                collisions -= bit.sum(i)\n\
    \                bit.add(i, -1)\n            }\n        }\n        collisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo3wk3qbj.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbit\e[0m = \e[33mnew\e[0m\
    \ \e[35mBinaryIndexedTree\e[0m(\e[31m2\e[0m * n.toInt)\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \       Not found: type BinaryIndexedTree\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792876
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.  We will sweep from left to right.\n        // We will\
    \ maintain a set of cars that are currently moving left to right.\n        //\
    \ For each car that's moving left to right, we will add it to the set.\n     \
    \   // For each car that's moving right to left, we will remove it from the set.\n\
    \        // If the set is empty, then we know that there is no collision.\n  \
    \      // If the set is not empty, then we know that there is a collision.\n \
    \       // The reason is that if the set is not empty, then there is at least\
    \ one car\n        // moving left to right.  If there is a car moving right to\
    \ left, then they will\n        // collide.\n        // The time complexity is\
    \ O(n).\n        var set = Set[Long]()\n        var result = 0L\n        for (i\
    \ <- 1 to 2 * n.toInt) {\n            if (i <= n) {\n                set += i\n\
    \            } else {\n                if (set.contains(i - n)) {\n          \
    \          result += 1\n                }\n                set -= (i - n)\n  \
    \          }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdrrdultx.scala:38)\n\tat Problem.main(tmpdrrdultx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.\n        // We will use a priority queue to store the\
    \ cars.\n        // The priority queue will be sorted by the position of the cars.\n\
    \        // The priority queue will also store the direction of the cars.\n  \
    \      // We will use a priority queue of size 2n.\n        // The first n cars\
    \ will be moving left to right.\n        // The second n cars will be moving right\
    \ to left.\n        // The first n cars will be stored in the first half of the\
    \ priority queue.\n        // The second n cars will be stored in the second half\
    \ of the priority queue.\n        // The first n cars will be stored in the priority\
    \ queue in increasing order of position.\n        // The second n cars will be\
    \ stored in the priority queue in decreasing order of position.\n        // The\
    \ first n cars will be stored in the priority queue with a positive direction.\n\
    \        // The second n cars will be stored in the priority queue with a negative\
    \ direction.\n        // We will use a variable to store the number of collisions.\n\
    \        // We will use a variable to store the current position of the sweep\
    \ line.\n        // We will use a variable to store the current position of the\
    \ car that is being processed.\n        // We will use a variable to store the\
    \ current direction of the car that is being processed.\n        // We will use\
    \ a variable to store the current position of the car that is being processed.\n\
    \        // We will use a variable to store the current direction of the car that\
    \ is being processed.\n        // We will use a variable to store the current\
    \ position of the car that is being processed.\n        // We will use a variable\
    \ to store the current direction of the car that is being processed.\n       \
    \ // We will use a variable to store the current position of the car that is being\
    \ processed.\n        // We will use a variable to store the current direction\
    \ of the car that is being processed.\n        // We will use a variable to store\
    \ the current position of the car that is being processed.\n        // We will\
    \ use a variable to store the current direction of the car that is being processed.\n\
    \        // We will use a variable to store the current position of the car that\
    \ is being processed.\n        // We will use a variable to store the current\
    \ direction of the car that is being processed.\n        // We will use a variable\
    \ to store the\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8ohrvc4z.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a sweep line algorithm.\e[0m\n\e[31m14 |\e[0m      \
    \  \e[34m// We will use a priority queue to store the cars.\e[0m\n\e[31m15 |\e\
    [0m        \e[34m// The priority queue will be sorted by the position of the cars.\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// The priority queue will also store the direction\
    \ of the cars.\e[0m\n\e[31m17 |\e[0m        \e[34m// We will use a priority queue\
    \ of size 2n.\e[0m\n\e[31m18 |\e[0m        \e[34m// The first n cars will be moving\
    \ left to right.\e[0m\n\e[31m19 |\e[0m        \e[34m// The second n cars will\
    \ be moving right to left.\e[0m\n\e[31m20 |\e[0m        \e[34m// The first n cars\
    \ will be stored in the first half of the priority queue.\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// The second n cars will be stored in the second half of the priority\
    \ queue.\e[0m\n\e[31m22 |\e[0m        \e[34m// The first n cars will be stored\
    \ in the priority queue in increasing order of position.\e[0m\n\e[31m23 |\e[0m\
    \        \e[34m// The second n cars will be stored in the priority queue in decreasing\
    \ order of position.\e[0m\n\e[31m24 |\e[0m        \e[34m// The first n cars will\
    \ be stored in the priority queue with a positive direction.\e[0m\n\e[31m25 |\e\
    [0m        \e[34m// The second n cars will be stored in the priority queue with\
    \ a negative direction.\e[0m\n\e[31m26 |\e[0m        \e[34m// We will use a variable\
    \ to store the number of collisions.\e[0m\n\e[31m27 |\e[0m        \e[34m// We\
    \ will use a variable to store the current position of the sweep line.\e[0m\n\e\
    [31m28 |\e[0m        \e[34m// We will use a variable to store the current position\
    \ of the car that is being processed.\e[0m\n\e[31m29 |\e[0m        \e[34m// We\
    \ will use a varia"
  stdout: ''
  timestamp: 1659792879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can solve it by sorting the cars by their\n        // starting\
    \ positions, and then iterating through the sorted list.  If the i-th\n      \
    \  // car is moving left to right, and the i+1-th car is moving right to left,\
    \ then\n        // they collide.  The number of collisions is the number of such\
    \ pairs.\n        // We can do this in O(n log n) time.\n        // However, we\
    \ can do better.  We can do this in O(n) time.\n        // The key observation\
    \ is that we can count the number of collisions by counting\n        // the number\
    \ of cars that are moving left to right, and the number of cars that\n       \
    \ // are moving right to left.  We can do this by iterating through the cars,\
    \ and\n        // keeping track of the number of cars that are moving left to\
    \ right, and the number\n        // of cars that are moving right to left.  Each\
    \ time we encounter a car moving left\n        // to right, we add the number\
    \ of cars that are moving right to left to the number\n        // of collisions.\
    \  Each time we encounter a car moving right to left, we add the\n        // number\
    \ of cars that are moving left to right to the number of collisions.\n       \
    \ // This algorithm runs in O(n) time.\n        var collisions = 0L\n        var\
    \ numLeftToRight = 0L\n        var numRightToLeft = 0L\n        for (i <- 0L until\
    \ n) {\n            if (i % 2 == 0) {\n                numLeftToRight += 1\n \
    \               collisions += numRightToLeft\n            } else {\n         \
    \       numRightToLeft += 1\n                collisions += numLeftToRight\n  \
    \          }\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp41kqedbu.scala:43)\n\tat Problem.main(tmp41kqedbu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // For each car that's\
    \ moving left to right, we'll keep track of its position\n        // at all times.\
    \  We'll do the same for the cars that are moving right to left.\n        // We'll\
    \ keep track of the positions of the cars that are moving left to right\n    \
    \    // in the array \"leftToRightPositions\", and the positions of the cars that\
    \ are\n        // moving right to left in the array \"rightToLeftPositions\".\n\
    \        // We'll also keep track of the number of collisions that have occurred\
    \ so far\n        // in the variable \"collisions\".\n        var leftToRightPositions\
    \ = ArrayBuffer[Long]()\n        var rightToLeftPositions = ArrayBuffer[Long]()\n\
    \        var collisions = 0L\n        // We'll keep track of the current time\
    \ in the variable \"time\".\n        var time = 0L\n        // We'll keep track\
    \ of the number of cars that are moving left to right\n        // that have reached\
    \ the end of the road in the variable \"leftToRightCompleted\".\n        // We'll\
    \ keep track of the number of cars that are moving right to left\n        // that\
    \ have reached the end of the road in the variable \"rightToLeftCompleted\".\n\
    \        var leftToRightCompleted = 0L\n        var rightToLeftCompleted = 0L\n\
    \        // We'll keep track of the number of cars that are moving left to right\n\
    \        // that have reached the end of the road in the variable \"leftToRightCompleted\"\
    .\n        // We'll keep track of the number of cars that are moving right to\
    \ left\n        // that have reached the end of the road in the variable \"rightToLeftCompleted\"\
    .\n        var leftToRightCompleted = 0L\n        var rightToLeftCompleted = 0L\n\
    \        // We'll keep track of the number of cars that are moving left to right\n\
    \        // that have reached the end of the road in the variable \"leftToRightCompleted\"\
    .\n        // We'll keep track of the number of cars that are moving right to\
    \ left\n        // that have reached the end of the road in the variable \"rightToLeftCompleted\"\
    .\n        var leftToRightCompleted = 0L\n        var rightToLeftCompleted = 0L\n\
    \        // We'll keep track of the number of cars that are moving left to right\n\
    \        // that have reached the end of the road in the variable \"leftTo\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2avx811n.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mvar\e[0m \e[36mleftToRightCompleted\e[0m\
    \ = \e[31m0L\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftToRightCompleted is already defined as \e[33mvariable\e\
    [0m \e[35mleftToRightCompleted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2avx811n.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mvar\e[0m \e[36mrightToLeftCompleted\e[0m\
    \ = \e[31m0L\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightToLeftCompleted is already defined as \e[33mvariable\e\
    [0m \e[35mrightToLeftCompleted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2avx811n.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mvar\e[0m \e[36mleftToRightCompleted\e[0m\
    \ = \e[31m0L\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftToRightCompleted is already defined as \e[33mvariable\e\
    [0m \e[35mleftToRightCompleted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2avx811n.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mvar\e[0m \e[36mrightToLeftCompleted\e[0m\
    \ = \e[31m0L\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightToLeftCompleted is already defined as \e[33mvariable\e\
    [0m \e[35mrightToLeftCompleted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2avx811n.scala:45:5 ---------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long"
  stdout: ''
  timestamp: 1659792879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars that are moving left to right\n        // are numbered 1\
    \ to n.  The cars that are moving right to left are numbered\n        // n+1 to\
    \ 2n.  The cars are moving at the same speed.  So, the cars that are\n       \
    \ // moving left to right will collide with the cars that are moving right to\
    \ left\n        // in the order 1, 2, 3, ..., n.  So, the answer is n.\n     \
    \   n\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3guobm6o.scala:21)\n\tat Problem.main(tmp3guobm6o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.  Then, the number of collisions\n     \
    \   // is the number of cars that start on the left side of the road, and the\
    \ number of cars\n        // that start on the right side of the road.\n     \
    \   // The number of cars that start on the left side of the road is n * (n +\
    \ 1) / 2.\n        // The number of cars that start on the right side of the road\
    \ is n * (n - 1) / 2.\n        // The total number of collisions is n * (n + 1)\
    \ / 2 * n * (n - 1) / 2.\n        n * (n + 1) / 2 * n * (n - 1) / 2\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2m4e2g0m.scala:22)\n\tat Problem.main(tmp2m4e2g0m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can count the number\
    \ of collisions by counting the number of cars\n        // that are moving in\
    \ the same direction.\n        // The number of cars moving in the same direction\
    \ is the number of cars\n        // that are moving left to right and the number\
    \ of cars that are moving right to left.\n        // The number of cars moving\
    \ left to right is the number of cars that are moving left to right\n        //\
    \ and the number of cars that are moving right to left.\n        // The number\
    \ of cars moving right to left is the number of cars that are moving left to right\n\
    \        // and the number of cars that are moving right to left.\n        //\
    \ The number of cars moving left to right and the number of cars moving right\
    \ to left\n        // is the number of cars that are moving left to right and\
    \ the number of cars that are moving right to left.\n        // The number of\
    \ cars moving left to right and the number of cars moving right to left\n    \
    \    // is the number of cars that are moving left to right and the number of\
    \ cars that are moving right to left.\n        // The number of cars moving left\
    \ to right and the number of cars moving right to left\n        // is the number\
    \ of cars that are moving left to right and the number of cars that are moving\
    \ right to left.\n        // The number of cars moving left to right and the number\
    \ of cars moving right to left\n        // is the number of cars that are moving\
    \ left to right and the number of cars that are moving right to left.\n      \
    \  // The number of cars moving left to right and the number of cars moving right\
    \ to left\n        // is the number of cars that are moving left to right and\
    \ the number of cars that are moving right to left.\n        // The number of\
    \ cars moving left to right and the number of cars moving right to left\n    \
    \    // is the number of cars that are moving left to right and the number of\
    \ cars that are moving right to left.\n        // The number of cars moving left\
    \ to right and the number of cars moving right to left\n        // is the number\
    \ of cars that are moving left to right and the number of cars that are moving\
    \ right to left.\n        // The number of cars moving left to right and the number\
    \ of cars moving right to left\n        // is the number of cars that are moving\
    \ left to right\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0_ebis7_.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can count the number of collisions by counting\
    \ the number of cars\e[0m\n\e[31m15 |\e[0m        \e[34m// that are moving in\
    \ the same direction.\e[0m\n\e[31m16 |\e[0m        \e[34m// The number of cars\
    \ moving in the same direction is the number of cars\e[0m\n\e[31m17 |\e[0m   \
    \     \e[34m// that are moving left to right and the number of cars that are moving\
    \ right to left.\e[0m\n\e[31m18 |\e[0m        \e[34m// The number of cars moving\
    \ left to right is the number of cars that are moving left to right\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// and the number of cars that are moving right to left.\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// The number of cars moving right to left is\
    \ the number of cars that are moving left to right\e[0m\n\e[31m21 |\e[0m     \
    \   \e[34m// and the number of cars that are moving right to left.\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// The number of cars moving left to right and the number\
    \ of cars moving right to left\e[0m\n\e[31m23 |\e[0m        \e[34m// is the number\
    \ of cars that are moving left to right and the number of cars that are moving\
    \ right to left.\e[0m\n\e[31m24 |\e[0m        \e[34m// The number of cars moving\
    \ left to right and the number of cars moving right to left\e[0m\n\e[31m25 |\e\
    [0m        \e[34m// is the number of cars that are moving left to right and the\
    \ number of cars that are moving right to left.\e[0m\n\e[31m26 |\e[0m        \e\
    [34m// The number of cars moving left to right and the number of cars moving right\
    \ to left\e[0m\n\e[31m27 |\e[0m        \e[34m// is the number of cars that are\
    \ moving left to right and the n"
  stdout: ''
  timestamp: 1659792881
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can solve it by brute force.\n        // We can simulate the movement\
    \ of the cars.  We can keep track of the\n        // position of each car.  We\
    \ can keep track of the number of collisions.\n        // We can keep track of\
    \ the number of cars that have already collided.\n        // We can keep track\
    \ of the number of cars that have already reached the end.\n        // We can\
    \ keep track of the number of cars that have already reached the end\n       \
    \ // and have collided.\n        // We can keep track of the number of cars that\
    \ have already reached the end\n        // and have not collided.\n        //\
    \ We can keep track of the number of cars that have not reached the end\n    \
    \    // and have collided.\n        // We can keep track of the number of cars\
    \ that have not reached the end\n        // and have not collided.\n        //\
    \ We can keep track of the number of cars that have not reached the end\n    \
    \    // and have not collided and are moving left to right.\n        // We can\
    \ keep track of the number of cars that have not reached the end\n        // and\
    \ have not collided and are moving right to left.\n        // We can keep track\
    \ of the number of cars that have not reached the end\n        // and have not\
    \ collided and are moving left to right and have collided.\n        // We can\
    \ keep track of the number of cars that have not reached the end\n        // and\
    \ have not collided and are moving right to left and have collided.\n        //\
    \ We can keep track of the number of cars that have not reached the end\n    \
    \    // and have not collided and are moving left to right and have not collided.\n\
    \        // We can keep track of the number of cars that have not reached the\
    \ end\n        // and have not collided and are moving right to left and have\
    \ not collided.\n        // We can keep track of the number of cars that have\
    \ not reached the end\n        // and have not collided and are moving left to\
    \ right and have not collided\n        // and have collided.\n        // We can\
    \ keep track of the number of cars that have not reached the end\n        // and\
    \ have not collided and are moving right to left and have not collided\n     \
    \   // and have collided.\n        // We can keep track of the number of cars\
    \ that have not reached the end\n        // and have not collided and are\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpenqlcc03.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  We can solve it by brute force.\e[0m\n\e\
    [31m14 |\e[0m        \e[34m// We can simulate the movement of the cars.  We can\
    \ keep track of the\e[0m\n\e[31m15 |\e[0m        \e[34m// position of each car.\
    \  We can keep track of the number of collisions.\e[0m\n\e[31m16 |\e[0m      \
    \  \e[34m// We can keep track of the number of cars that have already collided.\e\
    [0m\n\e[31m17 |\e[0m        \e[34m// We can keep track of the number of cars that\
    \ have already reached the end.\e[0m\n\e[31m18 |\e[0m        \e[34m// We can keep\
    \ track of the number of cars that have already reached the end\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// and have collided.\e[0m\n\e[31m20 |\e[0m        \e[34m//\
    \ We can keep track of the number of cars that have already reached the end\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// and have not collided.\e[0m\n\e[31m22 |\e\
    [0m        \e[34m// We can keep track of the number of cars that have not reached\
    \ the end\e[0m\n\e[31m23 |\e[0m        \e[34m// and have collided.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// We can keep track of the number of cars that have not\
    \ reached the end\e[0m\n\e[31m25 |\e[0m        \e[34m// and have not collided.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// We can keep track of the number of cars that\
    \ have not reached the end\e[0m\n\e[31m27 |\e[0m        \e[34m// and have not\
    \ collided and are moving left to right.\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ We can keep track of the number of cars that have not reached the end\e[0m\n\
    \e[31m29 |\e[0m        \e[34m// and have not collided and are moving right to\
    \ left.\e[0m\n\e[31m30 |\e[0m        \e[34m// We can keep track of the number\
    \ of cars that have not reached the end\e[0m\n\e[31m31 "
  stdout: ''
  timestamp: 1659792881
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can count the number\
    \ of collisions by looking at the\n        // number of cars that are moving in\
    \ the same direction.\n        // For example, if there are 3 cars moving left\
    \ to right, and 2 cars moving right to left,\n        // then there are 3 * 2\
    \ = 6 collisions.\n        // The number of collisions is the sum of the number\
    \ of collisions for each set of cars.\n        // For example, if there are 3\
    \ cars moving left to right, and 2 cars moving right to left,\n        // and\
    \ 4 cars moving left to right, and 1 car moving right to left,\n        // then\
    \ there are 3 * 2 + 4 * 1 = 10 collisions.\n        // The number of collisions\
    \ is the sum of the number of collisions for each set of cars.\n        // This\
    \ can be computed in O(n) time by using a stack.\n        // The stack stores\
    \ the number of cars moving in the same direction.\n        // For example, if\
    \ there are 3 cars moving left to right, and 2 cars moving right to left,\n  \
    \      // and 4 cars moving left to right, and 1 car moving right to left,\n \
    \       // then the stack stores 3, 2, 4, 1.\n        // The number of collisions\
    \ is the sum of the product of the numbers in the stack.\n        // For example,\
    \ if the stack stores 3, 2, 4, 1, then the number of collisions is 3 * 2 + 4 *\
    \ 1 = 10.\n        // The stack can be computed in O(n) time.\n        // The\
    \ total time complexity is O(n).\n        val stack = new Stack[Long]\n      \
    \  var collisions = 0L\n        for (i <- 1 to n.toInt) {\n            val car\
    \ = new Car(i)\n            if (stack.isEmpty || car.direction == stack.top.direction)\
    \ stack.push(1)\n            else {\n                val numCars = stack.pop\n\
    \                collisions += numCars * car.num\n                stack.push(numCars)\n\
    \            }\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqkgwyd8p.scala:35:26 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mcar\e[0m = \e[33mnew\e\
    [0m \e[35mCar\e[0m(i)\n\e[31m\e[31m   |\e[0m                          ^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: type Car\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659792880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their position.  Then, we can just iterate through\n        // the\
    \ cars and count the number of collisions.\n        // The time complexity is\
    \ O(n log n)\n        // The space complexity is O(n)\n        val leftToRight\
    \ = new Array[Long](n.toInt)\n        val rightToLeft = new Array[Long](n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            leftToRight(i) = i\n      \
    \      rightToLeft(i) = n - i - 1\n        }\n        leftToRight.sortWith(_ <\
    \ _)\n        rightToLeft.sortWith(_ < _)\n        var count = 0\n        for\
    \ (i <- 0 until n.toInt) {\n            if (leftToRight(i) > rightToLeft(i)) count\
    \ += 1\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxhg1ck48.scala:32)\n\tat Problem.main(tmpxhg1ck48.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars are moving in a straight line.\n        // As a result, the\
    \ cars that are moving in the same direction will never collide.\n        // The\
    \ cars that are moving in the opposite direction will collide if and only if\n\
    \        // they are in the same position.  As a result, the number of collisions\
    \ is the number\n        // of pairs of cars that are in the same position.  Since\
    \ the cars are moving in a straight\n        // line, the number of collisions\
    \ is the number of pairs of cars that are in the same position\n        // at\
    \ the start.  Since the cars are moving in the same speed, the number of collisions\
    \ is the\n        // number of pairs of cars that are in the same position at\
    \ the start.  Since the cars are\n        // moving in the same speed, the number\
    \ of collisions is the number of pairs of cars that are\n        // in the same\
    \ position at the start.  Since the cars are moving in the same speed, the number\n\
    \        // of collisions is the number of pairs of cars that are in the same\
    \ position at the start.\n        // Since the cars are moving in the same speed,\
    \ the number of collisions is the number of pairs\n        // of cars that are\
    \ in the same position at the start.  Since the cars are moving in the same\n\
    \        // speed, the number of collisions is the number of pairs of cars that\
    \ are in the same position\n        // at the start.  Since the cars are moving\
    \ in the same speed, the number of collisions is the\n        // number of pairs\
    \ of cars that are in the same position at the start.  Since the cars are moving\n\
    \        // in the same speed, the number of collisions is the number of pairs\
    \ of cars that are in the same\n        // position at the start.  Since the cars\
    \ are moving in the same speed, the number of collisions is\n        // the number\
    \ of pairs of cars that are in the same position at the start.  Since the cars\
    \ are moving\n        // in the same speed, the number of collisions is the number\
    \ of pairs of cars that are in the same\n        // position at the start.  Since\
    \ the cars are moving in the same speed, the number of collisions is\n       \
    \ // the number of pairs of cars that are in the same position at the start. \
    \ Since the cars are moving\n        // in the same speed, the number\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy58qkdus.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  The cars are moving in a straight line.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// As a result, the cars that are moving in\
    \ the same direction will never collide.\e[0m\n\e[31m15 |\e[0m        \e[34m//\
    \ The cars that are moving in the opposite direction will collide if and only\
    \ if\e[0m\n\e[31m16 |\e[0m        \e[34m// they are in the same position.  As\
    \ a result, the number of collisions is the number\e[0m\n\e[31m17 |\e[0m     \
    \   \e[34m// of pairs of cars that are in the same position.  Since the cars are\
    \ moving in a straight\e[0m\n\e[31m18 |\e[0m        \e[34m// line, the number\
    \ of collisions is the number of pairs of cars that are in the same position\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// at the start.  Since the cars are moving\
    \ in the same speed, the number of collisions is the\e[0m\n\e[31m20 |\e[0m   \
    \     \e[34m// number of pairs of cars that are in the same position at the start.\
    \  Since the cars are\e[0m\n\e[31m21 |\e[0m        \e[34m// moving in the same\
    \ speed, the number of collisions is the number of pairs of cars that are\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// in the same position at the start.  Since the\
    \ cars are moving in the same speed, the number\e[0m\n\e[31m23 |\e[0m        \e\
    [34m// of collisions is the number of pairs of cars that are in the same position\
    \ at the start.\e[0m\n\e[31m24 |\e[0m        \e[34m// Since the cars are moving\
    \ in the same speed, the number of collisions is the number of pairs\e[0m\n\e\
    [31m25 |\e[0m        \e[34m// of cars that are in the same position at the start.\
    \  Since the cars are moving in the same\e[0m\n\e[31m26 |\e[0m        \e[34m//\
    \ speed, the number of collisions is the numb"
  stdout: ''
  timestamp: 1659792882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can just simulate the problem.\n        // We'll use a queue to\
    \ represent the cars moving left to right, and a stack\n        // to represent\
    \ the cars moving right to left.\n        // We'll use a variable to represent\
    \ the current position of the cars.\n        // We'll use a variable to represent\
    \ the number of collisions.\n        // We'll use a variable to represent the\
    \ number of cars that have already\n        // reached the end of the road.\n\
    \        // We'll use a variable to represent the number of cars that have already\n\
    \        // reached the beginning of the road.\n        // We'll use a variable\
    \ to represent the current time.\n        // We'll use a variable to represent\
    \ the current speed of the cars.\n        // We'll use a variable to represent\
    \ the current position of the cars.\n        // We'll use a variable to represent\
    \ the current number of collisions.\n        // We'll use a variable to represent\
    \ the current number of cars that have already\n        // reached the end of\
    \ the road.\n        // We'll use a variable to represent the current number of\
    \ cars that have already\n        // reached the beginning of the road.\n    \
    \    // We'll use a variable to represent the current time.\n        // We'll\
    \ use a variable to represent the current speed of the cars.\n        // We'll\
    \ use a variable to represent the current position of the cars.\n        // We'll\
    \ use a variable to represent the current number of collisions.\n        // We'll\
    \ use a variable to represent the current number of cars that have already\n \
    \       // reached the end of the road.\n        // We'll use a variable to represent\
    \ the current number of cars that have already\n        // reached the beginning\
    \ of the road.\n        // We'll use a variable to represent the current time.\n\
    \        // We'll use a variable to represent the current speed of the cars.\n\
    \        // We'll use a variable to represent the current position of the cars.\n\
    \        // We'll use a variable to represent the current number of collisions.\n\
    \        // We'll use a variable to represent the current number of cars that\
    \ have already\n        // reached the end of the road.\n        // We'll use\
    \ a variable to represent the current number of cars that have already\n     \
    \   // reached the beginning of the road.\n        // We'll use a variable to\
    \ represent the current time.\n       \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb1vfmddp.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  We can just simulate the problem.\e[0m\n\
    \e[31m14 |\e[0m        \e[34m// We'll use a queue to represent the cars moving\
    \ left to right, and a stack\e[0m\n\e[31m15 |\e[0m        \e[34m// to represent\
    \ the cars moving right to left.\e[0m\n\e[31m16 |\e[0m        \e[34m// We'll use\
    \ a variable to represent the current position of the cars.\e[0m\n\e[31m17 |\e\
    [0m        \e[34m// We'll use a variable to represent the number of collisions.\e\
    [0m\n\e[31m18 |\e[0m        \e[34m// We'll use a variable to represent the number\
    \ of cars that have already\e[0m\n\e[31m19 |\e[0m        \e[34m// reached the\
    \ end of the road.\e[0m\n\e[31m20 |\e[0m        \e[34m// We'll use a variable\
    \ to represent the number of cars that have already\e[0m\n\e[31m21 |\e[0m    \
    \    \e[34m// reached the beginning of the road.\e[0m\n\e[31m22 |\e[0m       \
    \ \e[34m// We'll use a variable to represent the current time.\e[0m\n\e[31m23\
    \ |\e[0m        \e[34m// We'll use a variable to represent the current speed of\
    \ the cars.\e[0m\n\e[31m24 |\e[0m        \e[34m// We'll use a variable to represent\
    \ the current position of the cars.\e[0m\n\e[31m25 |\e[0m        \e[34m// We'll\
    \ use a variable to represent the current number of collisions.\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// We'll use a variable to represent the current number\
    \ of cars that have already\e[0m\n\e[31m27 |\e[0m        \e[34m// reached the\
    \ end of the road.\e[0m\n\e[31m28 |\e[0m        \e[34m// We'll use a variable\
    \ to represent the current number of cars that have already\e[0m\n\e[31m29 |\e\
    [0m        \e[34m// reached the beginning of the road.\e[0m\n\e[31m30 |\e[0m \
    \       \e[34m// We'll use a variable to represent the current time"
  stdout: ''
  timestamp: 1659792883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The following is a\
    \ brute force solution.  It is correct, but it is too slow.\n        // The problem\
    \ is that the number of collisions is O(n^2), and the time complexity\n      \
    \  // of the brute force solution is O(n^2).\n        // The following is a brute\
    \ force solution.  It is correct, but it is too slow.\n        // The problem\
    \ is that the number of collisions is O(n^2), and the time complexity\n      \
    \  // of the brute force solution is O(n^2).\n        // val leftToRight = (1\
    \ to n).toList\n        // val rightToLeft = (1 to n).toList.reverse\n       \
    \ // var collisions = 0\n        // for (i <- 0 until n) {\n        //     for\
    \ (j <- 0 until n) {\n        //         if (leftToRight(i) == rightToLeft(j))\
    \ collisions += 1\n        //     }\n        // }\n        // collisions\n   \
    \     // The following is a solution that is O(n).\n        // The idea is to\
    \ sort the left to right cars and the right to left cars.\n        // Then, we\
    \ can use a two pointer algorithm to find the number of collisions.\n        //\
    \ The two pointer algorithm is as follows:\n        // 1.  Start with the left\
    \ most car in the left to right list and the right most car\n        //     in\
    \ the right to left list.\n        // 2.  If the left to right car is less than\
    \ the right to left car, then there is no\n        //     collision.  Move the\
    \ left to right car to the right.\n        // 3.  If the left to right car is\
    \ greater than the right to left car, then there is\n        //     a collision.\
    \  Move the right to left car to the left.\n        // 4.  Repeat until the left\
    \ to right car is greater than the right to left car.\n        // 5.  The number\
    \ of collisions is the number of times the right to left car was moved.\n    \
    \    val leftToRight = (1 to n).toList\n        val rightToLeft = (1 to n).toList.reverse\n\
    \        val sortedLeftToRight = leftToRight.sorted\n        val sortedRightToLeft\
    \ = rightToLeft.sorted\n        var collisions = 0\n        var i\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpplh3sswp.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpplh3sswp.scala:40:32 --------------------\e[0m\e[0m\n\e[31m40 |\e[0m\
    \        \e[33mval\e[0m \e[36mleftToRight\e[0m = (\e[31m1\e[0m to n).toList\n\e\
    [31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m   \
    \                             Found:    (n : Long)\n\e[31m   |\e[0m          \
    \                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpplh3sswp.scala:41:32 --------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mrightToLeft\e[0m = (\e[31m1\e\
    [0m to n).toList.reverse\n\e[31m\e[31m   |\e[0m                              \
    \  ^\e[0m\n\e[31m   |\e[0m                                Found:    (n : Long)\n\
    \e[31m   |\e[0m                                Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpplh3sswp.scala:46:5 ---------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792886
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars are moving in a straight line.\n        // The cars that\
    \ are moving left to right are numbered 1 to n.  The cars that\n        // are\
    \ moving right to left are numbered n+1 to 2n.  The cars that are moving\n   \
    \     // left to right are at positions 1 to n.  The cars that are moving right\
    \ to left\n        // are at positions n+1 to 2n.  The cars that are moving left\
    \ to right are moving\n        // at speed 1.  The cars that are moving right\
    \ to left are moving at speed -1.\n        // The cars that are moving left to\
    \ right are at positions 1 to n.  The cars that\n        // are moving right to\
    \ left are at positions n+1 to 2n.  The cars that are moving\n        // left\
    \ to right are at positions 1 to n.  The cars that are moving right to left\n\
    \        // are at positions n+1 to 2n.  The cars that are moving left to right\
    \ are at positions\n        // 1 to n.  The cars that are moving right to left\
    \ are at positions n+1 to 2n.  The cars\n        // that are moving left to right\
    \ are at positions 1 to n.  The cars that are moving right\n        // to left\
    \ are at positions n+1 to 2n.  The cars that are moving left to right are at positions\n\
    \        // 1 to n.  The cars that are moving right to left are at positions n+1\
    \ to 2n.  The cars that\n        // are moving left to right are at positions\
    \ 1 to n.  The cars that are moving right to left\n        // are at positions\
    \ n+1 to 2n.  The cars that are moving left to right are at positions 1 to n.\n\
    \        // The cars that are moving right to left are at positions n+1 to 2n.\
    \  The cars that are moving\n        // left to right are at positions 1 to n.\
    \  The cars that are moving right to left are at positions\n        // n+1 to\
    \ 2n.  The cars that are moving left to right are at positions 1 to n.  The cars\
    \ that are\n        // moving right to left are at positions n+1 to 2n.  The cars\
    \ that are moving left to right are at\n        // positions 1 to n.  The cars\
    \ that are\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpylu_2kyu.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  The cars are moving in a straight line.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// The cars that are moving left to right are\
    \ numbered 1 to n.  The cars that\e[0m\n\e[31m15 |\e[0m        \e[34m// are moving\
    \ right to left are numbered n+1 to 2n.  The cars that are moving\e[0m\n\e[31m16\
    \ |\e[0m        \e[34m// left to right are at positions 1 to n.  The cars that\
    \ are moving right to left\e[0m\n\e[31m17 |\e[0m        \e[34m// are at positions\
    \ n+1 to 2n.  The cars that are moving left to right are moving\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// at speed 1.  The cars that are moving right to left are\
    \ moving at speed -1.\e[0m\n\e[31m19 |\e[0m        \e[34m// The cars that are\
    \ moving left to right are at positions 1 to n.  The cars that\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// are moving right to left are at positions n+1 to 2n.\
    \  The cars that are moving\e[0m\n\e[31m21 |\e[0m        \e[34m// left to right\
    \ are at positions 1 to n.  The cars that are moving right to left\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// are at positions n+1 to 2n.  The cars that are moving\
    \ left to right are at positions\e[0m\n\e[31m23 |\e[0m        \e[34m// 1 to n.\
    \  The cars that are moving right to left are at positions n+1 to 2n.  The cars\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// that are moving left to right are at positions\
    \ 1 to n.  The cars that are moving right\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ to left are at positions n+1 to 2n.  The cars that are moving left to right\
    \ are at positions\e[0m\n\e[31m26 |\e[0m        \e[34m// 1 to n.  The cars that\
    \ are moving right to left are at positions n+1 to 2n.  The cars that\e[0m\n\e\
    [31m27 |\e[0m        \e[34m// are mov"
  stdout: ''
  timestamp: 1659792884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.  Then, we can\n        // use a sweep line\
    \ algorithm to count the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // We start with the leftmost car.  We then move the\
    \ sweep line to the right\n        // until we reach the rightmost car.  We keep\
    \ track of the number of cars\n        // that are moving left to right and the\
    \ number of cars that are moving right to left.\n        // When we move the sweep\
    \ line, we update the number of cars that are moving left to right\n        //\
    \ and the number of cars that are moving right to left.  We also update the number\
    \ of collisions.\n        // The number of collisions is the number of cars that\
    \ are moving left to right times the number\n        // of cars that are moving\
    \ right to left.\n        // The time complexity is O(n log n) because we have\
    \ to sort the cars.\n        // The space complexity is O(n) because we have to\
    \ store the cars.\n        val cars = new Array[(Long, Boolean)](n.toInt)\n  \
    \      for (i <- 0 until n.toInt) {\n            val Array(x, v) = readLine.split(\"\
    \ \").map(_.toLong)\n            cars(i) = (x, v == 1)\n        }\n        val\
    \ sortedCars = cars.sortWith((a, b) => a._1 < b._1)\n        var leftToRight =\
    \ 0\n        var rightToLeft = 0\n        var collisions = 0L\n        for (i\
    \ <- 0 until n.toInt) {\n            if (sortedCars(i)._2) leftToRight += 1\n\
    \            else rightToLeft += 1\n            collisions += leftToRight * rightToLeft\n\
    \        }\n        collisions\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7mnvso64.scala:27:30 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m Array(x, v) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toLong)\n\e[31m\e[31m   |\e[0m                         \
    \     ^^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found: readLine\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7mnvso64.scala:27:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e\
    [0m Array(x, v) = readLine.split(\e[31m\" \"\e[0m).map(_.toLong)\n\e[31m\e[31m\
    \   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                      Recursive\
    \ \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp7mnvso64.scala:27:25 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m Array(x, v) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toLong)\n\e[31m\e[31m   |\e[0m                         ^\e\
    [0m\n\e[31m   |\e[0m                         Recursive \e[33mvalue\e[0m \e[35m$1$\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659792882
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm.\n        // We start with the leftmost car.  We move the sweep line\
    \ to the right,\n        // and we keep track of the number of cars that are moving\
    \ left to right\n        // and the number of cars that are moving right to left.\n\
    \        // When we move the sweep line to the right, we check if the car that's\n\
    \        // moving left to right is colliding with the car that's moving right\
    \ to left.\n        // If so, we increment the number of collisions.\n       \
    \ // We repeat this process until we reach the rightmost car.\n        // The\
    \ complexity is O(n log n).\n        val cars = new Array[(Long, Boolean)](2 *\
    \ n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i) = (i.toLong,\
    \ true)\n            cars(i + n.toInt) = (i.toLong, false)\n        }\n      \
    \  val sortedCars = cars.sortWith((a, b) => if (a._1 == b._1) a._2 else a._1 <\
    \ b._1)\n        var collisions = 0L\n        var leftCars = 0\n        var rightCars\
    \ = 0\n        for (i <- 0 until sortedCars.length) {\n            if (sortedCars(i)._2)\
    \ leftCars += 1\n            else rightCars += 1\n            if (leftCars > 0\
    \ && rightCars > 0) collisions += 1\n        }\n        collisions\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvjmkaiek.scala:40)\n\tat Problem.main(tmpvjmkaiek.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792887
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars and count the number of collisions.\n        // The time complexity\
    \ is O(n log n).\n        val cars = new Array[Long](2 * n.toInt)\n        for\
    \ (i <- 0 until n.toInt) {\n            cars(i) = i + 1\n            cars(i +\
    \ n.toInt) = -(i + 1)\n        }\n        val sortedCars = cars.sorted\n     \
    \   var collisions = 0L\n        for (i <- 0 until 2 * n.toInt - 1) {\n      \
    \      if (sortedCars(i) > 0 && sortedCars(i + 1) < 0) collisions += 1\n     \
    \   }\n        collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp31xljlqb.scala:29)\n\tat Problem.main(tmp31xljlqb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792887
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm to count the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // We start with a sweep line that's infinitely far\
    \ to the left.\n        // We then move the sweep line to the right.  As we move\
    \ the sweep line,\n        // we keep track of the cars that are currently in\
    \ the sweep line.\n        // When a car enters the sweep line, we add it to the\
    \ set of cars in the sweep line.\n        // When a car leaves the sweep line,\
    \ we remove it from the set of cars in the sweep line.\n        // We count a\
    \ collision whenever a car that's moving left to right enters the sweep line\n\
    \        // and there's a car that's moving right to left in the sweep line.\n\
    \        // The sweep line algorithm is O(n log n) because we sort the cars by\
    \ their starting position.\n        // The sweep line algorithm is O(n) because\
    \ we only process each car once.\n        // We can use a balanced binary search\
    \ tree to implement the sweep line algorithm.\n        // We can use a balanced\
    \ binary search tree to implement the sweep line algorithm.\n        // We can\
    \ use a balanced binary search tree to implement the sweep line algorithm.\n \
    \       // We can use a balanced binary search tree to implement the sweep line\
    \ algorithm.\n        // We can use a balanced binary search tree to implement\
    \ the sweep line algorithm.\n        // We can use a balanced binary search tree\
    \ to implement the sweep line algorithm.\n        // We can use a balanced binary\
    \ search tree to implement the sweep line algorithm.\n        // We can use a\
    \ balanced binary search tree to implement the sweep line algorithm.\n       \
    \ // We can use a balanced binary search tree to implement the sweep line algorithm.\n\
    \        // We can use a balanced binary search tree to implement the sweep line\
    \ algorithm.\n        // We can use a balanced binary search tree to implement\
    \ the sweep line algorithm.\n        // We can use a balanced binary search tree\
    \ to implement the sweep line algorithm.\n        // We can use a balanced binary\
    \ search tree to implement the sweep line algorithm.\n        // We can use a\
    \ balanced binary search tree to implement the sweep line algorithm.\n       \
    \ // We can use a balanced binary search tree to implement the sweep line algorithm.\n\
    \        // We can use a balanced binary search tree\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9hguubgr.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can use a sweep line algorithm to count the\
    \ number of collisions.\e[0m\n\e[31m15 |\e[0m        \e[34m// The sweep line algorithm\
    \ is as follows:\e[0m\n\e[31m16 |\e[0m        \e[34m// We start with a sweep line\
    \ that's infinitely far to the left.\e[0m\n\e[31m17 |\e[0m        \e[34m// We\
    \ then move the sweep line to the right.  As we move the sweep line,\e[0m\n\e\
    [31m18 |\e[0m        \e[34m// we keep track of the cars that are currently in\
    \ the sweep line.\e[0m\n\e[31m19 |\e[0m        \e[34m// When a car enters the\
    \ sweep line, we add it to the set of cars in the sweep line.\e[0m\n\e[31m20 |\e\
    [0m        \e[34m// When a car leaves the sweep line, we remove it from the set\
    \ of cars in the sweep line.\e[0m\n\e[31m21 |\e[0m        \e[34m// We count a\
    \ collision whenever a car that's moving left to right enters the sweep line\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// and there's a car that's moving right to\
    \ left in the sweep line.\e[0m\n\e[31m23 |\e[0m        \e[34m// The sweep line\
    \ algorithm is O(n log n) because we sort the cars by their starting position.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// The sweep line algorithm is O(n) because\
    \ we only process each car once.\e[0m\n\e[31m25 |\e[0m        \e[34m// We can\
    \ use a balanced binary search tree to implement the sweep line algorithm.\e[0m\n\
    \e[31m26 |\e[0m        \e[34m// We can use a balanced binary search tree to implement\
    \ the sweep line algorithm.\e[0m\n\e[31m27 |\e[0m        \e[34m// We can use a\
    \ balanced binary search tree to implement the sweep line algorithm.\e[0m\n\e\
    [31m28 |\e[0m        \e[34m// We can use a bala"
  stdout: ''
  timestamp: 1659792886
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to consider\
    \ the cars as points on a number line.\n        // The left-to-right cars are\
    \ at positions 1, 2, 3, ..., n.\n        // The right-to-left cars are at positions\
    \ -1, -2, -3, ..., -n.\n        // The cars are moving at the same speed, so the\
    \ time it takes for a car to move\n        // from position x to position y is\
    \ |x - y|.\n        // The time it takes for a left-to-right car to collide with\
    \ a right-to-left car is\n        // the time it takes for the left-to-right car\
    \ to reach the position of the right-to-left car.\n        // The time it takes\
    \ for the left-to-right car to reach position -i is i - 1.\n        // The time\
    \ it takes for the right-to-left car to reach position i is i + 1.\n        //\
    \ The time it takes for the left-to-right car to reach position -i is i - 1.\n\
    \        // The time it takes for the right-to-left car to reach position i is\
    \ i + 1.\n        // The time it takes for the left-to-right car to reach position\
    \ -i is i - 1.\n        // The time it takes for the right-to-left car to reach\
    \ position i is i + 1.\n        // The time it takes for the left-to-right car\
    \ to reach position -i is i - 1.\n        // The time it takes for the right-to-left\
    \ car to reach position i is i + 1.\n        // The time it takes for the left-to-right\
    \ car to reach position -i is i - 1.\n        // The time it takes for the right-to-left\
    \ car to reach position i is i + 1.\n        // The time it takes for the left-to-right\
    \ car to reach position -i is i - 1.\n        // The time it takes for the right-to-left\
    \ car to reach position i is i + 1.\n        // The time it takes for the left-to-right\
    \ car to reach position -i is i - 1.\n        // The time it takes for the right-to-left\
    \ car to reach position i is i + 1.\n        // The time it takes for the left\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz3wwi1uj.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to consider the cars as points on a number line.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// The left-to-right cars are at positions 1, 2, 3, ...,\
    \ n.\e[0m\n\e[31m15 |\e[0m        \e[34m// The right-to-left cars are at positions\
    \ -1, -2, -3, ..., -n.\e[0m\n\e[31m16 |\e[0m        \e[34m// The cars are moving\
    \ at the same speed, so the time it takes for a car to move\e[0m\n\e[31m17 |\e\
    [0m        \e[34m// from position x to position y is |x - y|.\e[0m\n\e[31m18 |\e\
    [0m        \e[34m// The time it takes for a left-to-right car to collide with\
    \ a right-to-left car is\e[0m\n\e[31m19 |\e[0m        \e[34m// the time it takes\
    \ for the left-to-right car to reach the position of the right-to-left car.\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// The time it takes for the left-to-right car\
    \ to reach position -i is i - 1.\e[0m\n\e[31m21 |\e[0m        \e[34m// The time\
    \ it takes for the right-to-left car to reach position i is i + 1.\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// The time it takes for the left-to-right car to reach\
    \ position -i is i - 1.\e[0m\n\e[31m23 |\e[0m        \e[34m// The time it takes\
    \ for the right-to-left car to reach position i is i + 1.\e[0m\n\e[31m24 |\e[0m\
    \        \e[34m// The time it takes for the left-to-right car to reach position\
    \ -i is i - 1.\e[0m\n\e[31m25 |\e[0m        \e[34m// The time it takes for the\
    \ right-to-left car to reach position i is i + 1.\e[0m\n\e[31m26 |\e[0m      \
    \  \e[34m// The time it takes for the left-to-right car to reach position -i is\
    \ i - 1.\e[0m\n\e[31m27 |\e[0m        \e[34m// The time it takes for the right-to-left\
    \ car to reach position i is i + 1.\e[0m\n\e[31m28 |\e[0m        \e[34m// The\
    \ time it takes for the left-to-right c"
  stdout: ''
  timestamp: 1659792886
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can simulate the\
    \ race by iterating through the cars\n        // in order of their starting positions.\
    \  If a car is moving left to right,\n        // then we can check if it collides\
    \ with the previous car.\n        // If a car is moving right to left, then we\
    \ can check if it collides with the next car.\n        // This is O(n log n) time\
    \ and O(n) space.\n        val cars = Array.fill(2 * n.toInt)(0)\n        for\
    \ (i <- 0 until n.toInt) {\n            cars(i) = i + 1\n            cars(i +\
    \ n.toInt) = -(i + 1)\n        }\n        scala.util.Sorting.quickSort(cars)\n\
    \        var collisions = 0L\n        for (i <- 0 until 2 * n.toInt) {\n     \
    \       if (cars(i) > 0) {\n                if (i > 0 && cars(i - 1) < 0) collisions\
    \ += 1\n            } else {\n                if (i < 2 * n.toInt - 1 && cars(i\
    \ + 1) > 0) collisions += 1\n            }\n        }\n        collisions\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyxlekvug.scala:36)\n\tat Problem.main(tmpyxlekvug.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars are moving in the same speed, so\n        // the order of\
    \ the cars does not matter.  We can just assume that all cars are\n        //\
    \ moving left to right.  Then, the problem is equivalent to finding the number\n\
    \        // of pairs of cars that are at the same position at the same time.\n\
    \        // The number of pairs of cars that are at the same position at the same\
    \ time\n        // is the number of ways to choose 2 cars from n cars.  This is\
    \ n choose 2, which\n        // is n * (n - 1) / 2.\n        n * (n - 1) / 2\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8c9u7zos.scala:23)\n\tat Problem.main(tmp8c9u7zos.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792887
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars that are moving\
    \ left to right are indexed from 0 to n - 1.\n        // The cars that are moving\
    \ right to left are indexed from 0 to n - 1.\n        // The ith car that is moving\
    \ left to right starts at position i.\n        // The ith car that is moving right\
    \ to left starts at position n - 1 - i.\n        // The ith car that is moving\
    \ left to right moves at speed i + 1.\n        // The ith car that is moving right\
    \ to left moves at speed n - i.\n        // The ith car that is moving left to\
    \ right will collide with the jth car that is moving right to left\n        //\
    \ if and only if i + j + 1 = n.\n        // The number of such collisions is the\
    \ number of pairs (i, j) such that i + j + 1 = n.\n        // This is the same\
    \ as the number of pairs (i, j) such that i + j = n - 1.\n        // This is the\
    \ same as the number of pairs (i, j) such that i + j = n - 1.\n        // This\
    \ is the same as the number of pairs (i, j) such that i + j = n - 1.\n       \
    \ // This is the same as the number of pairs (i, j) such that i + j = n - 1.\n\
    \        // This is the same as the number of pairs (i, j) such that i + j = n\
    \ - 1.\n        // This is the same as the number of pairs (i, j) such that i\
    \ + j = n - 1.\n        // This is the same as the number of pairs (i, j) such\
    \ that i + j = n - 1.\n        // This is the same as the number of pairs (i,\
    \ j) such that i + j = n - 1.\n        // This is the same as the number of pairs\
    \ (i, j) such that i + j = n - 1.\n        // This is the same as the number of\
    \ pairs (i, j) such that i + j = n - 1.\n        // This is the same as the number\
    \ of pairs (i, j) such that i + j = n - 1.\n        // This is the same as the\
    \ number of pairs (i, j) such that i + j = n - 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpllu1r0j1.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars that are moving left to right are indexed from 0 to n - 1.\e[0m\n\
    \e[31m14 |\e[0m        \e[34m// The cars that are moving right to left are indexed\
    \ from 0 to n - 1.\e[0m\n\e[31m15 |\e[0m        \e[34m// The ith car that is moving\
    \ left to right starts at position i.\e[0m\n\e[31m16 |\e[0m        \e[34m// The\
    \ ith car that is moving right to left starts at position n - 1 - i.\e[0m\n\e\
    [31m17 |\e[0m        \e[34m// The ith car that is moving left to right moves at\
    \ speed i + 1.\e[0m\n\e[31m18 |\e[0m        \e[34m// The ith car that is moving\
    \ right to left moves at speed n - i.\e[0m\n\e[31m19 |\e[0m        \e[34m// The\
    \ ith car that is moving left to right will collide with the jth car that is moving\
    \ right to left\e[0m\n\e[31m20 |\e[0m        \e[34m// if and only if i + j + 1\
    \ = n.\e[0m\n\e[31m21 |\e[0m        \e[34m// The number of such collisions is\
    \ the number of pairs (i, j) such that i + j + 1 = n.\e[0m\n\e[31m22 |\e[0m  \
    \      \e[34m// This is the same as the number of pairs (i, j) such that i + j\
    \ = n - 1.\e[0m\n\e[31m23 |\e[0m        \e[34m// This is the same as the number\
    \ of pairs (i, j) such that i + j = n - 1.\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ This is the same as the number of pairs (i, j) such that i + j = n - 1.\e[0m\n\
    \e[31m25 |\e[0m        \e[34m// This is the same as the number of pairs (i, j)\
    \ such that i + j = n - 1.\e[0m\n\e[31m26 |\e[0m        \e[34m// This is the same\
    \ as the number of pairs (i, j) such that i + j = n - 1.\e[0m\n\e[31m27 |\e[0m\
    \        \e[34m// This is the same as the number of pairs (i, j) such that i +\
    \ j = n - 1.\e[0m\n\e[31m28 |\e[0m        \e[34m// This is the same as the number\
    \ of pairs (i, j) such that i + j = n"
  stdout: ''
  timestamp: 1659792889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their position.  Then, we can just\n        // count the number\
    \ of cars that are moving in the same direction.\n        // The number of collisions\
    \ is the number of cars moving in the same direction\n        // minus 1.\n  \
    \      // The number of cars moving in the same direction is the number of cars\n\
    \        // that are moving left to right plus the number of cars that are moving\n\
    \        // right to left.\n        val cars = new Array[(Long, Boolean)](2 *\
    \ n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i) = (i.toLong,\
    \ true)\n            cars(i + n.toInt) = (i.toLong, false)\n        }\n      \
    \  val sortedCars = cars.sortWith((a, b) => a._1 < b._1)\n        var count =\
    \ 0\n        var result = 0L\n        for (i <- 0 until 2 * n.toInt) {\n     \
    \       if (sortedCars(i)._2) count += 1\n            else count -= 1\n      \
    \      result += count - 1\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm9i4o7ii.scala:36)\n\tat Problem.main(tmpm9i4o7ii.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key is to realize that the cars that\n        // are moving left\
    \ to right are numbered 1 to n, and the cars that are moving\n        // right\
    \ to left are numbered n+1 to 2n.  The cars that are moving left to right\n  \
    \      // are at positions 1, 2, 3, ..., n.  The cars that are moving right to\
    \ left\n        // are at positions n+1, n+2, n+3, ..., 2n.\n        // The cars\
    \ that are moving left to right are moving at speed 1.  The cars that\n      \
    \  // are moving right to left are moving at speed -1.  The cars that are moving\n\
    \        // left to right are at positions 1, 2, 3, ..., n.  The cars that are\
    \ moving\n        // right to left are at positions n+1, n+2, n+3, ..., 2n.\n\
    \        // The cars that are moving left to right are moving at speed 1.  The\
    \ cars that\n        // are moving right to left are moving at speed -1.  The\
    \ cars that are moving\n        // left to right are at positions 1, 2, 3, ...,\
    \ n.  The cars that are moving\n        // right to left are at positions n+1,\
    \ n+2, n+3, ..., 2n.\n        // The cars that are moving left to right are moving\
    \ at speed 1.  The cars that\n        // are moving right to left are moving at\
    \ speed -1.  The cars that are moving\n        // left to right are at positions\
    \ 1, 2, 3, ..., n.  The cars that are moving\n        // right to left are at\
    \ positions n+1, n+2, n+3, ..., 2n.\n        // The cars that are moving left\
    \ to right are moving at speed 1.  The cars that\n        // are moving right\
    \ to left are moving at speed -1.  The cars that are moving\n        // left to\
    \ right are at positions 1, 2, 3, ..., n.  The cars that are moving\n        //\
    \ right to left are at positions n+1, n+2, n+3, ..., 2n.\n        // The cars\
    \ that are moving left to right are moving at speed 1.  The cars that\n      \
    \  // are moving right to\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9opus9_h.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  The key is to realize that the cars that\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// are moving left to right are numbered 1 to\
    \ n, and the cars that are moving\e[0m\n\e[31m15 |\e[0m        \e[34m// right\
    \ to left are numbered n+1 to 2n.  The cars that are moving left to right\e[0m\n\
    \e[31m16 |\e[0m        \e[34m// are at positions 1, 2, 3, ..., n.  The cars that\
    \ are moving right to left\e[0m\n\e[31m17 |\e[0m        \e[34m// are at positions\
    \ n+1, n+2, n+3, ..., 2n.\e[0m\n\e[31m18 |\e[0m        \e[34m// The cars that\
    \ are moving left to right are moving at speed 1.  The cars that\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// are moving right to left are moving at speed -1.  The\
    \ cars that are moving\e[0m\n\e[31m20 |\e[0m        \e[34m// left to right are\
    \ at positions 1, 2, 3, ..., n.  The cars that are moving\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// right to left are at positions n+1, n+2, n+3, ..., 2n.\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// The cars that are moving left to right are moving\
    \ at speed 1.  The cars that\e[0m\n\e[31m23 |\e[0m        \e[34m// are moving\
    \ right to left are moving at speed -1.  The cars that are moving\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// left to right are at positions 1, 2, 3, ..., n.  The\
    \ cars that are moving\e[0m\n\e[31m25 |\e[0m        \e[34m// right to left are\
    \ at positions n+1, n+2, n+3, ..., 2n.\e[0m\n\e[31m26 |\e[0m        \e[34m// The\
    \ cars that are moving left to right are moving at speed 1.  The cars that\e[0m\n\
    \e[31m27 |\e[0m        \e[34m// are moving right to left are moving at speed -1.\
    \  The cars that are moving\e[0m\n\e[31m28 |\e[0m        \e[34m// left to right\
    \ are at positions 1, 2, 3, ..., n.  The c"
  stdout: ''
  timestamp: 1659792890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just count the\
    \ number of collisions by counting the number of cars\n        // that start in\
    \ the same position.\n        // The number of collisions is the number of cars\
    \ that start in the same position\n        // multiplied by the number of cars\
    \ that start in the same position.\n        // The number of cars that start in\
    \ the same position is the number of cars that start\n        // in the same position\
    \ multiplied by the number of cars that start in the same position.\n        //\
    \ The number of cars that start in the same position is the number of cars that\
    \ start\n        // in the same position multiplied by the number of cars that\
    \ start in the same position.\n        // The number of cars that start in the\
    \ same position is the number of cars that start\n        // in the same position\
    \ multiplied by the number of cars that start in the same position.\n        //\
    \ The number of cars that start in the same position is the number of cars that\
    \ start\n        // in the same position multiplied by the number of cars that\
    \ start in the same position.\n        // The number of cars that start in the\
    \ same position is the number of cars that start\n        // in the same position\
    \ multiplied by the number of cars that start in the same position.\n        //\
    \ The number of cars that start in the same position is the number of cars that\
    \ start\n        // in the same position multiplied by the number of cars that\
    \ start in the same position.\n        // The number of cars that start in the\
    \ same position is the number of cars that start\n        // in the same position\
    \ multiplied by the number of cars that start in the same position.\n        //\
    \ The number of cars that start in the same position is the number of cars that\
    \ start\n        // in the same position multiplied by the number of cars that\
    \ start in the same position.\n        // The number of cars that start in the\
    \ same position is the number of cars that start\n        // in the same position\
    \ multiplied by the number of cars that start in the same position.\n        //\
    \ The number of cars that start in the same position is the number of cars that\
    \ start\n        // in the same position multiplied by the number of cars that\
    \ start in the same position.\n        // The number of cars that start in the\
    \ same position is the number of cars that start\n        // in the same position\
    \ multiplied by the number of cars that\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxtpmuh71.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can just count the number of collisions by counting\
    \ the number of cars\e[0m\n\e[31m15 |\e[0m        \e[34m// that start in the same\
    \ position.\e[0m\n\e[31m16 |\e[0m        \e[34m// The number of collisions is\
    \ the number of cars that start in the same position\e[0m\n\e[31m17 |\e[0m   \
    \     \e[34m// multiplied by the number of cars that start in the same position.\e\
    [0m\n\e[31m18 |\e[0m        \e[34m// The number of cars that start in the same\
    \ position is the number of cars that start\e[0m\n\e[31m19 |\e[0m        \e[34m//\
    \ in the same position multiplied by the number of cars that start in the same\
    \ position.\e[0m\n\e[31m20 |\e[0m        \e[34m// The number of cars that start\
    \ in the same position is the number of cars that start\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// in the same position multiplied by the number of cars that start\
    \ in the same position.\e[0m\n\e[31m22 |\e[0m        \e[34m// The number of cars\
    \ that start in the same position is the number of cars that start\e[0m\n\e[31m23\
    \ |\e[0m        \e[34m// in the same position multiplied by the number of cars\
    \ that start in the same position.\e[0m\n\e[31m24 |\e[0m        \e[34m// The number\
    \ of cars that start in the same position is the number of cars that start\e[0m\n\
    \e[31m25 |\e[0m        \e[34m// in the same position multiplied by the number\
    \ of cars that start in the same position.\e[0m\n\e[31m26 |\e[0m        \e[34m//\
    \ The number of cars that start in the same position is the number of cars that\
    \ start\e[0m\n\e[31m27 |\e[0m        \e[34m// in the same position multiplied\
    \ by the number of cars that"
  stdout: ''
  timestamp: 1659792890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 1 to n.  The cars that are moving left to right\n        // are numbered\
    \ 1 to n.  The cars that are moving right to left are numbered\n        // n+1\
    \ to 2n.\n        // The cars that are moving left to right are at positions 1\
    \ to n.\n        // The cars that are moving right to left are at positions 2n\
    \ to n+1.\n        // The cars that are moving left to right are moving at speed\
    \ 1.\n        // The cars that are moving right to left are moving at speed -1.\n\
    \        // The cars are moving at constant speed.  Therefore, the time of collision\n\
    \        // between two cars is the same as the time of collision between the\
    \ two\n        // positions of the cars.\n        // The time of collision between\
    \ two cars is the same as the time of collision\n        // between the two positions\
    \ of the cars.\n        // The time of collision between two positions is the\
    \ same as the time of\n        // collision between the two numbers.\n       \
    \ // The time of collision between two numbers is the same as the time of\n  \
    \      // collision between the two numbers.\n        // The time of collision\
    \ between two numbers is the same as the time of\n        // collision between\
    \ the two numbers.\n        // The time of collision between two numbers is the\
    \ same as the time of\n        // collision between the two numbers.\n       \
    \ // The time of collision between two numbers is the same as the time of\n  \
    \      // collision between the two numbers.\n        // The time of collision\
    \ between two numbers is the same as the time of\n        // collision between\
    \ the two numbers.\n        // The time of collision between two numbers is the\
    \ same as the time of\n        // collision between the two numbers.\n       \
    \ // The time of collision between two numbers is the same as the time of\n  \
    \      // collision between the two numbers.\n        // The time of collision\
    \ between two numbers is the same as the time of\n        // collision between\
    \ the two numbers.\n        // The time of collision between two numbers is the\
    \ same as the time of\n        // collision between the two numbers.\n       \
    \ // The time of collision between two numbers is the same as the time of\n  \
    \      // collision between the two numbers.\n        // The time of collision\
    \ between two numbers is the same as the time of\n        // collision between\
    \ the two numbers.\n        //\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphfdx14sp.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 1 to n.  The cars that are moving left to right\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// are numbered 1 to n.  The cars that are moving\
    \ right to left are numbered\e[0m\n\e[31m15 |\e[0m        \e[34m// n+1 to 2n.\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// The cars that are moving left to right are\
    \ at positions 1 to n.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars that are\
    \ moving right to left are at positions 2n to n+1.\e[0m\n\e[31m18 |\e[0m     \
    \   \e[34m// The cars that are moving left to right are moving at speed 1.\e[0m\n\
    \e[31m19 |\e[0m        \e[34m// The cars that are moving right to left are moving\
    \ at speed -1.\e[0m\n\e[31m20 |\e[0m        \e[34m// The cars are moving at constant\
    \ speed.  Therefore, the time of collision\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ between two cars is the same as the time of collision between the two\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// positions of the cars.\e[0m\n\e[31m23 |\e[0m \
    \       \e[34m// The time of collision between two cars is the same as the time\
    \ of collision\e[0m\n\e[31m24 |\e[0m        \e[34m// between the two positions\
    \ of the cars.\e[0m\n\e[31m25 |\e[0m        \e[34m// The time of collision between\
    \ two positions is the same as the time of\e[0m\n\e[31m26 |\e[0m        \e[34m//\
    \ collision between the two numbers.\e[0m\n\e[31m27 |\e[0m        \e[34m// The\
    \ time of collision between two numbers is the same as the time of\e[0m\n\e[31m28\
    \ |\e[0m        \e[34m// collision between the two numbers.\e[0m\n\e[31m29 |\e\
    [0m        \e[34m// The time of collision between two numbers is the same as the\
    \ time of\e[0m\n\e[31m30 |\e[0m        \e[34m// collision between the two numbers.\e\
    [0m\n\e[31m31 |\e[0m        \e[34m//"
  stdout: ''
  timestamp: 1659792890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the left-to-right\
    \ cars are numbered 1 to n, and the right-to-left cars\n        // are numbered\
    \ n+1 to 2n.  We can represent the cars as a list of pairs (x, v),\n        //\
    \ where x is the starting position of the car, and v is the velocity of the car.\n\
    \        // For example, the left-to-right cars are [(1, 1), (2, 1), (3, 1), ...,\
    \ (n, 1)],\n        // and the right-to-left cars are [(2n, -1), (2n-1, -1), ...,\
    \ (n+1, -1)].\n        // The cars are sorted in the order of their starting positions.\n\
    \        // The cars are moving in the same speed, so the time it takes for a\
    \ car to reach\n        // another car is the difference of their starting positions\
    \ divided by their velocity.\n        // For example, the time it takes for the\
    \ left-to-right car 1 to reach the right-to-left\n        // car 2n is (2n - 1)\
    \ / (1 - (-1)) = 2n - 1.\n        // The time it takes for the right-to-left car\
    \ 2n to reach the left-to-right car 1 is\n        // (2n - 1) / (1 - 1) = 0.\n\
    \        // The time it takes for the left-to-right car 2 to reach the right-to-left\
    \ car 2n-1 is\n        // (2n - 2) / (1 - (-1)) = 2n - 2.\n        // The time\
    \ it takes for the right-to-left car 2n-1 to reach the left-to-right car 2 is\n\
    \        // (2n - 2) / (1 - 1) = 0.\n        // The time it takes for the left-to-right\
    \ car 3 to reach the right-to-left car 2n-2 is\n        // (2n - 3) / (1 - (-1))\
    \ = 2n - 3.\n        // The time it takes for the right-to-left car 2n-2 to reach\
    \ the left-to-right car 3 is\n        // (2n - 3) / (1 - 1) = 0.\n        // ...\n\
    \        //\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptckc7ao7.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say the left-to-right cars are numbered 1 to n, and the right-to-left\
    \ cars\e[0m\n\e[31m14 |\e[0m        \e[34m// are numbered n+1 to 2n.  We can represent\
    \ the cars as a list of pairs (x, v),\e[0m\n\e[31m15 |\e[0m        \e[34m// where\
    \ x is the starting position of the car, and v is the velocity of the car.\e[0m\n\
    \e[31m16 |\e[0m        \e[34m// For example, the left-to-right cars are [(1, 1),\
    \ (2, 1), (3, 1), ..., (n, 1)],\e[0m\n\e[31m17 |\e[0m        \e[34m// and the\
    \ right-to-left cars are [(2n, -1), (2n-1, -1), ..., (n+1, -1)].\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// The cars are sorted in the order of their starting positions.\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// The cars are moving in the same speed, so\
    \ the time it takes for a car to reach\e[0m\n\e[31m20 |\e[0m        \e[34m// another\
    \ car is the difference of their starting positions divided by their velocity.\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// For example, the time it takes for the left-to-right\
    \ car 1 to reach the right-to-left\e[0m\n\e[31m22 |\e[0m        \e[34m// car 2n\
    \ is (2n - 1) / (1 - (-1)) = 2n - 1.\e[0m\n\e[31m23 |\e[0m        \e[34m// The\
    \ time it takes for the right-to-left car 2n to reach the left-to-right car 1\
    \ is\e[0m\n\e[31m24 |\e[0m        \e[34m// (2n - 1) / (1 - 1) = 0.\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// The time it takes for the left-to-right car 2 to reach\
    \ the right-to-left car 2n-1 is\e[0m\n\e[31m26 |\e[0m        \e[34m// (2n - 2)\
    \ / (1 - (-1)) = 2n - 2.\e[0m\n\e[31m27 |\e[0m        \e[34m// The time it takes\
    \ for the right-to-left car 2n-1 to reach the left-to-right car 2 is\e[0m\n\e\
    [31m28 |\e[0m        \e[34m// (2n - 2) / (1 - 1) = 0.\e[0m\n\e[31m29 |\e[0m  \
    \      \e[34m// T"
  stdout: ''
  timestamp: 1659792890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can solve this problem\
    \ by using the pigeonhole principle.\n        // Imagine that the road is divided\
    \ into n segments.  Then, the cars that are\n        // moving left to right will\
    \ occupy n segments, and the cars that are moving\n        // right to left will\
    \ occupy n segments.  Since there are 2n segments and 2n cars,\n        // there\
    \ must be at least one segment that has two cars.  This means that there\n   \
    \     // must be at least one collision.\n        // The number of collisions\
    \ is at least 1, and at most n.\n        // The number of collisions is exactly\
    \ n if and only if the cars that are moving\n        // left to right occupy the\
    \ first n segments, and the cars that are moving right\n        // to left occupy\
    \ the last n segments.\n        // The number of collisions is exactly 1 if and\
    \ only if the cars that are moving\n        // left to right occupy the first\
    \ n segments, and the cars that are moving right\n        // to left occupy the\
    \ first n segments.\n        // The number of collisions is exactly k, where 1\
    \ < k < n, if and only if the cars\n        // that are moving left to right occupy\
    \ the first n segments, and the cars that\n        // are moving right to left\
    \ occupy the last n segments, except that the last k\n        // cars that are\
    \ moving right to left occupy the first k segments.\n        // This means that\
    \ the number of collisions is equal to the number of cars that\n        // are\
    \ moving right to left that occupy the first n segments.\n        // This means\
    \ that the number of collisions is equal to the number of cars that\n        //\
    \ are moving right to left that occupy the first n segments.\n        // This\
    \ means that the number of collisions is equal to the number of cars that\n  \
    \      // are moving right to left that occupy the first n segments.\n       \
    \ // This means that the number of collisions is equal to the number of cars that\n\
    \        // are moving right to left that occupy the first n segments.\n     \
    \   // This means that the number of collisions is equal to the number of cars\
    \ that\n        // are moving right to left that occupy the first n segments.\n\
    \        // This means that the number of collisions is equal to the number of\
    \ cars that\n        // are moving right to left that occupy the first n segments.\n\
    \        // This means that the number of collisions is equal to the number\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmfkmbv3k.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We can solve this problem by using the pigeonhole principle.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Imagine that the road is divided into n segments.  Then,\
    \ the cars that are\e[0m\n\e[31m15 |\e[0m        \e[34m// moving left to right\
    \ will occupy n segments, and the cars that are moving\e[0m\n\e[31m16 |\e[0m \
    \       \e[34m// right to left will occupy n segments.  Since there are 2n segments\
    \ and 2n cars,\e[0m\n\e[31m17 |\e[0m        \e[34m// there must be at least one\
    \ segment that has two cars.  This means that there\e[0m\n\e[31m18 |\e[0m    \
    \    \e[34m// must be at least one collision.\e[0m\n\e[31m19 |\e[0m        \e\
    [34m// The number of collisions is at least 1, and at most n.\e[0m\n\e[31m20 |\e\
    [0m        \e[34m// The number of collisions is exactly n if and only if the cars\
    \ that are moving\e[0m\n\e[31m21 |\e[0m        \e[34m// left to right occupy the\
    \ first n segments, and the cars that are moving right\e[0m\n\e[31m22 |\e[0m \
    \       \e[34m// to left occupy the last n segments.\e[0m\n\e[31m23 |\e[0m   \
    \     \e[34m// The number of collisions is exactly 1 if and only if the cars that\
    \ are moving\e[0m\n\e[31m24 |\e[0m        \e[34m// left to right occupy the first\
    \ n segments, and the cars that are moving right\e[0m\n\e[31m25 |\e[0m       \
    \ \e[34m// to left occupy the first n segments.\e[0m\n\e[31m26 |\e[0m        \e\
    [34m// The number of collisions is exactly k, where 1 < k < n, if and only if\
    \ the cars\e[0m\n\e[31m27 |\e[0m        \e[34m// that are moving left to right\
    \ occupy the first n segments, and the cars that\e[0m\n\e[31m28 |\e[0m       \
    \ \e[34m// are moving right to left occupy the last n segments, except that the\
    \ last k\e[0m\n\e[31m29 |\e[0m        \e[34m// cars"
  stdout: ''
  timestamp: 1659792891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can simply count\
    \ the number of cars that are moving\n        // in the same direction.\n    \
    \    // The number of collisions is the number of cars that are moving\n     \
    \   // in the same direction minus 1.\n        val cars = ArrayBuffer[(Long, Boolean)]()\n\
    \        for (i <- 1 to n.toInt) {\n            cars += ((i, true))\n        \
    \    cars += ((i, false))\n        }\n        val sortedCars = cars.sortWith((a,\
    \ b) => a._1 < b._1)\n        var count = 0\n        var collision = 0\n     \
    \   for (i <- 0 until sortedCars.length) {\n            if (sortedCars(i)._2)\
    \ count += 1\n            else count -= 1\n            if (count > 1) collision\
    \ += 1\n        }\n        collision\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoia54lsl.scala:34)\n\tat Problem.main(tmpoia54lsl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the sorted list and count the number of cars\n        // that are moving in\
    \ the opposite direction.\n        // The time complexity is O(n log n).\n   \
    \     val cars = Array.fill(n.toInt)((0, 0))\n        for (i <- 0 until n.toInt)\
    \ {\n            val Array(x, v) = readLine.split(\" \").map(_.toInt)\n      \
    \      cars(i) = (x, v)\n        }\n        val sortedCars = cars.sortBy(_._1)\n\
    \        var count = 0\n        for (i <- 0 until n.toInt) {\n            val\
    \ (x, v) = sortedCars(i)\n            if (v < 0) {\n                count += 1\n\
    \            }\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkfv1fl70.scala:19:30 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m Array(x, v) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                          \
    \    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found: readLine\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkfv1fl70.scala:19:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e\
    [0m Array(x, v) = readLine.split(\e[31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m\
    \   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                      Recursive\
    \ \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpkfv1fl70.scala:19:25 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m Array(x, v) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                         ^\e\
    [0m\n\e[31m   |\e[0m                         Recursive \e[33mvalue\e[0m \e[35m$1$\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659792889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The key observation\
    \ is that the cars that are moving in the same direction\n        // never collide.\
    \  So, we can focus on the collisions between the cars that\n        // are moving\
    \ in opposite directions.\n        // The cars that are moving in the same direction\
    \ are in a bijection with\n        // the natural numbers.  The cars that are\
    \ moving in the opposite direction\n        // are in a bijection with the negative\
    \ natural numbers.\n        // The car that's moving left to right with speed\
    \ 1 is in a bijection with 1.\n        // The car that's moving right to left\
    \ with speed 1 is in a bijection with -1.\n        // The car that's moving left\
    \ to right with speed 2 is in a bijection with 2.\n        // The car that's moving\
    \ right to left with speed 2 is in a bijection with -2.\n        // The car that's\
    \ moving left to right with speed 3 is in a bijection with 3.\n        // The\
    \ car that's moving right to left with speed 3 is in a bijection with -3.\n  \
    \      // ...\n        // The car that's moving left to right with speed n is\
    \ in a bijection with n.\n        // The car that's moving right to left with\
    \ speed n is in a bijection with -n.\n        // The car that's moving left to\
    \ right with speed n + 1 is in a bijection with n + 1.\n        // The car that's\
    \ moving right to left with speed n + 1 is in a bijection with -(n + 1).\n   \
    \     // ...\n        // The car that's moving left to right with speed 2n is\
    \ in a bijection with 2n.\n        // The car that's moving right to left with\
    \ speed 2n is in a bijection with -2n.\n        // The car that's moving left\
    \ to right with speed 2n + 1 is in a bijection with 2n + 1.\n        // The car\
    \ that's moving right to left with speed 2n + 1 is in a bijection with -(2n +\
    \ 1).\n        // ...\n        // The car that's moving left to right with speed\
    \ 3n is in a bijection with 3n.\n        // The car that's moving right to left\
    \ with speed 3n is in a bijection with -3n.\n        // The car that's moving\
    \ left to right with speed 3n +\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbo0y2rey.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The key observation is that the cars that are moving in the same direction\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// never collide.  So, we can focus on the collisions\
    \ between the cars that\e[0m\n\e[31m15 |\e[0m        \e[34m// are moving in opposite\
    \ directions.\e[0m\n\e[31m16 |\e[0m        \e[34m// The cars that are moving in\
    \ the same direction are in a bijection with\e[0m\n\e[31m17 |\e[0m        \e[34m//\
    \ the natural numbers.  The cars that are moving in the opposite direction\e[0m\n\
    \e[31m18 |\e[0m        \e[34m// are in a bijection with the negative natural numbers.\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// The car that's moving left to right with\
    \ speed 1 is in a bijection with 1.\e[0m\n\e[31m20 |\e[0m        \e[34m// The\
    \ car that's moving right to left with speed 1 is in a bijection with -1.\e[0m\n\
    \e[31m21 |\e[0m        \e[34m// The car that's moving left to right with speed\
    \ 2 is in a bijection with 2.\e[0m\n\e[31m22 |\e[0m        \e[34m// The car that's\
    \ moving right to left with speed 2 is in a bijection with -2.\e[0m\n\e[31m23\
    \ |\e[0m        \e[34m// The car that's moving left to right with speed 3 is in\
    \ a bijection with 3.\e[0m\n\e[31m24 |\e[0m        \e[34m// The car that's moving\
    \ right to left with speed 3 is in a bijection with -3.\e[0m\n\e[31m25 |\e[0m\
    \        \e[34m// ...\e[0m\n\e[31m26 |\e[0m        \e[34m// The car that's moving\
    \ left to right with speed n is in a bijection with n.\e[0m\n\e[31m27 |\e[0m \
    \       \e[34m// The car that's moving right to left with speed n is in a bijection\
    \ with -n.\e[0m\n\e[31m28 |\e[0m        \e[34m// The car that's moving left to\
    \ right with speed n + 1 is in a bijection with n + 1.\e[0m\n\e[31m29 |\e[0m \
    \       \e[34m// The "
  stdout: ''
  timestamp: 1659792891
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can use a sweep line\
    \ algorithm to find the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // 1.  Sort the cars by their starting positions.\n\
    \        // 2.  For each car, we will keep track of the number of cars that are\n\
    \        //     currently in front of it.  We will also keep track of the number\
    \ of\n        //     cars that are currently behind it.\n        // 3.  We will\
    \ keep track of the number of collisions.\n        // 4.  We will keep track of\
    \ the number of cars that are currently on the road.\n        // 5.  We will keep\
    \ track of the number of cars that are currently on the road\n        //     and\
    \ are moving left to right.\n        // 6.  We will keep track of the number of\
    \ cars that are currently on the road\n        //     and are moving right to\
    \ left.\n        // 7.  We will keep track of the number of cars that are currently\
    \ on the road\n        //     and are moving left to right and are currently in\
    \ front of the current car.\n        // 8.  We will keep track of the number of\
    \ cars that are currently on the road\n        //     and are moving right to\
    \ left and are currently behind the current car.\n        // 9.  We will keep\
    \ track of the number of cars that are currently on the road\n        //     and\
    \ are moving left to right and are currently behind the current car.\n       \
    \ // 10. We will keep track of the number of cars that are currently on the road\n\
    \        //     and are moving right to left and are currently in front of the\
    \ current car.\n        // 11. We will keep track of the number of cars that are\
    \ currently on the road\n        //     and are moving left to right and are currently\
    \ in front of the current car\n        //     and are currently in front of the\
    \ current car.\n        // 12. We will keep track of the number of cars that are\
    \ currently on the road\n        //     and are moving right to left and are currently\
    \ behind the current car\n        //     and are currently behind the current\
    \ car.\n        // 13. We will keep track of the number of cars that are currently\
    \ on the road\n        //     and are moving left to right and are currently behind\
    \ the current car\n\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkj6ukthr.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can use a sweep line algorithm to find the number\
    \ of collisions.\e[0m\n\e[31m15 |\e[0m        \e[34m// The sweep line algorithm\
    \ is as follows:\e[0m\n\e[31m16 |\e[0m        \e[34m// 1.  Sort the cars by their\
    \ starting positions.\e[0m\n\e[31m17 |\e[0m        \e[34m// 2.  For each car,\
    \ we will keep track of the number of cars that are\e[0m\n\e[31m18 |\e[0m    \
    \    \e[34m//     currently in front of it.  We will also keep track of the number\
    \ of\e[0m\n\e[31m19 |\e[0m        \e[34m//     cars that are currently behind\
    \ it.\e[0m\n\e[31m20 |\e[0m        \e[34m// 3.  We will keep track of the number\
    \ of collisions.\e[0m\n\e[31m21 |\e[0m        \e[34m// 4.  We will keep track\
    \ of the number of cars that are currently on the road.\e[0m\n\e[31m22 |\e[0m\
    \        \e[34m// 5.  We will keep track of the number of cars that are currently\
    \ on the road\e[0m\n\e[31m23 |\e[0m        \e[34m//     and are moving left to\
    \ right.\e[0m\n\e[31m24 |\e[0m        \e[34m// 6.  We will keep track of the number\
    \ of cars that are currently on the road\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \     and are moving right to left.\e[0m\n\e[31m26 |\e[0m        \e[34m// 7. \
    \ We will keep track of the number of cars that are currently on the road\e[0m\n\
    \e[31m27 |\e[0m        \e[34m//     and are moving left to right and are currently\
    \ in front of the current car.\e[0m\n\e[31m28 |\e[0m        \e[34m// 8.  We will\
    \ keep track of the number of cars that are currently on the road\e[0m\n\e[31m29\
    \ |\e[0m        \e[34m//     and are moving right to left and are currently behind\
    \ the current car.\e[0m\n\e[31m30 |\e[0m     "
  stdout: ''
  timestamp: 1659792892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the cars\
    \ are numbered from 1 to n.\n        // Let's say the cars that are moving left\
    \ to right are numbered from 1 to n.\n        // Let's say the cars that are moving\
    \ right to left are numbered from n to 1.\n        // Let's say the cars that\
    \ are moving left to right are at positions x1, x2, ..., xn.\n        // Let's\
    \ say the cars that are moving right to left are at positions y1, y2, ..., yn.\n\
    \        // Let's say the cars that are moving left to right are moving at speeds\
    \ s1, s2, ..., sn.\n        // Let's say the cars that are moving right to left\
    \ are moving at speeds t1, t2, ..., tn.\n        // Let's say the cars that are\
    \ moving left to right are at positions x1, x2, ..., xn.\n        // Let's say\
    \ the cars that are moving right to left are at positions y1, y2, ..., yn.\n \
    \       // Let's say the cars that are moving left to right are moving at speeds\
    \ s1, s2, ..., sn.\n        // Let's say the cars that are moving right to left\
    \ are moving at speeds t1, t2, ..., tn.\n        // Let's say the cars that are\
    \ moving left to right are at positions x1, x2, ..., xn.\n        // Let's say\
    \ the cars that are moving right to left are at positions y1, y2, ..., yn.\n \
    \       // Let's say the cars that are moving left to right are moving at speeds\
    \ s1, s2, ..., sn.\n        // Let's say the cars that are moving right to left\
    \ are moving at speeds t1, t2, ..., tn.\n        // Let's say the cars that are\
    \ moving left to right are at positions x1, x2, ..., xn.\n        // Let's say\
    \ the cars that are moving right to left are at positions y1, y2, ..., yn.\n \
    \       // Let's say the cars that are moving left to right are moving at speeds\
    \ s1, s2, ..., sn.\n        // Let's say the cars that are moving right to left\
    \ are moving at speeds t1, t2, ..., tn.\n        //\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1b7njmm4.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say the cars are numbered from 1 to n.\e[0m\n\e[31m14 |\e[0m    \
    \    \e[34m// Let's say the cars that are moving left to right are numbered from\
    \ 1 to n.\e[0m\n\e[31m15 |\e[0m        \e[34m// Let's say the cars that are moving\
    \ right to left are numbered from n to 1.\e[0m\n\e[31m16 |\e[0m        \e[34m//\
    \ Let's say the cars that are moving left to right are at positions x1, x2, ...,\
    \ xn.\e[0m\n\e[31m17 |\e[0m        \e[34m// Let's say the cars that are moving\
    \ right to left are at positions y1, y2, ..., yn.\e[0m\n\e[31m18 |\e[0m      \
    \  \e[34m// Let's say the cars that are moving left to right are moving at speeds\
    \ s1, s2, ..., sn.\e[0m\n\e[31m19 |\e[0m        \e[34m// Let's say the cars that\
    \ are moving right to left are moving at speeds t1, t2, ..., tn.\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// Let's say the cars that are moving left to right are\
    \ at positions x1, x2, ..., xn.\e[0m\n\e[31m21 |\e[0m        \e[34m// Let's say\
    \ the cars that are moving right to left are at positions y1, y2, ..., yn.\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// Let's say the cars that are moving left to right\
    \ are moving at speeds s1, s2, ..., sn.\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ Let's say the cars that are moving right to left are moving at speeds t1, t2,\
    \ ..., tn.\e[0m\n\e[31m24 |\e[0m        \e[34m// Let's say the cars that are moving\
    \ left to right are at positions x1, x2, ..., xn.\e[0m\n\e[31m25 |\e[0m      \
    \  \e[34m// Let's say the cars that are moving right to left are at positions\
    \ y1, y2, ..., yn.\e[0m\n\e[31m26 |\e[0m        \e[34m// Let's say the cars that\
    \ are moving left to right are moving at speeds s1, s2, ..., sn.\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// Let's say the "
  stdout: ''
  timestamp: 1659792677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can see that the number\
    \ of collisions is the number of cars\n        // that are moving left to right\
    \ that are to the left of the car that's\n        // moving right to left.\n \
    \       // The number of cars that are moving left to right that are to the left\
    \ of\n        // the car that's moving right to left is the same as the number\
    \ of cars\n        // that are moving right to left that are to the right of the\
    \ car that's\n        // moving left to right.\n        // So, we can just sort\
    \ the cars by their starting position, and then\n        // count the number of\
    \ cars that are moving right to left that are to the\n        // right of the\
    \ car that's moving left to right.\n        // This is the same as the number\
    \ of cars that are moving right to left\n        // that are to the right of the\
    \ car that's moving left to right.\n        // This is the same as the number\
    \ of cars that are moving left to right\n        // that are to the left of the\
    \ car that's moving right to left.\n        // This is the same as the number\
    \ of collisions.\n        // So, we can just sort the cars by their starting position,\
    \ and then\n        // count the number of cars that are moving right to left\
    \ that are to the\n        // right of the car that's moving left to right.\n\
    \        // This is the same as the number of cars that are moving right to left\n\
    \        // that are to the right of the car that's moving left to right.\n  \
    \      // This is the same as the number of cars that are moving left to right\n\
    \        // that are to the left of the car that's moving right to left.\n   \
    \     // This is the same as the number of collisions.\n        // So, we can\
    \ just sort the cars by their starting position, and then\n        // count the\
    \ number of cars that are moving right to left that are to the\n        // right\
    \ of the car that's moving left to right.\n        // This is the same as the\
    \ number of cars that are moving right to left\n        // that are to the right\
    \ of the car that's moving left to right.\n        // This is the same as the\
    \ number of cars that are moving left to right\n        // that are to the left\
    \ of the car that's\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6k8dd7wj.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can see that the number of collisions is the\
    \ number of cars\e[0m\n\e[31m15 |\e[0m        \e[34m// that are moving left to\
    \ right that are to the left of the car that's\e[0m\n\e[31m16 |\e[0m        \e\
    [34m// moving right to left.\e[0m\n\e[31m17 |\e[0m        \e[34m// The number\
    \ of cars that are moving left to right that are to the left of\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// the car that's moving right to left is the same as the\
    \ number of cars\e[0m\n\e[31m19 |\e[0m        \e[34m// that are moving right to\
    \ left that are to the right of the car that's\e[0m\n\e[31m20 |\e[0m        \e\
    [34m// moving left to right.\e[0m\n\e[31m21 |\e[0m        \e[34m// So, we can\
    \ just sort the cars by their starting position, and then\e[0m\n\e[31m22 |\e[0m\
    \        \e[34m// count the number of cars that are moving right to left that\
    \ are to the\e[0m\n\e[31m23 |\e[0m        \e[34m// right of the car that's moving\
    \ left to right.\e[0m\n\e[31m24 |\e[0m        \e[34m// This is the same as the\
    \ number of cars that are moving right to left\e[0m\n\e[31m25 |\e[0m        \e\
    [34m// that are to the right of the car that's moving left to right.\e[0m\n\e\
    [31m26 |\e[0m        \e[34m// This is the same as the number of cars that are\
    \ moving left to right\e[0m\n\e[31m27 |\e[0m        \e[34m// that are to the left\
    \ of the car that's moving right to left.\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ This is the same as the number of collisions.\e[0m\n\e[31m29 |\e[0m        \e\
    [34m// So, we can just sort the cars by their starting position, and then\e[0m\n\
    \e[31m30 |\e[0m        \e[34m// count the number of cars that are"
  stdout: ''
  timestamp: 1659792893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a simple problem\
    \ that can be solved by brute force.\n        // However, the problem is that\
    \ the brute force solution is too slow.\n        // We need to find a faster solution.\n\
    \        //\n        // First, let's consider the case where n = 1.  In this case,\
    \ there are no collisions.\n        //\n        // Now, let's consider the case\
    \ where n = 2.  In this case, there is 1 collision.\n        //\n        // Now,\
    \ let's consider the case where n = 3.  In this case, there are 3 collisions.\n\
    \        //\n        // Now, let's consider the case where n = 4.  In this case,\
    \ there are 6 collisions.\n        //\n        // Now, let's consider the case\
    \ where n = 5.  In this case, there are 10 collisions.\n        //\n        //\
    \ Now, let's consider the case where n = 6.  In this case, there are 15 collisions.\n\
    \        //\n        // Now, let's consider the case where n = 7.  In this case,\
    \ there are 21 collisions.\n        //\n        // Now, let's consider the case\
    \ where n = 8.  In this case, there are 28 collisions.\n        //\n        //\
    \ Now, let's consider the case where n = 9.  In this case, there are 36 collisions.\n\
    \        //\n        // Now, let's consider the case where n = 10.  In this case,\
    \ there are 45 collisions.\n        //\n        // Now, let's consider the case\
    \ where n = 11.  In this case, there are 55 collisions.\n        //\n        //\
    \ Now, let's consider the case where n = 12.  In this case, there are 66 collisions.\n\
    \        //\n        // Now, let's consider the case where n = 13.  In this case,\
    \ there are 78 collisions.\n        //\n        // Now, let's consider the case\
    \ where n = 14.  In this case, there are 91 collisions.\n        //\n        //\
    \ Now, let's consider the case where n = 15.  In this case, there are 105 collisions.\n\
    \        //\n        // Now, let's consider the case where n = 16.  In this case,\
    \ there are 120 collisions.\n        //\n        // Now, let's consider the case\
    \ where n = 17.  In\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3lsudhkx.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a simple problem that can be solved by brute force.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// However, the problem is that the brute force solution\
    \ is too slow.\e[0m\n\e[31m15 |\e[0m        \e[34m// We need to find a faster\
    \ solution.\e[0m\n\e[31m16 |\e[0m        \e[34m//\e[0m\n\e[31m17 |\e[0m      \
    \  \e[34m// First, let's consider the case where n = 1.  In this case, there are\
    \ no collisions.\e[0m\n\e[31m18 |\e[0m        \e[34m//\e[0m\n\e[31m19 |\e[0m \
    \       \e[34m// Now, let's consider the case where n = 2.  In this case, there\
    \ is 1 collision.\e[0m\n\e[31m20 |\e[0m        \e[34m//\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// Now, let's consider the case where n = 3.  In this case, there\
    \ are 3 collisions.\e[0m\n\e[31m22 |\e[0m        \e[34m//\e[0m\n\e[31m23 |\e[0m\
    \        \e[34m// Now, let's consider the case where n = 4.  In this case, there\
    \ are 6 collisions.\e[0m\n\e[31m24 |\e[0m        \e[34m//\e[0m\n\e[31m25 |\e[0m\
    \        \e[34m// Now, let's consider the case where n = 5.  In this case, there\
    \ are 10 collisions.\e[0m\n\e[31m26 |\e[0m        \e[34m//\e[0m\n\e[31m27 |\e\
    [0m        \e[34m// Now, let's consider the case where n = 6.  In this case, there\
    \ are 15 collisions.\e[0m\n\e[31m28 |\e[0m        \e[34m//\e[0m\n\e[31m29 |\e\
    [0m        \e[34m// Now, let's consider the case where n = 7.  In this case, there\
    \ are 21 collisions.\e[0m\n\e[31m30 |\e[0m        \e[34m//\e[0m\n\e[31m31 |\e\
    [0m        \e[34m// Now, let's consider the case where n = 8.  In this case, there\
    \ are 28 collisions.\e[0m\n\e[31m32 |\e[0m        \e[34m//\e[0m\n\e[31m33 |\e\
    [0m        \e[34m// Now, let's consider the case where n = 9.  In this case, there\
    \ are 36 collisions.\e[0m\n\e[31m34 |\e[0m        \e[34m//\e[0m\n\e[31m35 |\e"
  stdout: ''
  timestamp: 1659792893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.  We will sweep from left to right.\n        // We will\
    \ maintain a set of cars that are moving left to right.  We will also\n      \
    \  // maintain a set of cars that are moving right to left.  We will sweep from\
    \ left\n        // to right.  Whenever we encounter a car that's moving left to\
    \ right, we will\n        // add it to the set of cars that are moving left to\
    \ right.  Whenever we encounter\n        // a car that's moving right to left,\
    \ we will add it to the set of cars that are\n        // moving right to left.\
    \  Whenever we encounter a car that's moving left to right,\n        // we will\
    \ remove it from the set of cars that are moving left to right.  Whenever\n  \
    \      // we encounter a car that's moving right to left, we will remove it from\
    \ the set\n        // of cars that are moving right to left.  Whenever we encounter\
    \ a car that's moving\n        // left to right, we will check whether there are\
    \ any cars that are moving right to\n        // left.  If there are, we will increment\
    \ the number of collisions.  Whenever we\n        // encounter a car that's moving\
    \ right to left, we will check whether there are any\n        // cars that are\
    \ moving left to right.  If there are, we will increment the number\n        //\
    \ of collisions.\n        // The number of cars that are moving left to right\
    \ will be n.  The number of cars\n        // that are moving right to left will\
    \ also be n.  The number of cars that are moving\n        // left to right will\
    \ be n.  The number of cars that are moving right to left will\n        // also\
    \ be n.  The number of cars that are moving left to right will be n.  The number\n\
    \        // of cars that are moving right to left will also be n.  The number\
    \ of cars that are\n        // moving left to right will be n.  The number of\
    \ cars that are moving right to left\n        // will also be n.  The number of\
    \ cars that are moving left to right will be n.  The\n        // number of cars\
    \ that are moving right to left will also be n.  The number of cars that\n   \
    \     // are moving left to right will be n.  The number of cars that are moving\
    \ right to left\n        // will\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr6s_8i5o.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a sweep line algorithm.  We will sweep from left to\
    \ right.\e[0m\n\e[31m14 |\e[0m        \e[34m// We will maintain a set of cars\
    \ that are moving left to right.  We will also\e[0m\n\e[31m15 |\e[0m        \e\
    [34m// maintain a set of cars that are moving right to left.  We will sweep from\
    \ left\e[0m\n\e[31m16 |\e[0m        \e[34m// to right.  Whenever we encounter\
    \ a car that's moving left to right, we will\e[0m\n\e[31m17 |\e[0m        \e[34m//\
    \ add it to the set of cars that are moving left to right.  Whenever we encounter\e\
    [0m\n\e[31m18 |\e[0m        \e[34m// a car that's moving right to left, we will\
    \ add it to the set of cars that are\e[0m\n\e[31m19 |\e[0m        \e[34m// moving\
    \ right to left.  Whenever we encounter a car that's moving left to right,\e[0m\n\
    \e[31m20 |\e[0m        \e[34m// we will remove it from the set of cars that are\
    \ moving left to right.  Whenever\e[0m\n\e[31m21 |\e[0m        \e[34m// we encounter\
    \ a car that's moving right to left, we will remove it from the set\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// of cars that are moving right to left.  Whenever we encounter\
    \ a car that's moving\e[0m\n\e[31m23 |\e[0m        \e[34m// left to right, we\
    \ will check whether there are any cars that are moving right to\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// left.  If there are, we will increment the number of\
    \ collisions.  Whenever we\e[0m\n\e[31m25 |\e[0m        \e[34m// encounter a car\
    \ that's moving right to left, we will check whether there are any\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// cars that are moving left to right.  If there are, we\
    \ will increment the number\e[0m\n\e[31m27 |\e[0m        \e[34m// of collisions.\e\
    [0m\n\e[31m28 |\e[0m  "
  stdout: ''
  timestamp: 1659792894
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between the left-to-right cars and\n        // the\
    \ right-to-left cars.\n        def collisionCount(leftToRight : Array[Long], rightToLeft\
    \ : Array[Long]) : Long = {\n            // This function returns the number of\
    \ collisions between the left-to-right cars and\n            // the right-to-left\
    \ cars.  The cars are assumed to be sorted.\n            def collisionCountSorted(leftToRight\
    \ : Array[Long], rightToLeft : Array[Long]) : Long = {\n                // This\
    \ function returns the number of collisions between the left-to-right cars and\n\
    \                // the right-to-left cars.  The cars are assumed to be sorted.\n\
    \                def collisionCountSortedRecursive(leftToRight : Array[Long],\
    \ rightToLeft : Array[Long], leftToRightIndex : Int, rightToLeftIndex : Int) :\
    \ Long = {\n                    if (leftToRightIndex == leftToRight.length ||\
    \ rightToLeftIndex == rightToLeft.length) 0\n                    else if (leftToRight(leftToRightIndex)\
    \ < rightToLeft(rightToLeftIndex)) collisionCountSortedRecursive(leftToRight,\
    \ rightToLeft, leftToRightIndex + 1, rightToLeftIndex)\n                    else\
    \ if (leftToRight(leftToRightIndex) > rightToLeft(rightToLeftIndex)) collisionCountSortedRecursive(leftToRight,\
    \ rightToLeft, leftToRightIndex, rightToLeftIndex + 1)\n                    else\
    \ 1 + collisionCountSortedRecursive(leftToRight, rightToLeft, leftToRightIndex\
    \ + 1, rightToLeftIndex + 1)\n                }\n                collisionCountSortedRecursive(leftToRight,\
    \ rightToLeft, 0, 0)\n            }\n            val sortedLeftToRight = leftToRight.sorted\n\
    \            val sortedRightToLeft = rightToLeft.sorted\n            collisionCountSorted(sortedLeftToRight,\
    \ sortedRightToLeft)\n        }\n        val leftToRight = Array.fill(n.toInt)(0)\n\
    \        val rightToLeft = Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt)\
    \ {\n            leftToRight(i) = i\n            rightToLeft(i\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuqc_1vvu.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuqc_1vvu.scala:48:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m48 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpuqc_1vvu.scala:47:1 ---------------------\e[0m\e[0m\n\
    \e[31m47 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpuqc_1vvu.scala:39:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m39 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1659792897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm to find the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // We start with the leftmost car.  We then move the\
    \ sweep line to the right,\n        // and for each car that we encounter, we\
    \ check if it collides with the leftmost car.\n        // If it does, we increment\
    \ the number of collisions.  Then, we move the leftmost car\n        // to the\
    \ right, and repeat the process.\n        // The sweep line algorithm is O(n log\
    \ n) because we have to sort the cars by their\n        // starting position.\n\
    \        // The sweep line algorithm is O(n) because we have to move the sweep\
    \ line to the right\n        // n times.\n        // The sweep line algorithm\
    \ is O(n) because we have to check if each car collides with\n        // the leftmost\
    \ car.\n        // The sweep line algorithm is O(n log n) because we have to sort\
    \ the cars by their\n        // starting position.\n        // The sweep line\
    \ algorithm is O(n) because we have to move the sweep line to the right\n    \
    \    // n times.\n        // The sweep line algorithm is O(n) because we have\
    \ to check if each car collides with\n        // the leftmost car.\n        //\
    \ The sweep line algorithm is O(n log n) because we have to sort the cars by their\n\
    \        // starting position.\n        // The sweep line algorithm is O(n) because\
    \ we have to move the sweep line to the right\n        // n times.\n        //\
    \ The sweep line algorithm is O(n) because we have to check if each car collides\
    \ with\n        // the leftmost car.\n        // The sweep line algorithm is O(n\
    \ log n) because we have to sort the cars by their\n        // starting position.\n\
    \        // The sweep line algorithm is O(n) because we have to move the sweep\
    \ line to the right\n        // n times.\n        // The sweep line algorithm\
    \ is O(n) because we have to check if each car collides with\n        // the leftmost\
    \ car.\n        // The sweep line algorithm is O(n log n) because we have to sort\
    \ the cars by their\n        // starting position.\n       \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4bwijbhy.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can use a sweep line algorithm to find the number\
    \ of collisions.\e[0m\n\e[31m15 |\e[0m        \e[34m// The sweep line algorithm\
    \ is as follows:\e[0m\n\e[31m16 |\e[0m        \e[34m// We start with the leftmost\
    \ car.  We then move the sweep line to the right,\e[0m\n\e[31m17 |\e[0m      \
    \  \e[34m// and for each car that we encounter, we check if it collides with the\
    \ leftmost car.\e[0m\n\e[31m18 |\e[0m        \e[34m// If it does, we increment\
    \ the number of collisions.  Then, we move the leftmost car\e[0m\n\e[31m19 |\e\
    [0m        \e[34m// to the right, and repeat the process.\e[0m\n\e[31m20 |\e[0m\
    \        \e[34m// The sweep line algorithm is O(n log n) because we have to sort\
    \ the cars by their\e[0m\n\e[31m21 |\e[0m        \e[34m// starting position.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// The sweep line algorithm is O(n) because\
    \ we have to move the sweep line to the right\e[0m\n\e[31m23 |\e[0m        \e\
    [34m// n times.\e[0m\n\e[31m24 |\e[0m        \e[34m// The sweep line algorithm\
    \ is O(n) because we have to check if each car collides with\e[0m\n\e[31m25 |\e\
    [0m        \e[34m// the leftmost car.\e[0m\n\e[31m26 |\e[0m        \e[34m// The\
    \ sweep line algorithm is O(n log n) because we have to sort the cars by their\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// starting position.\e[0m\n\e[31m28 |\e[0m\
    \        \e[34m// The sweep line algorithm is O(n) because we have to move the\
    \ sweep line to the right\e[0m\n\e[31m29 |\e[0m        \e[34m// n times.\e[0m\n\
    \e[31m30 |\e[0m        \e[34m// The sweep line algorithm is O(n) because we have\
    \ to check if each car collides with\e[0m\n\e[31m31 |\e[0m  "
  stdout: ''
  timestamp: 1659792896
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can go through the\
    \ cars in order and see if they collide.\n        // If they do, we can remove\
    \ the car that's moving right to left.\n        // This is because the car that's\
    \ moving left to right will always collide with\n        // the car that's moving\
    \ right to left that's closest to it.\n        // This is because the car that's\
    \ moving left to right will always move faster\n        // than the car that's\
    \ moving right to left.\n        // This is because the car that's moving left\
    \ to right will always move faster\n        // than the car that's moving right\
    \ to left.\n        // This is because the car that's moving left to right will\
    \ always move faster\n        // than the car that's moving right to left.\n \
    \       // This is because the car that's moving left to right will always move\
    \ faster\n        // than the car that's moving right to left.\n        // This\
    \ is because the car that's moving left to right will always move faster\n   \
    \     // than the car that's moving right to left.\n        // This is because\
    \ the car that's moving left to right will always move faster\n        // than\
    \ the car that's moving right to left.\n        // This is because the car that's\
    \ moving left to right will always move faster\n        // than the car that's\
    \ moving right to left.\n        // This is because the car that's moving left\
    \ to right will always move faster\n        // than the car that's moving right\
    \ to left.\n        // This is because the car that's moving left to right will\
    \ always move faster\n        // than the car that's moving right to left.\n \
    \       // This is because the car that's moving left to right will always move\
    \ faster\n        // than the car that's moving right to left.\n        // This\
    \ is because the car that's moving left to right will always move faster\n   \
    \     // than the car that's moving right to left.\n        // This is because\
    \ the car that's moving left to right will always move faster\n        // than\
    \ the car that's moving right to left.\n        // This is because the car that's\
    \ moving left to right will always move faster\n        // than the car that's\
    \ moving right to left.\n        // This is because the car that's moving left\
    \ to right will always move faster\n        //\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq1dsorr7.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can go through the cars in order and see if\
    \ they collide.\e[0m\n\e[31m15 |\e[0m        \e[34m// If they do, we can remove\
    \ the car that's moving right to left.\e[0m\n\e[31m16 |\e[0m        \e[34m// This\
    \ is because the car that's moving left to right will always collide with\e[0m\n\
    \e[31m17 |\e[0m        \e[34m// the car that's moving right to left that's closest\
    \ to it.\e[0m\n\e[31m18 |\e[0m        \e[34m// This is because the car that's\
    \ moving left to right will always move faster\e[0m\n\e[31m19 |\e[0m        \e\
    [34m// than the car that's moving right to left.\e[0m\n\e[31m20 |\e[0m       \
    \ \e[34m// This is because the car that's moving left to right will always move\
    \ faster\e[0m\n\e[31m21 |\e[0m        \e[34m// than the car that's moving right\
    \ to left.\e[0m\n\e[31m22 |\e[0m        \e[34m// This is because the car that's\
    \ moving left to right will always move faster\e[0m\n\e[31m23 |\e[0m        \e\
    [34m// than the car that's moving right to left.\e[0m\n\e[31m24 |\e[0m       \
    \ \e[34m// This is because the car that's moving left to right will always move\
    \ faster\e[0m\n\e[31m25 |\e[0m        \e[34m// than the car that's moving right\
    \ to left.\e[0m\n\e[31m26 |\e[0m        \e[34m// This is because the car that's\
    \ moving left to right will always move faster\e[0m\n\e[31m27 |\e[0m        \e\
    [34m// than the car that's moving right to left.\e[0m\n\e[31m28 |\e[0m       \
    \ \e[34m// This is because the car that's moving left to right will always move\
    \ faster\e[0m\n\e[31m29 |\e[0m        \e[34m// than the car that's moving right\
    \ to left.\e[0m\n\e[31m30 |\e[0m        \e[34m// This is becau"
  stdout: ''
  timestamp: 1659792897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between the cars\n        // that are moving left to\
    \ right and the cars that are moving right to left.\n        // The cars are represented\
    \ by the arrays left and right.\n        // The cars are sorted by their position.\n\
    \        // The cars are moving at the same speed.\n        // The cars are infinitely\
    \ strong and sturdy.\n        // The cars are infinitely long.\n        // The\
    \ cars are moving in a straight line.\n        // The cars are moving in the same\
    \ direction.\n        // The cars are moving in the same direction.\n        //\
    \ The cars are moving in the same direction.\n        // The cars are moving in\
    \ the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        //\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqyj_ygdb.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This function returns the number of collisions between the cars\e[0m\n\e\
    [31m14 |\e[0m        \e[34m// that are moving left to right and the cars that\
    \ are moving right to left.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars are\
    \ represented by the arrays left and right.\e[0m\n\e[31m16 |\e[0m        \e[34m//\
    \ The cars are sorted by their position.\e[0m\n\e[31m17 |\e[0m        \e[34m//\
    \ The cars are moving at the same speed.\e[0m\n\e[31m18 |\e[0m        \e[34m//\
    \ The cars are infinitely strong and sturdy.\e[0m\n\e[31m19 |\e[0m        \e[34m//\
    \ The cars are infinitely long.\e[0m\n\e[31m20 |\e[0m        \e[34m// The cars\
    \ are moving in a straight line.\e[0m\n\e[31m21 |\e[0m        \e[34m// The cars\
    \ are moving in the same direction.\e[0m\n\e[31m22 |\e[0m        \e[34m// The\
    \ cars are moving in the same direction.\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ The cars are moving in the same direction.\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ The cars are moving in the same direction.\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ The cars are moving in the same direction.\e[0m\n\e[31m26 |\e[0m        \e[34m//\
    \ The cars are moving in the same direction.\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ The cars are moving in the same direction.\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ The cars are moving in the same direction.\e[0m\n\e[31m29 |\e[0m        \e[34m//\
    \ The cars are moving in the same direction.\e[0m\n\e[31m30 |\e[0m        \e[34m//\
    \ The cars are moving in the same direction.\e[0m\n\e[31m31 |\e[0m        \e[34m//\
    \ The cars are moving in the same direction.\e[0m\n\e[31m32 |\e[0m        \e[34m//\
    \ The cars are moving in the same direction.\e[0m\n\e[31m33 |\e[0m        \e[34m//\
    \ The cars are moving in the same direction.\e["
  stdout: ''
  timestamp: 1659792897
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can solve it in O(n) time.\n        // The key insight is that\
    \ the cars that collide are the ones that are closest\n        // to each other.\
    \  So we can just sort the cars by their position, and then\n        // count\
    \ the number of cars that are closest to each other.\n        val cars = Array.fill(2\
    \ * n.toInt)(0)\n        for (i <- 0 until n.toInt) {\n            cars(i) = i\n\
    \            cars(i + n.toInt) = -i\n        }\n        val sortedCars = cars.sorted\n\
    \        var collisions = 0\n        for (i <- 0 until 2 * n.toInt - 1) {\n  \
    \          if (sortedCars(i) + sortedCars(i + 1) == 0) collisions += 1\n     \
    \   }\n        collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8034pdzp.scala:30)\n\tat Problem.main(tmp8034pdzp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm to count the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // We start at the leftmost car.  We move the sweep\
    \ line to the right.\n        // When we encounter a car that's moving left to\
    \ right, we add it to a set.\n        // When we encounter a car that's moving\
    \ right to left, we remove it from the set.\n        // If the set is empty, then\
    \ we know that the car we just encountered does not collide\n        // with any\
    \ other car.  If the set is not empty, then we know that the car we just encountered\n\
    \        // collides with every car in the set.\n        // The sweep line algorithm\
    \ runs in O(n log n) time.\n        // The sorting step runs in O(n log n) time.\n\
    \        // The sweep line algorithm runs in O(n) time.\n        // Therefore,\
    \ the total running time is O(n log n).\n        // The total space complexity\
    \ is O(n).\n        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n     \
    \   for (i <- 0 until n.toInt) {\n            cars(i) = (i.toLong, true)\n   \
    \         cars(i + n.toInt) = (i.toLong, false)\n        }\n        val sortedCars\
    \ = cars.sortWith((a, b) => a._1 < b._1)\n        var collisions = 0L\n      \
    \  val set = new HashSet[Long]\n        for (i <- 0 until 2 * n.toInt) {\n   \
    \         if (sortedCars(i)._2) {\n                if (!set.isEmpty) collisions\
    \ += set.size\n                set.add(sortedCars(i)._1)\n            } else {\n\
    \                set.remove(sortedCars(i)._1)\n            }\n        }\n    \
    \    collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe_eaawt0.scala:46)\n\tat Problem.main(tmpe_eaawt0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm.\n        // The sweep line algorithm is as follows:\n        // We\
    \ start at the leftmost car.  We keep track of the number of cars that are\n \
    \       // currently moving left to right.  We also keep track of the number of\
    \ cars that\n        // are currently moving right to left.  We then move the\
    \ sweep line to the rightmost\n        // car.  We then move the sweep line to\
    \ the next car to the right.  When we move the\n        // sweep line to the next\
    \ car to the right, we update the number of cars that are\n        // currently\
    \ moving left to right and the number of cars that are currently moving\n    \
    \    // right to left.  We then move the sweep line to the next car to the right.\
    \  We\n        // continue doing this until we reach the rightmost car.\n    \
    \    // The number of collisions is the number of times that the number of cars\
    \ that are\n        // currently moving left to right is greater than the number\
    \ of cars that are currently\n        // moving right to left.\n        // The\
    \ time complexity of this algorithm is O(n log n).\n        var cars = new Array[(Long,\
    \ Long)](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i)\
    \ = (i.toLong, 1)\n        }\n        for (i <- n.toInt until 2 * n.toInt) {\n\
    \            cars(i) = (i.toLong - n, -1)\n        }\n        cars = cars.sortWith((a,\
    \ b) => a._1 < b._1)\n        var collisions = 0L\n        var leftToRight = 0\n\
    \        var rightToLeft = 0\n        for (i <- 0 until 2 * n.toInt) {\n     \
    \       if (cars(i)._2 == 1) {\n                leftToRight += 1\n           \
    \ } else {\n                rightToLeft += 1\n            }\n            if (leftToRight\
    \ > rightToLeft) {\n                collisions += 1\n            }\n        }\n\
    \        collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppbmlulh8.scala:52)\n\tat Problem.main(tmppbmlulh8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm to count the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // We start at the leftmost car.  We keep track of the\
    \ number of cars that are\n        // currently on the road.  We move the sweep\
    \ line to the right.  When the sweep line\n        // encounters a car that's\
    \ moving left to right, we increment the number of cars\n        // on the road.\
    \  When the sweep line encounters a car that's moving right to left,\n       \
    \ // we decrement the number of cars on the road.  We keep track of the maximum\
    \ number\n        // of cars on the road.  The number of collisions is the maximum\
    \ number of cars on the road\n        // minus 1.\n        // The time complexity\
    \ of this algorithm is O(n log n).\n        val cars = new Array[(Long, Boolean)](2\
    \ * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i) = (i.toLong,\
    \ true)\n            cars(i + n.toInt) = (i.toLong, false)\n        }\n      \
    \  val sortedCars = cars.sortWith((a, b) => a._1 < b._1)\n        var maxCars\
    \ = 0\n        var currentCars = 0\n        for (i <- 0 until 2 * n.toInt) {\n\
    \            if (sortedCars(i)._2) currentCars += 1\n            else currentCars\
    \ -= 1\n            maxCars = max(maxCars, currentCars)\n        }\n        maxCars\
    \ - 1\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8dpqi7lu.scala:40)\n\tat Problem.main(tmp8dpqi7lu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792900
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 1 to n.\n        // The cars that are moving left to right are numbered\
    \ from 1 to n.\n        // The cars that are moving right to left are numbered\
    \ from n to 1.\n        // The cars that are moving left to right are at position\
    \ x1, x2, ..., xn.\n        // The cars that are moving right to left are at position\
    \ y1, y2, ..., yn.\n        // The cars that are moving left to right are moving\
    \ at speed v1, v2, ..., vn.\n        // The cars that are moving right to left\
    \ are moving at speed w1, w2, ..., wn.\n        // We have x1 < x2 < ... < xn\
    \ and y1 > y2 > ... > yn.\n        // We have v1 = v2 = ... = vn and w1 = w2 =\
    \ ... = wn.\n        // We have x1 = yn and xn = y1.\n        // We have v1 =\
    \ w1.\n        // The cars that are moving left to right are numbered from 1 to\
    \ n.\n        // The cars that are moving right to left are numbered from n to\
    \ 1.\n        // The cars that are moving left to right are at position x1, x2,\
    \ ..., xn.\n        // The cars that are moving right to left are at position\
    \ y1, y2, ..., yn.\n        // The cars that are moving left to right are moving\
    \ at speed v1, v2, ..., vn.\n        // The cars that are moving right to left\
    \ are moving at speed w1, w2, ..., wn.\n        // We have x1 < x2 < ... < xn\
    \ and y1 > y2 > ... > yn.\n        // We have v1 = v2 = ... = vn and w1 = w2 =\
    \ ... = wn.\n        // We have x1 = yn and xn = y1.\n        // We have v1 =\
    \ w1.\n        // We have x1 = 0.\n        // We have y1 = 0.\n        // We have\
    \ v1 = 1.\n        // We have w1 = 1.\n        // We have xn = n.\n        //\
    \ We have yn = n.\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr48vjfzp.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 1 to n.\e[0m\n\e[31m14 |\e[0m        \e[34m//\
    \ The cars that are moving left to right are numbered from 1 to n.\e[0m\n\e[31m15\
    \ |\e[0m        \e[34m// The cars that are moving right to left are numbered from\
    \ n to 1.\e[0m\n\e[31m16 |\e[0m        \e[34m// The cars that are moving left\
    \ to right are at position x1, x2, ..., xn.\e[0m\n\e[31m17 |\e[0m        \e[34m//\
    \ The cars that are moving right to left are at position y1, y2, ..., yn.\e[0m\n\
    \e[31m18 |\e[0m        \e[34m// The cars that are moving left to right are moving\
    \ at speed v1, v2, ..., vn.\e[0m\n\e[31m19 |\e[0m        \e[34m// The cars that\
    \ are moving right to left are moving at speed w1, w2, ..., wn.\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// We have x1 < x2 < ... < xn and y1 > y2 > ... > yn.\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// We have v1 = v2 = ... = vn and w1 = w2 =\
    \ ... = wn.\e[0m\n\e[31m22 |\e[0m        \e[34m// We have x1 = yn and xn = y1.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// We have v1 = w1.\e[0m\n\e[31m24 |\e[0m  \
    \      \e[34m// The cars that are moving left to right are numbered from 1 to\
    \ n.\e[0m\n\e[31m25 |\e[0m        \e[34m// The cars that are moving right to left\
    \ are numbered from n to 1.\e[0m\n\e[31m26 |\e[0m        \e[34m// The cars that\
    \ are moving left to right are at position x1, x2, ..., xn.\e[0m\n\e[31m27 |\e\
    [0m        \e[34m// The cars that are moving right to left are at position y1,\
    \ y2, ..., yn.\e[0m\n\e[31m28 |\e[0m        \e[34m// The cars that are moving\
    \ left to right are moving at speed v1, v2, ..., vn.\e[0m\n\e[31m29 |\e[0m   \
    \     \e[34m// The cars that are moving right to left are moving at speed w1,\
    \ w2, ..., wn.\e[0m\n\e[31m30 |\e[0m        \e[34m// We have "
  stdout: ''
  timestamp: 1659792899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can just simulate the cars moving.\n        // We can do this by\
    \ using a set of integers.  The set will contain all the\n        // positions\
    \ of the cars that are moving left to right.  We will then iterate\n        //\
    \ through the set, and for each car, we will check if the car is moving into\n\
    \        // a position that is occupied by a car moving right to left.  If so,\
    \ we will\n        // increment the number of collisions.\n        // We can do\
    \ this in O(n log n) time.\n        var collisions = 0L\n        var leftToRight\
    \ = Set[Long]()\n        for (i <- 1L to n) leftToRight += i\n        for (i <-\
    \ 1L to n) {\n            val position = i * n\n            if (leftToRight.contains(position))\
    \ collisions += 1\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_46kf_uq.scala:30)\n\tat Problem.main(tmp_46kf_uq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792902
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can simply go through\
    \ the sorted list and count the number of\n        // cars that are moving left\
    \ to right and the number of cars that are moving\n        // right to left. \
    \ Whenever the number of cars moving left to right is greater\n        // than\
    \ the number of cars moving right to left, we have a collision.\n        // This\
    \ is because the cars moving left to right are in front of the cars moving\n \
    \       // right to left.\n        // We can do this in O(n log n) time.\n   \
    \     val cars = new Array[(Long, Boolean)](2 * n.toInt)\n        for (i <- 0\
    \ until n.toInt) {\n            cars(i) = (i.toLong, true)\n            cars(i\
    \ + n.toInt) = (i.toLong, false)\n        }\n        val sortedCars = cars.sortWith((a,\
    \ b) => {\n            if (a._1 == b._1) a._2 else a._1 < b._1\n        })\n \
    \       var count = 0L\n        var leftToRight = 0\n        var rightToLeft =\
    \ 0\n        for (i <- 0 until 2 * n.toInt) {\n            if (sortedCars(i)._2)\
    \ leftToRight += 1\n            else rightToLeft += 1\n            count += leftToRight\
    \ - rightToLeft\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp95lv6_ie.scala:40)\n\tat Problem.main(tmp95lv6_ie.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792902
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // For each car that's\
    \ moving left to right, we'll keep track of its position.\n        // The cars\
    \ are numbered from 0 to n - 1.\n        // For each car that's moving right to\
    \ left, we'll keep track of its position.\n        // The cars are numbered from\
    \ 0 to n - 1.\n        // For each car that's moving left to right, we'll keep\
    \ track of its speed.\n        // The speed is a positive integer.\n        //\
    \ For each car that's moving right to left, we'll keep track of its speed.\n \
    \       // The speed is a positive integer.\n        // For each car that's moving\
    \ left to right, we'll keep track of its direction.\n        // The direction\
    \ is either 1 or -1.\n        // For each car that's moving right to left, we'll\
    \ keep track of its direction.\n        // The direction is either 1 or -1.\n\
    \        // For each car that's moving left to right, we'll keep track of its\
    \ time.\n        // The time is a positive integer.\n        // For each car that's\
    \ moving right to left, we'll keep track of its time.\n        // The time is\
    \ a positive integer.\n        // For each car that's moving left to right, we'll\
    \ keep track of its collision time.\n        // The collision time is a positive\
    \ integer.\n        // For each car that's moving right to left, we'll keep track\
    \ of its collision time.\n        // The collision time is a positive integer.\n\
    \        // For each car that's moving left to right, we'll keep track of its\
    \ collision car.\n        // The collision car is a positive integer.\n      \
    \  // For each car that's moving right to left, we'll keep track of its collision\
    \ car.\n        // The collision car is a positive integer.\n        // For each\
    \ car that's moving left to right, we'll keep track of its collision position.\n\
    \        // The collision position is a positive integer.\n        // For each\
    \ car that's moving right to left, we'll keep track of its collision position.\n\
    \        // The collision position is a positive integer.\n        // For each\
    \ car that's moving left to right, we'll keep track of its collision speed.\n\
    \        // The collision speed is a positive integer.\n        // For each car\
    \ that's moving right to left, we'll keep track of its collision speed\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0f3clgng.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// For each car that's moving left to right, we'll keep track of its position.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// The cars are numbered from 0 to n - 1.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// For each car that's moving right to left,\
    \ we'll keep track of its position.\e[0m\n\e[31m16 |\e[0m        \e[34m// The\
    \ cars are numbered from 0 to n - 1.\e[0m\n\e[31m17 |\e[0m        \e[34m// For\
    \ each car that's moving left to right, we'll keep track of its speed.\e[0m\n\e\
    [31m18 |\e[0m        \e[34m// The speed is a positive integer.\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// For each car that's moving right to left, we'll keep\
    \ track of its speed.\e[0m\n\e[31m20 |\e[0m        \e[34m// The speed is a positive\
    \ integer.\e[0m\n\e[31m21 |\e[0m        \e[34m// For each car that's moving left\
    \ to right, we'll keep track of its direction.\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// The direction is either 1 or -1.\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ For each car that's moving right to left, we'll keep track of its direction.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// The direction is either 1 or -1.\e[0m\n\e\
    [31m25 |\e[0m        \e[34m// For each car that's moving left to right, we'll\
    \ keep track of its time.\e[0m\n\e[31m26 |\e[0m        \e[34m// The time is a\
    \ positive integer.\e[0m\n\e[31m27 |\e[0m        \e[34m// For each car that's\
    \ moving right to left, we'll keep track of its time.\e[0m\n\e[31m28 |\e[0m  \
    \      \e[34m// The time is a positive integer.\e[0m\n\e[31m29 |\e[0m        \e\
    [34m// For each car that's moving left to right, we'll keep track of its collision\
    \ time.\e[0m\n\e[31m30 |\e[0m        \e[34m// The collision time is a positive\
    \ integer.\e[0m\n\e[31m31 |\e[0m        \e[34m// For each car tha"
  stdout: ''
  timestamp: 1659792901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key is to realize that the cars\n        // are moving at the\
    \ same speed.  As a result, the order of the cars\n        // does not change.\
    \  The only thing that matters is the distance between\n        // the cars. \
    \ If the distance is positive, then the cars do not collide.\n        // If the\
    \ distance is negative, then the cars collide.\n        // The distance between\
    \ the cars is the difference between the position\n        // of the car moving\
    \ left to right and the position of the car moving right to left.\n        //\
    \ The position of the car moving left to right is the same as the index of the\
    \ car.\n        // The position of the car moving right to left is n - 1 - the\
    \ index of the car.\n        // The distance between the cars is therefore n -\
    \ 1 - 2 * index.\n        // The number of collisions is the number of negative\
    \ distances.\n        // The number of negative distances is the number of indices\
    \ for which\n        // n - 1 - 2 * index is negative.\n        // The number\
    \ of indices for which n - 1 - 2 * index is negative is\n        // the number\
    \ of indices for which index is greater than (n - 1) / 2.\n        // The number\
    \ of indices for which index is greater than (n - 1) / 2 is\n        // (n - 1)\
    \ / 2 + 1.\n        (n - 1) / 2 + 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphjxz1u5z.scala:33)\n\tat Problem.main(tmphjxz1u5z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can simply count\
    \ the number of cars that are moving in the same direction.\n        // The number\
    \ of collisions is the number of cars moving in the same direction minus 1.\n\
    \        // The reason is that the first car in the sorted list does not collide\
    \ with any other cars.\n        // The second car collides with the first car,\
    \ but not with any other cars.\n        // The third car collides with the first\
    \ and second cars, but not with any other cars.\n        // And so on.\n     \
    \   // The total number of collisions is the number of cars minus 1.\n       \
    \ val cars = new Array[(Long, Int)](2 * n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = (i, 1)\n            cars(i + n.toInt) = (i, -1)\n \
    \       }\n        val sortedCars = cars.sortWith((a, b) => a._1 < b._1)\n   \
    \     var collisions = 0L\n        var carsInSameDirection = 0\n        for (car\
    \ <- sortedCars) {\n            if (car._2 == 1) carsInSameDirection += 1\n  \
    \          else carsInSameDirection -= 1\n            collisions += carsInSameDirection\
    \ - 1\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4_64_gkp.scala:37)\n\tat Problem.main(tmp4_64_gkp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792903
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm to find the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // We start with the leftmost car.  We then move the\
    \ sweep line to the right,\n        // and we keep track of the number of cars\
    \ that are moving right to left.\n        // We add the number of cars that are\
    \ moving right to left to the number of collisions.\n        // We then move the\
    \ sweep line to the right, and we keep track of the number of cars\n        //\
    \ that are moving right to left.  We add the number of cars that are moving right\
    \ to left\n        // to the number of collisions.  We repeat this process until\
    \ we reach the rightmost car.\n        // The total number of collisions is the\
    \ number of collisions we found.\n        // The time complexity is O(n log n)\
    \ because we need to sort the cars.\n        // The space complexity is O(n) because\
    \ we need to store the cars in an array.\n        val cars = new Array[(Long,\
    \ Boolean)](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i)\
    \ = (i, true)\n            cars(i + n.toInt) = (i, false)\n        }\n       \
    \ val sortedCars = cars.sortWith((a, b) => if (a._1 == b._1) a._2 else a._1 <\
    \ b._1)\n        var collisions = 0L\n        var numCarsMovingRightToLeft = 0\n\
    \        for (i <- 0 until 2 * n.toInt) {\n            if (sortedCars(i)._2) {\n\
    \                collisions += numCarsMovingRightToLeft\n            } else {\n\
    \                numCarsMovingRightToLeft += 1\n            }\n        }\n   \
    \     collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa1tufbzs.scala:43)\n\tat Problem.main(tmpa1tufbzs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their position.  Then, we can simply count the number of\n     \
    \   // cars that are moving in the same direction.\n        // The number of cars\
    \ moving in the same direction is the number of collisions.\n        // The number\
    \ of cars moving in the same direction is the number of collisions.\n        //\
    \ The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving in the same direction is the number of collisions.\n\
    \        // The number of cars moving\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpamp7i65r.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their position.  Then, we can simply count\
    \ the number of\e[0m\n\e[31m14 |\e[0m        \e[34m// cars that are moving in\
    \ the same direction.\e[0m\n\e[31m15 |\e[0m        \e[34m// The number of cars\
    \ moving in the same direction is the number of collisions.\e[0m\n\e[31m16 |\e\
    [0m        \e[34m// The number of cars moving in the same direction is the number\
    \ of collisions.\e[0m\n\e[31m17 |\e[0m        \e[34m// The number of cars moving\
    \ in the same direction is the number of collisions.\e[0m\n\e[31m18 |\e[0m   \
    \     \e[34m// The number of cars moving in the same direction is the number of\
    \ collisions.\e[0m\n\e[31m19 |\e[0m        \e[34m// The number of cars moving\
    \ in the same direction is the number of collisions.\e[0m\n\e[31m20 |\e[0m   \
    \     \e[34m// The number of cars moving in the same direction is the number of\
    \ collisions.\e[0m\n\e[31m21 |\e[0m        \e[34m// The number of cars moving\
    \ in the same direction is the number of collisions.\e[0m\n\e[31m22 |\e[0m   \
    \     \e[34m// The number of cars moving in the same direction is the number of\
    \ collisions.\e[0m\n\e[31m23 |\e[0m        \e[34m// The number of cars moving\
    \ in the same direction is the number of collisions.\e[0m\n\e[31m24 |\e[0m   \
    \     \e[34m// The number of cars moving in the same direction is the number of\
    \ collisions.\e[0m\n\e[31m25 |\e[0m        \e[34m// The number of cars moving\
    \ in the same direction is the number of collisions.\e[0m\n\e[31m26 |\e[0m   \
    \     \e[34m// The number of cars moving in the same direction is the number of\
    \ collisions.\e[0m\n\e[31m27 |\e[0m        \e[34m// The number of cars moving\
    \ in the same direction is the number of collisions.\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659792902
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key is to realize that the cars that are\n        // moving in\
    \ the same direction will never collide.  The only collisions are\n        //\
    \ between cars that are moving in opposite directions.  The cars that are moving\n\
    \        // in the same direction will never collide because they are moving in\
    \ the same\n        // direction.  The cars that are moving in opposite directions\
    \ will collide if\n        // and only if they are at the same position at the\
    \ same time.  The cars that are\n        // moving in the same direction will\
    \ never collide because they are moving in the\n        // same direction.  The\
    \ cars that are moving in opposite directions will collide\n        // if and\
    \ only if they are at the same position at the same time.  The cars that\n   \
    \     // are moving in the same direction will never collide because they are\
    \ moving in\n        // the same direction.  The cars that are moving in opposite\
    \ directions will collide\n        // if and only if they are at the same position\
    \ at the same time.  The cars that are\n        // moving in the same direction\
    \ will never collide because they are moving in the\n        // same direction.\
    \  The cars that are moving in opposite directions will collide\n        // if\
    \ and only if they are at the same position at the same time.  The cars that are\n\
    \        // moving in the same direction will never collide because they are moving\
    \ in the\n        // same direction.  The cars that are moving in opposite directions\
    \ will collide\n        // if and only if they are at the same position at the\
    \ same time.  The cars that are\n        // moving in the same direction will\
    \ never collide because they are moving in the\n        // same direction.  The\
    \ cars that are moving in opposite directions will collide\n        // if and\
    \ only if they are at the same position at the same time.  The cars that are\n\
    \        // moving in the same direction will never collide because they are moving\
    \ in the\n        // same direction.  The cars that are moving in opposite directions\
    \ will collide\n        // if and only if they are at the same position at the\
    \ same time.  The cars that are\n        // moving in the same direction will\
    \ never collide because they are moving in the\n        // same direction.  The\
    \ cars that are moving in opposite directions will collide\n        // if and\
    \ only if they are at the same position at the same time.  The cars that are\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp59iyla8z.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  The key is to realize that the cars that\
    \ are\e[0m\n\e[31m14 |\e[0m        \e[34m// moving in the same direction will\
    \ never collide.  The only collisions are\e[0m\n\e[31m15 |\e[0m        \e[34m//\
    \ between cars that are moving in opposite directions.  The cars that are moving\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// in the same direction will never collide\
    \ because they are moving in the same\e[0m\n\e[31m17 |\e[0m        \e[34m// direction.\
    \  The cars that are moving in opposite directions will collide if\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// and only if they are at the same position at the same\
    \ time.  The cars that are\e[0m\n\e[31m19 |\e[0m        \e[34m// moving in the\
    \ same direction will never collide because they are moving in the\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// same direction.  The cars that are moving in opposite\
    \ directions will collide\e[0m\n\e[31m21 |\e[0m        \e[34m// if and only if\
    \ they are at the same position at the same time.  The cars that\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// are moving in the same direction will never collide because\
    \ they are moving in\e[0m\n\e[31m23 |\e[0m        \e[34m// the same direction.\
    \  The cars that are moving in opposite directions will collide\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// if and only if they are at the same position at the same\
    \ time.  The cars that are\e[0m\n\e[31m25 |\e[0m        \e[34m// moving in the\
    \ same direction will never collide because they are moving in the\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// same direction.  The cars that are moving in opposite\
    \ directions will collide\e[0m\n\e[31m27 |\e[0m        \e[34m// if and only if\
    \ they are at the same position "
  stdout: ''
  timestamp: 1659792902
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position and then\n        // count the number of\
    \ cars that are moving in the same direction.\n        // The number of collisions\
    \ is the number of cars moving in the same direction\n        // minus 1.\n  \
    \      val leftToRight = Array.fill(n.toInt)(0)\n        val rightToLeft = Array.fill(n.toInt)(0)\n\
    \        for (i <- 0 until n.toInt) {\n            val Array(x, y) = readLine.split(\"\
    \ \").map(_.toInt)\n            if (x < y) leftToRight(i) = 1\n            else\
    \ rightToLeft(i) = 1\n        }\n        var collisions = 0\n        for (i <-\
    \ 0 until n.toInt) {\n            if (leftToRight(i) == 1) {\n               \
    \ for (j <- i + 1 until n.toInt) {\n                    if (leftToRight(j) ==\
    \ 1) collisions += 1\n                }\n            }\n            if (rightToLeft(i)\
    \ == 1) {\n                for (j <- i + 1 until n.toInt) {\n                \
    \    if (rightToLeft(j) == 1) collisions += 1\n                }\n           \
    \ }\n        }\n        collisions\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsthphn_g.scala:20:30 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m Array(x, y) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                          \
    \    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found: readLine\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsthphn_g.scala:20:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e\
    [0m Array(x, y) = readLine.split(\e[31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m\
    \   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                      Recursive\
    \ \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpsthphn_g.scala:20:25 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m Array(x, y) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                         ^\e\
    [0m\n\e[31m   |\e[0m                         Recursive \e[33mvalue\e[0m \e[35m$1$\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659792900
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can solve this problem\
    \ using the pigeonhole principle.\n        // Imagine a line of n cars moving\
    \ left to right.  We can place n pigeons\n        // in the n cars.  Now imagine\
    \ a line of n cars moving right to left.\n        // We can place n pigeons in\
    \ the n cars.  The pigeonhole principle says\n        // that at least one pigeon\
    \ must be in two cars.  This means that at least\n        // one car is moving\
    \ left to right and another car is moving right to left.\n        // This means\
    \ that there is at least one collision.\n        // The number of collisions is\
    \ at least n.\n        // The number of collisions is at most n^2.\n        //\
    \ The number of collisions is exactly n^2.\n        // The number of collisions\
    \ is exactly n^2 - n.\n        // The number of collisions is exactly n^2 - 2n.\n\
    \        // The number of collisions is exactly n^2 - 3n.\n        // The number\
    \ of collisions is exactly n^2 - 4n.\n        // The number of collisions is exactly\
    \ n^2 - 5n.\n        // The number of collisions is exactly n^2 - 6n.\n      \
    \  // The number of collisions is exactly n^2 - 7n.\n        // The number of\
    \ collisions is exactly n^2 - 8n.\n        // The number of collisions is exactly\
    \ n^2 - 9n.\n        // The number of collisions is exactly n^2 - 10n.\n     \
    \   // The number of collisions is exactly n^2 - 11n.\n        // The number of\
    \ collisions is exactly n^2 - 12n.\n        // The number of collisions is exactly\
    \ n^2 - 13n.\n        // The number of collisions is exactly n^2 - 14n.\n    \
    \    // The number of collisions is exactly n^2 - 15n.\n        // The number\
    \ of collisions is exactly n^2 - 16n.\n        // The number of collisions is\
    \ exactly n^2 - 17n.\n        // The number of collisions is exactly n^2 - 18n.\n\
    \        // The number of collisions is exactly n^2 - 19n.\n        // The number\
    \ of collisions is exactly n^2 - 20n.\n        // The number of collisions is\
    \ exactly n^2 - 21n.\n        // The number of collisions is exactly n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4uhl0mni.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We can solve this problem using the pigeonhole principle.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Imagine a line of n cars moving left to right.  We can\
    \ place n pigeons\e[0m\n\e[31m15 |\e[0m        \e[34m// in the n cars.  Now imagine\
    \ a line of n cars moving right to left.\e[0m\n\e[31m16 |\e[0m        \e[34m//\
    \ We can place n pigeons in the n cars.  The pigeonhole principle says\e[0m\n\e\
    [31m17 |\e[0m        \e[34m// that at least one pigeon must be in two cars.  This\
    \ means that at least\e[0m\n\e[31m18 |\e[0m        \e[34m// one car is moving\
    \ left to right and another car is moving right to left.\e[0m\n\e[31m19 |\e[0m\
    \        \e[34m// This means that there is at least one collision.\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// The number of collisions is at least n.\e[0m\n\e[31m21\
    \ |\e[0m        \e[34m// The number of collisions is at most n^2.\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// The number of collisions is exactly n^2.\e[0m\n\e[31m23\
    \ |\e[0m        \e[34m// The number of collisions is exactly n^2 - n.\e[0m\n\e\
    [31m24 |\e[0m        \e[34m// The number of collisions is exactly n^2 - 2n.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// The number of collisions is exactly n^2 -\
    \ 3n.\e[0m\n\e[31m26 |\e[0m        \e[34m// The number of collisions is exactly\
    \ n^2 - 4n.\e[0m\n\e[31m27 |\e[0m        \e[34m// The number of collisions is\
    \ exactly n^2 - 5n.\e[0m\n\e[31m28 |\e[0m        \e[34m// The number of collisions\
    \ is exactly n^2 - 6n.\e[0m\n\e[31m29 |\e[0m        \e[34m// The number of collisions\
    \ is exactly n^2 - 7n.\e[0m\n\e[31m30 |\e[0m        \e[34m// The number of collisions\
    \ is exactly n^2 - 8n.\e[0m\n\e[31m31 |\e[0m        \e[34m// The number of collisions\
    \ is exactly n^2 - 9n.\e[0m\n\e[31m32 |\e[0"
  stdout: ''
  timestamp: 1659792903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is that the\
    \ cars that are moving left to right are numbered from 1 to n,\n        // and\
    \ the cars that are moving right to left are numbered from n to 1.\n        //\
    \ The cars that are moving left to right are at positions 1, 2, 3, ..., n.\n \
    \       // The cars that are moving right to left are at positions n, n - 1, n\
    \ - 2, ..., 1.\n        // The cars that are moving left to right are moving at\
    \ speeds 1, 2, 3, ..., n.\n        // The cars that are moving right to left are\
    \ moving at speeds n, n - 1, n - 2, ..., 1.\n        // The time it takes for\
    \ the car that's moving left to right at speed i to reach the\n        // car\
    \ that's moving right to left at speed j is (n - i + j) / (i + j).\n        //\
    \ The time it takes for the car that's moving right to left at speed j to reach\
    \ the\n        // car that's moving left to right at speed i is (n - j + i) /\
    \ (i + j).\n        // So, the two cars collide if (n - i + j) / (i + j) = (n\
    \ - j + i) / (i + j).\n        // This is equivalent to (n - i + j) * (i + j)\
    \ = (n - j + i) * (i + j).\n        // This is equivalent to (n - i + j) * (i\
    \ + j) - (n - j + i) * (i + j) = 0.\n        // This is equivalent to (n - i +\
    \ j) * (i + j) - (n - j + i) * (i + j) = 0.\n        // This is equivalent to\
    \ (n - i + j) * (i + j) - (n - j + i) * (i + j) = 0.\n        // This is equivalent\
    \ to (n - i + j) * (i + j) - (n - j + i) * (i + j) = 0.\n        // This is equivalent\
    \ to (n - i + j) * (i + j) - (n - j + i) * (i + j) = 0.\n        // This is equivalent\
    \ to (n - i\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2kobvh7x.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is that the cars that are moving left to right are numbered from\
    \ 1 to n,\e[0m\n\e[31m14 |\e[0m        \e[34m// and the cars that are moving right\
    \ to left are numbered from n to 1.\e[0m\n\e[31m15 |\e[0m        \e[34m// The\
    \ cars that are moving left to right are at positions 1, 2, 3, ..., n.\e[0m\n\e\
    [31m16 |\e[0m        \e[34m// The cars that are moving right to left are at positions\
    \ n, n - 1, n - 2, ..., 1.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars that\
    \ are moving left to right are moving at speeds 1, 2, 3, ..., n.\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// The cars that are moving right to left are moving at\
    \ speeds n, n - 1, n - 2, ..., 1.\e[0m\n\e[31m19 |\e[0m        \e[34m// The time\
    \ it takes for the car that's moving left to right at speed i to reach the\e[0m\n\
    \e[31m20 |\e[0m        \e[34m// car that's moving right to left at speed j is\
    \ (n - i + j) / (i + j).\e[0m\n\e[31m21 |\e[0m        \e[34m// The time it takes\
    \ for the car that's moving right to left at speed j to reach the\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// car that's moving left to right at speed i is (n - j\
    \ + i) / (i + j).\e[0m\n\e[31m23 |\e[0m        \e[34m// So, the two cars collide\
    \ if (n - i + j) / (i + j) = (n - j + i) / (i + j).\e[0m\n\e[31m24 |\e[0m    \
    \    \e[34m// This is equivalent to (n - i + j) * (i + j) = (n - j + i) * (i +\
    \ j).\e[0m\n\e[31m25 |\e[0m        \e[34m// This is equivalent to (n - i + j)\
    \ * (i + j) - (n - j + i) * (i + j) = 0.\e[0m\n\e[31m26 |\e[0m        \e[34m//\
    \ This is equivalent to (n - i + j) * (i + j) - (n - j + i) * (i + j) = 0.\e[0m\n\
    \e[31m27 |\e[0m        \e[34m// This is equivalent to (n - i + j) * (i + j) -\
    \ (n - j + i) * (i + j) = 0.\e[0m\n\e[31m2"
  stdout: ''
  timestamp: 1659792903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the cars\
    \ moving left to right are numbered 1 to n, and the cars moving\n        // right\
    \ to left are numbered 1 to n.  We can represent the position of the cars\n  \
    \      // as a pair of arrays, where the ith element of the first array is the\
    \ position\n        // of the ith car moving left to right, and the ith element\
    \ of the second array\n        // is the position of the ith car moving right\
    \ to left.\n        // We can represent the speed of the cars as a pair of arrays,\
    \ where the ith element\n        // of the first array is the speed of the ith\
    \ car moving left to right, and the ith\n        // element of the second array\
    \ is the speed of the ith car moving right to left.\n        // We can represent\
    \ the time as a single number.\n        // We can represent the number of collisions\
    \ as a single number.\n        // We can represent the state of the system as\
    \ a tuple of the above four values.\n        // We can represent the state of\
    \ the system at time t as a function from t to the\n        // state of the system.\n\
    \        // We can represent the state of the system at time t as a function from\
    \ t to the\n        // number of collisions.\n        // We can represent the\
    \ state of the system at time t as a function from t to the\n        // number\
    \ of collisions.\n        // We can represent the state of the system at time\
    \ t as a function from t to the\n        // number of collisions.\n        //\
    \ We can represent the state of the system at time t as a function from t to the\n\
    \        // number of collisions.\n        // We can represent the state of the\
    \ system at time t as a function from t to the\n        // number of collisions.\n\
    \        // We can represent the state of the system at time t as a function from\
    \ t to the\n        // number of collisions.\n        // We can represent the\
    \ state of the system at time t as a function from t to the\n        // number\
    \ of collisions.\n        // We can represent the state of the system at time\
    \ t as a function from t to the\n        // number of collisions.\n        //\
    \ We can represent the state of the system at time t as a function from t to the\n\
    \        // number of collisions.\n        // We can represent the state of the\
    \ system at time t\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkbuckopu.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say the cars moving left to right are numbered 1 to n, and the cars\
    \ moving\e[0m\n\e[31m14 |\e[0m        \e[34m// right to left are numbered 1 to\
    \ n.  We can represent the position of the cars\e[0m\n\e[31m15 |\e[0m        \e\
    [34m// as a pair of arrays, where the ith element of the first array is the position\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// of the ith car moving left to right, and\
    \ the ith element of the second array\e[0m\n\e[31m17 |\e[0m        \e[34m// is\
    \ the position of the ith car moving right to left.\e[0m\n\e[31m18 |\e[0m    \
    \    \e[34m// We can represent the speed of the cars as a pair of arrays, where\
    \ the ith element\e[0m\n\e[31m19 |\e[0m        \e[34m// of the first array is\
    \ the speed of the ith car moving left to right, and the ith\e[0m\n\e[31m20 |\e\
    [0m        \e[34m// element of the second array is the speed of the ith car moving\
    \ right to left.\e[0m\n\e[31m21 |\e[0m        \e[34m// We can represent the time\
    \ as a single number.\e[0m\n\e[31m22 |\e[0m        \e[34m// We can represent the\
    \ number of collisions as a single number.\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ We can represent the state of the system as a tuple of the above four values.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// We can represent the state of the system\
    \ at time t as a function from t to the\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ state of the system.\e[0m\n\e[31m26 |\e[0m        \e[34m// We can represent\
    \ the state of the system at time t as a function from t to the\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// number of collisions.\e[0m\n\e[31m28 |\e[0m        \e\
    [34m// We can represent the state of the system at time t as a function from t\
    \ to the\e[0m\n\e[31m29 |\e[0m        \e[34m// nu"
  stdout: ''
  timestamp: 1659792904
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key observation is that the cars that\n        // are moving left\
    \ to right are numbered 1 to n, and the cars that are moving\n        // right\
    \ to left are numbered n to 1.  The collision between car i and car j\n      \
    \  // happens when i + j = n + 1.\n        // So, the number of collisions is\
    \ the number of pairs (i, j) such that i + j = n + 1.\n        // This is the\
    \ same as the number of pairs (i, j) such that i + j = n + 1 and i <= j.\n   \
    \     // This is the same as the number of pairs (i, j) such that i + j = n +\
    \ 1 and i <= n / 2.\n        // This is the same as the number of pairs (i, j)\
    \ such that i + j = n + 1 and i <= n / 2 and j >= i.\n        // This is the same\
    \ as the number of pairs (i, j) such that i + j = n + 1 and i <= n / 2 and j >=\
    \ i and i >= 1.\n        // This is the same as the number of pairs (i, j) such\
    \ that i + j = n + 1 and i <= n / 2 and j >= i and i >= 1 and j <= n.\n      \
    \  // This is the same as the number of pairs (i, j) such that i + j = n + 1 and\
    \ i <= n / 2 and j >= i and i >= 1 and j <= n and i <= j.\n        // This is\
    \ the same as the number of pairs (i, j) such that i + j = n + 1 and i <= n /\
    \ 2 and j >= i and i >= 1 and j <= n and i <= j and j >= 1.\n        // This is\
    \ the same as the number of pairs (i, j) such that i + j = n + 1 and i <= n /\
    \ 2 and j >= i and i >= 1 and j <= n and i <= j and j >= 1 and i <= n.\n     \
    \   // This is the same as the number of pairs (i, j) such that i + j = n + 1\
    \ and i <= n / 2 and j >= i and i >= 1 and j <= n and i <= j and j >= 1 and i\
    \ <= n and j <= n.\n        //\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2rdtvik7.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  The key observation is that the cars that\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// are moving left to right are numbered 1 to\
    \ n, and the cars that are moving\e[0m\n\e[31m15 |\e[0m        \e[34m// right\
    \ to left are numbered n to 1.  The collision between car i and car j\e[0m\n\e\
    [31m16 |\e[0m        \e[34m// happens when i + j = n + 1.\e[0m\n\e[31m17 |\e[0m\
    \        \e[34m// So, the number of collisions is the number of pairs (i, j) such\
    \ that i + j = n + 1.\e[0m\n\e[31m18 |\e[0m        \e[34m// This is the same as\
    \ the number of pairs (i, j) such that i + j = n + 1 and i <= j.\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// This is the same as the number of pairs (i, j) such that\
    \ i + j = n + 1 and i <= n / 2.\e[0m\n\e[31m20 |\e[0m        \e[34m// This is\
    \ the same as the number of pairs (i, j) such that i + j = n + 1 and i <= n /\
    \ 2 and j >= i.\e[0m\n\e[31m21 |\e[0m        \e[34m// This is the same as the\
    \ number of pairs (i, j) such that i + j = n + 1 and i <= n / 2 and j >= i and\
    \ i >= 1.\e[0m\n\e[31m22 |\e[0m        \e[34m// This is the same as the number\
    \ of pairs (i, j) such that i + j = n + 1 and i <= n / 2 and j >= i and i >= 1\
    \ and j <= n.\e[0m\n\e[31m23 |\e[0m        \e[34m// This is the same as the number\
    \ of pairs (i, j) such that i + j = n + 1 and i <= n / 2 and j >= i and i >= 1\
    \ and j <= n and i <= j.\e[0m\n\e[31m24 |\e[0m        \e[34m// This is the same\
    \ as the number of pairs (i, j) such that i + j = n + 1 and i <= n / 2 and j >=\
    \ i and i >= 1 and j <= n and i <= j and j >= 1.\e[0m\n\e[31m25 |\e[0m       \
    \ \e[34m// This is the same as the number of pairs (i, j) such that i + j = n\
    \ + 1 and i <= n / 2 and j >= i and i "
  stdout: ''
  timestamp: 1659792903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The key observation\
    \ is that the cars that are moving in the same direction\n        // as each other\
    \ will never collide.  So we only need to consider the cars that\n        // are\
    \ moving in opposite directions.\n        // Let's say the cars that are moving\
    \ left to right are numbered from 1 to n.\n        // Let's say the cars that\
    \ are moving right to left are numbered from n+1 to 2n.\n        // Let's say\
    \ the car numbered i is at position xi.\n        // Let's say the car numbered\
    \ i is moving at speed si.\n        // Then the car numbered i will collide with\
    \ the car numbered n+i if and only if\n        // xi + si * t = xn+i - si * t\n\
    \        // or equivalently,\n        // 2 * si * t = xn+i - xi\n        // or\
    \ equivalently,\n        // t = (xn+i - xi) / (2 * si)\n        // So we need\
    \ to find all pairs (i, j) such that\n        // xi + si * t = xj - sj * t\n \
    \       // or equivalently,\n        // xi + si * t = xj + sj * t\n        //\
    \ or equivalently,\n        // xi - xj = (sj - si) * t\n        // or equivalently,\n\
    \        // t = (xi - xj) / (sj - si)\n        // or equivalently,\n        //\
    \ t = (xi - xj) / (si - sj)\n        // or equivalently,\n        // t = (xj -\
    \ xi) / (sj - si)\n        // or equivalently,\n        // t = (xj - xi) / (si\
    \ - sj)\n        // or equivalently,\n        // t = (xj - xi) / (sj - si)\n \
    \       // or equivalently,\n        // t = (xj - xi) / (si - sj)\n        //\
    \ or equivalently,\n        // t = (xj - xi) / (sj - si)\n        // or equivalently,\n\
    \        // t = (xj - xi) / (si - sj)\n        // or equivalently,\n        //\
    \ t =\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptzzgk747.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The key observation is that the cars that are moving in the same direction\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// as each other will never collide.  So we\
    \ only need to consider the cars that\e[0m\n\e[31m15 |\e[0m        \e[34m// are\
    \ moving in opposite directions.\e[0m\n\e[31m16 |\e[0m        \e[34m// Let's say\
    \ the cars that are moving left to right are numbered from 1 to n.\e[0m\n\e[31m17\
    \ |\e[0m        \e[34m// Let's say the cars that are moving right to left are\
    \ numbered from n+1 to 2n.\e[0m\n\e[31m18 |\e[0m        \e[34m// Let's say the\
    \ car numbered i is at position xi.\e[0m\n\e[31m19 |\e[0m        \e[34m// Let's\
    \ say the car numbered i is moving at speed si.\e[0m\n\e[31m20 |\e[0m        \e\
    [34m// Then the car numbered i will collide with the car numbered n+i if and only\
    \ if\e[0m\n\e[31m21 |\e[0m        \e[34m// xi + si * t = xn+i - si * t\e[0m\n\e\
    [31m22 |\e[0m        \e[34m// or equivalently,\e[0m\n\e[31m23 |\e[0m        \e\
    [34m// 2 * si * t = xn+i - xi\e[0m\n\e[31m24 |\e[0m        \e[34m// or equivalently,\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// t = (xn+i - xi) / (2 * si)\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// So we need to find all pairs (i, j) such that\e[0m\n\e\
    [31m27 |\e[0m        \e[34m// xi + si * t = xj - sj * t\e[0m\n\e[31m28 |\e[0m\
    \        \e[34m// or equivalently,\e[0m\n\e[31m29 |\e[0m        \e[34m// xi +\
    \ si * t = xj + sj * t\e[0m\n\e[31m30 |\e[0m        \e[34m// or equivalently,\e\
    [0m\n\e[31m31 |\e[0m        \e[34m// xi - xj = (sj - si) * t\e[0m\n\e[31m32 |\e\
    [0m        \e[34m// or equivalently,\e[0m\n\e[31m33 |\e[0m        \e[34m// t =\
    \ (xi - xj) / (sj - si)\e[0m\n\e[31m34 |\e[0m        \e[34m// or equivalently,\e\
    [0m\n\e[31m35 |\e[0m        \e[34m// t = (xi - xj) / (si - sj)\e[0m\n\e["
  stdout: ''
  timestamp: 1659792904
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a brute force\
    \ solution.  It's easy to see that the number of collisions\n        // is the\
    \ number of pairs of cars that are moving in opposite directions and\n       \
    \ // have the same position.  This brute force solution just checks all pairs\
    \ of cars\n        // and counts the number of such pairs.\n        // The time\
    \ complexity is O(n^2).\n        var count = 0L\n        for (i <- 1 to n.toInt)\
    \ {\n            for (j <- 1 to n.toInt) {\n                if (i != j && (i +\
    \ j) % 2 == 0) count += 1\n            }\n        }\n        count\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ljxcpvv.scala:27)\n\tat Problem.main(tmp2ljxcpvv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say that the\
    \ left-to-right cars are numbered 1 to n, and the right-to-left cars\n       \
    \ // are numbered n+1 to 2n.  Let's say that the left-to-right car i is at position\
    \ xi,\n        // and the right-to-left car i is at position yi.  Let's say that\
    \ the left-to-right car\n        // i is moving at speed si, and the right-to-left\
    \ car i is moving at speed ti.\n        // Then, the number of collisions is the\
    \ number of pairs (i, j) such that\n        // xi + si * t = yj + tj * t for some\
    \ t > 0.\n        // This is the same as the number of pairs (i, j) such that\n\
    \        // xi - yj = (tj - si) * t for some t > 0.\n        // This is the same\
    \ as the number of pairs (i, j) such that\n        // xi - yj is divisible by\
    \ tj - si.\n        // This is the same as the number of pairs (i, j) such that\n\
    \        // xi - yj is divisible by gcd(tj - si, tj - si).\n        // This is\
    \ the same as the number of pairs (i, j) such that\n        // xi - yj is divisible\
    \ by gcd(tj - si, tj - si) and gcd(tj - si, tj - si) > 0.\n        // This is\
    \ the same as the number of pairs (i, j) such that\n        // xi - yj is divisible\
    \ by gcd(tj - si, tj - si) and tj - si > 0.\n        // This is the same as the\
    \ number of pairs (i, j) such that\n        // xi - yj is divisible by gcd(tj\
    \ - si, tj - si) and tj > si.\n        // This is the same as the number of pairs\
    \ (i, j) such that\n        // xi - yj is divisible by gcd(tj - si, tj - si) and\
    \ tj > si and tj - si > 0.\n        // This is the same as the number of pairs\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwb3r9nnw.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say that the left-to-right cars are numbered 1 to n, and the right-to-left\
    \ cars\e[0m\n\e[31m14 |\e[0m        \e[34m// are numbered n+1 to 2n.  Let's say\
    \ that the left-to-right car i is at position xi,\e[0m\n\e[31m15 |\e[0m      \
    \  \e[34m// and the right-to-left car i is at position yi.  Let's say that the\
    \ left-to-right car\e[0m\n\e[31m16 |\e[0m        \e[34m// i is moving at speed\
    \ si, and the right-to-left car i is moving at speed ti.\e[0m\n\e[31m17 |\e[0m\
    \        \e[34m// Then, the number of collisions is the number of pairs (i, j)\
    \ such that\e[0m\n\e[31m18 |\e[0m        \e[34m// xi + si * t = yj + tj * t for\
    \ some t > 0.\e[0m\n\e[31m19 |\e[0m        \e[34m// This is the same as the number\
    \ of pairs (i, j) such that\e[0m\n\e[31m20 |\e[0m        \e[34m// xi - yj = (tj\
    \ - si) * t for some t > 0.\e[0m\n\e[31m21 |\e[0m        \e[34m// This is the\
    \ same as the number of pairs (i, j) such that\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// xi - yj is divisible by tj - si.\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ This is the same as the number of pairs (i, j) such that\e[0m\n\e[31m24 |\e\
    [0m        \e[34m// xi - yj is divisible by gcd(tj - si, tj - si).\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// This is the same as the number of pairs (i, j) such that\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// xi - yj is divisible by gcd(tj - si, tj -\
    \ si) and gcd(tj - si, tj - si) > 0.\e[0m\n\e[31m27 |\e[0m        \e[34m// This\
    \ is the same as the number of pairs (i, j) such that\e[0m\n\e[31m28 |\e[0m  \
    \      \e[34m// xi - yj is divisible by gcd(tj - si, tj - si) and tj - si > 0.\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// This is the same as the number of pairs (i,\
    \ j) such that\e[0m\n\e[31m30 |\e[0m        \e[34m/"
  stdout: ''
  timestamp: 1659792906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a simple problem\
    \ that can be solved by sorting the cars by their\n        // starting position.\
    \  The number of collisions is then the number of cars\n        // that are in\
    \ the same position.\n        // The time complexity is O(n log n) and the space\
    \ complexity is O(n).\n        val cars = Array.fill(n.toInt)(scala.util.Random.nextInt(n.toInt))\n\
    \        val sortedCars = cars.sorted\n        var collisions = 0\n        for\
    \ (i <- 0 until n.toInt) {\n            if (sortedCars(i) == sortedCars(i + 1))\
    \ collisions += 1\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length\
    \ 2\n\tat Problem$.carRaceCollision$$anonfun$1(tmp1ummxlzu.scala:21)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.carRaceCollision(tmp1ummxlzu.scala:22)\n\
    \tat Problem$.main(tmp1ummxlzu.scala:26)\n\tat Problem.main(tmp1ummxlzu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can easily count\
    \ the number of collisions.\n        // The number of collisions is the number\
    \ of cars that are moving right to left\n        // that are to the left of the\
    \ first car that is moving left to right.\n        // This is because the first\
    \ car that is moving left to right will collide with\n        // all cars that\
    \ are moving right to left that are to its left.\n        // The number of cars\
    \ that are moving right to left that are to the left of the first\n        //\
    \ car that is moving left to right is the number of cars that are moving right\
    \ to left\n        // that are to the left of the median of the starting positions\
    \ of the cars that are\n        // moving right to left.\n        // The median\
    \ of the starting positions of the cars that are moving right to left\n      \
    \  // is the median of the starting positions of all cars.\n        // Thus, the\
    \ number of collisions is the number of cars that are moving right to left\n \
    \       // that are to the left of the median of the starting positions of all\
    \ cars.\n        // The number of cars that are moving right to left that are\
    \ to the left of the median\n        // of the starting positions of all cars\
    \ is the number of cars that are moving right to left\n        // that are to\
    \ the left of the median of the starting positions of all cars\n        // minus\
    \ the number of cars that are moving left to right that are to the left of the\
    \ median\n        // of the starting positions of all cars.\n        // The number\
    \ of cars that are moving right to left that are to the left of the median\n \
    \       // of the starting positions of all cars is the number of cars that are\
    \ moving right to left\n        // minus the number of cars that are moving right\
    \ to left that are to the right of the median\n        // of the starting positions\
    \ of all cars.\n        // The number of cars that are moving right to left that\
    \ are to the right of the median\n        // of the starting positions of all\
    \ cars is the number of cars that are moving right to left\n        // minus the\
    \ number of cars that are moving right to left that are to the left of the median\n\
    \        // of the starting positions of all cars.\n        // The number of cars\
    \ that are moving right to left that are to the left of the median\n        //\
    \ of the starting\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpewogdqfm.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can easily count the number of collisions.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// The number of collisions is the number of\
    \ cars that are moving right to left\e[0m\n\e[31m16 |\e[0m        \e[34m// that\
    \ are to the left of the first car that is moving left to right.\e[0m\n\e[31m17\
    \ |\e[0m        \e[34m// This is because the first car that is moving left to\
    \ right will collide with\e[0m\n\e[31m18 |\e[0m        \e[34m// all cars that\
    \ are moving right to left that are to its left.\e[0m\n\e[31m19 |\e[0m       \
    \ \e[34m// The number of cars that are moving right to left that are to the left\
    \ of the first\e[0m\n\e[31m20 |\e[0m        \e[34m// car that is moving left to\
    \ right is the number of cars that are moving right to left\e[0m\n\e[31m21 |\e\
    [0m        \e[34m// that are to the left of the median of the starting positions\
    \ of the cars that are\e[0m\n\e[31m22 |\e[0m        \e[34m// moving right to left.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// The median of the starting positions of the\
    \ cars that are moving right to left\e[0m\n\e[31m24 |\e[0m        \e[34m// is\
    \ the median of the starting positions of all cars.\e[0m\n\e[31m25 |\e[0m    \
    \    \e[34m// Thus, the number of collisions is the number of cars that are moving\
    \ right to left\e[0m\n\e[31m26 |\e[0m        \e[34m// that are to the left of\
    \ the median of the starting positions of all cars.\e[0m\n\e[31m27 |\e[0m    \
    \    \e[34m// The number of cars that are moving right to left that are to the\
    \ left of the median\e[0m\n\e[31m28 |\e[0m        \e[34m// of the starting positions\
    \ of all cars is the number of cars that are mo"
  stdout: ''
  timestamp: 1659792906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm to count the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // We start with the leftmost car.  We then move the\
    \ sweep line to the right.\n        // Whenever we encounter a car that's moving\
    \ left to right, we add it to a set.\n        // Whenever we encounter a car that's\
    \ moving right to left, we remove it from the set.\n        // We count the number\
    \ of cars in the set.  This is the number of collisions that\n        // the car\
    \ that we just encountered has.  We add this number to the total number of collisions.\n\
    \        // We repeat this process until we reach the rightmost car.\n       \
    \ // The time complexity is O(n log n).\n        // The space complexity is O(n).\n\
    \        val cars = new Array[(Long, Int)](2 * n.toInt)\n        for (i <- 0 until\
    \ n.toInt) {\n            cars(i) = (i.toLong, 1)\n            cars(i + n.toInt)\
    \ = (i.toLong, -1)\n        }\n        val sortedCars = cars.sortBy(x => x._1)\n\
    \        var collisions = 0L\n        var set = new HashSet[Long]\n        for\
    \ (car <- sortedCars) {\n            if (car._2 == 1) {\n                set.add(car._1)\n\
    \            } else {\n                set.remove(car._1)\n            }\n   \
    \         collisions += set.size\n        }\n        collisions\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_yg17okj.scala:43)\n\tat Problem.main(tmp_yg17okj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a classic problem\
    \ in combinatorics.\n        // The answer is n * (n - 1) / 2.\n        n * (n\
    \ - 1) / 2\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb4an1vw_.scala:18)\n\tat Problem.main(tmpb4an1vw_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can simulate the\
    \ cars moving left to right and right to left.\n        // The cars moving left\
    \ to right will be called \"left cars\" and the cars moving\n        // right\
    \ to left will be called \"right cars\".\n        // The left cars will be sorted\
    \ in ascending order by their starting positions.\n        // The right cars will\
    \ be sorted in descending order by their starting positions.\n        // We will\
    \ simulate the cars moving left to right and right to left by\n        // iterating\
    \ through the left cars and right cars.\n        // We will keep track of the\
    \ current position of the left cars and right cars.\n        // We will also keep\
    \ track of the number of collisions.\n        // We will iterate through the left\
    \ cars and right cars in parallel.\n        // When we iterate through the left\
    \ cars, we will increment the current position\n        // of the left cars by\
    \ 1.  When we iterate through the right cars, we will decrement\n        // the\
    \ current position of the right cars by 1.\n        // If the current position\
    \ of the left cars is equal to the current position of the\n        // right cars,\
    \ then we have a collision.  We will increment the number of collisions\n    \
    \    // by 1.\n        // We will continue iterating through the left cars and\
    \ right cars until we have\n        // iterated through all the left cars and\
    \ right cars.\n        // The number of collisions will be the answer.\n     \
    \   // The time complexity is O(n log n) because we have to sort the cars.\n \
    \       // The space complexity is O(n) because we have to store the cars.\n \
    \       val leftCars = ArrayBuffer[Long]()\n        val rightCars = ArrayBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            val leftCar = scala.io.StdIn.readLine.toLong\n\
    \            val rightCar = scala.io.StdIn.readLine.toLong\n            leftCars\
    \ += leftCar\n            rightCars += rightCar\n        }\n        leftCars.sortInPlace()\n\
    \        rightCars.sortInPlace(Ordering[Long].reverse)\n        var leftCarPosition\
    \ = 0\n        var rightCarPosition = 0\n        var collisions =\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppi8eet4c.scala:47:24 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mvar\e[0m \e[36mcollisions\e[0m =\n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmppi8eet4c.scala:44:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        rightCars.sortInPlace(Ordering[\e[35mLong\e[0m].reverse)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m      too many arguments for \e[33mmethod\e[0m \e[35msortInPlace\e\
    [0m in \e[33mclass\e[0m \e[35mArrayBuffer\e[0m: ()\n\e[31m   |\e[0m        (\e\
    [33mimplicit \e[0mord: Ordering[B]): \n\e[31m   |\e[0m          (rightCars : scala.collection.mutable.ArrayBuffer[Long])\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppi8eet4c.scala:48:5 ---------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can solve this problem\
    \ by first sorting the cars by their starting position.\n        // Then, we can\
    \ iterate through the cars from left to right.  For each car, we can\n       \
    \ // find the number of cars that are to the right of it and moving left to right.\n\
    \        // This is the number of collisions that the car will have.\n       \
    \ // We can do this in O(n log n) time.\n        // However, we can do better.\
    \  We can do this in O(n) time.\n        // We can do this by using a stack. \
    \ We can iterate through the cars from left to right.\n        // For each car,\
    \ we can push it onto the stack.  Then, we can pop cars off the stack\n      \
    \  // until we find a car that's moving left to right.  The number of cars that\
    \ we pop off\n        // the stack is the number of collisions that the car has.\n\
    \        // We can do this in O(n) time.\n        // However, we can do better.\
    \  We can do this in O(1) time.\n        // We can do this by using a stack. \
    \ We can iterate through the cars from left to right.\n        // For each car,\
    \ we can push it onto the stack.  Then, we can pop cars off the stack\n      \
    \  // until we find a car that's moving left to right.  The number of cars that\
    \ we pop off\n        // the stack is the number of collisions that the car has.\n\
    \        // We can do this in O(n) time.\n        // However, we can do better.\
    \  We can do this in O(1) time.\n        // We can do this by using a stack. \
    \ We can iterate through the cars from left to right.\n        // For each car,\
    \ we can push it onto the stack.  Then, we can pop cars off the stack\n      \
    \  // until we find a car that's moving left to right.  The number of cars that\
    \ we pop off\n        // the stack is the number of collisions that the car has.\n\
    \        // We can do this in O(n) time.\n        // However, we can do better.\
    \  We can do this in O(1) time.\n        // We can do this by using a stack. \
    \ We can iterate through the cars from\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp05haj3a0.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We can solve this problem by first sorting the cars by their starting position.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// Then, we can iterate through the cars from\
    \ left to right.  For each car, we can\e[0m\n\e[31m15 |\e[0m        \e[34m// find\
    \ the number of cars that are to the right of it and moving left to right.\e[0m\n\
    \e[31m16 |\e[0m        \e[34m// This is the number of collisions that the car\
    \ will have.\e[0m\n\e[31m17 |\e[0m        \e[34m// We can do this in O(n log n)\
    \ time.\e[0m\n\e[31m18 |\e[0m        \e[34m// However, we can do better.  We can\
    \ do this in O(n) time.\e[0m\n\e[31m19 |\e[0m        \e[34m// We can do this by\
    \ using a stack.  We can iterate through the cars from left to right.\e[0m\n\e\
    [31m20 |\e[0m        \e[34m// For each car, we can push it onto the stack.  Then,\
    \ we can pop cars off the stack\e[0m\n\e[31m21 |\e[0m        \e[34m// until we\
    \ find a car that's moving left to right.  The number of cars that we pop off\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// the stack is the number of collisions that\
    \ the car has.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can do this in O(n) time.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// However, we can do better.  We can do this\
    \ in O(1) time.\e[0m\n\e[31m25 |\e[0m        \e[34m// We can do this by using\
    \ a stack.  We can iterate through the cars from left to right.\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// For each car, we can push it onto the stack.  Then, we\
    \ can pop cars off the stack\e[0m\n\e[31m27 |\e[0m        \e[34m// until we find\
    \ a car that's moving left to right.  The number of cars that we pop off\e[0m\n\
    \e[31m28 |\e[0m        \e[34m// the stack is the number of collisions that the\
    \ car has.\e[0m\n\e[31m29 |\e[0m "
  stdout: ''
  timestamp: 1659792907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between the cars that are moving\n        // left to\
    \ right and the cars that are moving right to left.\n        // The cars are numbered\
    \ from 0 to n-1.\n        // The cars that are moving left to right are numbered\
    \ from 0 to n-1.\n        // The cars that are moving right to left are numbered\
    \ from n-1 to 0.\n        // The cars that are moving left to right are at positions\
    \ x0, x1, ..., x(n-1).\n        // The cars that are moving right to left are\
    \ at positions y0, y1, ..., y(n-1).\n        // The cars that are moving left\
    \ to right are moving at speeds v0, v1, ..., v(n-1).\n        // The cars that\
    \ are moving right to left are moving at speeds w0, w1, ..., w(n-1).\n       \
    \ // The cars that are moving left to right are moving at speeds 1, 2, ..., n.\n\
    \        // The cars that are moving right to left are moving at speeds n, n-1,\
    \ ..., 1.\n        // The cars that are moving left to right are at positions\
    \ 0, 1, ..., n-1.\n        // The cars that are moving right to left are at positions\
    \ n-1, n-2, ..., 0.\n        // The cars that are moving left to right are at\
    \ positions 0, 1, ..., n-1.\n        // The cars that are moving right to left\
    \ are at positions n-1, n-2, ..., 0.\n        // The cars that are moving left\
    \ to right are at positions 0, 1, ..., n-1.\n        // The cars that are moving\
    \ right to left are at positions n-1, n-2, ..., 0.\n        // The cars that are\
    \ moving left to right are at positions 0, 1, ..., n-1.\n        // The cars that\
    \ are moving right to left are at positions n-1, n-2, ..., 0.\n        // The\
    \ cars that are moving left to right are at positions 0, 1, ..., n-1.\n      \
    \  // The cars that are moving right to left are at positions n-1, n-2, ..., 0.\n\
    \        // The cars that are moving left to right are at positions\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp67fdctdb.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This function returns the number of collisions between the cars that are\
    \ moving\e[0m\n\e[31m14 |\e[0m        \e[34m// left to right and the cars that\
    \ are moving right to left.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars are\
    \ numbered from 0 to n-1.\e[0m\n\e[31m16 |\e[0m        \e[34m// The cars that\
    \ are moving left to right are numbered from 0 to n-1.\e[0m\n\e[31m17 |\e[0m \
    \       \e[34m// The cars that are moving right to left are numbered from n-1\
    \ to 0.\e[0m\n\e[31m18 |\e[0m        \e[34m// The cars that are moving left to\
    \ right are at positions x0, x1, ..., x(n-1).\e[0m\n\e[31m19 |\e[0m        \e\
    [34m// The cars that are moving right to left are at positions y0, y1, ..., y(n-1).\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// The cars that are moving left to right are\
    \ moving at speeds v0, v1, ..., v(n-1).\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ The cars that are moving right to left are moving at speeds w0, w1, ..., w(n-1).\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// The cars that are moving left to right are\
    \ moving at speeds 1, 2, ..., n.\e[0m\n\e[31m23 |\e[0m        \e[34m// The cars\
    \ that are moving right to left are moving at speeds n, n-1, ..., 1.\e[0m\n\e\
    [31m24 |\e[0m        \e[34m// The cars that are moving left to right are at positions\
    \ 0, 1, ..., n-1.\e[0m\n\e[31m25 |\e[0m        \e[34m// The cars that are moving\
    \ right to left are at positions n-1, n-2, ..., 0.\e[0m\n\e[31m26 |\e[0m     \
    \   \e[34m// The cars that are moving left to right are at positions 0, 1, ...,\
    \ n-1.\e[0m\n\e[31m27 |\e[0m        \e[34m// The cars that are moving right to\
    \ left are at positions n-1, n-2, ..., 0.\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ The cars that are moving left to right are"
  stdout: ''
  timestamp: 1659792907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just count the\
    \ number of cars that are moving in the opposite direction\n        // as the\
    \ car that's currently being considered.\n        // The number of cars that are\
    \ moving in the opposite direction is equal to the number of cars\n        //\
    \ that are moving in the same direction as the current car, but are to the left\
    \ of the current car.\n        // This is because the cars are sorted by their\
    \ starting positions.\n        // The number of cars that are moving in the same\
    \ direction as the current car, but are to the left of the current car\n     \
    \   // is equal to the number of cars that are moving in the opposite direction\
    \ as the current car, but are to the right of the current car.\n        // This\
    \ is because the cars are sorted by their starting positions.\n        // The\
    \ number of cars that are moving in the opposite direction as the current car,\
    \ but are to the right of the current car\n        // is equal to the number of\
    \ cars that are moving in the same direction as the current car, but are to the\
    \ left of the current car.\n        // This is because the cars are sorted by\
    \ their starting positions.\n        // The number of cars that are moving in\
    \ the same direction as the current car, but are to the left of the current car\n\
    \        // is equal to the number of cars that are moving in the opposite direction\
    \ as the current car, but are to the right of the current car.\n        // This\
    \ is because the cars are sorted by their starting positions.\n        // The\
    \ number of cars that are moving in the opposite direction as the current car,\
    \ but are to the right of the current car\n        // is equal to the number of\
    \ cars that are moving in the same direction as the current car, but are to the\
    \ left of the current car.\n        // This is because the cars are sorted by\
    \ their starting positions.\n        // The number of cars that are moving in\
    \ the same direction as the current car, but are to the left of the current car\n\
    \        // is equal to the number of cars that are moving in the opposite direction\
    \ as the current car, but are to the right of the current car.\n        // This\
    \ is because the cars are sorted by their starting positions.\n        // The\
    \ number of cars that are moving in the opposite direction as the current car,\
    \ but are to the right of the current car\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj1bl5k7k.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can just count the number of cars that are moving\
    \ in the opposite direction\e[0m\n\e[31m15 |\e[0m        \e[34m// as the car that's\
    \ currently being considered.\e[0m\n\e[31m16 |\e[0m        \e[34m// The number\
    \ of cars that are moving in the opposite direction is equal to the number of\
    \ cars\e[0m\n\e[31m17 |\e[0m        \e[34m// that are moving in the same direction\
    \ as the current car, but are to the left of the current car.\e[0m\n\e[31m18 |\e\
    [0m        \e[34m// This is because the cars are sorted by their starting positions.\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// The number of cars that are moving in the\
    \ same direction as the current car, but are to the left of the current car\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// is equal to the number of cars that are moving\
    \ in the opposite direction as the current car, but are to the right of the current\
    \ car.\e[0m\n\e[31m21 |\e[0m        \e[34m// This is because the cars are sorted\
    \ by their starting positions.\e[0m\n\e[31m22 |\e[0m        \e[34m// The number\
    \ of cars that are moving in the opposite direction as the current car, but are\
    \ to the right of the current car\e[0m\n\e[31m23 |\e[0m        \e[34m// is equal\
    \ to the number of cars that are moving in the same direction as the current car,\
    \ but are to the left of the current car.\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ This is because the cars are sorted by their starting positions.\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// The number of cars that are moving in the same direction\
    \ as the current car, but are to the left of the current car\e[0m\n\e[31m26 |\e\
    [0m "
  stdout: ''
  timestamp: 1659792908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just iterate\
    \ through the cars and count the number of collisions.\n        // The time complexity\
    \ is O(n log n).\n        val cars = Array.fill(n.toInt)(0)\n        for (i <-\
    \ 0 until n.toInt) cars(i) = i\n        scala.util.Sorting.quickSort(cars)\n \
    \       var collisions = 0L\n        for (i <- 0 until n.toInt) {\n          \
    \  collisions += (cars(i) - i)\n        }\n        collisions\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgds5e4ky.scala:26)\n\tat Problem.main(tmpgds5e4ky.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792908
