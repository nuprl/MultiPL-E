name: HumanEval_115_max_fill
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n    // and each 1 in a row represents a single unit of water.\n    // Each\
  \ well has a corresponding bucket that can be used to extract water from it, \n\
  \    // and all buckets have the same capacity.\n    // Your task is to use the\
  \ buckets to empty the wells.\n    // Output the number of times you need to lower\
  \ the buckets.\n    // Example 1:\n    // Input: \n    // grid : [[0,0,1,0], [0,1,0,0],\
  \ [1,1,1,1]]\n    // bucket_capacity : 1\n    // Output: 6\n    // Example 2:\n\
  \    // Input: \n    // grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n  \
  \  // bucket_capacity : 2\n    // Output: 5\n    // Example 3:\n    // Input: \n\
  \    // grid : [[0,0,0], [0,0,0]]\n    // bucket_capacity : 5\n    // Output: 0\n\
  \    // Constraints:\n    // * all wells have the same length\n    // * 1 <= grid.length\
  \ <= 10^2\n    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n\
  \    // * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity\
  \ : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
  \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
  \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) ==\
  \ (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
  \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
  \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
  \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l)) ==\
  \ (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
  \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
  \ (9l)) == (2l));\n    }\n\n}\n"
completions: ["        val n = grid.length\n        val m = grid(0).length\n     \
    \   val maxFill = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n     \
    \               maxFill(i)(j) = capacity\n                } else {\n         \
    \           maxFill(i)(j) = 0\n                }\n            }\n        }\n \
    \       for (i <- 0 until n) {\n            for (j <- 0 until m) {\n         \
    \       if (i > 0) {\n                    maxFill(i)(j) = max(maxFill(i)(j), maxFill(i\
    \ - 1)(j))\n                }\n                if (j > 0) {\n                \
    \    maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n                }\n\
    \            }\n        }\n        var result = 0L\n        for (i <- n - 1 to\
    \ 0 by -1) {\n            for (j <- m - 1 to 0 by -1) {\n                if (i\
    \ < n - 1) {\n                    maxFill(i)(j) = max(maxFill(i)(j), maxFill(i\
    \ + 1)(j))\n                }\n                if (j < m - 1) {\n            \
    \        maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j + 1))\n             \
    \   }\n                result += maxFill(i)(j) - grid(i)(j)\n            }\n \
    \       }\n        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n     \
    \               dp(i)(j) = capacity\n                }\n                if (i\
    \ > 0) {\n                    dp(i)(j) = max(dp(i)(j), dp(i - 1)(j))\n       \
    \         }\n                if (j > 0) {\n                    dp(i)(j) = max(dp(i)(j),\
    \ dp(i)(j - 1))\n                }\n            }\n        }\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               result += dp(i)(j)\n            }\n        }\n        result",
  "        val n = grid.length\n        val m = grid(0).length\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               if (grid(i)(j) == 1) {\n                    result += 1\n    \
    \                grid(i)(j) = 0\n                    var k = i + 1\n         \
    \           while (k < n && grid(k)(j) == 1) {\n                        grid(k)(j)\
    \ = 0\n                        k += 1\n                    }\n               \
    \     k = i - 1\n                    while (k >= 0 && grid(k)(j) == 1) {\n   \
    \                     grid(k)(j) = 0\n                        k -= 1\n       \
    \             }\n                }\n            }\n        }\n        result",
  "        val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (grid(i)(j) == 1) {\n                    maxFill(i)(j)\
    \ = capacity\n                } else {\n                    if (i > 0) maxFill(i)(j)\
    \ = maxFill(i - 1)(j)\n                    if (j > 0) maxFill(i)(j) = max(maxFill(i)(j),\
    \ maxFill(i)(j - 1))\n                }\n            }\n        }\n        maxFill(n\
    \ - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        var result = 0L\n        for (i <- 0 until n) {\n            var count\
    \ = 0L\n            for (j <- 0 until m) {\n                if (grid(i)(j) ==\
    \ 1) count += 1\n            }\n            result += (count + capacity - 1) /\
    \ capacity\n        }\n        result", "        // The problem is equivalent\
    \ to finding the minimum number of times you need to lower the buckets\n     \
    \   // to empty the wells.\n        // The minimum number of times you need to\
    \ lower the buckets is the maximum number of times you need to fill the buckets.\n\
    \        // The maximum number of times you need to fill the buckets is the maximum\
    \ number of times you need to fill the buckets\n        // in a single well.\n\
    \        // The maximum number of times you need to fill the buckets in a single\
    \ well is the maximum number of units of water\n        // in a single well divided\
    \ by the bucket capacity.\n        // The maximum number of units of water in\
    \ a single well is the maximum number of 1s in a single well.\n        // The\
    \ maximum number of 1s in a single well is the length of the longest consecutive\
    \ sequence of 1s in a single well.\n        // The length of the longest consecutive\
    \ sequence of 1s in a single well is the length of the longest consecutive sequence\n\
    \        // of 1s in a single well divided by the bucket capacity.\n        //\
    \ The length of the longest consecutive sequence of 1s in a single well is the\
    \ length of the longest consecutive sequence\n        // of 1s in a single well\
    \ divided by the bucket capacity.\n        // The length of the longest consecutive\
    \ sequence of 1s in a single well is the length of the longest consecutive sequence\n\
    \        // of 1s in a single well divided by the bucket capacity.\n        //\
    \ The length of the longest consecutive sequence of 1s in a single well is the\
    \ length of the longest consecutive sequence\n        // of 1s in a single well\
    \ divided by the bucket capacity.\n        // The length of the longest consecutive\
    \ sequence of 1s in a single well is the length of the longest consecutive sequence\n\
    \        // of 1s in a single well divided by the bucket capacity.\n        //\
    \ The length of the longest consecutive sequence of 1s in a single well is the\
    \ length of the longest consecutive sequence\n        // of 1s in a single well\
    \ divided by the bucket capacity.\n        // The length of the longest consecutive\
    \ sequence of 1s in a single well is the length of the longest consecutive sequence\n\
    \        // of 1s in a single well divided by the bucket capacity.\n        //\
    \ The length of the longest consecutive sequence of 1s in a single well is the\
    \ length of the longest consecutive sequence\n        // of 1s in a single well\
    \ divided by the bucket capacity.\n", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        var sum = 0L\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until m) {\n                sum += grid(i)(j)\n      \
    \      }\n        }\n        sum / capacity", "        val n = grid.length\n \
    \       val m = grid(0).length\n        val dp = Array.fill(n, m)(0L)\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n         \
    \       }\n                if (i > 0) {\n                    dp(i)(j) = max(dp(i)(j),\
    \ dp(i - 1)(j))\n                }\n                if (j > 0) {\n           \
    \         dp(i)(j) = max(dp(i)(j), dp(i)(j - 1))\n                }\n        \
    \    }\n        }\n        var result = 0L\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n \
    \                   result += capacity - dp(i)(j)\n                }\n       \
    \     }\n        }\n        result", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n        for (i\
    \ <- 0 until n) {\n            var j = 0\n            while (j < m && grid(i)(j)\
    \ == 0) j += 1\n            maxFill(i) = j\n        }\n        var result = 0L\n\
    \        var i = 0\n        while (i < n) {\n            var j = 0\n         \
    \   while (j < m && grid(i)(j) == 0) j += 1\n            if (j == m) {\n     \
    \           i += 1\n                continue\n            }\n            val maxFill\
    \ = maxFill(i)\n            if (maxFill == 0) {\n                result += 1\n\
    \                i += 1\n                continue\n            }\n           \
    \ var k = i + 1\n            while (k < n && maxFill(k) >= maxFill) k += 1\n \
    \           val num = min(k - i, capacity)\n            result += num\n      \
    \      i += num\n        }\n        result", "        val rows = grid.length\n\
    \        val cols = grid(0).length\n        val maxFill = Array.fill(rows, cols)(0L)\n\
    \        for (i <- 0 until rows) {\n            for (j <- 0 until cols) {\n  \
    \              if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n\
    \                } else {\n                    if (i > 0) maxFill(i)(j) = maxFill(i\
    \ - 1)(j)\n                    if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j\
    \ - 1))\n                }\n            }\n        }\n        maxFill(rows - 1)(cols\
    \ - 1)", "        val n = grid.length\n        val m = grid(0).length\n      \
    \  val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n         \
    \   for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n         \
    \           maxFill(i) += 1\n                }\n            }\n        }\n   \
    \     val maxFillSum = maxFill.sum\n        val maxFillSum2 = maxFill.map(x =>\
    \ x * x).sum\n        val maxFillSum3 = maxFill.map(x => x * x * x).sum\n    \
    \    val maxFillSum4 = maxFill.map(x => x * x * x * x).sum\n        val maxFillSum5\
    \ = maxFill.map(x => x * x * x * x * x).sum\n        val maxFillSum6 = maxFill.map(x\
    \ => x * x * x * x * x * x).sum\n        val maxFillSum7 = maxFill.map(x => x\
    \ * x * x * x * x * x * x).sum\n        val maxFillSum8 = maxFill.map(x => x *\
    \ x * x * x * x * x * x * x).sum\n        val maxFillSum9 = maxFill.map(x => x\
    \ * x * x * x * x * x * x * x * x).sum\n        val maxFillSum10 = maxFill.map(x\
    \ => x * x * x * x * x * x * x * x * x * x).sum\n        val maxFillSum11 = maxFill.map(x\
    \ => x * x * x * x * x * x * x * x * x * x * x).sum\n        val maxFillSum12\
    \ = maxFill.map(x => x * x * x * x * x * x * x * x * x * x * x * x).sum\n    \
    \    val maxFillSum13 = maxFill.map(x => x * x * x * x * x * x * x * x * x * x\
    \ * x * x * x).sum\n        val maxFillSum14 = maxFill.map(x => x * x * x * x\
    \ * x * x * x * x * x * x * x * x * x * x", "        val maxFill = grid.map(row\
    \ => row.sum).max\n        if (maxFill <= capacity) 0 else maxFill / capacity\
    \ + (if (maxFill % capacity == 0) 0 else 1)", "        val n = grid.length\n \
    \       val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n    \
    \    for (i <- 0 until n) {\n            var j = 0\n            while (j < m &&\
    \ grid(i)(j) == 0) j += 1\n            maxFill(i) = j\n        }\n        val\
    \ dp = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n            var j =\
    \ 0\n            while (j < n && i + j < n) {\n                dp(i + j) = max(dp(i\
    \ + j), dp(i) + maxFill(i + j))\n                j += 1\n            }\n     \
    \   }\n        dp(n - 1) / capacity", "        val m = grid.length\n        val\
    \ n = grid(0).length\n        val dp = Array.ofDim[Long](m, n)\n        for (i\
    \ <- 0 until m) {\n            for (j <- 0 until n) {\n                if (i ==\
    \ 0) dp(i)(j) = grid(i)(j)\n                else dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n\
    \            }\n        }\n        var result = 0L\n        for (i <- 0 until\
    \ m) {\n            for (j <- 0 until n) {\n                if (dp(i)(j) < capacity)\
    \ {\n                    result += capacity - dp(i)(j)\n                }\n  \
    \          }\n        }\n        result", "        val n = grid.length\n     \
    \   val m = grid(0).length\n        val maxFill = Array.fill(n, m)(0L)\n     \
    \   for (i <- 0 until n) {\n            for (j <- 0 until m) {\n             \
    \   if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n   \
    \             } else {\n                    maxFill(i)(j) = 0\n              \
    \  }\n            }\n        }\n        for (i <- 1 until n) {\n            for\
    \ (j <- 0 until m) {\n                if (grid(i)(j) == 0) {\n               \
    \     maxFill(i)(j) = maxFill(i - 1)(j)\n                }\n            }\n  \
    \      }\n        for (i <- n - 2 to 0 by -1) {\n            for (j <- 0 until\
    \ m) {\n                if (grid(i)(j) == 0) {\n                    maxFill(i)(j)\
    \ = min(maxFill(i)(j), maxFill(i + 1)(j))\n                }\n            }\n\
    \        }\n        var result = 0L\n        for (i <- 0 until n) {\n        \
    \    for (j <- 0 until m) {\n                result += maxFill(i)(j)\n       \
    \     }\n        }\n        result", "        // grid.map(x => x.map(y => if (y\
    \ == 1) capacity else 0)).flatten.sum\n        grid.map(x => x.map(y => if (y\
    \ == 1) capacity else 0).sum).sum", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        var result = 0L\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    result += capacity - 1\n                }\n            }\n\
    \        }\n        result", "        var maxFill = 0L\n        for (row <- grid)\
    \ {\n            var fill = 0L\n            for (well <- row) {\n            \
    \    if (well == 1) fill += 1\n                else {\n                    maxFill\
    \ = max(maxFill, fill)\n                    fill = 0\n                }\n    \
    \        }\n            maxFill = max(maxFill, fill)\n        }\n        maxFill",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                dp(i)(j) = grid(i)(j)\n                if (i > 0) dp(i)(j) =\
    \ max(dp(i)(j), dp(i - 1)(j))\n                if (j > 0) dp(i)(j) = max(dp(i)(j),\
    \ dp(i)(j - 1))\n            }\n        }\n        var result = 0L\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (dp(i)(j)\
    \ > 0) {\n                    result += dp(i)(j)\n                    dp(i)(j)\
    \ = 0\n                    if (i > 0) dp(i - 1)(j) = max(dp(i - 1)(j) - capacity,\
    \ 0)\n                    if (j > 0) dp(i)(j - 1) = max(dp(i)(j - 1) - capacity,\
    \ 0)\n                }\n            }\n        }\n        result", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n\
    \        var total = 0L\n        for (i <- 0 until n) {\n            var sum =\
    \ 0L\n            for (j <- 0 until m) {\n                sum += grid(i)(j)\n\
    \                if (sum > capacity) {\n                    total += sum - capacity\n\
    \                    sum = capacity\n                }\n            }\n      \
    \      maxFill(i) = sum\n        }\n        var result = total\n        for (j\
    \ <- 0 until m) {\n            var sum = 0L\n            for (i <- 0 until n)\
    \ {\n                sum += maxFill(i)\n                if (sum > capacity) {\n\
    \                    total += sum - capacity\n                    sum = capacity\n\
    \                }\n            }\n            result = min(result, total)\n \
    \       }\n        result"]
stop_tokens:
- "\n    }\n"
