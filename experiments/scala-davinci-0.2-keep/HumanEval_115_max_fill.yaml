name: HumanEval_115_max_fill
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n    // and each 1 in a row represents a single unit of water.\n    // Each\
  \ well has a corresponding bucket that can be used to extract water from it, \n\
  \    // and all buckets have the same capacity.\n    // Your task is to use the\
  \ buckets to empty the wells.\n    // Output the number of times you need to lower\
  \ the buckets.\n    // Example 1:\n    // Input: \n    // grid : [[0,0,1,0], [0,1,0,0],\
  \ [1,1,1,1]]\n    // bucket_capacity : 1\n    // Output: 6\n    // Example 2:\n\
  \    // Input: \n    // grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n  \
  \  // bucket_capacity : 2\n    // Output: 5\n    // Example 3:\n    // Input: \n\
  \    // grid : [[0,0,0], [0,0,0]]\n    // bucket_capacity : 5\n    // Output: 0\n\
  \    // Constraints:\n    // * all wells have the same length\n    // * 1 <= grid.length\
  \ <= 10^2\n    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n\
  \    // * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity\
  \ : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
  \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
  \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) ==\
  \ (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
  \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
  \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
  \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l)) ==\
  \ (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
  \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
  \ (9l)) == (2l));\n    }\n\n}\n"
completions: ["        val n = grid.length\n        val m = grid(0).length\n     \
    \   val maxFill = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n     \
    \               maxFill(i)(j) = capacity\n                } else {\n         \
    \           maxFill(i)(j) = 0\n                }\n            }\n        }\n \
    \       for (i <- 0 until n) {\n            for (j <- 0 until m) {\n         \
    \       if (i > 0) {\n                    maxFill(i)(j) = max(maxFill(i)(j), maxFill(i\
    \ - 1)(j))\n                }\n                if (j > 0) {\n                \
    \    maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n                }\n\
    \            }\n        }\n        var result = 0L\n        for (i <- n - 1 to\
    \ 0 by -1) {\n            for (j <- m - 1 to 0 by -1) {\n                if (i\
    \ < n - 1) {\n                    maxFill(i)(j) = max(maxFill(i)(j), maxFill(i\
    \ + 1)(j))\n                }\n                if (j < m - 1) {\n            \
    \        maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j + 1))\n             \
    \   }\n                result += maxFill(i)(j) - grid(i)(j)\n            }\n \
    \       }\n        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n     \
    \               dp(i)(j) = capacity\n                }\n                if (i\
    \ > 0) {\n                    dp(i)(j) = max(dp(i)(j), dp(i - 1)(j))\n       \
    \         }\n                if (j > 0) {\n                    dp(i)(j) = max(dp(i)(j),\
    \ dp(i)(j - 1))\n                }\n            }\n        }\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               result += dp(i)(j)\n            }\n        }\n        result",
  "        val n = grid.length\n        val m = grid(0).length\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               if (grid(i)(j) == 1) {\n                    result += 1\n    \
    \                grid(i)(j) = 0\n                    var k = i + 1\n         \
    \           while (k < n && grid(k)(j) == 1) {\n                        grid(k)(j)\
    \ = 0\n                        k += 1\n                    }\n               \
    \     k = i - 1\n                    while (k >= 0 && grid(k)(j) == 1) {\n   \
    \                     grid(k)(j) = 0\n                        k -= 1\n       \
    \             }\n                }\n            }\n        }\n        result",
  "        val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (grid(i)(j) == 1) {\n                    maxFill(i)(j)\
    \ = capacity\n                } else {\n                    if (i > 0) maxFill(i)(j)\
    \ = maxFill(i - 1)(j)\n                    if (j > 0) maxFill(i)(j) = max(maxFill(i)(j),\
    \ maxFill(i)(j - 1))\n                }\n            }\n        }\n        maxFill(n\
    \ - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        var result = 0L\n        for (i <- 0 until n) {\n            var count\
    \ = 0L\n            for (j <- 0 until m) {\n                if (grid(i)(j) ==\
    \ 1) count += 1\n            }\n            result += (count + capacity - 1) /\
    \ capacity\n        }\n        result", "        // The problem is equivalent\
    \ to finding the minimum number of times you need to lower the buckets\n     \
    \   // to empty the wells.\n        // The minimum number of times you need to\
    \ lower the buckets is the maximum number of times you need to fill the buckets.\n\
    \        // The maximum number of times you need to fill the buckets is the maximum\
    \ number of times you need to fill the buckets\n        // in a single well.\n\
    \        // The maximum number of times you need to fill the buckets in a single\
    \ well is the maximum number of units of water\n        // in a single well divided\
    \ by the bucket capacity.\n        // The maximum number of units of water in\
    \ a single well is the maximum number of 1s in a single well.\n        // The\
    \ maximum number of 1s in a single well is the length of the longest consecutive\
    \ sequence of 1s in a single well.\n        // The length of the longest consecutive\
    \ sequence of 1s in a single well is the length of the longest consecutive sequence\n\
    \        // of 1s in a single well divided by the bucket capacity.\n        //\
    \ The length of the longest consecutive sequence of 1s in a single well is the\
    \ length of the longest consecutive sequence\n        // of 1s in a single well\
    \ divided by the bucket capacity.\n        // The length of the longest consecutive\
    \ sequence of 1s in a single well is the length of the longest consecutive sequence\n\
    \        // of 1s in a single well divided by the bucket capacity.\n        //\
    \ The length of the longest consecutive sequence of 1s in a single well is the\
    \ length of the longest consecutive sequence\n        // of 1s in a single well\
    \ divided by the bucket capacity.\n        // The length of the longest consecutive\
    \ sequence of 1s in a single well is the length of the longest consecutive sequence\n\
    \        // of 1s in a single well divided by the bucket capacity.\n        //\
    \ The length of the longest consecutive sequence of 1s in a single well is the\
    \ length of the longest consecutive sequence\n        // of 1s in a single well\
    \ divided by the bucket capacity.\n        // The length of the longest consecutive\
    \ sequence of 1s in a single well is the length of the longest consecutive sequence\n\
    \        // of 1s in a single well divided by the bucket capacity.\n        //\
    \ The length of the longest consecutive sequence of 1s in a single well is the\
    \ length of the longest consecutive sequence\n        // of 1s in a single well\
    \ divided by the bucket capacity.\n", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        var sum = 0L\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until m) {\n                sum += grid(i)(j)\n      \
    \      }\n        }\n        sum / capacity", "        val n = grid.length\n \
    \       val m = grid(0).length\n        val dp = Array.fill(n, m)(0L)\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n         \
    \       }\n                if (i > 0) {\n                    dp(i)(j) = max(dp(i)(j),\
    \ dp(i - 1)(j))\n                }\n                if (j > 0) {\n           \
    \         dp(i)(j) = max(dp(i)(j), dp(i)(j - 1))\n                }\n        \
    \    }\n        }\n        var result = 0L\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n \
    \                   result += capacity - dp(i)(j)\n                }\n       \
    \     }\n        }\n        result", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n        for (i\
    \ <- 0 until n) {\n            var j = 0\n            while (j < m && grid(i)(j)\
    \ == 0) j += 1\n            maxFill(i) = j\n        }\n        var result = 0L\n\
    \        var i = 0\n        while (i < n) {\n            var j = 0\n         \
    \   while (j < m && grid(i)(j) == 0) j += 1\n            if (j == m) {\n     \
    \           i += 1\n                continue\n            }\n            val maxFill\
    \ = maxFill(i)\n            if (maxFill == 0) {\n                result += 1\n\
    \                i += 1\n                continue\n            }\n           \
    \ var k = i + 1\n            while (k < n && maxFill(k) >= maxFill) k += 1\n \
    \           val num = min(k - i, capacity)\n            result += num\n      \
    \      i += num\n        }\n        result", "        val rows = grid.length\n\
    \        val cols = grid(0).length\n        val maxFill = Array.fill(rows, cols)(0L)\n\
    \        for (i <- 0 until rows) {\n            for (j <- 0 until cols) {\n  \
    \              if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n\
    \                } else {\n                    if (i > 0) maxFill(i)(j) = maxFill(i\
    \ - 1)(j)\n                    if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j\
    \ - 1))\n                }\n            }\n        }\n        maxFill(rows - 1)(cols\
    \ - 1)", "        val n = grid.length\n        val m = grid(0).length\n      \
    \  val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n         \
    \   for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n         \
    \           maxFill(i) += 1\n                }\n            }\n        }\n   \
    \     val maxFillSum = maxFill.sum\n        val maxFillSum2 = maxFill.map(x =>\
    \ x * x).sum\n        val maxFillSum3 = maxFill.map(x => x * x * x).sum\n    \
    \    val maxFillSum4 = maxFill.map(x => x * x * x * x).sum\n        val maxFillSum5\
    \ = maxFill.map(x => x * x * x * x * x).sum\n        val maxFillSum6 = maxFill.map(x\
    \ => x * x * x * x * x * x).sum\n        val maxFillSum7 = maxFill.map(x => x\
    \ * x * x * x * x * x * x).sum\n        val maxFillSum8 = maxFill.map(x => x *\
    \ x * x * x * x * x * x * x).sum\n        val maxFillSum9 = maxFill.map(x => x\
    \ * x * x * x * x * x * x * x * x).sum\n        val maxFillSum10 = maxFill.map(x\
    \ => x * x * x * x * x * x * x * x * x * x).sum\n        val maxFillSum11 = maxFill.map(x\
    \ => x * x * x * x * x * x * x * x * x * x * x).sum\n        val maxFillSum12\
    \ = maxFill.map(x => x * x * x * x * x * x * x * x * x * x * x * x).sum\n    \
    \    val maxFillSum13 = maxFill.map(x => x * x * x * x * x * x * x * x * x * x\
    \ * x * x * x).sum\n        val maxFillSum14 = maxFill.map(x => x * x * x * x\
    \ * x * x * x * x * x * x * x * x * x * x", "        val maxFill = grid.map(row\
    \ => row.sum).max\n        if (maxFill <= capacity) 0 else maxFill / capacity\
    \ + (if (maxFill % capacity == 0) 0 else 1)", "        val n = grid.length\n \
    \       val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n    \
    \    for (i <- 0 until n) {\n            var j = 0\n            while (j < m &&\
    \ grid(i)(j) == 0) j += 1\n            maxFill(i) = j\n        }\n        val\
    \ dp = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n            var j =\
    \ 0\n            while (j < n && i + j < n) {\n                dp(i + j) = max(dp(i\
    \ + j), dp(i) + maxFill(i + j))\n                j += 1\n            }\n     \
    \   }\n        dp(n - 1) / capacity", "        val m = grid.length\n        val\
    \ n = grid(0).length\n        val dp = Array.ofDim[Long](m, n)\n        for (i\
    \ <- 0 until m) {\n            for (j <- 0 until n) {\n                if (i ==\
    \ 0) dp(i)(j) = grid(i)(j)\n                else dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n\
    \            }\n        }\n        var result = 0L\n        for (i <- 0 until\
    \ m) {\n            for (j <- 0 until n) {\n                if (dp(i)(j) < capacity)\
    \ {\n                    result += capacity - dp(i)(j)\n                }\n  \
    \          }\n        }\n        result", "        val n = grid.length\n     \
    \   val m = grid(0).length\n        val maxFill = Array.fill(n, m)(0L)\n     \
    \   for (i <- 0 until n) {\n            for (j <- 0 until m) {\n             \
    \   if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n   \
    \             } else {\n                    maxFill(i)(j) = 0\n              \
    \  }\n            }\n        }\n        for (i <- 1 until n) {\n            for\
    \ (j <- 0 until m) {\n                if (grid(i)(j) == 0) {\n               \
    \     maxFill(i)(j) = maxFill(i - 1)(j)\n                }\n            }\n  \
    \      }\n        for (i <- n - 2 to 0 by -1) {\n            for (j <- 0 until\
    \ m) {\n                if (grid(i)(j) == 0) {\n                    maxFill(i)(j)\
    \ = min(maxFill(i)(j), maxFill(i + 1)(j))\n                }\n            }\n\
    \        }\n        var result = 0L\n        for (i <- 0 until n) {\n        \
    \    for (j <- 0 until m) {\n                result += maxFill(i)(j)\n       \
    \     }\n        }\n        result", "        // grid.map(x => x.map(y => if (y\
    \ == 1) capacity else 0)).flatten.sum\n        grid.map(x => x.map(y => if (y\
    \ == 1) capacity else 0).sum).sum", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        var result = 0L\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    result += capacity - 1\n                }\n            }\n\
    \        }\n        result", "        var maxFill = 0L\n        for (row <- grid)\
    \ {\n            var fill = 0L\n            for (well <- row) {\n            \
    \    if (well == 1) fill += 1\n                else {\n                    maxFill\
    \ = max(maxFill, fill)\n                    fill = 0\n                }\n    \
    \        }\n            maxFill = max(maxFill, fill)\n        }\n        maxFill",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                dp(i)(j) = grid(i)(j)\n                if (i > 0) dp(i)(j) =\
    \ max(dp(i)(j), dp(i - 1)(j))\n                if (j > 0) dp(i)(j) = max(dp(i)(j),\
    \ dp(i)(j - 1))\n            }\n        }\n        var result = 0L\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (dp(i)(j)\
    \ > 0) {\n                    result += dp(i)(j)\n                    dp(i)(j)\
    \ = 0\n                    if (i > 0) dp(i - 1)(j) = max(dp(i - 1)(j) - capacity,\
    \ 0)\n                    if (j > 0) dp(i)(j - 1) = max(dp(i)(j - 1) - capacity,\
    \ 0)\n                }\n            }\n        }\n        result", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n\
    \        var total = 0L\n        for (i <- 0 until n) {\n            var sum =\
    \ 0L\n            for (j <- 0 until m) {\n                sum += grid(i)(j)\n\
    \                if (sum > capacity) {\n                    total += sum - capacity\n\
    \                    sum = capacity\n                }\n            }\n      \
    \      maxFill(i) = sum\n        }\n        var result = total\n        for (j\
    \ <- 0 until m) {\n            var sum = 0L\n            for (i <- 0 until n)\
    \ {\n                sum += maxFill(i)\n                if (sum > capacity) {\n\
    \                    total += sum - capacity\n                    sum = capacity\n\
    \                }\n            }\n            result = min(result, total)\n \
    \       }\n        result", "        val maxFill = grid.map(row => row.max).max\n\
    \        val minFill = grid.map(row => row.min).min\n        if (maxFill == minFill)\
    \ return 0\n        val maxFillCount = grid.map(row => row.count(_ == maxFill)).sum\n\
    \        val minFillCount = grid.map(row => row.count(_ == minFill)).sum\n   \
    \     val maxFillCountPerBucket = maxFillCount / capacity\n        val minFillCountPerBucket\
    \ = minFillCount / capacity\n        val maxFillCountPerBucketRemainder = maxFillCount\
    \ % capacity\n        val minFillCountPerBucketRemainder = minFillCount % capacity\n\
    \        val maxFillCountPerBucketRemainderCount = grid.map(row => row.count(_\
    \ == maxFill - 1)).sum\n        val minFillCountPerBucketRemainderCount = grid.map(row\
    \ => row.count(_ == minFill + 1)).sum\n        val maxFillCountPerBucketRemainderCountPerBucket\
    \ = maxFillCountPerBucketRemainderCount / capacity\n        val minFillCountPerBucketRemainderCountPerBucket\
    \ = minFillCountPerBucketRemainderCount / capacity\n        val maxFillCountPerBucketRemainderCountPerBucketRemainder\
    \ = maxFillCountPerBucketRemainderCount % capacity\n        val minFillCountPerBucketRemainderCountPerBucketRemainder\
    \ = minFillCountPerBucketRemainderCount % capacity\n        val maxFillCountPerBucketRemainderCountPerBucketRemainderCount\
    \ = grid.map(row => row.count(_ == maxFill - 2)).sum\n        val minFillCountPerBucketRemainderCountPerBucketRemainderCount\
    \ = grid.map(row => row.count(_ == minFill + 2)).sum\n        val maxFillCountPerBucketRemainderCountPerBucketRemainderCountPerBucket\
    \ = maxFillCountPerBucketRemainderCountPerBucketRemainderCount / capacity\n  \
    \      val minFillCountPerBucketRemainderCountPerBucketRemainderCountPerBucket\
    \ = minFillCountPerBucketRemainderCountPerBucketRemainderCount / capacity\n  \
    \      val maxFillCountPerBucketRem", "        val maxFill = grid.map(row => row.max).max\n\
    \        val minFill = grid.map(row => row.min).min\n        var result = 0L\n\
    \        for (fill <- minFill to maxFill) {\n            result += grid.map(row\
    \ => row.count(_ >= fill)).max\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val max = grid.map(row => row.sum).max\n\
    \        var ans = 0L\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                if (grid(i)(j) == 1) {\n                    ans\
    \ += 1\n                    grid(i)(j) = 0\n                }\n            }\n\
    \        }\n        ans += max / capacity\n        if (max % capacity != 0) ans\
    \ += 1\n        ans", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n   \
    \         var count = 0L\n            for (j <- 0 until m) {\n               \
    \ if (grid(i)(j) == 1) count += 1\n            }\n            maxFill(i) = count\n\
    \        }\n        var result = 0L\n        for (i <- 0 until n) {\n        \
    \    if (maxFill(i) > capacity) {\n                result += maxFill(i) - capacity\n\
    \            }\n        }\n        result", "        val n = grid.length\n   \
    \     val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n      \
    \  for (i <- 0 until n) {\n            var j = 0\n            while (j < m &&\
    \ grid(i)(j) == 0) j += 1\n            maxFill(i) = min(j, capacity)\n       \
    \ }\n        maxFill.sum", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n   \
    \         var j = 0\n            while (j < m && grid(i)(j) == 0) j += 1\n   \
    \         maxFill(i) = j\n        }\n        val maxFillSum = maxFill.sum\n  \
    \      val maxFillSum2 = maxFill.map(x => x * x).sum\n        val maxFillSum3\
    \ = maxFill.map(x => x * x * x).sum\n        val maxFillSum4 = maxFill.map(x =>\
    \ x * x * x * x).sum\n        val maxFillSum5 = maxFill.map(x => x * x * x * x\
    \ * x).sum\n        val maxFillSum6 = maxFill.map(x => x * x * x * x * x * x).sum\n\
    \        val maxFillSum7 = maxFill.map(x => x * x * x * x * x * x * x).sum\n \
    \       val maxFillSum8 = maxFill.map(x => x * x * x * x * x * x * x * x).sum\n\
    \        val maxFillSum9 = maxFill.map(x => x * x * x * x * x * x * x * x * x).sum\n\
    \        val maxFillSum10 = maxFill.map(x => x * x * x * x * x * x * x * x * x\
    \ * x).sum\n        val maxFillSum11 = maxFill.map(x => x * x * x * x * x * x\
    \ * x * x * x * x * x).sum\n        val maxFillSum12 = maxFill.map(x => x * x\
    \ * x * x * x * x * x * x * x * x * x * x).sum\n        val maxFillSum13 = maxFill.map(x\
    \ => x * x * x * x * x * x * x * x * x * x * x * x * x).sum\n        val maxFillSum14\
    \ = maxFill.map(x => x * x * x * x * x * x * x * x * x * x * x * x * x * x).sum\n\
    \        val", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n     \
    \               dp(i)(j) = capacity\n                }\n                if (i\
    \ > 0) {\n                    dp(i)(j) = max(dp(i)(j), dp(i - 1)(j))\n       \
    \         }\n                if (j > 0) {\n                    dp(i)(j) = max(dp(i)(j),\
    \ dp(i)(j - 1))\n                }\n            }\n        }\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               result += dp(i)(j)\n            }\n        }\n        result",
  "        val n = grid.length\n        val m = grid(0).length\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n           \
    \ for (j <- 0 until m) {\n                sum += grid(i)(j)\n                if\
    \ (sum > capacity) {\n                    result += sum - capacity\n         \
    \           sum = capacity\n                }\n            }\n        }\n    \
    \    result", "        val n = grid.length\n        val m = grid(0).length\n \
    \       val dp = Array.fill(n)(Array.fill(m)(0L))\n        var ans = 0L\n    \
    \    for (i <- 0 until n) {\n            for (j <- 0 until m) {\n            \
    \    if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n       \
    \             ans += capacity\n                }\n                if (i > 0) {\n\
    \                    val diff = min(dp(i - 1)(j), capacity - dp(i)(j))\n     \
    \               dp(i)(j) += diff\n                    ans += diff\n          \
    \      }\n                if (j > 0) {\n                    val diff = min(dp(i)(j\
    \ - 1), capacity - dp(i)(j))\n                    dp(i)(j) += diff\n         \
    \           ans += diff\n                }\n            }\n        }\n       \
    \ ans", "        val n = grid.length\n        val m = grid(0).length\n       \
    \ var result = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n\
    \            for (j <- 0 until m) {\n                sum += grid(i)(j)\n     \
    \           if (sum > capacity) {\n                    result += sum - capacity\n\
    \                    sum = capacity\n                }\n            }\n      \
    \  }\n        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(capacity)\n        var result = 0L\n    \
    \    while (true) {\n            var isEmpty = true\n            for (i <- 0 until\
    \ n) {\n                for (j <- 0 until m) {\n                    if (grid(i)(j)\
    \ > 0) {\n                        isEmpty = false\n                        val\
    \ fill = min(grid(i)(j), maxFill(i))\n                        grid(i)(j) -= fill\n\
    \                        maxFill(i) -= fill\n                        result +=\
    \ fill\n                    }\n                }\n            }\n            if\
    \ (isEmpty) return result\n            for (i <- 0 until n) maxFill(i) = capacity\n\
    \        }\n        return result", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        var maxFill = 0L\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill = max(maxFill, capacity - grid(i)(j))\n         \
    \       }\n            }\n        }\n        maxFill", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val filled = Array.fill(n)(0L)\n    \
    \    var count = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n\
    \            for (j <- 0 until m) {\n                sum += grid(i)(j)\n     \
    \           if (sum == capacity) {\n                    filled(i) = capacity\n\
    \                    count += 1\n                    sum = 0\n               \
    \ } else if (sum > capacity) {\n                    filled(i) = capacity\n   \
    \                 count += 1\n                    sum = grid(i)(j)\n         \
    \       }\n            }\n            if (sum > 0) {\n                filled(i)\
    \ = sum\n                count += 1\n            }\n        }\n        count",
  "        val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n, m)(0L)\n        var maxFillCount = 0L\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j) ==\
    \ 1) {\n                    maxFill(i)(j) = capacity\n                    maxFillCount\
    \ += capacity\n                }\n            }\n        }\n        maxFillCount",
  "        val m = grid.length\n        val n = grid(0).length\n        var result\
    \ = 0L\n        for (i <- 0 until m) {\n            var sum = 0L\n           \
    \ for (j <- 0 until n) {\n                sum += grid(i)(j)\n                if\
    \ (sum > capacity) {\n                    result += sum - capacity\n         \
    \           sum = capacity\n                }\n            }\n        }\n    \
    \    result", "        val m = grid.length\n        val n = grid(0).length\n \
    \       val maxFill = Array.fill(m, n)(0L)\n        for (i <- 0 until m) {\n \
    \           for (j <- 0 until n) {\n                if (grid(i)(j) == 1) {\n \
    \                   maxFill(i)(j) = capacity\n                } else {\n     \
    \               if (i > 0) maxFill(i)(j) = maxFill(i - 1)(j)\n               \
    \     if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n     \
    \           }\n            }\n        }\n        maxFill(m - 1)(n - 1)", "   \
    \     val maxFill = grid.map(row => row.sum).max\n        val maxFillCount = grid.map(row\
    \ => row.count(_ == maxFill)).max\n        val maxFillCount2 = grid.map(row =>\
    \ row.count(_ == maxFill - 1)).max\n        val maxFillCount3 = grid.map(row =>\
    \ row.count(_ == maxFill - 2)).max\n        val maxFillCount4 = grid.map(row =>\
    \ row.count(_ == maxFill - 3)).max\n        val maxFillCount5 = grid.map(row =>\
    \ row.count(_ == maxFill - 4)).max\n        val maxFillCount6 = grid.map(row =>\
    \ row.count(_ == maxFill - 5)).max\n        val maxFillCount7 = grid.map(row =>\
    \ row.count(_ == maxFill - 6)).max\n        val maxFillCount8 = grid.map(row =>\
    \ row.count(_ == maxFill - 7)).max\n        val maxFillCount9 = grid.map(row =>\
    \ row.count(_ == maxFill - 8)).max\n        val maxFillCount10 = grid.map(row\
    \ => row.count(_ == maxFill - 9)).max\n        val maxFillCount11 = grid.map(row\
    \ => row.count(_ == maxFill - 10)).max\n        val maxFillCount12 = grid.map(row\
    \ => row.count(_ == maxFill - 11)).max\n        val maxFillCount13 = grid.map(row\
    \ => row.count(_ == maxFill - 12)).max\n        val maxFillCount14 = grid.map(row\
    \ => row.count(_ == maxFill - 13)).max\n        val maxFillCount15 = grid.map(row\
    \ => row.count(_ == maxFill - 14)).max\n        val maxFillCount16 = grid.map(row\
    \ => row.count(_ == maxFill - 15)).max\n        val maxFillCount17 = grid.map(row\
    \ => row.count(_ == maxFill - 16)).max\n        val maxFillCount18 = grid.map(row\
    \ => row.count(_ == maxFill - 17)).max\n        val maxFillCount19 = grid.map(row\
    \ => row.count(_ == maxFill - 18)).max\n        val maxFillCount20 = grid.map(row\
    \ => row.count(_ == maxFill - 19", "        val n = grid.length\n        val m\
    \ = grid(0).length\n        val maxFill = Array.fill(n, m)(0L)\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    maxFill(i)(j) = capacity\n                } else\
    \ {\n                    if (i > 0) maxFill(i)(j) = maxFill(i - 1)(j)\n      \
    \              if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n\
    \                }\n            }\n        }\n        maxFill(n - 1)(m - 1)",
  "        val n = grid.length\n        val m = grid(0).length\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n           \
    \ for (j <- 0 until m) {\n                sum += grid(i)(j)\n                if\
    \ (sum > capacity) {\n                    result += sum - capacity\n         \
    \           sum = capacity\n                }\n            }\n        }\n    \
    \    result", "        var maxFill = 0L\n        for (row <- grid) {\n       \
    \     var fill = 0L\n            for (well <- row) {\n                if (well\
    \ == 1) fill += 1\n                else if (fill > 0) {\n                    maxFill\
    \ = max(maxFill, fill)\n                    fill = 0\n                }\n    \
    \        }\n            maxFill = max(maxFill, fill)\n        }\n        maxFill",
  "        val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (grid(i)(j) == 1) {\n                    maxFill(i)(j)\
    \ = capacity\n                } else {\n                    if (i > 0) maxFill(i)(j)\
    \ = maxFill(i - 1)(j)\n                    if (j > 0) maxFill(i)(j) = max(maxFill(i)(j),\
    \ maxFill(i)(j - 1))\n                }\n            }\n        }\n        maxFill(n\
    \ - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        var max = 0L\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                if (grid(i)(j) == 1) {\n                    max\
    \ = max max (i + 1)\n                }\n            }\n        }\n        max",
  "        val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                if (grid(i)(j) == 1) {\n                    maxFill(i)\
    \ += 1\n                }\n            }\n        }\n        var result = 0L\n\
    \        for (i <- 0 until n) {\n            val fill = maxFill(i)\n         \
    \   if (fill > 0) {\n                val times = ceil(fill.toDouble / capacity.toDouble).toLong\n\
    \                result += times\n                for (j <- 0 until n) {\n   \
    \                 if (j != i) {\n                        maxFill(j) = max(0, maxFill(j)\
    \ - capacity * times)\n                    }\n                }\n            }\n\
    \        }\n        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                } else {\n    \
    \                maxFill(i)(j) = 0\n                }\n            }\n       \
    \ }\n        for (i <- 1 until n) {\n            for (j <- 0 until m) {\n    \
    \            if (grid(i)(j) == 0) {\n                    maxFill(i)(j) = maxFill(i\
    \ - 1)(j)\n                }\n            }\n        }\n        for (i <- 0 until\
    \ n) {\n            for (j <- 1 until m) {\n                if (grid(i)(j) ==\
    \ 0) {\n                    maxFill(i)(j) = maxFill(i)(j - 1)\n              \
    \  }\n            }\n        }\n        for (i <- n - 2 to 0 by -1) {\n      \
    \      for (j <- m - 1 to 0 by -1) {\n                if (grid(i)(j) == 0) {\n\
    \                    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i + 1)(j))\n \
    \               }\n            }\n        }\n        for (i <- n - 1 to 0 by -1)\
    \ {\n            for (j <- m - 2 to 0 by -1) {\n                if (grid(i)(j)\
    \ == 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j\
    \ + 1))\n                }\n            }\n        }\n        var result = 0L\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        result += maxFill(i)(j)\n            }\n        }\n        result", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n)(Array.fill(m)(0L))\n        for (i <- 0 until n) {\n       \
    \     for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n       \
    \             maxFill(i)(j) = capacity\n                }\n            }\n   \
    \     }\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (grid(i)(j) == 1) {\n                    if (i > 0) {\n  \
    \                      maxFill(i)(j) = min(maxFill(i)(j), maxFill(i - 1)(j) +\
    \ capacity)\n                    }\n                    if (j > 0) {\n       \
    \                 maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1) + capacity)\n\
    \                    }\n                }\n            }\n        }\n        var\
    \ result = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m)\
    \ {\n                if (grid(i)(j) == 1) {\n                    result += maxFill(i)(j)\n\
    \                }\n            }\n        }\n        result", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (grid(i)(j) == 1) {\n                    dp(i)(j) = 1\n  \
    \                  if (i > 0) dp(i)(j) += dp(i - 1)(j)\n                    if\
    \ (j > 0) dp(i)(j) += dp(i)(j - 1)\n                    if (i > 0 && j > 0) dp(i)(j)\
    \ -= dp(i - 1)(j - 1)\n                }\n            }\n        }\n        var\
    \ result = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m)\
    \ {\n                for (k <- i until n) {\n                    for (l <- j until\
    \ m) {\n                        val count = dp(k)(l)\n                       \
    \ if (i > 0) count -= dp(i - 1)(l)\n                        if (j > 0) count -=\
    \ dp(k)(j - 1)\n                        if (i > 0 && j > 0) count += dp(i - 1)(j\
    \ - 1)\n                        if (count > 0) {\n                           \
    \ val times = ceil(count.toDouble / capacity.toDouble).toLong\n              \
    \              result += times\n                        }\n                  \
    \  }\n                }\n            }\n        }\n        result", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n)(Array.fill(m)(0L))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0) {\n                    dp(i)(j) = grid(i)(j)\n          \
    \      } else {\n                    dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n  \
    \              }\n            }\n        }\n        var result = 0L\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                val\
    \ fill = min(dp(i)(j), capacity)\n                result += fill\n           \
    \     dp(i)(j) -= fill\n            }\n        }\n        result", "        val\
    \ m = grid.length\n        val n = grid(0).length\n        var result = 0L\n \
    \       for (i <- 0 until m) {\n            var sum = 0L\n            for (j <-\
    \ 0 until n) {\n                sum += grid(i)(j)\n                if (sum > capacity)\
    \ {\n                    result += sum - capacity\n                    sum = capacity\n\
    \                }\n            }\n        }\n        result", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (grid(i)(j) == 1) {\n                    maxFill(i) += 1\n       \
    \         }\n            }\n        }\n        val minFill = maxFill.min\n   \
    \     val maxFillSum = maxFill.sum\n        val minFillSum = minFill * n\n   \
    \     if (minFillSum <= maxFillSum) {\n            return minFillSum\n       \
    \ }\n        var result = 0L\n        for (i <- 0 until n) {\n            result\
    \ += maxFill(i) - minFill\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        var max = 0L\n        for (i <- 0 until\
    \ n) {\n            var sum = 0L\n            for (j <- 0 until m) {\n       \
    \         sum += grid(i)(j)\n                if (sum > max) max = sum\n      \
    \      }\n        }\n        max / capacity + (if (max % capacity == 0) 0 else\
    \ 1)", "        val m = grid.length\n        val n = grid(0).length\n        var\
    \ result = 0L\n        for (i <- 0 until m) {\n            var sum = 0L\n    \
    \        for (j <- 0 until n) {\n                sum += grid(i)(j)\n         \
    \       if (sum > capacity) {\n                    result += sum - capacity\n\
    \                    sum = capacity\n                }\n            }\n      \
    \  }\n        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(Array.fill(m)(0L))\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j) ==\
    \ 1) {\n                    maxFill(i)(j) = capacity\n                } else {\n\
    \                    if (i > 0) maxFill(i)(j) = maxFill(i - 1)(j)\n          \
    \          if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n\
    \                }\n            }\n        }\n        maxFill(n - 1)(m - 1)",
  "        val maxFill = grid.map(row => row.max).max\n        val maxFillCount =\
    \ grid.map(row => row.count(_ == maxFill)).sum\n        maxFill * maxFillCount",
  "        val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                if (grid(i)(j) == 1) {\n                    maxFill(i)\
    \ += 1\n                }\n            }\n        }\n        val maxFillSum =\
    \ maxFill.sum\n        val minFill = Array.fill(n)(0L)\n        var result = 0L\n\
    \        while (minFill.sum < maxFillSum) {\n            for (i <- 0 until n)\
    \ {\n                if (minFill(i) < maxFill(i)) {\n                    minFill(i)\
    \ += 1\n                    result += 1\n                }\n            }\n  \
    \      }\n        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n   \
    \         var j = 0\n            while (j < m && grid(i)(j) == 0) j += 1\n   \
    \         if (j == m) maxFill(i) = capacity\n            else maxFill(i) = j\n\
    \        }\n        maxFill", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(Array.fill(m)(0L))\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j) ==\
    \ 1) {\n                    maxFill(i)(j) = capacity\n                }\n    \
    \        }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                if (i > 0) {\n                    maxFill(i)(j)\
    \ = max(maxFill(i)(j), maxFill(i - 1)(j))\n                }\n               \
    \ if (j > 0) {\n                    maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j\
    \ - 1))\n                }\n            }\n        }\n        var total = 0L\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        total += maxFill(i)(j)\n            }\n        }\n        total", " \
    \       val n = grid.length\n        val m = grid(0).length\n        var maxFill\
    \ = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               if (grid(i)(j) == 1) {\n                    maxFill = max(maxFill,\
    \ j + 1)\n                }\n            }\n        }\n        maxFill", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n           \
    \ for (j <- 0 until m) {\n                sum += grid(i)(j)\n                if\
    \ (sum > capacity) {\n                    result += sum - capacity\n         \
    \           sum = capacity\n                }\n            }\n        }\n    \
    \    result", "        val n = grid.length\n        val m = grid(0).length\n \
    \       var result = 0L\n        for (i <- 0 until n) {\n            var sum =\
    \ 0L\n            for (j <- 0 until m) {\n                sum += grid(i)(j)\n\
    \                if (sum > capacity) {\n                    result += sum - capacity\n\
    \                    sum = capacity\n                }\n            }\n      \
    \  }\n        result", "        val m = grid.length\n        val n = grid(0).length\n\
    \        val maxFill = Array.ofDim[Long](m, n)\n        for (i <- 0 until m) {\n\
    \            for (j <- 0 until n) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                } else {\n    \
    \                maxFill(i)(j) = 0\n                }\n            }\n       \
    \ }\n        for (i <- 0 until m) {\n            for (j <- 0 until n) {\n    \
    \            if (i > 0) {\n                    maxFill(i)(j) = max(maxFill(i)(j),\
    \ maxFill(i - 1)(j))\n                }\n                if (j > 0) {\n      \
    \              maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n       \
    \         }\n            }\n        }\n        var result = 0L\n        for (i\
    \ <- m - 1 to 0 by -1) {\n            for (j <- n - 1 to 0 by -1) {\n        \
    \        if (i < m - 1) {\n                    maxFill(i)(j) = max(maxFill(i)(j),\
    \ maxFill(i + 1)(j))\n                }\n                if (j < n - 1) {\n  \
    \                  maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j + 1))\n   \
    \             }\n                result += maxFill(i)(j) - grid(i)(j)\n      \
    \      }\n        }\n        result", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(0L)\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    dp(i)(j) = 1\n                    if (i > 0) dp(i)(j)\
    \ += dp(i - 1)(j)\n                    if (j > 0) dp(i)(j) += dp(i)(j - 1)\n \
    \                   if (i > 0 && j > 0) dp(i)(j) -= dp(i - 1)(j - 1)\n       \
    \         }\n            }\n        }\n        var result = 0L\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                for (k\
    \ <- i until n) {\n                    for (l <- j until m) {\n              \
    \          var count = dp(k)(l)\n                        if (i > 0) count -= dp(i\
    \ - 1)(l)\n                        if (j > 0) count -= dp(k)(j - 1)\n        \
    \                if (i > 0 && j > 0) count += dp(i - 1)(j - 1)\n             \
    \           if (count > 0) {\n                            result += (count + capacity\
    \ - 1) / capacity\n                        }\n                    }\n        \
    \        }\n            }\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n   \
    \     for (i <- 0 until n) {\n            var j = 0\n            while (j < m\
    \ && grid(i)(j) == 0) j += 1\n            if (j < m) {\n                maxFill(i)\
    \ = (m - j).toLong\n            }\n        }\n        maxFill.sorted.reverse.zipWithIndex.map(x\
    \ => (x._1 - 1) / capacity + x._2 + 1).sum", "        val n = grid.length\n  \
    \      val m = grid(0).length\n        val dp = Array.fill(n, m)(0L)\n       \
    \ for (i <- 0 until n) {\n            for (j <- 0 until m) {\n               \
    \ if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n          \
    \      }\n                if (i > 0) {\n                    dp(i)(j) = max(dp(i)(j),\
    \ dp(i - 1)(j))\n                }\n                if (j > 0) {\n           \
    \         dp(i)(j) = max(dp(i)(j), dp(i)(j - 1))\n                }\n        \
    \    }\n        }\n        var result = 0L\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until m) {\n                result += dp(i)(j)\n     \
    \       }\n        }\n        result", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(0L)\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    dp(i)(j) = capacity\n                }\n      \
    \          if (i > 0) {\n                    dp(i)(j) = max(dp(i)(j), dp(i - 1)(j))\n\
    \                }\n                if (j > 0) {\n                    dp(i)(j)\
    \ = max(dp(i)(j), dp(i)(j - 1))\n                }\n            }\n        }\n\
    \        var result = 0L\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                result += dp(i)(j)\n            }\n        }\n\
    \        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n   \
    \         var j = 0\n            while (j < m && grid(i)(j) == 0) j += 1\n   \
    \         maxFill(i) = j\n        }\n        var result = 0L\n        for (i <-\
    \ 0 until n) {\n            val fill = maxFill(i)\n            if (fill > 0) {\n\
    \                result += (fill - 1) / capacity + 1\n                for (j <-\
    \ i + 1 until n) {\n                    val fill = maxFill(j)\n              \
    \      if (fill > 0) {\n                        maxFill(j) = max(0, fill - capacity)\n\
    \                    }\n                }\n            }\n        }\n        result",
  "        val n = grid.length\n        val m = grid(0).length\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n           \
    \ for (j <- 0 until m) {\n                sum += grid(i)(j)\n                if\
    \ (sum > capacity) {\n                    result += sum - capacity\n         \
    \           sum = capacity\n                }\n            }\n        }\n    \
    \    result", "        val m = grid.length\n        val n = grid(0).length\n \
    \       var maxFill = 0L\n        for (i <- 0 until m) {\n            var fill\
    \ = 0L\n            for (j <- 0 until n) {\n                if (grid(i)(j) ==\
    \ 1) fill += 1\n            }\n            maxFill = max(maxFill, fill)\n    \
    \    }\n        maxFill", "        val n = grid.length\n        val m = grid(0).length\n\
    \        var maxFill = 0L\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                if (grid(i)(j) == 1) {\n                  \
    \  maxFill = max(maxFill, j + 1)\n                }\n            }\n        }\n\
    \        maxFill", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n   \
    \         var j = 0\n            while (j < m && grid(i)(j) == 0) j += 1\n   \
    \         if (j < m) {\n                val fill = min(capacity, m - j)\n    \
    \            maxFill(i) = fill\n                for (k <- j until j + fill.toInt)\
    \ grid(i)(k) = 0\n            }\n        }\n        maxFill.sum", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        var max = 0L\n    \
    \    for (i <- 0 until n) {\n            for (j <- 0 until m) {\n            \
    \    if (grid(i)(j) == 1) {\n                    max = max max (i + 1)\n     \
    \           }\n            }\n        }\n        max * capacity", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        var max = 0L\n    \
    \    for (i <- 0 until n) {\n            for (j <- 0 until m) {\n            \
    \    if (grid(i)(j) == 1) {\n                    max = max max (i + 1)\n     \
    \           }\n            }\n        }\n        max * capacity", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n\
    \                }\n                if (i > 0) {\n                    dp(i)(j)\
    \ = max(dp(i)(j), dp(i - 1)(j))\n                }\n                if (j > 0)\
    \ {\n                    dp(i)(j) = max(dp(i)(j), dp(i)(j - 1))\n            \
    \    }\n            }\n        }\n        var result = 0L\n        for (i <- 0\
    \ until n) {\n            for (j <- 0 until m) {\n                result += dp(i)(j)\n\
    \            }\n        }\n        result", "        val n = grid.length\n   \
    \     val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n      \
    \  for (i <- 0 until n) {\n            var sum = 0L\n            for (j <- 0 until\
    \ m) {\n                sum += grid(i)(j)\n                if (sum > capacity)\
    \ {\n                    maxFill(i) = capacity\n                    sum = 0\n\
    \                }\n            }\n            maxFill(i) = max(maxFill(i), sum)\n\
    \        }\n        maxFill.sum", "        // get the max height of each column\n\
    \        val maxHeights = grid.transpose.map(_.sum)\n        // get the max height\
    \ of each row\n        val maxWidths = grid.map(_.sum)\n        // get the max\
    \ height of the grid\n        val maxHeight = maxHeights.max\n        // get the\
    \ max width of the grid\n        val maxWidth = maxWidths.max\n        // get\
    \ the number of rows\n        val rows = grid.length\n        // get the number\
    \ of columns\n        val columns = grid(0).length\n        // get the number\
    \ of buckets\n        val buckets = maxHeight * maxWidth\n        // get the number\
    \ of times we need to lower the buckets\n        val lowers = maxHeights.map(maxHeight\
    \ - _).sum\n        // get the number of times we need to raise the buckets\n\
    \        val raises = maxWidths.map(maxWidth - _).sum\n        // get the number\
    \ of times we need to move the buckets\n        val moves = (rows - 1) * columns\
    \ + (columns - 1) * rows\n        // get the number of times we need to use the\
    \ buckets\n        val uses = maxHeights.map(maxHeight - _).sum * maxWidths.map(maxWidth\
    \ - _).sum\n        // get the number of times we need to use the buckets\n  \
    \      val uses2 = maxHeights.map(maxHeight - _).sum * maxWidths.map(maxWidth\
    \ - _).sum\n        // get the number of times we need to use the buckets\n  \
    \      val uses3 = maxHeights.map(maxHeight - _).sum * maxWidths.map(maxWidth\
    \ - _).sum\n        // get the number of times we need to use the buckets\n  \
    \      val uses4 = maxHeights.map(maxHeight - _).sum * maxWidths.map(maxWidth\
    \ - _).sum\n        // get the number of times we need to use the buckets\n  \
    \      val uses5 = maxHeights.map(maxHeight - _).sum * maxWidths.map(maxWidth\
    \ - _).sum\n        // get the number of times we need to use the buckets\n  \
    \      val uses6 = maxHeights.map(maxHeight - _).sum * maxWidths.map(maxWidth\
    \ - _).sum\n", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n     \
    \               dp(i)(j) = capacity\n                }\n                if (i\
    \ > 0) {\n                    dp(i)(j) = max(dp(i)(j), dp(i - 1)(j))\n       \
    \         }\n                if (j > 0) {\n                    dp(i)(j) = max(dp(i)(j),\
    \ dp(i)(j - 1))\n                }\n            }\n        }\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               if (grid(i)(j) == 1) {\n                    result += capacity\
    \ - dp(i)(j)\n                }\n            }\n        }\n        result", " \
    \       val max = grid.map(x => x.max).max\n        if (max == 0) 0\n        else\
    \ {\n            val min = grid.map(x => x.min).min\n            if (min == 1)\
    \ max\n            else {\n                val fill = min * capacity\n       \
    \         val newGrid = grid.map(x => x.map(y => y - fill))\n                fill\
    \ + maxFill(newGrid, capacity)\n            }\n        }", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n   \
    \     for (i <- 0 until n) {\n            var j = 0\n            while (j < m\
    \ && grid(i)(j) == 0) j += 1\n            maxFill(i) = j\n        }\n        val\
    \ dp = Array.fill(n + 1)(0L)\n        for (i <- 1 to n) {\n            dp(i) =\
    \ dp(i - 1) + maxFill(i - 1)\n            if (i >= capacity) dp(i) = min(dp(i),\
    \ dp(i - capacity) + m)\n        }\n        dp(n)", "        val rows = grid.length\n\
    \        val cols = grid(0).length\n        val rowMax = grid.map(row => row.sum)\n\
    \        val colMax = (0 until cols).map(j => grid.map(row => row(j)).sum)\n \
    \       val max = rowMax.max\n        val rowMaxIndex = rowMax.indexOf(max)\n\
    \        val colMaxIndex = colMax.indexOf(max)\n        val rowMaxCount = rowMax(rowMaxIndex)\n\
    \        val colMaxCount = colMax(colMaxIndex)\n        val rowMaxFill = min(rowMaxCount,\
    \ capacity)\n        val colMaxFill = min(colMaxCount, capacity)\n        val\
    \ rowMaxFillCount = rowMaxCount / capacity + (if (rowMaxCount % capacity == 0)\
    \ 0 else 1)\n        val colMaxFillCount = colMaxCount / capacity + (if (colMaxCount\
    \ % capacity == 0) 0 else 1)\n        val rowMaxFillCount2 = (0 until rows).map(i\
    \ => grid(i).sum / capacity + (if (grid(i).sum % capacity == 0) 0 else 1)).sum\n\
    \        val colMaxFillCount2 = (0 until cols).map(j => grid.map(row => row(j)).sum\
    \ / capacity + (if (grid.map(row => row(j)).sum % capacity == 0) 0 else 1)).sum\n\
    \        val rowMaxFillCount3 = (0 until rows).map(i => grid(i).sum / capacity\
    \ + (if (grid(i).sum % capacity == 0) 0 else 1)).sum - rowMaxFillCount\n     \
    \   val colMaxFillCount3 = (0 until cols).map(j => grid.map(row => row(j)).sum\
    \ / capacity + (if (grid.map(row => row(j)).sum % capacity == 0) 0 else 1)).sum\
    \ - colMaxFillCount\n        val rowMaxFillCount4 = (0 until rows).map(i => grid(i).sum\
    \ / capacity + (if (grid(i).sum % capacity == 0) 0 else 1)).sum - rowMaxFillCount\n\
    \        val colMaxFillCount4 = (0 until cols).map(j => grid.map(row => row(j)).sum\
    \ / capacity +", "        val wells = grid.map(_.map(x => if (x == 1) capacity\
    \ else 0))\n        var count = 0\n        while (wells.map(_.sum).sum > 0) {\n\
    \            wells.foreach(x => {\n                val fill = min(x.sum, capacity)\n\
    \                x.foreach(y => {\n                    if (y > 0) {\n        \
    \                val new_y = y - fill\n                        if (new_y < 0)\
    \ {\n                            x(x.indexOf(y)) = 0\n                       \
    \ } else {\n                            x(x.indexOf(y)) = new_y\n            \
    \            }\n                    }\n                })\n            })\n  \
    \          count += 1\n        }\n        count", "        val rows = grid.length\n\
    \        val cols = grid(0).length\n        val maxFill = Array.fill(rows)(0L)\n\
    \        for (i <- 0 until rows) {\n            var sum = 0L\n            for\
    \ (j <- 0 until cols) {\n                sum += grid(i)(j)\n                maxFill(i)\
    \ = max(maxFill(i), sum)\n            }\n        }\n        maxFill.map(x => (x\
    \ + capacity - 1) / capacity).sum", "        val rows = grid.length\n        val\
    \ cols = grid(0).length\n        val maxFill = Array.fill(rows)(Array.fill(cols)(0L))\n\
    \        for (i <- 0 until rows) {\n            for (j <- 0 until cols) {\n  \
    \              if (i == 0) {\n                    maxFill(i)(j) = grid(i)(j)\n\
    \                } else {\n                    maxFill(i)(j) = maxFill(i - 1)(j)\
    \ + grid(i)(j)\n                }\n            }\n        }\n        var result\
    \ = 0L\n        for (i <- 0 until rows) {\n            for (j <- 0 until cols)\
    \ {\n                if (maxFill(i)(j) < capacity) {\n                    result\
    \ += capacity - maxFill(i)(j)\n                }\n            }\n        }\n \
    \       result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                } else {\n    \
    \                if (i > 0) maxFill(i)(j) = maxFill(i - 1)(j)\n              \
    \      if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n    \
    \            }\n            }\n        }\n        maxFill(n - 1)(m - 1)", "  \
    \      val maxFill = grid.map(row => row.sum).max\n        val maxFillRows = grid.filter(row\
    \ => row.sum == maxFill)\n        val maxFillRow = maxFillRows.head\n        val\
    \ maxFillRowLength = maxFillRow.length\n        val maxFillRowLengths = maxFillRows.map(row\
    \ => row.length)\n        val maxFillRowLengthsSum = maxFillRowLengths.sum\n \
    \       val maxFillRowLengthsSumDiv = maxFillRowLengthsSum / maxFillRowLength\n\
    \        val maxFillRowLengthsSumMod = maxFillRowLengthsSum % maxFillRowLength\n\
    \        val maxFillRowLengthsSumDivCeil = ceil(maxFillRowLengthsSumDiv).toLong\n\
    \        val maxFillRowLengthsSumDivFloor = floor(maxFillRowLengthsSumDiv).toLong\n\
    \        val maxFillRowLengthsSumDivCeilMod = maxFillRowLengthsSumDivCeil % capacity\n\
    \        val maxFillRowLengthsSumDivFloorMod = maxFillRowLengthsSumDivFloor %\
    \ capacity\n        val maxFillRowLengthsSumDivCeilModDiv = maxFillRowLengthsSumDivCeilMod\
    \ / capacity\n        val maxFillRowLengthsSumDivFloorModDiv = maxFillRowLengthsSumDivFloorMod\
    \ / capacity\n        val maxFillRowLengthsSumDivCeilModDivCeil = ceil(maxFillRowLengthsSumDivCeilModDiv).toLong\n\
    \        val maxFillRowLengthsSumDivFloorModDivCeil = ceil(maxFillRowLengthsSumDivFloorModDiv).toLong\n\
    \        val maxFillRowLengthsSumDivCeilModDivFloor = floor(maxFillRowLengthsSumDivCeilModDiv).toLong\n\
    \        val maxFillRowLengthsSumDivFloorModDivFloor = floor(maxFillRowLengthsSumDivFloorModDiv).toLong\n\
    \        val maxFillRowLengthsSumDivCeilModDivCeilMod = maxFillRowLengthsSumDivCeilModDivCeil\
    \ % capacity\n        val maxFillRowLengthsSumDivFloorModDivCeilMod = maxFillRowLengthsSumDivFloor",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n\
    \                }\n                if (i > 0) {\n                    dp(i)(j)\
    \ = max(dp(i)(j), dp(i - 1)(j))\n                }\n                if (j > 0)\
    \ {\n                    dp(i)(j) = max(dp(i)(j), dp(i)(j - 1))\n            \
    \    }\n            }\n        }\n        var result = 0L\n        for (i <- 0\
    \ until n) {\n            for (j <- 0 until m) {\n                result += dp(i)(j)\n\
    \            }\n        }\n        result", "        val n = grid.length\n   \
    \     val m = grid(0).length\n        var result = 0L\n        for (i <- 0 until\
    \ n) {\n            var current = 0L\n            for (j <- 0 until m) {\n   \
    \             if (grid(i)(j) == 1) {\n                    if (current < capacity)\
    \ {\n                        result += capacity - current\n                  \
    \      current = capacity\n                    }\n                } else {\n \
    \                   current = 0\n                }\n            }\n        }\n\
    \        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val sum = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until m) {\n                sum(i)(j) = grid(i)(j) + (if\
    \ (i > 0) sum(i - 1)(j) else 0) + (if (j > 0) sum(i)(j - 1) else 0) - (if (i >\
    \ 0 && j > 0) sum(i - 1)(j - 1) else 0)\n            }\n        }\n        var\
    \ result = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m)\
    \ {\n                for (k <- i until n) {\n                    for (l <- j until\
    \ m) {\n                        val total = sum(k)(l) - (if (i > 0) sum(i - 1)(l)\
    \ else 0) - (if (j > 0) sum(k)(j - 1) else 0) + (if (i > 0 && j > 0) sum(i - 1)(j\
    \ - 1) else 0)\n                        if (total > 0) {\n                   \
    \         val count = (total - 1) / capacity + 1\n                           \
    \ result += count\n                        }\n                    }\n        \
    \        }\n            }\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        var result = 0L\n        for (i <- 0\
    \ until n) {\n            var sum = 0L\n            for (j <- 0 until m) {\n \
    \               sum += grid(i)(j)\n                if (sum > capacity) {\n   \
    \                 result += sum - capacity\n                    sum = capacity\n\
    \                }\n            }\n        }\n        result", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        var maxFill = 0L\n  \
    \      for (i <- 0 until n) {\n            for (j <- 0 until m) {\n          \
    \      if (grid(i)(j) == 1) {\n                    maxFill = max(maxFill, j +\
    \ 1)\n                }\n            }\n        }\n        maxFill", "       \
    \ val n = grid.length\n        val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (grid(i)(j) == 1) {\n                    maxFill(i) += 1\n       \
    \         }\n            }\n        }\n        var result = 0L\n        for (i\
    \ <- 0 until n) {\n            result += maxFill(i) / capacity\n            if\
    \ (maxFill(i) % capacity != 0) result += 1\n        }\n        result", "    \
    \    val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n)(Array.fill(m)(0L))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0) {\n                    if (j == 0) dp(i)(j) = grid(i)(j)\n\
    \                    else dp(i)(j) = dp(i)(j - 1) + grid(i)(j)\n             \
    \   }\n                else {\n                    if (j == 0) dp(i)(j) = dp(i\
    \ - 1)(j) + grid(i)(j)\n                    else dp(i)(j) = min(dp(i - 1)(j),\
    \ dp(i)(j - 1)) + grid(i)(j)\n                }\n            }\n        }\n  \
    \      val maxFill = dp(n - 1)(m - 1)\n        val maxFillPerBucket = capacity\n\
    \        val totalBuckets = maxFill / maxFillPerBucket\n        val remaining\
    \ = maxFill % maxFillPerBucket\n        if (remaining == 0) totalBuckets\n   \
    \     else totalBuckets + 1", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n   \
    \         var j = 0\n            while (j < m && grid(i)(j) == 0) j += 1\n   \
    \         maxFill(i) = j\n        }\n        var ans = 0L\n        while (maxFill.exists(_\
    \ > 0)) {\n            ans += 1\n            for (i <- 0 until n) {\n        \
    \        if (maxFill(i) > 0) {\n                    maxFill(i) -= 1\n        \
    \        }\n            }\n        }\n        ans", "        val rows = grid.length\n\
    \        val cols = grid(0).length\n        val rowMax = grid.map(row => row.sum)\n\
    \        val colMax = (0 until cols).map(j => grid.map(row => row(j)).sum)\n \
    \       val max = rowMax.max\n        val min = rowMax.min\n        val maxCol\
    \ = colMax.max\n        val minCol = colMax.min\n        val maxRow = rowMax.indexOf(max)\n\
    \        val minRow = rowMax.indexOf(min)\n        val maxColIndex = colMax.indexOf(maxCol)\n\
    \        val minColIndex = colMax.indexOf(minCol)\n        val rowDiff = max -\
    \ min\n        val colDiff = maxCol - minCol\n        val rowCount = if (rowDiff\
    \ > 0) rowDiff / capacity + (if (rowDiff % capacity > 0) 1 else 0) else 0\n  \
    \      val colCount = if (colDiff > 0) colDiff / capacity + (if (colDiff % capacity\
    \ > 0) 1 else 0) else 0\n        val rowMove = if (rowDiff > 0) min + capacity\
    \ * rowCount else 0\n        val colMove = if (colDiff > 0) minCol + capacity\
    \ * colCount else 0\n        val rowMoveCount = (0 until rows).map(i => if (i\
    \ != maxRow) (rowMove - rowMax(i)) / capacity + (if ((rowMove - rowMax(i)) % capacity\
    \ > 0) 1 else 0) else 0).sum\n        val colMoveCount = (0 until cols).map(j\
    \ => if (j != maxColIndex) (colMove - colMax(j)) / capacity + (if ((colMove -\
    \ colMax(j)) % capacity > 0) 1 else 0) else 0).sum\n        rowMoveCount + colMoveCount",
  "        val maxFill = grid.map(row => row.sum).max\n        val maxFillCount =\
    \ grid.map(row => row.count(_ == maxFill)).max\n        val maxFillCount2 = grid.map(row\
    \ => row.count(_ == maxFill - 1)).max\n        val maxFillCount3 = grid.map(row\
    \ => row.count(_ == maxFill - 2)).max\n        val maxFillCount4 = grid.map(row\
    \ => row.count(_ == maxFill - 3)).max\n        val maxFillCount5 = grid.map(row\
    \ => row.count(_ == maxFill - 4)).max\n        val maxFillCount6 = grid.map(row\
    \ => row.count(_ == maxFill - 5)).max\n        val maxFillCount7 = grid.map(row\
    \ => row.count(_ == maxFill - 6)).max\n        val maxFillCount8 = grid.map(row\
    \ => row.count(_ == maxFill - 7)).max\n        val maxFillCount9 = grid.map(row\
    \ => row.count(_ == maxFill - 8)).max\n        val maxFillCount10 = grid.map(row\
    \ => row.count(_ == maxFill - 9)).max\n        val maxFillCount11 = grid.map(row\
    \ => row.count(_ == maxFill - 10)).max\n        val maxFillCount12 = grid.map(row\
    \ => row.count(_ == maxFill - 11)).max\n        val maxFillCount13 = grid.map(row\
    \ => row.count(_ == maxFill - 12)).max\n        val maxFillCount14 = grid.map(row\
    \ => row.count(_ == maxFill - 13)).max\n        val maxFillCount15 = grid.map(row\
    \ => row.count(_ == maxFill - 14)).max\n        val maxFillCount16 = grid.map(row\
    \ => row.count(_ == maxFill - 15)).max\n        val maxFillCount17 = grid.map(row\
    \ => row.count(_ == maxFill - 16)).max\n        val maxFillCount18 = grid.map(row\
    \ => row.count(_ == maxFill - 17)).max\n        val maxFillCount19 = grid.map(row\
    \ => row.count(_ == maxFill - 18)).max\n        val maxFillCount20 = grid.map(row\
    \ => row.count(_ == maxFill - 19", "        val n = grid.length\n        val m\
    \ = grid(0).length\n        val maxFill = Array.fill(n, m)(0L)\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    maxFill(i)(j) = capacity\n                } else\
    \ {\n                    if (i > 0) maxFill(i)(j) = maxFill(i - 1)(j)\n      \
    \              if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n\
    \                }\n            }\n        }\n        maxFill(n - 1)(m - 1)",
  "        val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (j < m && grid(i)(j) == 0) j += 1\n            maxFill(i) =\
    \ j\n        }\n        val dp = Array.fill(n)(0L)\n        dp(0) = maxFill(0)\n\
    \        for (i <- 1 until n) {\n            dp(i) = min(dp(i - 1) + maxFill(i),\
    \ capacity)\n        }\n        dp(n - 1)", "        val n = grid.length\n   \
    \     val m = grid(0).length\n        val dp = Array.fill(n, m)(0L)\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    dp(i)(j) = capacity\n                }\n      \
    \          if (i > 0) {\n                    dp(i)(j) = max(dp(i)(j), dp(i - 1)(j))\n\
    \                }\n                if (j > 0) {\n                    dp(i)(j)\
    \ = max(dp(i)(j), dp(i)(j - 1))\n                }\n            }\n        }\n\
    \        var result = 0L\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (grid(i)(j) == 1) {\n                    result\
    \ += capacity - dp(i)(j)\n                }\n            }\n        }\n      \
    \  result", "        val maxFill = grid.map(row => row.sum).max\n        maxFill\
    \ / capacity + (if (maxFill % capacity == 0) 0 else 1)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        var maxFill = 0L\n        for (i <- 0\
    \ until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    maxFill = max(maxFill, j + 1)\n               \
    \ }\n            }\n        }\n        maxFill", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n   \
    \     for (i <- 0 until n) {\n            var j = 0\n            while (j < m\
    \ && grid(i)(j) == 0) j += 1\n            if (j < m) {\n                maxFill(i)\
    \ = j\n            } else {\n                maxFill(i) = m\n            }\n \
    \       }\n        var result = 0L\n        var i = 0\n        while (i < n) {\n\
    \            var j = 0\n            while (j < m) {\n                var k = i\n\
    \                var fill = 0L\n                while (k < n && fill + maxFill(k)\
    \ >= j) {\n                    fill += maxFill(k) - j\n                    k +=\
    \ 1\n                }\n                result += 1\n                j += 1\n\
    \            }\n            i = k\n        }\n        result", "        val maxFill\
    \ = grid.map(row => row.sum).max\n        if (maxFill <= capacity) 0\n       \
    \ else maxFill / capacity + (if (maxFill % capacity == 0) 0 else 1)", "      \
    \  val n = grid.length\n        val m = grid(0).length\n        val maxFill =\
    \ Array.fill(n)(0L)\n        var total = 0L\n        for (i <- 0 until n) {\n\
    \            var fill = 0L\n            for (j <- 0 until m) {\n             \
    \   if (grid(i)(j) == 1) fill += 1\n            }\n            maxFill(i) = fill\n\
    \            total += fill\n        }\n        val maxFillSorted = maxFill.sorted\n\
    \        var left = 0\n        var right = n - 1\n        var result = 0L\n  \
    \      while (left < right) {\n            val min = min(maxFillSorted(left),\
    \ maxFillSorted(right))\n            if (min < capacity) {\n                total\
    \ -= min\n                left += 1\n                right -= 1\n            }\
    \ else {\n                total -= capacity\n                right -= 1\n    \
    \        }\n            result += 1\n        }\n        if (total > 0) result\
    \ += (total + capacity - 1) / capacity\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n   \
    \     for (i <- 0 until n) {\n            var j = 0\n            while (j < m\
    \ && grid(i)(j) == 0) j += 1\n            if (j == m) maxFill(i) = capacity\n\
    \            else maxFill(i) = min(capacity, j)\n        }\n        maxFill.sum",
  "        val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (j < m && grid(i)(j) == 0) j += 1\n            maxFill(i) =\
    \ j\n        }\n        var result = 0L\n        while (maxFill.max > 0) {\n \
    \           val min = maxFill.min\n            for (i <- 0 until n) {\n      \
    \          if (maxFill(i) > 0) {\n                    maxFill(i) -= min\n    \
    \                result += min\n                }\n            }\n        }\n\
    \        result", "        // find the maximum number of buckets that can be filled\n\
    \        // by the wells in a single row\n        def maxFillRow(row : List[Long])\
    \ : Long = {\n            // find the maximum number of buckets that can be filled\n\
    \            // by the wells in a single row\n            def maxFillRow(row :\
    \ List[Long], acc : Long) : Long = {\n                if (row.isEmpty) acc\n \
    \               else if (row.head == 1) maxFillRow(row.tail, acc + 1)\n      \
    \          else maxFillRow(row.tail, acc)\n            }\n            maxFillRow(row,\
    \ 0)\n        }\n        // find the maximum number of buckets that can be filled\n\
    \        // by the wells in a single row\n        def maxFillRow(grid : List[List[Long]],\
    \ acc : Long) : Long = {\n            if (grid.isEmpty) acc\n            else\
    \ maxFillRow(grid.tail, max(acc, maxFillRow(grid.head)))\n        }\n        //\
    \ find the minimum number of buckets that can be filled\n        // by the wells\
    \ in a single row\n        def minFillRow(row : List[Long]) : Long = {\n     \
    \       // find the minimum number of buckets that can be filled\n           \
    \ // by the wells in a single row\n            def minFillRow(row : List[Long],\
    \ acc : Long) : Long = {\n                if (row.isEmpty) acc\n             \
    \   else if (row.head == 1) minFillRow(row.tail, acc + 1)\n                else\
    \ minFillRow(row.tail, acc)\n            }\n            minFillRow(row, 0)\n \
    \       }\n        // find the minimum number of buckets that can be filled\n\
    \        // by the wells in a single row\n        def minFillRow(grid : List[List[Long]],\
    \ acc : Long) : Long = {\n            if (grid.isEmpty) acc\n            else\
    \ minFillRow(grid.tail, min(acc, minFillRow(grid.head)))\n        }\n        //\
    \ find the number of buckets that can be filled\n        // by the wells in a\
    \ single row\n        def fillRow(row : List[Long]) : Long = {\n            //\
    \ find the number of buckets that can be filled\n            // by", "       \
    \ // fill the first row\n        var total = 0L\n        var lastRow = grid.head\n\
    \        for (i <- 0 until lastRow.length) {\n            if (lastRow(i) == 1)\
    \ {\n                total += 1\n                lastRow = lastRow.updated(i,\
    \ 0)\n            }\n        }\n        // fill the rest of the rows\n       \
    \ for (row <- grid.tail) {\n            for (i <- 0 until row.length) {\n    \
    \            if (row(i) == 1) {\n                    if (lastRow(i) == 0) {\n\
    \                        total += 1\n                        lastRow = lastRow.updated(i,\
    \ capacity)\n                    }\n                    else {\n             \
    \           lastRow = lastRow.updated(i, lastRow(i) - 1)\n                   \
    \ }\n                }\n            }\n        }\n        total", "        val\
    \ rows = grid.length\n        val cols = grid(0).length\n        val fill = Array.fill(rows)(Array.fill(cols)(0L))\n\
    \        var count = 0L\n        for (i <- 0 until rows) {\n            for (j\
    \ <- 0 until cols) {\n                if (grid(i)(j) == 1) {\n               \
    \     fill(i)(j) = 1\n                    count += 1\n                }\n    \
    \        }\n        }\n        for (i <- 0 until rows) {\n            for (j <-\
    \ 0 until cols) {\n                if (fill(i)(j) == 1) {\n                  \
    \  if (i - 1 >= 0 && fill(i - 1)(j) == 0) {\n                        fill(i -\
    \ 1)(j) = 1\n                        count += 1\n                    }\n     \
    \               if (i + 1 < rows && fill(i + 1)(j) == 0) {\n                 \
    \       fill(i + 1)(j) = 1\n                        count += 1\n             \
    \       }\n                    if (j - 1 >= 0 && fill(i)(j - 1) == 0) {\n    \
    \                    fill(i)(j - 1) = 1\n                        count += 1\n\
    \                    }\n                    if (j + 1 < cols && fill(i)(j + 1)\
    \ == 0) {\n                        fill(i)(j + 1) = 1\n                      \
    \  count += 1\n                    }\n                }\n            }\n     \
    \   }\n        count", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n   \
    \         var j = 0\n            while (j < m && grid(i)(j) == 0) j += 1\n   \
    \         maxFill(i) = j\n        }\n        val maxFillSum = maxFill.sum\n  \
    \      val minFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n     \
    \       var j = m - 1\n            while (j >= 0 && grid(i)(j) == 0) j -= 1\n\
    \            minFill(i) = m - 1 - j\n        }\n        val minFillSum = minFill.sum\n\
    \        val maxFillSum2 = maxFill.map(x => x * x).sum\n        val minFillSum2\
    \ = minFill.map(x => x * x).sum\n        val maxFillSumMinFillSum = maxFill.zip(minFill).map(x\
    \ => x._1 * x._2).sum\n        val maxFillSumMinFillSum2 = maxFill.zip(minFill).map(x\
    \ => x._1 * x._2 * x._2).sum\n        val maxFillSum2MinFillSum = maxFill.zip(minFill).map(x\
    \ => x._1 * x._1 * x._2).sum\n        val maxFillSum2MinFillSum2 = maxFill.zip(minFill).map(x\
    \ => x._1 * x._1 * x._2 * x._2).sum\n        val maxFillSum3 = maxFill.map(x =>\
    \ x * x * x).sum\n        val minFillSum3 = minFill.map(x => x * x * x).sum\n\
    \        val maxFillSum2MinFillSum3 = maxFill.zip(minFill).map(x => x._1 * x._1\
    \ * x._2 * x._2 * x._2).sum\n        val maxFillSum3MinFillSum2 = maxFill.zip(minFill).map(x\
    \ => x._1 * x._1 * x._1 * x._2 * x._2).sum\n        val maxFillSum3MinFillSum\
    \ = maxFill.zip(minFill).map", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n   \
    \         var j = 0\n            while (j < m && grid(i)(j) == 0) j += 1\n   \
    \         maxFill(i) = j\n        }\n        var result = 0L\n        while (maxFill.max\
    \ > 0) {\n            val min = maxFill.min\n            for (i <- 0 until n)\
    \ {\n                if (maxFill(i) > 0) {\n                    maxFill(i) -=\
    \ min\n                    if (maxFill(i) < 0) maxFill(i) = 0\n              \
    \  }\n            }\n            result += min\n        }\n        result", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val fill\
    \ = Array.fill(n)(0L)\n        var result = 0L\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    fill(i) += 1\n                }\n            }\n        }\n\
    \        while (fill.exists(_ > 0)) {\n            result += 1\n            for\
    \ (i <- 0 until n) {\n                if (fill(i) > 0) {\n                   \
    \ fill(i) -= min(fill(i), capacity)\n                }\n            }\n      \
    \  }\n        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val grid2 = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                grid2(i)(j) = grid(i)(j)\n\
    \            }\n        }\n        var result = 0L\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                if (grid2(i)(j) !=\
    \ 0) {\n                    val fill = min(grid2(i)(j), capacity)\n          \
    \          grid2(i)(j) -= fill\n                    result += fill\n         \
    \       }\n            }\n        }\n        for (i <- 0 until n) {\n        \
    \    for (j <- 0 until m) {\n                if (grid2(i)(j) != 0) {\n       \
    \             val fill = min(grid2(i)(j), capacity)\n                    grid2(i)(j)\
    \ -= fill\n                    result += fill\n                }\n           \
    \ }\n        }\n        result", "        val m = grid.length\n        val n =\
    \ grid(0).length\n        val maxFill = Array.fill(m, n)(0L)\n        for (i <-\
    \ 0 until m) {\n            for (j <- 0 until n) {\n                if (grid(i)(j)\
    \ == 1) {\n                    maxFill(i)(j) = capacity\n                } else\
    \ {\n                    if (i > 0) maxFill(i)(j) = maxFill(i - 1)(j)\n      \
    \              if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n\
    \                }\n            }\n        }\n        maxFill(m - 1)(n - 1)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n\
    \                }\n                if (i > 0) {\n                    dp(i)(j)\
    \ = max(dp(i)(j), dp(i - 1)(j))\n                }\n                if (j > 0)\
    \ {\n                    dp(i)(j) = max(dp(i)(j), dp(i)(j - 1))\n            \
    \    }\n            }\n        }\n        var result = 0L\n        for (i <- 0\
    \ until n) {\n            for (j <- 0 until m) {\n                result += dp(i)(j)\n\
    \            }\n        }\n        result", "        val n = grid.length\n   \
    \     val m = grid(0).length\n        val maxFill = Array.fill(n, m)(0L)\n   \
    \     for (i <- 0 until n) {\n            for (j <- 0 until m) {\n           \
    \     if (i == 0) maxFill(i)(j) = grid(i)(j)\n                else maxFill(i)(j)\
    \ = maxFill(i - 1)(j) + grid(i)(j)\n            }\n        }\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               val max = maxFill(i)(j)\n                if (max > 0) {\n    \
    \                result += max / capacity\n                    if (max % capacity\
    \ > 0) result += 1\n                }\n            }\n        }\n        result",
  "        val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (grid(i)(j) == 1) {\n                    maxFill(i)(j)\
    \ = capacity\n                } else {\n                    if (i > 0) maxFill(i)(j)\
    \ = maxFill(i - 1)(j)\n                    if (j > 0) maxFill(i)(j) = max(maxFill(i)(j),\
    \ maxFill(i)(j - 1))\n                }\n            }\n        }\n        maxFill(n\
    \ - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val max = grid.map(row => row.sum).max\n        val min = grid.map(row\
    \ => row.sum).min\n        var result = 0L\n        for (i <- min to max) {\n\
    \            var count = 0L\n            for (row <- grid) {\n               \
    \ var j = 0\n                while (j < m) {\n                    if (row(j) >=\
    \ i) {\n                        count += 1\n                        j += capacity.toInt\n\
    \                    } else j += 1\n                }\n            }\n       \
    \     result = max(result, count)\n        }\n        result", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n\
    \                    if (i > 0) dp(i)(j) = min(dp(i)(j), dp(i - 1)(j))\n     \
    \               if (j > 0) dp(i)(j) = min(dp(i)(j), dp(i)(j - 1))\n          \
    \      }\n            }\n        }\n        var result = 0L\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    result += capacity - dp(i)(j)\n               \
    \ }\n            }\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        var result = 0L\n        for (i <- 0\
    \ until n) {\n            var sum = 0L\n            for (j <- 0 until m) {\n \
    \               sum += grid(i)(j)\n                if (sum > capacity) {\n   \
    \                 result += sum - capacity\n                    sum = capacity\n\
    \                }\n            }\n        }\n        result", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val maxFill = Array.fill(n,\
    \ m)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n\
    \                } else {\n                    if (i > 0) maxFill(i)(j) = maxFill(i\
    \ - 1)(j)\n                    if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j\
    \ - 1))\n                }\n            }\n        }\n        maxFill(n - 1)(m\
    \ - 1)", "        val n = grid.length\n        val m = grid(0).length\n      \
    \  val dp = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n           \
    \ for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n           \
    \         dp(i)(j) = 1\n                    if (i > 0) dp(i)(j) += dp(i - 1)(j)\n\
    \                    if (j > 0) dp(i)(j) += dp(i)(j - 1)\n                   \
    \ if (i > 0 && j > 0) dp(i)(j) -= dp(i - 1)(j - 1)\n                }\n      \
    \      }\n        }\n        var result = 0L\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                for (k <- i until n) {\n\
    \                    for (l <- j until m) {\n                        var sum =\
    \ dp(k)(l)\n                        if (i > 0) sum -= dp(i - 1)(l)\n         \
    \               if (j > 0) sum -= dp(k)(j - 1)\n                        if (i\
    \ > 0 && j > 0) sum += dp(i - 1)(j - 1)\n                        if (sum > 0)\
    \ {\n                            result += (sum - 1) / capacity + 1\n        \
    \                }\n                    }\n                }\n            }\n\
    \        }\n        result", "        // we can fill up to capacity units of water\
    \ in each well\n        // we can fill up to capacity units of water in each well\n\
    \        // we can fill up to capacity units of water in each well\n        //\
    \ we can fill up to capacity units of water in each well\n        // we can fill\
    \ up to capacity units of water in each well\n        // we can fill up to capacity\
    \ units of water in each well\n        // we can fill up to capacity units of\
    \ water in each well\n        // we can fill up to capacity units of water in\
    \ each well\n        // we can fill up to capacity units of water in each well\n\
    \        // we can fill up to capacity units of water in each well\n        //\
    \ we can fill up to capacity units of water in each well\n        // we can fill\
    \ up to capacity units of water in each well\n        // we can fill up to capacity\
    \ units of water in each well\n        // we can fill up to capacity units of\
    \ water in each well\n        // we can fill up to capacity units of water in\
    \ each well\n        // we can fill up to capacity units of water in each well\n\
    \        // we can fill up to capacity units of water in each well\n        //\
    \ we can fill up to capacity units of water in each well\n        // we can fill\
    \ up to capacity units of water in each well\n        // we can fill up to capacity\
    \ units of water in each well\n        // we can fill up to capacity units of\
    \ water in each well\n        // we can fill up to capacity units of water in\
    \ each well\n        // we can fill up to capacity units of water in each well\n\
    \        // we can fill up to capacity units of water in each well\n        //\
    \ we can fill up to capacity units of water in each well\n        // we can fill\
    \ up to capacity units of water in each well\n        // we can fill up to capacity\
    \ units of water in each well\n        // we can fill up to capacity units of\
    \ water in each well\n        // we can fill up to capacity units of water in\
    \ each well\n        // we can fill up to capacity units of water in each well\n\
    \        // we can fill up to capacity units of water in each well\n        //\
    \ we can fill up to capacity units of water in each well\n        // we can fill\
    \ up to capacity units of water in each well\n        // we can fill up to capacity\
    \ units of water in each well\n       ", "        val n = grid.length\n      \
    \  val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n        var\
    \ result = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n    \
    \        for (j <- 0 until m) {\n                sum += grid(i)(j)\n         \
    \       if (sum == capacity) {\n                    maxFill(i) = j + 1\n     \
    \               sum = 0\n                }\n            }\n        }\n       \
    \ for (i <- 0 until n) {\n            var sum = 0L\n            for (j <- 0 until\
    \ m) {\n                sum += grid(i)(j)\n                if (sum == capacity)\
    \ {\n                    result += 1\n                    sum = 0\n          \
    \      } else if (sum > capacity) {\n                    result += 1\n       \
    \             sum = grid(i)(j)\n                }\n                if (j == maxFill(i)\
    \ - 1) {\n                    result += 1\n                    sum = 0\n     \
    \           }\n            }\n            if (sum > 0) result += 1\n        }\n\
    \        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n   \
    \         var j = 0\n            while (j < m && grid(i)(j) == 0) j += 1\n   \
    \         if (j < m) {\n                maxFill(i) = min(capacity, m - j)\n  \
    \          }\n        }\n        var result = 0L\n        for (i <- 0 until n)\
    \ {\n            if (maxFill(i) > 0) {\n                result += maxFill(i)\n\
    \                for (j <- 0 until n) {\n                    if (maxFill(j) >\
    \ 0) {\n                        maxFill(j) = min(maxFill(j), maxFill(i))\n   \
    \                 }\n                }\n            }\n        }\n        result",
  "        val n = grid.length\n        val m = grid(0).length\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            var j = 0\n            while\
    \ (j < m) {\n                if (grid(i)(j) == 1) {\n                    var k\
    \ = j\n                    var sum = 0L\n                    while (k < m && sum\
    \ < capacity) {\n                        sum += grid(i)(k)\n                 \
    \       k += 1\n                    }\n                    if (sum == capacity)\
    \ {\n                        j = k\n                        result += 1\n    \
    \                } else {\n                        j += 1\n                  \
    \  }\n                } else {\n                    j += 1\n                }\n\
    \            }\n        }\n        result", "        // for each row, find the\
    \ maximum number of buckets that can be filled\n        // then find the minimum\
    \ of those numbers\n        // we can fill that many buckets\n        // then\
    \ we can fill the remaining wells with the remaining capacity\n        // we can\
    \ then repeat this process until all wells are empty\n        // this is O(n^2)\n\
    \        var total = 0L\n        while (grid.exists(_.exists(_ > 0))) {\n    \
    \        val maxFill = grid.map(row => row.count(_ > 0)).min\n            total\
    \ += maxFill\n            grid.foreach(row => row.map(x => x - maxFill))\n   \
    \     }\n        total", "        val n = grid.length\n        val m = grid(0).length\n\
    \        var maxFill = 0L\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                if (grid(i)(j) == 1) {\n                  \
    \  maxFill = max(maxFill, j + 1)\n                }\n            }\n        }\n\
    \        maxFill", "        val maxRow = grid.map(row => row.sum).max\n      \
    \  val maxCol = grid.transpose.map(col => col.sum).max\n        val max = max(maxRow,\
    \ maxCol)\n        if (max == 0) 0\n        else {\n            val num = max\
    \ / capacity\n            if (max % capacity == 0) num\n            else num +\
    \ 1\n        }", "        val rows = grid.length\n        val cols = grid(0).length\n\
    \        var maxFill = 0L\n        for (i <- 0 until rows) {\n            for\
    \ (j <- 0 until cols) {\n                if (grid(i)(j) == 1) {\n            \
    \        maxFill = max(maxFill, j + 1)\n                }\n            }\n   \
    \     }\n        maxFill", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n   \
    \         for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n   \
    \                 maxFill(i) += 1\n                }\n            }\n        }\n\
    \        val maxFillSum = maxFill.sum\n        val maxFillSumCapacity = maxFillSum\
    \ / capacity\n        val maxFillSumCapacityRemainder = maxFillSum % capacity\n\
    \        val maxFillSumCapacityRemainderCount = maxFill.count(_ >= maxFillSumCapacityRemainder)\n\
    \        maxFillSumCapacity + (if (maxFillSumCapacityRemainder > 0 && maxFillSumCapacityRemainderCount\
    \ == 0) 1 else 0)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n   \
    \         var j = 0\n            while (j < m && grid(i)(j) == 0) j += 1\n   \
    \         maxFill(i) = j\n        }\n        var result = 0L\n        while (maxFill.max\
    \ > 0) {\n            val min = maxFill.min\n            for (i <- 0 until n)\
    \ {\n                if (maxFill(i) > 0) {\n                    maxFill(i) -=\
    \ min\n                    result += min\n                }\n            }\n \
    \       }\n        result", "        val m = grid.length\n        val n = grid(0).length\n\
    \        val dp = Array.fill(m, n)(0L)\n        for (i <- 0 until m) {\n     \
    \       for (j <- 0 until n) {\n                if (grid(i)(j) == 1) {\n     \
    \               dp(i)(j) = capacity\n                    if (i > 0) dp(i)(j) =\
    \ min(dp(i)(j), dp(i - 1)(j))\n                    if (j > 0) dp(i)(j) = min(dp(i)(j),\
    \ dp(i)(j - 1))\n                }\n            }\n        }\n        var result\
    \ = 0L\n        for (i <- 0 until m) {\n            for (j <- 0 until n) {\n \
    \               if (grid(i)(j) == 1) {\n                    result += capacity\
    \ - dp(i)(j)\n                }\n            }\n        }\n        result", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (grid(i)(j) == 1) {\n                    dp(i)(j)\
    \ = 1\n                    if (i > 0) dp(i)(j) += dp(i - 1)(j)\n             \
    \       if (j > 0) dp(i)(j) += dp(i)(j - 1)\n                    if (i > 0 &&\
    \ j > 0) dp(i)(j) -= dp(i - 1)(j - 1)\n                }\n            }\n    \
    \    }\n        var result = 0L\n        for (i <- 0 until n) {\n            for\
    \ (j <- 0 until m) {\n                for (k <- i until n) {\n               \
    \     for (l <- j until m) {\n                        var sum = dp(k)(l)\n   \
    \                     if (i > 0) sum -= dp(i - 1)(l)\n                       \
    \ if (j > 0) sum -= dp(k)(j - 1)\n                        if (i > 0 && j > 0)\
    \ sum += dp(i - 1)(j - 1)\n                        if (sum > 0) {\n          \
    \                  val times = (sum - 1) / capacity + 1\n                    \
    \        result += times\n                        }\n                    }\n \
    \               }\n            }\n        }\n        result", "        val wells\
    \ = grid.map(x => x.sum)\n        val maxWell = wells.max\n        val minWell\
    \ = wells.min\n        val maxFill = capacity * grid.length\n        if (maxWell\
    \ <= maxFill) maxWell\n        else if (minWell >= maxFill) maxFill\n        else\
    \ {\n            var result = maxFill\n            while (result > minWell) {\n\
    \                var isValid = true\n                for (well <- wells) {\n \
    \                   if (well > result) {\n                        isValid = false\n\
    \                        break\n                    }\n                }\n   \
    \             if (isValid) return result\n                result -= 1\n      \
    \      }\n            result\n        }", "        val n = grid.length\n     \
    \   val m = grid(0).length\n        val dp = Array.fill(n, m)(0L)\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    dp(i)(j) = capacity\n                    if (i\
    \ > 0) dp(i)(j) = min(dp(i)(j), dp(i - 1)(j))\n                    if (j > 0)\
    \ dp(i)(j) = min(dp(i)(j), dp(i)(j - 1))\n                }\n            }\n \
    \       }\n        var result = 0L\n        for (i <- 0 until n) {\n         \
    \   for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n         \
    \           if (i > 0) dp(i)(j) = min(dp(i)(j), dp(i - 1)(j))\n              \
    \      if (j > 0) dp(i)(j) = min(dp(i)(j), dp(i)(j - 1))\n                   \
    \ result += dp(i)(j)\n                }\n            }\n        }\n        result",
  "        val n = grid.length\n        val m = grid(0).length\n        var maxFill\
    \ = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               if (grid(i)(j) == 1) {\n                    maxFill = max(maxFill,\
    \ j + 1)\n                }\n            }\n        }\n        maxFill", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (i == 0) {\n                    dp(i)(j) = grid(i)(j)\n  \
    \              } else {\n                    dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n\
    \                }\n            }\n        }\n        var result = 0L\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  val fill = min(dp(i)(j), capacity)\n                result += fill\n      \
    \          dp(i)(j) -= fill\n            }\n        }\n        result", "    \
    \    val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0L)\n        dp(0)(0) = grid(0)(0)\n        for (i <- 1 until n) dp(i)(0)\
    \ = dp(i - 1)(0) + grid(i)(0)\n        for (j <- 1 until m) dp(0)(j) = dp(0)(j\
    \ - 1) + grid(0)(j)\n        for (i <- 1 until n; j <- 1 until m) {\n        \
    \    dp(i)(j) = dp(i - 1)(j) + dp(i)(j - 1) - dp(i - 1)(j - 1) + grid(i)(j)\n\
    \        }\n        def sum(i : Int, j : Int, k : Int, l : Int) : Long = {\n \
    \           val a = if (i == 0) 0 else dp(i - 1)(l)\n            val b = if (j\
    \ == 0) 0 else dp(k)(j - 1)\n            val c = if (i == 0 || j == 0) 0 else\
    \ dp(i - 1)(j - 1)\n            dp(k)(l) - a - b + c\n        }\n        def fill(i\
    \ : Int, j : Int, k : Int, l : Int) : Long = {\n            val s = sum(i, j,\
    \ k, l)\n            val c = capacity\n            if (s <= c) 0 else {\n    \
    \            val r = s % c\n                val q = s / c\n                if\
    \ (r == 0) q else q + 1\n            }\n        }\n        var result = 0L\n \
    \       for (i <- 0 until n; j <- 0 until m) {\n            for (k <- i until\
    \ n; l <- j until m) {\n                result += fill(i, j, k, l)\n         \
    \   }\n        }\n        result", "        val n = grid.length\n        val m\
    \ = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n        for (i <-\
    \ 0 until n) {\n            var j = 0\n            while (j < m && grid(i)(j)\
    \ == 0) j += 1\n            maxFill(i) = j\n        }\n        var count = 0L\n\
    \        while (maxFill.max > 0) {\n            val max = maxFill.max\n      \
    \      val min = maxFill.min\n            val fill = min + capacity\n        \
    \    for (i <- 0 until n) {\n                if (maxFill(i) > 0) {\n         \
    \           val f = min(maxFill(i), fill)\n                    maxFill(i) -= f\n\
    \                    count += f\n                }\n            }\n        }\n\
    \        count", "        var max = 0L\n        for (row <- grid) {\n        \
    \    var sum = 0L\n            for (cell <- row) {\n                sum += cell\n\
    \                if (sum > capacity) {\n                    sum = capacity\n \
    \               }\n            }\n            max = max max sum\n        }\n \
    \       max", "        val rows = grid.length\n        val cols = grid(0).length\n\
    \        val maxFill = Array.fill(rows, cols)(0L)\n        for (i <- 0 until rows)\
    \ {\n            for (j <- 0 until cols) {\n                if (grid(i)(j) ==\
    \ 1) {\n                    maxFill(i)(j) = capacity\n                } else {\n\
    \                    if (i > 0) maxFill(i)(j) = maxFill(i - 1)(j)\n          \
    \          if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n\
    \                }\n            }\n        }\n        maxFill(rows - 1)(cols -\
    \ 1)", "        // fill the wells from the bottom\n        // return the number\
    \ of times you need to lower the buckets\n        // fill the wells from the bottom\n\
    \        // return the number of times you need to lower the buckets\n       \
    \ val n = grid.length\n        val m = grid(0).length\n        val wells = Array.ofDim[Long](n,\
    \ m)\n        for (i <- 0 until n) {\n            var sum = 0L\n            for\
    \ (j <- m - 1 to 0 by -1) {\n                sum += grid(i)(j)\n             \
    \   wells(i)(j) = sum\n            }\n        }\n        // wells(i)(j) = the\
    \ number of water units in the well (i, j)\n        // wells(i)(j) = the number\
    \ of water units in the well (i, j)\n        var result = 0L\n        for (j <-\
    \ 0 until m) {\n            var sum = 0L\n            for (i <- 0 until n) {\n\
    \                sum += wells(i)(j)\n                wells(i)(j) = sum\n     \
    \       }\n            result += sum / capacity\n            if (sum % capacity\
    \ != 0) result += 1\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n   \
    \     for (i <- 0 until n) {\n            var j = 0\n            while (j < m\
    \ && grid(i)(j) == 0) j += 1\n            maxFill(i) = j\n        }\n        var\
    \ result = 0L\n        while (maxFill.max > 0) {\n            val max = maxFill.max\n\
    \            val min = maxFill.min\n            val num = min / capacity\n   \
    \         val rem = min % capacity\n            for (i <- 0 until n) {\n     \
    \           if (maxFill(i) > 0) {\n                    maxFill(i) -= num * capacity\n\
    \                    if (maxFill(i) < rem) maxFill(i) = 0\n                  \
    \  else maxFill(i) -= rem\n                }\n            }\n            result\
    \ += num + (if (rem > 0) 1 else 0)\n        }\n        result", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val rowMax = grid.map(row\
    \ => row.sum)\n        val colMax = (0 until m).map(j => grid.map(row => row(j)).sum)\n\
    \        val rowMaxSum = rowMax.sum\n        val colMaxSum = colMax.sum\n    \
    \    val rowMaxMax = rowMax.max\n        val colMaxMax = colMax.max\n        val\
    \ rowMaxMaxSum = rowMax.filter(x => x == rowMaxMax).sum\n        val colMaxMaxSum\
    \ = colMax.filter(x => x == colMaxMax).sum\n        val rowMaxMaxCount = rowMax.filter(x\
    \ => x == rowMaxMax).length\n        val colMaxMaxCount = colMax.filter(x => x\
    \ == colMaxMax).length\n        val rowMaxMaxSumCount = rowMax.filter(x => x ==\
    \ rowMaxMax).count(x => x == rowMaxMax)\n        val colMaxMaxSumCount = colMax.filter(x\
    \ => x == colMaxMax).count(x => x == colMaxMax)\n        val rowMaxMaxSumCountSum\
    \ = rowMax.filter(x => x == rowMaxMax).count(x => x == rowMaxMax).sum\n      \
    \  val colMaxMaxSumCountSum = colMax.filter(x => x == colMaxMax).count(x => x\
    \ == colMaxMax).sum\n        val rowMaxMaxSumCountSumSum = rowMax.filter(x =>\
    \ x == rowMaxMax).count(x => x == rowMaxMax).sum.sum\n        val colMaxMaxSumCountSumSum\
    \ = colMax.filter(x => x == colMaxMax).count(x => x == colMaxMax).sum.sum\n  \
    \      val rowMaxMaxSumCountSumSumSum = rowMax.filter(x => x == rowMaxMax).count(x\
    \ => x == rowMaxMax).sum.sum.sum\n        val colMaxMaxSumCountSumSumSum = colMax.filter(x\
    \ => x == colMaxMax).count(x => x == colMaxMax).sum.sum.sum\n        val rowMaxMaxSumCountSumSumSumSum\
    \ = rowMax.filter(x => x == rowMaxMax).count(x => x == row", "        val max\
    \ = grid.map(x => x.sum).max\n        val min = grid.map(x => x.sum).min\n   \
    \     if (min == max) return 0\n        val num = max / capacity\n        val\
    \ rem = max % capacity\n        if (rem == 0) return num\n        num + 1", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (j < m && grid(i)(j) == 0) j += 1\n            if (j < m) {\n\
    \                maxFill(i) = (m - j).toLong\n            }\n        }\n     \
    \   maxFill.min", "        // for each row, find the maximum number of consecutive\
    \ 1s\n        // then, for each row, fill the wells with the maximum number of\
    \ consecutive 1s\n        // then, for each row, fill the wells with the maximum\
    \ number of consecutive 1s\n        // then, for each row, fill the wells with\
    \ the maximum number of consecutive 1s\n        // then, for each row, fill the\
    \ wells with the maximum number of consecutive 1s\n        // then, for each row,\
    \ fill the wells with the maximum number of consecutive 1s\n        // then, for\
    \ each row, fill the wells with the maximum number of consecutive 1s\n       \
    \ // then, for each row, fill the wells with the maximum number of consecutive\
    \ 1s\n        // then, for each row, fill the wells with the maximum number of\
    \ consecutive 1s\n        // then, for each row, fill the wells with the maximum\
    \ number of consecutive 1s\n        // then, for each row, fill the wells with\
    \ the maximum number of consecutive 1s\n        // then, for each row, fill the\
    \ wells with the maximum number of consecutive 1s\n        // then, for each row,\
    \ fill the wells with the maximum number of consecutive 1s\n        // then, for\
    \ each row, fill the wells with the maximum number of consecutive 1s\n       \
    \ // then, for each row, fill the wells with the maximum number of consecutive\
    \ 1s\n        // then, for each row, fill the wells with the maximum number of\
    \ consecutive 1s\n        // then, for each row, fill the wells with the maximum\
    \ number of consecutive 1s\n        // then, for each row, fill the wells with\
    \ the maximum number of consecutive 1s\n        // then, for each row, fill the\
    \ wells with the maximum number of consecutive 1s\n        // then, for each row,\
    \ fill the wells with the maximum number of consecutive 1s\n        // then, for\
    \ each row, fill the wells with the maximum number of consecutive 1s\n       \
    \ // then, for each row, fill the wells with the maximum number of consecutive\
    \ 1s\n        // then, for each row, fill the wells with the maximum number of\
    \ consecutive 1s\n        // then, for each row, fill the wells with the maximum\
    \ number of consecutive 1s\n        // then, for each row, fill the wells with\
    \ the maximum number of consecutive 1s\n        // then, for each row, fill the\
    \ wells with the maximum number of", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val maxFill = Array.fill(n, m)(0L)\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    maxFill(i)(j) = capacity\n                } else\
    \ {\n                    if (i > 0) maxFill(i)(j) = maxFill(i - 1)(j)\n      \
    \              if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n\
    \                }\n            }\n        }\n        maxFill(n - 1)(m - 1)",
  "        val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n)(Array.fill(m)(0L))\n        for (i <- 0 until n) {\n       \
    \     for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n       \
    \             maxFill(i)(j) = capacity\n                }\n            }\n   \
    \     }\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (i > 0) {\n                    maxFill(i)(j) = max(maxFill(i)(j),\
    \ maxFill(i - 1)(j))\n                }\n                if (j > 0) {\n      \
    \              maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n       \
    \         }\n            }\n        }\n        var result = 0L\n        for (i\
    \ <- n - 1 to 0 by -1) {\n            for (j <- m - 1 to 0 by -1) {\n        \
    \        if (grid(i)(j) == 1) {\n                    if (i < n - 1) {\n      \
    \                  maxFill(i)(j) = min(maxFill(i)(j), maxFill(i + 1)(j))\n   \
    \                 }\n                    if (j < m - 1) {\n                  \
    \      maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j + 1))\n               \
    \     }\n                    result += capacity - maxFill(i)(j)\n            \
    \    }\n            }\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n   \
    \     for (i <- 0 until n) {\n            for (j <- 0 until m) {\n           \
    \     if (grid(i)(j) == 1) {\n                    maxFill(i) += 1\n          \
    \      }\n            }\n        }\n        val maxFillSum = maxFill.sum\n   \
    \     val maxFillSumSorted = maxFill.sorted\n        var result = 0L\n       \
    \ for (i <- 0 until n) {\n            val maxFillSumSortedWithoutI = maxFillSum\
    \ - maxFillSumSorted(i)\n            val maxFillSumSortedWithoutIAndCapacity =\
    \ maxFillSumSortedWithoutI - capacity\n            if (maxFillSumSortedWithoutIAndCapacity\
    \ <= 0) {\n                result = maxFillSumSortedWithoutI\n               \
    \ break\n            }\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        var result = 0L\n        for (i <- 0\
    \ until n) {\n            var sum = 0L\n            for (j <- 0 until m) {\n \
    \               sum += grid(i)(j)\n                if (sum > capacity) {\n   \
    \                 result += sum - capacity\n                    sum = capacity\n\
    \                }\n            }\n        }\n        result", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n\
    \        for (i <- 0 until n) {\n            var j = 0\n            while (j <\
    \ m && grid(i)(j) == 0) j += 1\n            if (j < m) {\n                var\
    \ k = j\n                while (k < m && grid(i)(k) == 1) k += 1\n           \
    \     maxFill(i) = k - j\n            }\n        }\n        val dp = Array.fill(n)(0L)\n\
    \        for (i <- 0 until n) {\n            dp(i) = maxFill(i)\n            if\
    \ (i > 0) dp(i) = max(dp(i), dp(i - 1) + maxFill(i))\n        }\n        var result\
    \ = 0L\n        var i = 0\n        while (i < n) {\n            var j = i\n  \
    \          var sum = 0L\n            while (j < n && sum + maxFill(j) <= capacity)\
    \ {\n                sum += maxFill(j)\n                j += 1\n            }\n\
    \            result += 1\n            i = j\n        }\n        result", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                if (grid(i)(j) == 1) {\n                    maxFill(i)\
    \ += 1\n                }\n            }\n        }\n        val maxFillSum =\
    \ maxFill.sum\n        val minFill = maxFill.min\n        val minFillSum = minFill\
    \ * n\n        val diff = maxFillSum - minFillSum\n        val bucketCount = diff\
    \ / capacity\n        if (diff % capacity == 0) bucketCount else bucketCount +\
    \ 1", "        val n = grid.length\n        val m = grid(0).length\n        val\
    \ maxFill = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n           \
    \ for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n           \
    \         maxFill(i)(j) = capacity\n                } else {\n               \
    \     if (i > 0) maxFill(i)(j) = maxFill(i - 1)(j)\n                    if (j\
    \ > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n               \
    \ }\n            }\n        }\n        maxFill(n - 1)(m - 1)", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (i == 0) {\n                    dp(i)(j) = grid(i)(j)\n  \
    \              } else {\n                    dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n\
    \                }\n            }\n        }\n        var result = 0L\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  val fill = min(dp(i)(j), capacity)\n                result += fill\n      \
    \          dp(i)(j) -= fill\n            }\n        }\n        result", "    \
    \    val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (grid(i)(j) == 1) {\n                    maxFill(i)(j)\
    \ = capacity\n                } else {\n                    if (i > 0) maxFill(i)(j)\
    \ = maxFill(i - 1)(j)\n                    if (j > 0) maxFill(i)(j) = max(maxFill(i)(j),\
    \ maxFill(i)(j - 1))\n                }\n            }\n        }\n        maxFill(n\
    \ - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                } else {\n    \
    \                if (i > 0) maxFill(i)(j) = maxFill(i - 1)(j)\n              \
    \      if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n    \
    \            }\n            }\n        }\n        maxFill(n - 1)(m - 1)", "  \
    \      val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (j < m && grid(i)(j) == 0) j += 1\n            if (j < m) {\n\
    \                maxFill(i) = min(capacity, m - j)\n            }\n        }\n\
    \        var result = 0L\n        for (i <- 0 until n) {\n            var j =\
    \ 0\n            while (j < m && grid(i)(j) == 0) j += 1\n            if (j <\
    \ m) {\n                val fill = min(maxFill(i), capacity - (m - j))\n     \
    \           result += fill\n                maxFill(i) -= fill\n            }\n\
    \        }\n        result", "        val m = grid.length\n        val n = grid(0).length\n\
    \        val maxFill = Array.fill(m, n)(0L)\n        for (i <- 0 until m) {\n\
    \            for (j <- 0 until n) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                } else {\n    \
    \                if (i > 0) maxFill(i)(j) = maxFill(i - 1)(j)\n              \
    \      if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n    \
    \            }\n            }\n        }\n        maxFill(m - 1)(n - 1)", "  \
    \      val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (j < m && grid(i)(j) == 0) j += 1\n            maxFill(i) =\
    \ j\n        }\n        var result = 0L\n        while (maxFill.exists(_ > 0))\
    \ {\n            val min = maxFill.min\n            for (i <- 0 until n) {\n \
    \               maxFill(i) -= min\n                if (maxFill(i) > 0) {\n   \
    \                 maxFill(i) = max(0, maxFill(i) - capacity)\n               \
    \ }\n            }\n            result += min\n        }\n        result", " \
    \       val rows = grid.length\n        val cols = grid(0).length\n        val\
    \ maxFill = Array.fill(rows, cols)(0L)\n        for (i <- 0 until rows) {\n  \
    \          for (j <- 0 until cols) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                } else {\n    \
    \                maxFill(i)(j) = 0\n                }\n            }\n       \
    \ }\n        for (i <- 0 until rows) {\n            for (j <- 0 until cols) {\n\
    \                if (i > 0) {\n                    maxFill(i)(j) = max(maxFill(i)(j),\
    \ maxFill(i - 1)(j))\n                }\n                if (j > 0) {\n      \
    \              maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n       \
    \         }\n            }\n        }\n        var result = 0L\n        for (i\
    \ <- 0 until rows) {\n            for (j <- 0 until cols) {\n                result\
    \ += maxFill(i)(j)\n            }\n        }\n        result", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n\
    \                    if (i > 0) dp(i)(j) = min(dp(i)(j), dp(i - 1)(j))\n     \
    \               if (j > 0) dp(i)(j) = min(dp(i)(j), dp(i)(j - 1))\n          \
    \      }\n            }\n        }\n        var result = 0L\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    result += capacity - dp(i)(j)\n               \
    \ }\n            }\n        }\n        result", "        val m = grid.length\n\
    \        val n = grid(0).length\n        val maxFill = Array.fill(m, n)(0L)\n\
    \        for (i <- 0 until m) {\n            for (j <- 0 until n) {\n        \
    \        if (grid(i)(j) == 1) {\n                    if (i == 0) maxFill(i)(j)\
    \ = capacity\n                    else maxFill(i)(j) = maxFill(i - 1)(j) + capacity\n\
    \                }\n                else {\n                    if (i == 0) maxFill(i)(j)\
    \ = 0\n                    else maxFill(i)(j) = maxFill(i - 1)(j)\n          \
    \      }\n            }\n        }\n        maxFill.map(x => x.min).sum", "  \
    \      val maxFill = grid.map(row => row.sum).max\n        if (maxFill <= capacity)\
    \ 0\n        else maxFill / capacity + (if (maxFill % capacity == 0) 0 else 1)",
  "        val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (grid(i)(j) == 1) {\n                    maxFill(i)(j)\
    \ = capacity\n                } else {\n                    if (i > 0) maxFill(i)(j)\
    \ = maxFill(i - 1)(j)\n                    if (j > 0) maxFill(i)(j) = max(maxFill(i)(j),\
    \ maxFill(i)(j - 1))\n                }\n            }\n        }\n        maxFill(n\
    \ - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(Array.fill(m)(0L))\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j) ==\
    \ 1) {\n                    maxFill(i)(j) = capacity\n                }\n    \
    \        }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                if (grid(i)(j) == 1) {\n                    if (i\
    \ > 0) {\n                        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i\
    \ - 1)(j) + capacity)\n                    }\n                    if (j > 0) {\n\
    \                        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1)\
    \ + capacity)\n                    }\n                }\n            }\n     \
    \   }\n        var result = 0L\n        for (i <- 0 until n) {\n            for\
    \ (j <- 0 until m) {\n                result += maxFill(i)(j)\n            }\n\
    \        }\n        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n   \
    \         var j = 0\n            while (j < m && grid(i)(j) == 0) j += 1\n   \
    \         if (j < m) {\n                var k = j\n                while (k <\
    \ m && grid(i)(k) == 1) k += 1\n                maxFill(i) = (k - j) min capacity\n\
    \            }\n        }\n        maxFill.sum", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n)(Array.fill(m)(0L))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n   \
    \                 if (i > 0) dp(i)(j) = max(dp(i)(j), dp(i - 1)(j))\n        \
    \            if (j > 0) dp(i)(j) = max(dp(i)(j), dp(i)(j - 1))\n             \
    \   }\n            }\n        }\n        var result = 0L\n        for (i <- 0\
    \ until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    var min = capacity\n                    if (i >\
    \ 0) min = min(min, dp(i - 1)(j))\n                    if (j > 0) min = min(min,\
    \ dp(i)(j - 1))\n                    result += min\n                }\n      \
    \      }\n        }\n        result", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(0L)\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                if (i == 0)\
    \ {\n                    dp(i)(j) = grid(i)(j)\n                } else {\n   \
    \                 dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n                }\n  \
    \          }\n        }\n        val maxFill = dp.map(_.max).max\n        val\
    \ result = if (maxFill % capacity == 0) maxFill / capacity else maxFill / capacity\
    \ + 1\n        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n, m)(0)\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n \
    \                   maxFill(i)(j) = capacity\n                } else {\n     \
    \               if (i > 0) maxFill(i)(j) = maxFill(i - 1)(j)\n               \
    \     if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n     \
    \           }\n            }\n        }\n        maxFill(n - 1)(m - 1)", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n\
    \                }\n                if (i > 0) {\n                    dp(i)(j)\
    \ = max(dp(i)(j), dp(i - 1)(j))\n                }\n                if (j > 0)\
    \ {\n                    dp(i)(j) = max(dp(i)(j), dp(i)(j - 1))\n            \
    \    }\n            }\n        }\n        var result = 0L\n        for (i <- 0\
    \ until n) {\n            for (j <- 0 until m) {\n                result += dp(i)(j)\n\
    \            }\n        }\n        result", "        val n = grid.length\n   \
    \     val m = grid(0).length\n        val dp = Array.fill(n, m)(0L)\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    dp(i)(j) = capacity\n                }\n      \
    \          if (i > 0) {\n                    dp(i)(j) = max(dp(i)(j), dp(i - 1)(j))\n\
    \                }\n                if (j > 0) {\n                    dp(i)(j)\
    \ = max(dp(i)(j), dp(i)(j - 1))\n                }\n            }\n        }\n\
    \        var result = 0L\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                result += dp(i)(j)\n            }\n        }\n\
    \        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n     \
    \               dp(i)(j) = capacity\n                }\n                if (i\
    \ > 0) {\n                    dp(i)(j) = max(dp(i)(j), dp(i - 1)(j))\n       \
    \         }\n                if (j > 0) {\n                    dp(i)(j) = max(dp(i)(j),\
    \ dp(i)(j - 1))\n                }\n            }\n        }\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               if (grid(i)(j) == 1) {\n                    result += capacity\
    \ - dp(i)(j)\n                }\n            }\n        }\n        result", " \
    \       val m = grid.length\n        val n = grid(0).length\n        val maxFill\
    \ = Array.fill(m)(0L)\n        for (i <- 0 until m) {\n            for (j <- 0\
    \ until n) {\n                if (grid(i)(j) == 1) {\n                    maxFill(i)\
    \ += 1\n                }\n            }\n        }\n        val minFill = maxFill.min\n\
    \        var result = 0L\n        for (i <- 0 until m) {\n            if (maxFill(i)\
    \ > minFill) {\n                val diff = maxFill(i) - minFill\n            \
    \    result += diff / capacity\n                if (diff % capacity != 0) result\
    \ += 1\n            }\n        }\n        result", "        val m = grid.length\n\
    \        val n = grid(0).length\n        val maxFill = Array.fill(m, n)(0L)\n\
    \        for (i <- 0 until m) {\n            for (j <- 0 until n) {\n        \
    \        if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n\
    \                } else {\n                    if (i > 0) maxFill(i)(j) = maxFill(i\
    \ - 1)(j)\n                    if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j\
    \ - 1))\n                }\n            }\n        }\n        maxFill(m - 1)(n\
    \ - 1)", "        val n = grid.length\n        val m = grid(0).length\n      \
    \  val maxFill = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n      \
    \      for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n      \
    \              maxFill(i)(j) = capacity\n                } else {\n          \
    \          if (i > 0) maxFill(i)(j) = maxFill(i - 1)(j)\n                    if\
    \ (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n            \
    \    }\n            }\n        }\n        maxFill(n - 1)(m - 1)", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n\
    \                }\n                if (i > 0) {\n                    dp(i)(j)\
    \ = max(dp(i)(j), dp(i - 1)(j))\n                }\n                if (j > 0)\
    \ {\n                    dp(i)(j) = max(dp(i)(j), dp(i)(j - 1))\n            \
    \    }\n            }\n        }\n        var result = 0L\n        for (i <- 0\
    \ until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    result += capacity - dp(i)(j)\n               \
    \ }\n            }\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        var max = 0L\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j) ==\
    \ 1) {\n                    max = max max (i + 1)\n                }\n       \
    \     }\n        }\n        max * capacity", "        val maxFill = grid.map(row\
    \ => row.max).max\n        maxFill", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(0L)\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    dp(i)(j) = capacity\n                }\n      \
    \          if (i > 0) {\n                    dp(i)(j) = max(dp(i)(j), dp(i - 1)(j))\n\
    \                }\n                if (j > 0) {\n                    dp(i)(j)\
    \ = max(dp(i)(j), dp(i)(j - 1))\n                }\n            }\n        }\n\
    \        var result = 0L\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                result += dp(i)(j)\n            }\n        }\n\
    \        result", "        val m = grid.length\n        val n = grid(0).length\n\
    \        val maxFill = Array.fill(m)(Array.fill(n)(0L))\n        for (i <- 0 until\
    \ m) {\n            for (j <- 0 until n) {\n                if (grid(i)(j) ==\
    \ 1) {\n                    maxFill(i)(j) = capacity\n                }\n    \
    \        }\n        }\n        for (i <- 0 until m) {\n            for (j <- 0\
    \ until n) {\n                if (i > 0) {\n                    maxFill(i)(j)\
    \ = max(maxFill(i)(j), maxFill(i - 1)(j))\n                }\n               \
    \ if (j > 0) {\n                    maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j\
    \ - 1))\n                }\n            }\n        }\n        var result = 0L\n\
    \        for (i <- m - 1 to 0 by -1) {\n            for (j <- n - 1 to 0 by -1)\
    \ {\n                if (grid(i)(j) == 1) {\n                    result += capacity\
    \ - maxFill(i)(j)\n                }\n            }\n        }\n        result",
  "        val n = grid.length\n        val m = grid(0).length\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n           \
    \ for (j <- 0 until m) {\n                sum += grid(i)(j)\n                if\
    \ (sum > capacity) {\n                    result += sum - capacity\n         \
    \           sum = capacity\n                }\n            }\n        }\n    \
    \    result", "        val n = grid.length\n        val m = grid(0).length\n \
    \       val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n    \
    \        var j = 0\n            while (j < m && grid(i)(j) == 0) j += 1\n    \
    \        maxFill(i) = j\n        }\n        val maxFillSum = maxFill.sum\n   \
    \     val maxFillSum2 = maxFill.map(x => x * x).sum\n        val maxFillSum3 =\
    \ maxFill.map(x => x * x * x).sum\n        val maxFillSum4 = maxFill.map(x =>\
    \ x * x * x * x).sum\n        val maxFillSum5 = maxFill.map(x => x * x * x * x\
    \ * x).sum\n        val maxFillSum6 = maxFill.map(x => x * x * x * x * x * x).sum\n\
    \        val maxFillSum7 = maxFill.map(x => x * x * x * x * x * x * x).sum\n \
    \       val maxFillSum8 = maxFill.map(x => x * x * x * x * x * x * x * x).sum\n\
    \        val maxFillSum9 = maxFill.map(x => x * x * x * x * x * x * x * x * x).sum\n\
    \        val maxFillSum10 = maxFill.map(x => x * x * x * x * x * x * x * x * x\
    \ * x).sum\n        val maxFillSum11 = maxFill.map(x => x * x * x * x * x * x\
    \ * x * x * x * x * x).sum\n        val maxFillSum12 = maxFill.map(x => x * x\
    \ * x * x * x * x * x * x * x * x * x * x).sum\n        val maxFillSum13 = maxFill.map(x\
    \ => x * x * x * x * x * x * x * x * x * x * x * x * x).sum\n        val maxFillSum14\
    \ = maxFill.map(x => x * x * x * x * x * x * x * x * x * x * x * x * x * x).sum\n\
    \        val", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n   \
    \         var j = 0\n            while (j < m && grid(i)(j) == 0) j += 1\n   \
    \         maxFill(i) = j\n        }\n        var result = 0L\n        var i =\
    \ 0\n        while (i < n) {\n            var j = 0\n            while (j < m\
    \ && grid(i)(j) == 0) j += 1\n            if (j == m) {\n                i +=\
    \ 1\n                continue\n            }\n            var k = i\n        \
    \    while (k < n && maxFill(k) >= j) k += 1\n            val count = min(capacity,\
    \ (k - i).toLong)\n            for (l <- i until k) {\n                grid(l)(j)\
    \ -= count\n                if (grid(l)(j) == 0) maxFill(l) = j\n            }\n\
    \            result += count\n            i = k\n        }\n        result", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                maxFill(i) += grid(i)(j)\n            }\n      \
    \  }\n        val maxFillSum = maxFill.sum\n        val maxFillSumCapacity = maxFillSum\
    \ / capacity\n        val maxFillSumCapacityRemainder = maxFillSum % capacity\n\
    \        val maxFillSumCapacityRemainderMax = maxFillSumCapacityRemainder * n\n\
    \        val maxFillSumCapacityRemainderMaxIndex = maxFill.zipWithIndex.maxBy(_._1)._2\n\
    \        val maxFillSumCapacityRemainderMaxIndexRemainder = maxFill(maxFillSumCapacityRemainderMaxIndex)\
    \ - maxFillSumCapacityRemainder\n        val maxFillSumCapacityRemainderMaxIndexRemainderMax\
    \ = maxFillSumCapacityRemainderMaxIndexRemainder / capacity\n        val maxFillSumCapacityRemainderMaxIndexRemainderMaxRemainder\
    \ = maxFillSumCapacityRemainderMaxIndexRemainder % capacity\n        val maxFillSumCapacityRemainderMaxIndexRemainderMaxRemainderMax\
    \ = maxFillSumCapacityRemainderMaxIndexRemainderMaxRemainder * n\n        val\
    \ maxFillSumCapacityRemainderMaxIndexRemainderMaxRemainderMaxIndex = maxFill.zipWithIndex.maxBy(_._1)._2\n\
    \        val maxFillSumCapacityRemainderMaxIndexRemainderMaxRemainderMaxIndexRemainder\
    \ = maxFill(maxFillSumCapacityRemainderMaxIndexRemainderMaxRemainderMaxIndex)\
    \ - maxFillSumCapacityRemainderMaxIndexRemainderMaxRemainder\n        val maxFillSumCapacityRemainderMaxIndexRemainderMaxRemainderMaxIndexRemainderMax\
    \ = maxFillSumCapacityRemainderMaxIndexRemainderMaxRemainderMaxIndexRemainder\
    \ / capacity\n        val maxFillSumCapacityRemainderMaxIndexRemainderMaxRemainderMaxIndexRemainderMaxRemainder\
    \ = maxFillSumCapacityRemain", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                } else {\n    \
    \                if (i > 0) maxFill(i)(j) = maxFill(i - 1)(j)\n              \
    \      if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j - 1))\n    \
    \            }\n            }\n        }\n        maxFill(n - 1)(m - 1)", "  \
    \      val n = grid.length\n        val m = grid(0).length\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n           \
    \ for (j <- 0 until m) {\n                sum += grid(i)(j)\n                if\
    \ (sum > capacity) {\n                    result += sum - capacity\n         \
    \           sum = capacity\n                }\n            }\n        }\n    \
    \    result", "        val n = grid.length\n        val m = grid(0).length\n \
    \       var ans = 0L\n        for (i <- 0 until n) {\n            var cnt = 0L\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) cnt\
    \ += 1\n            }\n            ans += (cnt + capacity - 1) / capacity\n  \
    \      }\n        ans", "        val m = grid.length\n        val n = grid(0).length\n\
    \        var max = 0L\n        for (i <- 0 until m) {\n            for (j <- 0\
    \ until n) {\n                if (grid(i)(j) == 1) {\n                    max\
    \ = max max (i + 1)\n                }\n            }\n        }\n        max\
    \ * capacity", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until m) {\n                if (i == 0) {\n              \
    \      dp(i)(j) = grid(i)(j)\n                } else {\n                    dp(i)(j)\
    \ = dp(i - 1)(j) + grid(i)(j)\n                }\n            }\n        }\n \
    \       var result = 0L\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (dp(i)(j) > capacity) {\n                 \
    \   result += dp(i)(j) - capacity\n                    dp(i)(j) = capacity\n \
    \               }\n            }\n        }\n        result", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n\
    \                }\n                if (i > 0) {\n                    dp(i)(j)\
    \ = max(dp(i)(j), dp(i - 1)(j))\n                }\n                if (j > 0)\
    \ {\n                    dp(i)(j) = max(dp(i)(j), dp(i)(j - 1))\n            \
    \    }\n            }\n        }\n        var result = 0L\n        for (i <- 0\
    \ until n) {\n            for (j <- 0 until m) {\n                result += dp(i)(j)\n\
    \            }\n        }\n        result", "        val maxFill = grid.map(row\
    \ => row.sum).max\n        if (maxFill <= capacity) 0\n        else maxFill /\
    \ capacity + (if (maxFill % capacity == 0) 0 else 1)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(0L)\n     \
    \   for (i <- 0 until n) {\n            for (j <- 0 until m) {\n             \
    \   if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n        \
    \            if (i > 0) dp(i)(j) = min(dp(i)(j), dp(i - 1)(j))\n             \
    \       if (j > 0) dp(i)(j) = min(dp(i)(j), dp(i)(j - 1))\n                }\n\
    \            }\n        }\n        var result = 0L\n        for (i <- n - 1 to\
    \ 0 by -1) {\n            for (j <- m - 1 to 0 by -1) {\n                if (grid(i)(j)\
    \ == 1) {\n                    if (i < n - 1) dp(i)(j) = min(dp(i)(j), dp(i +\
    \ 1)(j))\n                    if (j < m - 1) dp(i)(j) = min(dp(i)(j), dp(i)(j\
    \ + 1))\n                    result += capacity - dp(i)(j)\n                }\n\
    \            }\n        }\n        result", "        val n = grid.length\n   \
    \     val m = grid(0).length\n        var ans = 0L\n        for (i <- 0 until\
    \ n) {\n            var sum = 0L\n            for (j <- 0 until m) {\n       \
    \         sum += grid(i)(j)\n                if (sum > capacity) {\n         \
    \           ans += sum - capacity\n                    sum = capacity\n      \
    \          }\n            }\n        }\n        ans", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val maxFill = Array.fill(n)(0L)\n   \
    \     for (i <- 0 until n) {\n            var count = 0L\n            for (j <-\
    \ 0 until m) {\n                if (grid(i)(j) == 1) count += 1\n            }\n\
    \            maxFill(i) = count\n        }\n        var result = 0L\n        for\
    \ (i <- 0 until n) {\n            val fill = maxFill(i)\n            if (fill\
    \ > 0) {\n                val times = ceil(fill.toDouble / capacity.toDouble).toLong\n\
    \                result += times\n                for (j <- 0 until n) {\n   \
    \                 if (i != j) {\n                        val diff = min(times\
    \ * capacity, maxFill(j))\n                        maxFill(j) -= diff\n      \
    \              }\n                }\n            }\n        }\n        result",
  "        var maxFill = 0L\n        for (i <- 0 until grid.length) {\n          \
    \  var fill = 0L\n            for (j <- 0 until grid(i).length) {\n          \
    \      if (grid(i)(j) == 1) fill += 1\n            }\n            maxFill = max(maxFill,\
    \ fill)\n        }\n        maxFill", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val maxFill = Array.fill(n)(Array.fill(m)(0L))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n\
    \                }\n            }\n        }\n        for (i <- 1 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = min(maxFill(i - 1)(j), capacity)\n      \
    \          }\n            }\n        }\n        for (i <- n - 2 to 0 by -1) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = min(maxFill(i + 1)(j), maxFill(i)(j))\n \
    \               }\n            }\n        }\n        var result = 0L\n       \
    \ for (i <- 0 until n) {\n            for (j <- 0 until m) {\n               \
    \ if (grid(i)(j) == 1) {\n                    result += maxFill(i)(j)\n      \
    \          }\n            }\n        }\n        result", "        val rows = grid.length\n\
    \        val cols = grid(0).length\n        var total = 0L\n        for (i <-\
    \ 0 until rows) {\n            for (j <- 0 until cols) {\n                if (grid(i)(j)\
    \ == 1) {\n                    total += capacity\n                }\n        \
    \    }\n        }\n        total", "        val maxFill = grid.map(x => x.sum).max\n\
    \        if (maxFill <= capacity) 0\n        else maxFill / capacity + (if (maxFill\
    \ % capacity == 0) 0 else 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n   \
    \         var j = 0\n            while (j < m && grid(i)(j) == 0) j += 1\n   \
    \         if (j < m) {\n                maxFill(i) = j + 1\n            }\n  \
    \      }\n        var result = 0L\n        for (i <- 0 until n) {\n          \
    \  if (maxFill(i) > 0) {\n                val fill = min(maxFill(i), capacity)\n\
    \                result += fill\n                for (j <- 0 until m) {\n    \
    \                if (grid(i)(j) == 1) {\n                        grid(i)(j) =\
    \ 0\n                        if (fill == 1) return result\n                  \
    \      fill -= 1\n                    }\n                }\n            }\n  \
    \      }\n        result", "        val rows = grid.length\n        val cols =\
    \ grid(0).length\n        val maxFill = Array.fill(rows, cols)(0L)\n        for\
    \ (i <- 0 until rows) {\n            for (j <- 0 until cols) {\n             \
    \   if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n   \
    \             } else {\n                    maxFill(i)(j) = 0\n              \
    \  }\n            }\n        }\n        for (i <- 0 until rows) {\n          \
    \  for (j <- 0 until cols) {\n                if (i > 0) {\n                 \
    \   maxFill(i)(j) = max(maxFill(i)(j), maxFill(i - 1)(j))\n                }\n\
    \                if (j > 0) {\n                    maxFill(i)(j) = max(maxFill(i)(j),\
    \ maxFill(i)(j - 1))\n                }\n            }\n        }\n        var\
    \ result = 0L\n        for (i <- rows - 1 to 0 by -1) {\n            for (j <-\
    \ cols - 1 to 0 by -1) {\n                if (i < rows - 1) {\n              \
    \      maxFill(i)(j) = min(maxFill(i)(j), maxFill(i + 1)(j))\n               \
    \ }\n                if (j < cols - 1) {\n                    maxFill(i)(j) =\
    \ min(maxFill(i)(j), maxFill(i)(j + 1))\n                }\n                result\
    \ += maxFill(i)(j)\n            }\n        }\n        result", "        val maxFill\
    \ = grid.map(x => x.sum).max\n        if (maxFill <= capacity) 0\n        else\
    \ {\n            val maxFillRow = grid.indexWhere(x => x.sum == maxFill)\n   \
    \         val maxFillCol = grid(maxFillRow).indexWhere(x => x == 1)\n        \
    \    val maxFillRowCount = grid(maxFillRow).count(x => x == 1)\n            val\
    \ maxFillColCount = grid.map(x => x(maxFillCol)).count(x => x == 1)\n        \
    \    val maxFillRowFill = maxFillRowCount - capacity\n            val maxFillColFill\
    \ = maxFillColCount - capacity\n            val maxFillRowFillCount = if (maxFillRowFill\
    \ <= 0) 0 else maxFillRowFill\n            val maxFillColFillCount = if (maxFillColFill\
    \ <= 0) 0 else maxFillColFill\n            val maxFillRowFillCount2 = if (maxFillRowFill\
    \ <= 0) 0 else maxFillRowFill - 1\n            val maxFillColFillCount2 = if (maxFillColFill\
    \ <= 0) 0 else maxFillColFill - 1\n            val maxFillRowFillCount3 = if (maxFillRowFill\
    \ <= 0) 0 else maxFillRowFill - 2\n            val maxFillColFillCount3 = if (maxFillColFill\
    \ <= 0) 0 else maxFillColFill - 2\n            val maxFillRowFillCount4 = if (maxFillRowFill\
    \ <= 0) 0 else maxFillRowFill - 3\n            val maxFillColFillCount4 = if (maxFillColFill\
    \ <= 0) 0 else maxFillColFill - 3\n            val maxFillRowFillCount5 = if (maxFillRowFill\
    \ <= 0) 0 else maxFillRowFill - 4\n            val maxFillColFillCount5 = if (maxFillColFill\
    \ <= 0) 0 else maxFillColFill - 4\n            val maxFillRowFillCount6 = if (maxFillRowFill\
    \ <= 0) 0 else maxFillRowFill - 5\n            val maxFillColFillCount6 = if (maxFillColFill\
    \ <= 0) 0 else maxFillColFill - 5\n            val maxFillRowFillCount7 = if (maxFillRowFill\
    \ <= 0) 0 else maxFillRowFill - 6\n            val maxFillColFillCount7 = if (maxFillCol"]
stop_tokens:
- "\n    }\n"
