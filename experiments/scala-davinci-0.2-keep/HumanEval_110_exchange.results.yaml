language: scala
name: HumanEval_110_exchange
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.length == odds2.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp34qzb6fb.scala:24)\n\tat Problem.main(tmp34qzb6fb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ + lst2Even.size >= lst1.size) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Odd = lst1.filter(_\
    \ % 2 == 1)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Odd.size\
    \ <= lst2Even.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Odd = lst1.filter(x\
    \ => x % 2 == 1)\n        val lst2Even = lst2.filter(x => x % 2 == 0)\n      \
    \  if (lst1Odd.length <= lst2Even.length) \"YES\" else \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odd1 = lst1.filter(_\
    \ % 2 == 1)\n        val odd2 = lst2.filter(_ % 2 == 1)\n        if (odd1.size\
    \ == odd2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprnyhgxxg.scala:24)\n\tat Problem.main(tmprnyhgxxg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdbf2vvg9.scala:24)\n\tat Problem.main(tmpdbf2vvg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length == 0) return \"NO\"\n        if (odds.length == 0) return \"YES\"\
    \n        if (evens.length >= odds.length) return \"YES\"\n        return \"NO\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphu4bmssh.scala:27)\n\tat Problem.main(tmphu4bmssh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(x\
    \ => x % 2 == 0)\n        val lst1Odd = lst1.filter(x => x % 2 == 1)\n       \
    \ val lst2Even = lst2.filter(x => x % 2 == 0)\n        val lst2Odd = lst2.filter(x\
    \ => x % 2 == 1)\n        if (lst1Even.length + lst2Even.length >= lst1.length)\
    \ \"YES\"\n        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odd1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odd2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odd1.size == odd2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbk9vyy5p.scala:24)\n\tat Problem.main(tmpbk9vyy5p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odd1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odd2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odd1.size == odd2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbk9vyy5p.scala:24)\n\tat Problem.main(tmpbk9vyy5p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ == lst1.size) \"YES\"\n        else if (lst2Even.size == lst2.size) \"YES\"\n\
    \        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxkzxdb4.scala:23)\n\tat Problem.main(tmpaxkzxdb4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Odd = lst1.filter(x\
    \ => x % 2 == 1)\n        val lst2Even = lst2.filter(x => x % 2 == 0)\n      \
    \  if (lst1Odd.length <= lst2Even.length) \"YES\" else \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdbf2vvg9.scala:24)\n\tat Problem.main(tmpdbf2vvg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odd1 = lst1.filter(_\
    \ % 2 == 1)\n        val odd2 = lst2.filter(_ % 2 == 1)\n        if (odd1.size\
    \ == odd2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprnyhgxxg.scala:24)\n\tat Problem.main(tmprnyhgxxg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length == lst1.length) \"YES\"\n        else if (odds.length == lst2.length)\
    \ \"NO\"\n        else \"YES\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9_g2vp5t.scala:24)\n\tat Problem.main(tmp9_g2vp5t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odd1 = lst1.filter(_\
    \ % 2 == 1)\n        val odd2 = lst2.filter(_ % 2 == 1)\n        if (odd1.size\
    \ == odd2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprnyhgxxg.scala:24)\n\tat Problem.main(tmprnyhgxxg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        var lst1_odd = lst1.filter(x\
    \ => x % 2 == 1)\n        var lst2_even = lst2.filter(x => x % 2 == 0)\n     \
    \   if (lst1_odd.length <= lst2_even.length) \"YES\" else \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(x\
    \ => x % 2 == 0)\n        val lst1Odd = lst1.filter(x => x % 2 == 1)\n       \
    \ val lst2Even = lst2.filter(x => x % 2 == 0)\n        val lst2Odd = lst2.filter(x\
    \ => x % 2 == 1)\n        if (lst1Even.length + lst2Even.length >= lst1.length)\
    \ \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdbf2vvg9.scala:24)\n\tat Problem.main(tmpdbf2vvg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ == lst1.size) \"YES\"\n        else if (lst2Even.size == lst2.size) \"YES\"\n\
    \        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxkzxdb4.scala:23)\n\tat Problem.main(tmpaxkzxdb4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val s1 = lst1.filter(_\
    \ % 2 == 1).size\n        val s2 = lst2.filter(_ % 2 == 1).size\n        if (s1\
    \ == s2) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmubp1fg4.scala:24)\n\tat Problem.main(tmpmubp1fg4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ + lst2Even.size >= lst1.size) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ == lst1.size) \"YES\"\n        else if (lst2Even.size == lst2.size) \"YES\"\n\
    \        else if (lst1Even.size + lst2Even.size >= lst1.size) \"YES\"\n      \
    \  else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1odd = lst1.filter(x\
    \ => x % 2 == 1)\n        val lst2even = lst2.filter(x => x % 2 == 0)\n      \
    \  if (lst1odd.length <= lst2even.length) \"YES\" else \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        // Fill in the code here\n\
    \        \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzy2q2aze.scala:20)\n\tat Problem.main(tmpzy2q2aze.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Odd = lst1.filter(x\
    \ => x % 2 == 1)\n        val lst2Even = lst2.filter(x => x % 2 == 0)\n      \
    \  if (lst1Odd.length <= lst2Even.length) \"YES\" else \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        if (lst1.forall(x =>\
    \ x % 2 == 0)) return \"YES\"\n        if (lst2.forall(x => x % 2 == 0)) return\
    \ \"YES\"\n        for (i <- 0 until lst1.length) {\n            for (j <- 0 until\
    \ lst2.length) {\n                val lst1_ = lst1.updated(i, lst2(j))\n     \
    \           val lst2_ = lst2.updated(j, lst1(i))\n                if (lst1_.forall(x\
    \ => x % 2 == 0)) return \"YES\"\n                if (lst2_.forall(x => x % 2\
    \ == 0)) return \"YES\"\n            }\n        }\n        \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbygne6gh.scala:29)\n\tat Problem.main(tmpbygne6gh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ == lst1.size) \"YES\"\n        else if (lst2Even.size == lst2.size) \"YES\"\n\
    \        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxkzxdb4.scala:23)\n\tat Problem.main(tmpaxkzxdb4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odd1 = lst1.filter(_\
    \ % 2 == 1)\n        val odd2 = lst2.filter(_ % 2 == 1)\n        if (odd1.size\
    \ == odd2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprnyhgxxg.scala:24)\n\tat Problem.main(tmprnyhgxxg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        // Fill in the code here\n\
    \        \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzy2q2aze.scala:20)\n\tat Problem.main(tmpzy2q2aze.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdbf2vvg9.scala:24)\n\tat Problem.main(tmpdbf2vvg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ + lst2Even.size >= lst1.size) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        // Fill in the code here\n\
    \        \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzy2q2aze.scala:20)\n\tat Problem.main(tmpzy2q2aze.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        var odd1 = 0\n      \
    \  var odd2 = 0\n        for (i <- lst1) if (i % 2 == 1) odd1 += 1\n        for\
    \ (i <- lst2) if (i % 2 == 1) odd2 += 1\n        if (odd1 % 2 == odd2 % 2) \"\
    YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1qyneqkd.scala:26)\n\tat Problem.main(tmp1qyneqkd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Odd = lst1.filter(_\
    \ % 2 == 1)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Odd.size\
    \ <= lst2Even.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6n1aag6h.scala:21)\n\tat Problem.main(tmp6n1aag6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        val lst1Odd\
    \ = lst1.filter(_ % 2 == 1)\n        val lst2Odd = lst2.filter(_ % 2 == 1)\n \
    \       if (lst1Even.length + lst2Even.length >= lst1.length) \"YES\"\n      \
    \  else if (lst1Odd.length + lst2Odd.length >= lst2.length) \"YES\"\n        else\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx58rtq0l.scala:26)\n\tat Problem.main(tmpx58rtq0l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        val lst1Odd\
    \ = lst1.filter(_ % 2 == 1)\n        val lst2Odd = lst2.filter(_ % 2 == 1)\n \
    \       if (lst1Even.length + lst2Even.length >= lst1.length) \"YES\"\n      \
    \  else if (lst1Odd.length + lst2Odd.length >= lst2.length) \"YES\"\n        else\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx58rtq0l.scala:26)\n\tat Problem.main(tmpx58rtq0l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        // Fill in the code here.\n\
    \        \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3enuta5e.scala:20)\n\tat Problem.main(tmp3enuta5e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1odd = lst1.filter(_\
    \ % 2 == 1)\n        val lst2even = lst2.filter(_ % 2 == 0)\n        if (lst1odd.size\
    \ <= lst2even.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ + lst2Even.size >= lst1.size) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        if (lst1.forall(_ % 2\
    \ == 0)) \"YES\"\n        else if (lst2.forall(_ % 2 == 0)) \"YES\"\n        else\
    \ if (lst1.exists(_ % 2 == 0) && lst2.exists(_ % 2 == 0)) \"YES\"\n        else\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuoaif6hm.scala:23)\n\tat Problem.main(tmpuoaif6hm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(_\
    \ % 2 == 1)\n        val odds2 = lst2.filter(_ % 2 == 1)\n        if (odds1.size\
    \ == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdhw_ta1l.scala:24)\n\tat Problem.main(tmpdhw_ta1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(_\
    \ % 2 == 1)\n        val odds2 = lst2.filter(_ % 2 == 1)\n        if (odds1.size\
    \ == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdhw_ta1l.scala:24)\n\tat Problem.main(tmpdhw_ta1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odd1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odd2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odd1.size == odd2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbk9vyy5p.scala:24)\n\tat Problem.main(tmpbk9vyy5p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ == lst1.size) \"YES\"\n        else if (lst2Even.size == lst2.size) \"YES\"\n\
    \        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxkzxdb4.scala:23)\n\tat Problem.main(tmpaxkzxdb4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.length == odds2.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp34qzb6fb.scala:24)\n\tat Problem.main(tmp34qzb6fb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        // Fill in the code here.\n\
    \        val lst1Even = lst1.filter(_ % 2 == 0)\n        val lst2Odd = lst2.filter(_\
    \ % 2 == 1)\n        if (lst1Even.size + lst2Odd.size == lst1.size) \"YES\" else\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ikls1vm.scala:25)\n\tat Problem.main(tmp2ikls1vm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        // Fill in the code here\n\
    \        \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzy2q2aze.scala:20)\n\tat Problem.main(tmpzy2q2aze.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb_4dbi0m.scala:22)\n\tat Problem.main(tmpb_4dbi0m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1odd = lst1.filter(_\
    \ % 2 == 1)\n        val lst2even = lst2.filter(_ % 2 == 0)\n        if (lst1odd.size\
    \ <= lst2even.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ == lst1.size) \"YES\"\n        else if (lst2Even.size == lst2.size) \"YES\"\n\
    \        else if (lst1Even.size + lst2Even.size >= lst1.size) \"YES\"\n      \
    \  else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1odd = lst1.filter(x\
    \ => x % 2 == 1)\n        val lst2even = lst2.filter(x => x % 2 == 0)\n      \
    \  if (lst1odd.length <= lst2even.length) \"YES\" else \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ + lst2Even.size >= lst1.size) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        val lst1Odd\
    \ = lst1.filter(_ % 2 == 1)\n        val lst2Odd = lst2.filter(_ % 2 == 1)\n \
    \       if (lst1Even.length + lst2Even.length >= lst1.length) \"YES\"\n      \
    \  else if (lst1Odd.length + lst2Odd.length >= lst2.length) \"YES\"\n        else\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx58rtq0l.scala:26)\n\tat Problem.main(tmpx58rtq0l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb_4dbi0m.scala:22)\n\tat Problem.main(tmpb_4dbi0m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb_4dbi0m.scala:22)\n\tat Problem.main(tmpb_4dbi0m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ + lst2Even.size >= lst1.size) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ == lst1.size) \"YES\"\n        else if (lst2Even.size == lst2.size) \"YES\"\n\
    \        else if (lst1Even.size + lst2Even.size >= lst1.size) \"YES\"\n      \
    \  else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ == lst1.size) \"YES\"\n        else if (lst2Even.size == lst2.size) \"YES\"\n\
    \        else if (lst1Even.size + lst2Even.size >= lst1.size) \"YES\"\n      \
    \  else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odd1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odd2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odd1.size == odd2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbk9vyy5p.scala:24)\n\tat Problem.main(tmpbk9vyy5p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdbf2vvg9.scala:24)\n\tat Problem.main(tmpdbf2vvg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Odd = lst1.filter(_\
    \ % 2 == 1)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Odd.size\
    \ <= lst2Even.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length == lst1.length) \"YES\"\n        else if (odds.length == lst2.length)\
    \ \"NO\"\n        else \"YES\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9_g2vp5t.scala:24)\n\tat Problem.main(tmp9_g2vp5t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6n1aag6h.scala:21)\n\tat Problem.main(tmp6n1aag6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens1 = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds1 = lst1.filter(x => x % 2 == 1)\n        val\
    \ evens2 = lst2.filter(x => x % 2 == 0)\n        val odds2 = lst2.filter(x =>\
    \ x % 2 == 1)\n        if (evens1.length + evens2.length >= lst1.length) \"YES\"\
    \ else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(_\
    \ % 2 == 1)\n        val odds2 = lst2.filter(_ % 2 == 1)\n        if (odds1.size\
    \ == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdhw_ta1l.scala:24)\n\tat Problem.main(tmpdhw_ta1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ == lst1.length) \"YES\"\n        else if (odds.length == lst2.length) \"NO\"\
    \n        else \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsxawzuh8.scala:24)\n\tat Problem.main(tmpsxawzuh8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        var evens = 0\n     \
    \   for (i <- lst1) if (i % 2 == 0) evens += 1\n        var odds = 0\n       \
    \ for (i <- lst2) if (i % 2 == 1) odds += 1\n        if (evens == lst1.length\
    \ || odds == lst2.length) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwv4rtgf6.scala:23)\n\tat Problem.main(tmpwv4rtgf6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ + lst2Even.size >= lst1.size) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdbf2vvg9.scala:24)\n\tat Problem.main(tmpdbf2vvg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        // Fill in the code here\n\
    \        \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzy2q2aze.scala:20)\n\tat Problem.main(tmpzy2q2aze.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1_odd = lst1.filter(x\
    \ => x % 2 == 1)\n        val lst2_even = lst2.filter(x => x % 2 == 0)\n     \
    \   if (lst1_odd.length <= lst2_even.length) \"YES\" else \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1odd = lst1.filter(_\
    \ % 2 == 1)\n        val lst2even = lst2.filter(_ % 2 == 0)\n        if (lst1odd.size\
    \ <= lst2even.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1_even = lst1.filter(x\
    \ => x % 2 == 0)\n        val lst1_odd = lst1.filter(x => x % 2 == 1)\n      \
    \  val lst2_even = lst2.filter(x => x % 2 == 0)\n        val lst2_odd = lst2.filter(x\
    \ => x % 2 == 1)\n        if (lst1_even.length + lst2_even.length >= lst1.length)\
    \ \"YES\"\n        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb_4dbi0m.scala:22)\n\tat Problem.main(tmpb_4dbi0m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        if (lst1.forall(x =>\
    \ x % 2 == 0)) return \"YES\"\n        if (lst2.forall(x => x % 2 == 0)) return\
    \ \"YES\"\n        var odd1 = lst1.filter(x => x % 2 == 1)\n        var odd2 =\
    \ lst2.filter(x => x % 2 == 1)\n        if (odd1.length == 0 || odd2.length ==\
    \ 0) return \"NO\"\n        if (odd1.length % 2 == 1 && odd2.length % 2 == 1)\
    \ return \"NO\"\n        return \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpntwstf6d.scala:26)\n\tat Problem.main(tmpntwstf6d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Odd = lst1.filter(x\
    \ => x % 2 == 1)\n        val lst2Even = lst2.filter(x => x % 2 == 0)\n      \
    \  if (lst1Odd.length <= lst2Even.length) \"YES\" else \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(_\
    \ % 2 == 1)\n        val odds2 = lst2.filter(_ % 2 == 1)\n        if (odds1.size\
    \ == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdhw_ta1l.scala:24)\n\tat Problem.main(tmpdhw_ta1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdbf2vvg9.scala:24)\n\tat Problem.main(tmpdbf2vvg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb_4dbi0m.scala:22)\n\tat Problem.main(tmpb_4dbi0m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb_4dbi0m.scala:22)\n\tat Problem.main(tmpb_4dbi0m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val even1 = lst1.filter(_\
    \ % 2 == 0)\n        val odd1 = lst1.filter(_ % 2 == 1)\n        val even2 = lst2.filter(_\
    \ % 2 == 0)\n        val odd2 = lst2.filter(_ % 2 == 1)\n        if (even1.length\
    \ + even2.length >= lst1.length) \"YES\"\n        else \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length == lst1.length) \"YES\"\n        else if (evens.length + odds.length\
    \ >= lst1.length) \"YES\"\n        else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5d3h7ukp.scala:24)\n\tat Problem.main(tmp5d3h7ukp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odd1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odd2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odd1.size == odd2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbk9vyy5p.scala:24)\n\tat Problem.main(tmpbk9vyy5p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ + lst2Even.size >= lst1.size) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds = lst1.filter(x\
    \ => x % 2 == 1)\n        val evens = lst2.filter(x => x % 2 == 0)\n        if\
    \ (odds.length <= evens.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1odd = lst1.filter(x\
    \ => x % 2 == 1)\n        val lst2even = lst2.filter(x => x % 2 == 0)\n      \
    \  if (lst1odd.length <= lst2even.length) \"YES\" else \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1_odd = lst1.filter(_\
    \ % 2 == 1)\n        val lst2_even = lst2.filter(_ % 2 == 0)\n        if (lst1_odd.size\
    \ <= lst2_even.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1_odd = lst1.filter(x\
    \ => x % 2 == 1)\n        val lst2_even = lst2.filter(x => x % 2 == 0)\n     \
    \   if (lst1_odd.length <= lst2_even.length) \"YES\" else \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        var odds = 0\n      \
    \  for (i <- lst1) if (i % 2 == 1) odds += 1\n        for (i <- lst2) if (i %\
    \ 2 == 1) odds -= 1\n        if (odds == 0) \"YES\" else \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo_cg34cj.scala:25)\n\tat Problem.main(tmpo_cg34cj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val even1 = lst1.filter(x\
    \ => x % 2 == 0)\n        val odd1 = lst1.filter(x => x % 2 == 1)\n        val\
    \ even2 = lst2.filter(x => x % 2 == 0)\n        val odd2 = lst2.filter(x => x\
    \ % 2 == 1)\n        if (even1.length + even2.length >= lst1.length) \"YES\" else\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        // Fill in the code here\n\
    \        \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzy2q2aze.scala:20)\n\tat Problem.main(tmpzy2q2aze.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(x\
    \ => x % 2 == 0)\n        val lst1Odd = lst1.filter(x => x % 2 == 1)\n       \
    \ val lst2Even = lst2.filter(x => x % 2 == 0)\n        val lst2Odd = lst2.filter(x\
    \ => x % 2 == 1)\n        if (lst1Even.length + lst2Even.length >= lst1.length)\
    \ \"YES\"\n        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val count1 = lst1.count(_\
    \ % 2 == 1)\n        val count2 = lst2.count(_ % 2 == 1)\n        if (count1 ==\
    \ count2) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2_hzjolg.scala:24)\n\tat Problem.main(tmp2_hzjolg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1_odd = lst1.filter(_\
    \ % 2 == 1)\n        val lst2_even = lst2.filter(_ % 2 == 0)\n        if (lst1_odd.size\
    \ <= lst2_even.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        // Fill in the code here\n\
    \        \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzy2q2aze.scala:20)\n\tat Problem.main(tmpzy2q2aze.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1odd = lst1.filter(x\
    \ => x % 2 == 1)\n        val lst2even = lst2.filter(x => x % 2 == 0)\n      \
    \  if (lst1odd.length <= lst2even.length) \"YES\" else \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ + lst2Even.size >= lst1.size) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb_4dbi0m.scala:22)\n\tat Problem.main(tmpb_4dbi0m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdbf2vvg9.scala:24)\n\tat Problem.main(tmpdbf2vvg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        var evens = 0\n     \
    \   for (i <- lst1) if (i % 2 == 0) evens += 1\n        var odds = 0\n       \
    \ for (i <- lst2) if (i % 2 == 1) odds += 1\n        if (evens == lst1.length\
    \ || odds == lst2.length) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwv4rtgf6.scala:23)\n\tat Problem.main(tmpwv4rtgf6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdbf2vvg9.scala:24)\n\tat Problem.main(tmpdbf2vvg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb_4dbi0m.scala:22)\n\tat Problem.main(tmpb_4dbi0m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1odd = lst1.filter(_\
    \ % 2 == 1)\n        val lst2even = lst2.filter(_ % 2 == 0)\n        if (lst1odd.size\
    \ <= lst2even.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6n1aag6h.scala:21)\n\tat Problem.main(tmp6n1aag6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb_4dbi0m.scala:22)\n\tat Problem.main(tmpb_4dbi0m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ + lst2Even.size >= lst1.size) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Odd = lst1.filter(_\
    \ % 2 == 1)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Odd.size\
    \ <= lst2Even.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(_\
    \ % 2 == 1)\n        val odds2 = lst2.filter(_ % 2 == 1)\n        if (odds1.size\
    \ == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdhw_ta1l.scala:24)\n\tat Problem.main(tmpdhw_ta1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odd1 = lst1.filter(_\
    \ % 2 == 1)\n        val odd2 = lst2.filter(_ % 2 == 1)\n        if (odd1.size\
    \ == odd2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprnyhgxxg.scala:24)\n\tat Problem.main(tmprnyhgxxg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ + lst2Even.size >= lst1.size) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ == lst1.size) \"YES\"\n        else if (lst2Even.size == lst2.size) \"YES\"\n\
    \        else if (lst1Even.size + lst2Even.size >= lst1.size) \"YES\"\n      \
    \  else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ == lst1.size) \"YES\"\n        else if (lst2Even.size == lst2.size) \"YES\"\n\
    \        else if (lst1Even.size + lst2Even.size >= lst1.size) \"YES\"\n      \
    \  else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1_odd = lst1.filter(_\
    \ % 2 == 1)\n        val lst2_even = lst2.filter(_ % 2 == 0)\n        if (lst1_odd.size\
    \ <= lst2_even.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdbf2vvg9.scala:24)\n\tat Problem.main(tmpdbf2vvg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds = lst1.filter(_\
    \ % 2 == 1)\n        val evens = lst2.filter(_ % 2 == 0)\n        if (odds.size\
    \ <= evens.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odd1 = lst1.filter(_\
    \ % 2 == 1)\n        val odd2 = lst2.filter(_ % 2 == 1)\n        if (odd1.size\
    \ == odd2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprnyhgxxg.scala:24)\n\tat Problem.main(tmprnyhgxxg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6n1aag6h.scala:21)\n\tat Problem.main(tmp6n1aag6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1_even = lst1.filter(_\
    \ % 2 == 0)\n        val lst1_odd = lst1.filter(_ % 2 == 1)\n        val lst2_even\
    \ = lst2.filter(_ % 2 == 0)\n        val lst2_odd = lst2.filter(_ % 2 == 1)\n\
    \        if (lst1_even.length + lst2_even.length >= lst1.length) \"YES\"\n   \
    \     else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1odd = lst1.filter(_\
    \ % 2 == 1)\n        val lst2even = lst2.filter(_ % 2 == 0)\n        if (lst1odd.size\
    \ <= lst2even.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6n1aag6h.scala:21)\n\tat Problem.main(tmp6n1aag6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ + lst2Even.size >= lst1.size) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val s1 = lst1.filter(_\
    \ % 2 == 1).size\n        val s2 = lst2.filter(_ % 2 == 1).size\n        if (s1\
    \ == s2) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmubp1fg4.scala:24)\n\tat Problem.main(tmpmubp1fg4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odd1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odd2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odd1.size == odd2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbk9vyy5p.scala:24)\n\tat Problem.main(tmpbk9vyy5p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odd1 = lst1.filter(_\
    \ % 2 == 1)\n        val odd2 = lst2.filter(_ % 2 == 1)\n        if (odd1.size\
    \ == odd2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprnyhgxxg.scala:24)\n\tat Problem.main(tmprnyhgxxg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        if (lst1.forall(_ % 2\
    \ == 0)) \"YES\"\n        else if (lst2.forall(_ % 2 == 0)) \"YES\"\n        else\
    \ if (lst1.exists(_ % 2 == 0) && lst2.exists(_ % 2 == 0)) \"YES\"\n        else\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuoaif6hm.scala:23)\n\tat Problem.main(tmpuoaif6hm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6n1aag6h.scala:21)\n\tat Problem.main(tmp6n1aag6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdbf2vvg9.scala:24)\n\tat Problem.main(tmpdbf2vvg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(x\
    \ => x % 2 == 0)\n        val lst1Odd = lst1.filter(x => x % 2 == 1)\n       \
    \ val lst2Even = lst2.filter(x => x % 2 == 0)\n        val lst2Odd = lst2.filter(x\
    \ => x % 2 == 1)\n        if (lst1Even.length + lst2Even.length >= lst1.length)\
    \ \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ + lst2Even.size >= lst1.size) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6n1aag6h.scala:21)\n\tat Problem.main(tmp6n1aag6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        // Write your code here\n\
    \        \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeuetjcv5.scala:20)\n\tat Problem.main(tmpeuetjcv5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdbf2vvg9.scala:24)\n\tat Problem.main(tmpdbf2vvg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ == lst1.size) \"YES\"\n        else if (lst2Even.size == lst2.size) \"YES\"\n\
    \        else if (lst1Even.size + lst2Even.size >= lst1.size) \"YES\"\n      \
    \  else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        // Fill in the code here\n\
    \        \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphvxu8ooi.scala:21)\n\tat Problem.main(tmphvxu8ooi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        if (lst1.forall(x =>\
    \ x % 2 == 0)) \"YES\"\n        else if (lst2.forall(x => x % 2 == 0)) \"YES\"\
    \n        else {\n            val lst1odd = lst1.filter(x => x % 2 == 1)\n   \
    \         val lst2odd = lst2.filter(x => x % 2 == 1)\n            if (lst1odd.size\
    \ % 2 == 0 && lst2odd.size % 2 == 0) \"YES\"\n            else \"NO\"\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        // Fill in the code here\n\
    \        \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzy2q2aze.scala:20)\n\tat Problem.main(tmpzy2q2aze.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vec88sn.scala:21)\n\tat Problem.main(tmp1vec88sn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ + lst2Even.size >= lst1.size) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ == lst1.size) \"YES\"\n        else if (lst2Even.size == lst2.size) \"YES\"\n\
    \        else if (lst1Even.size + lst2Even.size >= lst1.size) \"YES\"\n      \
    \  else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(x\
    \ => x % 2 == 0)\n        val lst2Odd = lst2.filter(x => x % 2 == 1)\n       \
    \ if (lst1Even.length + lst2Odd.length >= lst1.length) \"YES\" else \"NO\"\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnhbqlfgd.scala:22)\n\tat Problem.main(tmpnhbqlfgd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1odd = lst1.filter(_\
    \ % 2 == 1)\n        val lst2even = lst2.filter(_ % 2 == 0)\n        if (lst1odd.size\
    \ <= lst2even.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        // Write your code here\n\
    \        \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzz16fwaq.scala:21)\n\tat Problem.main(tmpzz16fwaq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794396
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdbf2vvg9.scala:24)\n\tat Problem.main(tmpdbf2vvg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(_\
    \ % 2 == 1)\n        val odds2 = lst2.filter(_ % 2 == 1)\n        if (odds1.size\
    \ == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdhw_ta1l.scala:24)\n\tat Problem.main(tmpdhw_ta1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdbf2vvg9.scala:24)\n\tat Problem.main(tmpdbf2vvg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw6fu91k.scala:22)\n\tat Problem.main(tmpmw6fu91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val lst1Even = lst1.filter(x\
    \ => x % 2 == 0)\n        val lst1Odd = lst1.filter(x => x % 2 == 1)\n       \
    \ val lst2Even = lst2.filter(x => x % 2 == 0)\n        val lst2Odd = lst2.filter(x\
    \ => x % 2 == 1)\n        if (lst1Even.length + lst2Even.length >= lst1.length)\
    \ \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4]) => \"YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"\
    NO\"\n    // It is assumed that the input lists will be non-empty.\n    def exchange(lst1\
    \ : List[Long], lst2 : List[Long]) : String = {\n        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdbf2vvg9.scala:24)\n\tat Problem.main(tmpdbf2vvg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794373
