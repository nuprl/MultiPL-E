name: HumanEval_119_match_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of two strings, both strings consist of open\n    //\
  \ parentheses '(' or close parentheses ')' only.\n    // Your job is to check if\
  \ it is possible to concatenate the two strings in\n    // some order, that the\
  \ resulting string will be good.\n    // A string S is considered to be good if\
  \ and only if all parentheses in S\n    // are balanced. For example: the string\
  \ '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes'\
  \ if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n\
  \    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')', ')']) ==\
  \ 'No'\n    def matchParens(lst : List[String]) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
  ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
  , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
  , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
  , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
  , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\"\
  , \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\",\
  \ \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
  , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
  , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \"\
  )(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"\
  Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\"\
  )));\n    }\n\n}\n"
completions: ["        val s1 = lst(0)\n        val s2 = lst(1)\n        val s1c =\
    \ s1.count(_ == '(')\n        val s2c = s2.count(_ == '(')\n        val s1o =\
    \ s1.count(_ == ')')\n        val s2o = s2.count(_ == ')')\n        if (s1c ==\
    \ s1o && s2c == s2o) \"Yes\"\n        else if (s1c == s1o && s2c > s2o) \"Yes\"\
    \n        else if (s1c > s1o && s2c == s2o) \"Yes\"\n        else if (s1c > s1o\
    \ && s2c > s2o) \"Yes\"\n        else \"No\"", "        val s1 = lst(0)\n    \
    \    val s2 = lst(1)\n        var count = 0\n        for (i <- 0 until s1.length)\
    \ {\n            if (s1(i) == '(') count += 1\n            else count -= 1\n \
    \       }\n        for (i <- 0 until s2.length) {\n            if (s2(i) == '(')\
    \ count += 1\n            else count -= 1\n        }\n        if (count == 0)\
    \ \"Yes\" else \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n  \
    \      val s = s1 + s2\n        var stack = new Stack[Char]\n        for (c <-\
    \ s) {\n            if (c == '(') stack.push(c)\n            else if (c == ')')\
    \ {\n                if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"", " \
    \       val s1 = lst(0)\n        val s2 = lst(1)\n        val s1_count = s1.count(_\
    \ == '(')\n        val s2_count = s2.count(_ == '(')\n        if (s1_count ==\
    \ s2_count) {\n            if (s1.count(_ == ')') == s2.count(_ == ')')) {\n \
    \               \"Yes\"\n            } else {\n                \"No\"\n      \
    \      }\n        } else {\n            if (s1_count > s2_count) {\n         \
    \       if (s1.count(_ == ')') >= s2.count(_ == ')')) {\n                    \"\
    Yes\"\n                } else {\n                    \"No\"\n                }\n\
    \            } else {\n                if (s2.count(_ == ')') >= s1.count(_ ==\
    \ ')')) {\n                    \"Yes\"\n                } else {\n           \
    \         \"No\"\n                }\n            }\n        }", "        val s1\
    \ = lst(0)\n        val s2 = lst(1)\n        val s1_open = s1.count(_ == '(')\n\
    \        val s1_close = s1.count(_ == ')')\n        val s2_open = s2.count(_ ==\
    \ '(')\n        val s2_close = s2.count(_ == ')')\n        if (s1_open == s1_close\
    \ && s2_open == s2_close) return \"Yes\"\n        if (s1_open == s1_close) {\n\
    \            if (s2_open > s2_close) {\n                if (s2_open - s2_close\
    \ == 1) return \"Yes\"\n                else return \"No\"\n            }\n  \
    \          else {\n                if (s2_close - s2_open == 1) return \"Yes\"\
    \n                else return \"No\"\n            }\n        }\n        else if\
    \ (s2_open == s2_close) {\n            if (s1_open > s1_close) {\n           \
    \     if (s1_open - s1_close == 1) return \"Yes\"\n                else return\
    \ \"No\"\n            }\n            else {\n                if (s1_close - s1_open\
    \ == 1) return \"Yes\"\n                else return \"No\"\n            }\n  \
    \      }\n        else return \"No\"", "        val s1 = lst(0)\n        val s2\
    \ = lst(1)\n        val s1c = s1.count(_ == '(')\n        val s2c = s2.count(_\
    \ == '(')\n        val s1o = s1.count(_ == ')')\n        val s2o = s2.count(_\
    \ == ')')\n        if (s1c == s1o && s2c == s2o) \"Yes\"\n        else if (s1c\
    \ == s1o && s2c > s2o) \"Yes\"\n        else if (s1c > s1o && s2c == s2o) \"Yes\"\
    \n        else if (s1c > s1o && s2c > s2o) \"Yes\"\n        else \"No\"", "  \
    \      val s1 = lst(0)\n        val s2 = lst(1)\n        val s1_open = s1.count(_\
    \ == '(')\n        val s1_close = s1.count(_ == ')')\n        val s2_open = s2.count(_\
    \ == '(')\n        val s2_close = s2.count(_ == ')')\n        if (s1_open == s1_close\
    \ && s2_open == s2_close) return \"Yes\"\n        if (s1_open == s1_close) {\n\
    \            if (s2_open > s2_close) {\n                val diff = s2_open - s2_close\n\
    \                if (diff % 2 == 0) return \"Yes\"\n            }\n        }\n\
    \        if (s2_open == s2_close) {\n            if (s1_open > s1_close) {\n \
    \               val diff = s1_open - s1_close\n                if (diff % 2 ==\
    \ 0) return \"Yes\"\n            }\n        }\n        return \"No\"", "     \
    \   val s1 = lst(0)\n        val s2 = lst(1)\n        val n1 = s1.length\n   \
    \     val n2 = s2.length\n        val dp = Array.ofDim[Boolean](n1 + 1, n2 + 1)\n\
    \        dp(0)(0) = true\n        for (i <- 1 to n1) {\n            dp(i)(0) =\
    \ dp(i - 1)(0) && s1(i - 1) == '('\n        }\n        for (j <- 1 to n2) {\n\
    \            dp(0)(j) = dp(0)(j - 1) && s2(j - 1) == '('\n        }\n        for\
    \ (i <- 1 to n1; j <- 1 to n2) {\n            dp(i)(j) = (dp(i - 1)(j) && s1(i\
    \ - 1) == '(') || (dp(i)(j - 1) && s2(j - 1) == '(') || (dp(i - 1)(j - 1) && (s1(i\
    \ - 1) == ')' || s2(j - 1) == ')'))\n        }\n        if (dp(n1)(n2)) \"Yes\"\
    \ else \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n        var\
    \ cnt = 0\n        for (i <- 0 until s1.length) {\n            if (s1(i) == '(')\
    \ cnt += 1\n            else cnt -= 1\n        }\n        for (i <- 0 until s2.length)\
    \ {\n            if (s2(i) == '(') cnt += 1\n            else cnt -= 1\n     \
    \   }\n        if (cnt == 0) \"Yes\" else \"No\"", "        val s1 = lst(0)\n\
    \        val s2 = lst(1)\n        val s1_open = s1.count(_ == '(')\n        val\
    \ s1_close = s1.count(_ == ')')\n        val s2_open = s2.count(_ == '(')\n  \
    \      val s2_close = s2.count(_ == ')')\n        if (s1_open == s1_close && s2_open\
    \ == s2_close) return \"Yes\"\n        if (s1_open == s1_close) {\n          \
    \  if (s2_open > s2_close) return \"Yes\"\n            else return \"No\"\n  \
    \      }\n        if (s2_open == s2_close) {\n            if (s1_open > s1_close)\
    \ return \"Yes\"\n            else return \"No\"\n        }\n        if (s1_open\
    \ > s1_close) {\n            if (s2_open > s2_close) return \"Yes\"\n        \
    \    else return \"No\"\n        }\n        if (s2_open > s2_close) {\n      \
    \      if (s1_open > s1_close) return \"Yes\"\n            else return \"No\"\n\
    \        }\n        if (s1_open < s1_close) {\n            if (s2_open < s2_close)\
    \ return \"Yes\"\n            else return \"No\"\n        }\n        if (s2_open\
    \ < s2_close) {\n            if (s1_open < s1_close) return \"Yes\"\n        \
    \    else return \"No\"\n        }\n        \"No\"", "        val s1 = lst(0)\n\
    \        val s2 = lst(1)\n        val s1_count = s1.count(_ == '(')\n        val\
    \ s2_count = s2.count(_ == '(')\n        if (s1_count == s2_count) {\n       \
    \     val s = s1 + s2\n            if (s.count(_ == '(') == s.count(_ == ')'))\
    \ \"Yes\" else \"No\"\n        } else if (s1_count > s2_count) {\n           \
    \ val s = s1 + s2\n            if (s.count(_ == '(') == s.count(_ == ')')) \"\
    Yes\" else \"No\"\n        } else {\n            val s = s2 + s1\n           \
    \ if (s.count(_ == '(') == s.count(_ == ')')) \"Yes\" else \"No\"\n        }",
  "        val s1 = lst(0)\n        val s2 = lst(1)\n        val s1_open = s1.count(_\
    \ == '(')\n        val s1_close = s1.count(_ == ')')\n        val s2_open = s2.count(_\
    \ == '(')\n        val s2_close = s2.count(_ == ')')\n        if (s1_open == s1_close\
    \ && s2_open == s2_close) {\n            \"Yes\"\n        } else if (s1_open ==\
    \ s1_close && s2_open > s2_close) {\n            \"Yes\"\n        } else if (s1_open\
    \ > s1_close && s2_open == s2_close) {\n            \"Yes\"\n        } else {\n\
    \            \"No\"\n        }", "        val s = lst.mkString\n        val c\
    \ = s.count(_ == '(') - s.count(_ == ')')\n        if (c == 0) \"Yes\" else if\
    \ (c < 0) \"No\" else {\n            val l = s.splitAt(s.indexOf(')') + 1)\n \
    \           if (l._1.count(_ == '(') == l._1.count(_ == ')')) \"Yes\" else \"\
    No\"\n        }", "        val s1 = lst(0)\n        val s2 = lst(1)\n        val\
    \ s1_open = s1.count(_ == '(')\n        val s1_close = s1.count(_ == ')')\n  \
    \      val s2_open = s2.count(_ == '(')\n        val s2_close = s2.count(_ ==\
    \ ')')\n        if (s1_open == s1_close && s2_open == s2_close) return \"Yes\"\
    \n        if (s1_open == s1_close) {\n            if (s2_open > s2_close) return\
    \ \"Yes\"\n            else return \"No\"\n        }\n        if (s2_open == s2_close)\
    \ {\n            if (s1_open > s1_close) return \"Yes\"\n            else return\
    \ \"No\"\n        }\n        if (s1_open > s1_close) {\n            if (s2_open\
    \ > s2_close) return \"Yes\"\n            else return \"No\"\n        }\n    \
    \    if (s2_open > s2_close) {\n            if (s1_open > s1_close) return \"\
    Yes\"\n            else return \"No\"\n        }\n        return \"No\"", "  \
    \      val s = lst.foldLeft(\"\")(_ + _)\n        if (s.count(_ == '(') == s.count(_\
    \ == ')')) \"Yes\" else \"No\"", "        val left = lst(0).count(_ == '(')\n\
    \        val right = lst(1).count(_ == ')')\n        if (left == right) \"Yes\"\
    \ else \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n        val\
    \ s1c = s1.count(_ == '(')\n        val s2c = s2.count(_ == '(')\n        val\
    \ s1o = s1.count(_ == ')')\n        val s2o = s2.count(_ == ')')\n        if (s1c\
    \ == s1o && s2c == s2o) return \"Yes\"\n        if (s1c == s1o && s2c > s2o) return\
    \ \"Yes\"\n        if (s1c > s1o && s2c == s2o) return \"Yes\"\n        if (s1c\
    \ > s1o && s2c > s2o) return \"Yes\"\n        \"No\"", "        val (a, b) = (lst(0),\
    \ lst(1))\n        val (c, d) = (a.count(_ == '('), a.count(_ == ')'))\n     \
    \   val (e, f) = (b.count(_ == '('), b.count(_ == ')'))\n        if (c == d &&\
    \ e == f) \"Yes\"\n        else if (c == d && e > f) \"Yes\"\n        else if\
    \ (c > d && e == f) \"Yes\"\n        else \"No\"", "        val lst1 = lst(0).toList\n\
    \        val lst2 = lst(1).toList\n        val lst1_open = lst1.filter(x => x\
    \ == '(').length\n        val lst1_close = lst1.filter(x => x == ')').length\n\
    \        val lst2_open = lst2.filter(x => x == '(').length\n        val lst2_close\
    \ = lst2.filter(x => x == ')').length\n        if (lst1_open == lst1_close &&\
    \ lst2_open == lst2_close) {\n            if (lst1_open == lst2_close && lst1_close\
    \ == lst2_open) \"Yes\"\n            else \"No\"\n        }\n        else \"No\"",
  "        val s1 = lst(0)\n        val s2 = lst(1)\n        val n1 = s1.length\n\
    \        val n2 = s2.length\n        val dp = Array.ofDim[Int](n1 + 1, n2 + 1)\n\
    \        for (i <- 0 to n1) dp(i)(0) = 0\n        for (j <- 0 to n2) dp(0)(j)\
    \ = 0\n        for (i <- 1 to n1; j <- 1 to n2) {\n            dp(i)(j) = max(dp(i\
    \ - 1)(j), dp(i)(j - 1))\n            if (s1(i - 1) == '(' && s2(j - 1) == ')')\
    \ dp(i)(j) = max(dp(i)(j), dp(i - 1)(j - 1) + 1)\n        }\n        if (dp(n1)(n2)\
    \ == 0) \"No\" else \"Yes\""]
stop_tokens:
- "\n    }\n"
