name: HumanEval_107_even_odd_palindrome
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return a tuple that has the number of even and\
  \ odd\n    // integer palindromes that fall within the range(1, n), inclusive.\n\
  \    // Example 1:\n    // Input: 3\n    // Output: (1, 2)\n    // Explanation:\n\
  \    // Integer palindrome are 1, 2, 3. one of them is even, and two of them are\
  \ odd.\n    // Example 2:\n    // Input: 12\n    // Output: (4, 6)\n    // Explanation:\n\
  \    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even,\
  \ and 6 of them are odd.\n    // Note:\n    // 1. 1 <= n <= 10^3\n    // 2. returned\
  \ tuple has the number of even and odd integer palindromes respectively.\n    def\
  \ evenOddPalindrome(n : Long) : Tuple2[Long, Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(evenOddPalindrome((123l)).equals(((8l,\
  \ 13l))));\n    assert(evenOddPalindrome((12l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((3l)).equals(((1l,\
  \ 2l))));\n    assert(evenOddPalindrome((63l)).equals(((6l, 8l))));\n    assert(evenOddPalindrome((25l)).equals(((5l,\
  \ 6l))));\n    assert(evenOddPalindrome((19l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((9l)).equals(((4l,\
  \ 5l))));\n    assert(evenOddPalindrome((1l)).equals(((0l, 1l))));\n    }\n\n}\n"
completions: ["        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x\
    \ % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "        var\
    \ even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n            if\
    \ (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n           \
    \     else odd += 1\n            }\n        }\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n        \
    \    if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n     \
    \           else odd += 1\n            }\n        }\n        (even, odd)", " \
    \       var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n  \
    \          if (i.toString == i.toString.reverse) {\n                if (i % 2\
    \ == 0) even += 1\n                else odd += 1\n            }\n        }\n \
    \       (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n       \
    \ for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes += i\n\
    \        }\n        val even = palindromes.filter(_ % 2 == 0).length\n       \
    \ val odd = palindromes.filter(_ % 2 == 1).length\n        (even, odd)", "   \
    \     val palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) palindromes += i\n        }\n        val even\
    \ = palindromes.filter(x => x % 2 == 0).length\n        val odd = palindromes.filter(x\
    \ => x % 2 == 1).length\n        (even, odd)", "        def isPalindrome(num :\
    \ Long) : Boolean = {\n            val str = num.toString\n            str ==\
    \ str.reverse\n        }\n        var even = 0L\n        var odd = 0L\n      \
    \  for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x => isPalindrome(x)\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => isPalindrome(x)\
    \ && x % 2 == 1).length\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        return (even, odd)", "        val evens = (n / 2) + 1\n        val odds\
    \ = n - evens\n        (evens, odds)", "        var even = 0L\n        var odd\
    \ = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n   \
    \             if (i % 2 == 0) even += 1\n                else odd += 1\n     \
    \       }\n        }\n        (even, odd)", "        var even = 0L\n        var\
    \ odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n\
    \                if (i % 2 == 0) even += 1\n                else odd += 1\n  \
    \          }\n        }\n        (even, odd)", "        def isPalindrome(x : Long)\
    \ : Boolean = {\n            val s = x.toString\n            s == s.reverse\n\
    \        }\n        def isEven(x : Long) : Boolean = x % 2 == 0\n        def isOdd(x\
    \ : Long) : Boolean = !isEven(x)\n        val even = (1L to n).filter(x => isEven(x)\
    \ && isPalindrome(x)).length\n        val odd = (1L to n).filter(x => isOdd(x)\
    \ && isPalindrome(x)).length\n        (even, odd)", "        var even = 0L\n \
    \       var odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        var even = 0L\n    \
    \    var odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes\
    \ += i\n        }\n        val even = palindromes.filter(x => x % 2 == 0).length\n\
    \        val odd = palindromes.filter(x => x % 2 == 1).length\n        (even,\
    \ odd)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to\
    \ n) {\n            if (i.toString == i.toString.reverse) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        return (even, odd)", "        var even = 0L\n        var odd =\
    \ 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n     \
    \           if (i % 2 == 0) even += 1\n                else odd += 1\n       \
    \     }\n        }\n        (even, odd)", "        val even = (1 to 9).map(x =>\
    \ x.toLong).toList.filter(x => x % 2 == 0).map(x => x.toString).map(x => x + x.reverse).map(x\
    \ => x.toLong).filter(x => x <= n).length\n        val odd = (1 to 9).map(x =>\
    \ x.toLong).toList.filter(x => x % 2 == 1).map(x => x.toString).map(x => x + x.reverse).map(x\
    \ => x.toLong).filter(x => x <= n).length\n        (even, odd)"]
stop_tokens:
- "\n    }\n"
