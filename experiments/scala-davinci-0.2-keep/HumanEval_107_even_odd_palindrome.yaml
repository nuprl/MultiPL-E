name: HumanEval_107_even_odd_palindrome
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return a tuple that has the number of even and\
  \ odd\n    // integer palindromes that fall within the range(1, n), inclusive.\n\
  \    // Example 1:\n    // Input: 3\n    // Output: (1, 2)\n    // Explanation:\n\
  \    // Integer palindrome are 1, 2, 3. one of them is even, and two of them are\
  \ odd.\n    // Example 2:\n    // Input: 12\n    // Output: (4, 6)\n    // Explanation:\n\
  \    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even,\
  \ and 6 of them are odd.\n    // Note:\n    // 1. 1 <= n <= 10^3\n    // 2. returned\
  \ tuple has the number of even and odd integer palindromes respectively.\n    def\
  \ evenOddPalindrome(n : Long) : Tuple2[Long, Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(evenOddPalindrome((123l)).equals(((8l,\
  \ 13l))));\n    assert(evenOddPalindrome((12l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((3l)).equals(((1l,\
  \ 2l))));\n    assert(evenOddPalindrome((63l)).equals(((6l, 8l))));\n    assert(evenOddPalindrome((25l)).equals(((5l,\
  \ 6l))));\n    assert(evenOddPalindrome((19l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((9l)).equals(((4l,\
  \ 5l))));\n    assert(evenOddPalindrome((1l)).equals(((0l, 1l))));\n    }\n\n}\n"
completions: ["        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x\
    \ % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "        var\
    \ even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n            if\
    \ (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n           \
    \     else odd += 1\n            }\n        }\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n        \
    \    if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n     \
    \           else odd += 1\n            }\n        }\n        (even, odd)", " \
    \       var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n  \
    \          if (i.toString == i.toString.reverse) {\n                if (i % 2\
    \ == 0) even += 1\n                else odd += 1\n            }\n        }\n \
    \       (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n       \
    \ for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes += i\n\
    \        }\n        val even = palindromes.filter(_ % 2 == 0).length\n       \
    \ val odd = palindromes.filter(_ % 2 == 1).length\n        (even, odd)", "   \
    \     val palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) palindromes += i\n        }\n        val even\
    \ = palindromes.filter(x => x % 2 == 0).length\n        val odd = palindromes.filter(x\
    \ => x % 2 == 1).length\n        (even, odd)", "        def isPalindrome(num :\
    \ Long) : Boolean = {\n            val str = num.toString\n            str ==\
    \ str.reverse\n        }\n        var even = 0L\n        var odd = 0L\n      \
    \  for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x => isPalindrome(x)\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => isPalindrome(x)\
    \ && x % 2 == 1).length\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        return (even, odd)", "        val evens = (n / 2) + 1\n        val odds\
    \ = n - evens\n        (evens, odds)", "        var even = 0L\n        var odd\
    \ = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n   \
    \             if (i % 2 == 0) even += 1\n                else odd += 1\n     \
    \       }\n        }\n        (even, odd)", "        var even = 0L\n        var\
    \ odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n\
    \                if (i % 2 == 0) even += 1\n                else odd += 1\n  \
    \          }\n        }\n        (even, odd)", "        def isPalindrome(x : Long)\
    \ : Boolean = {\n            val s = x.toString\n            s == s.reverse\n\
    \        }\n        def isEven(x : Long) : Boolean = x % 2 == 0\n        def isOdd(x\
    \ : Long) : Boolean = !isEven(x)\n        val even = (1L to n).filter(x => isEven(x)\
    \ && isPalindrome(x)).length\n        val odd = (1L to n).filter(x => isOdd(x)\
    \ && isPalindrome(x)).length\n        (even, odd)", "        var even = 0L\n \
    \       var odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        var even = 0L\n    \
    \    var odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes\
    \ += i\n        }\n        val even = palindromes.filter(x => x % 2 == 0).length\n\
    \        val odd = palindromes.filter(x => x % 2 == 1).length\n        (even,\
    \ odd)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to\
    \ n) {\n            if (i.toString == i.toString.reverse) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        return (even, odd)", "        var even = 0L\n        var odd =\
    \ 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n     \
    \           if (i % 2 == 0) even += 1\n                else odd += 1\n       \
    \     }\n        }\n        (even, odd)", "        val even = (1 to 9).map(x =>\
    \ x.toLong).toList.filter(x => x % 2 == 0).map(x => x.toString).map(x => x + x.reverse).map(x\
    \ => x.toLong).filter(x => x <= n).length\n        val odd = (1 to 9).map(x =>\
    \ x.toLong).toList.filter(x => x % 2 == 1).map(x => x.toString).map(x => x + x.reverse).map(x\
    \ => x.toLong).filter(x => x <= n).length\n        (even, odd)", "        var\
    \ even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n            if\
    \ (i.toString.reverse == i.toString) {\n                if (i % 2 == 0) even +=\
    \ 1\n                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n   \
    \         if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n   \
    \         if (i.toString == i.toString.reverse) {\n                if (i % 2 ==\
    \ 0) even += 1\n                else odd += 1\n            }\n        }\n    \
    \    (even, odd)", "        var even = 0L\n        var odd = 0L\n        for (i\
    \ <- 1L to n) {\n            if (isPalindrome(i)) {\n                if (i % 2\
    \ == 0) even += 1\n                else odd += 1\n            }\n        }\n \
    \       (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n       \
    \ for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes += i\n\
    \        }\n        val even = palindromes.filter(x => x % 2 == 0).length\n  \
    \      val odd = palindromes.filter(x => x % 2 == 1).length\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n   \
    \         if (i.toString.reverse == i.toString) {\n                if (i % 2 ==\
    \ 0) even += 1\n                else odd += 1\n            }\n        }\n    \
    \    (even, odd)", "        val palindromes = new ArrayBuffer[Long]\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes += i\n \
    \       }\n        val even = palindromes.filter(x => x % 2 == 0).length\n   \
    \     val odd = palindromes.filter(x => x % 2 == 1).length\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n   \
    \         if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1 else\
    \ odd += 1\n            }\n        }\n        (even, odd)", "        val palindromes\
    \ = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ palindromes += i\n        }\n        val evens = palindromes.filter(x => x %\
    \ 2 == 0).length\n        val odds = palindromes.filter(x => x % 2 == 1).length\n\
    \        (evens, odds)", "        val palindromes = ArrayBuffer[Long]()\n    \
    \    for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes +=\
    \ i\n        }\n        val even = palindromes.filter(x => x % 2 == 0).length\n\
    \        val odd = palindromes.filter(x => x % 2 == 1).length\n        (even,\
    \ odd)", "        val (even, odd) = (0L, 0L)\n        if (n < 1) return (even,\
    \ odd)\n        val digits = n.toString.length\n        val halfDigits = digits\
    \ / 2\n        val halfDigitsEven = digits % 2 == 0\n        val halfDigitsOdd\
    \ = digits % 2 == 1\n        val halfDigitsOddMax = pow(10, halfDigits).toLong\
    \ - 1\n        val halfDigitsEvenMax = pow(10, halfDigits - 1).toLong - 1\n  \
    \      val halfDigitsOddMin = pow(10, halfDigits - 1).toLong\n        val halfDigitsEvenMin\
    \ = pow(10, halfDigits - 1).toLong\n        if (halfDigitsEven) {\n          \
    \  val halfDigitsEvenCount = halfDigitsEvenMax - halfDigitsEvenMin + 1\n     \
    \       val halfDigitsOddCount = halfDigitsOddMax - halfDigitsOddMin + 1\n   \
    \         val evenCount = halfDigitsEvenCount * halfDigitsOddCount\n         \
    \   val oddCount = halfDigitsEvenCount * halfDigitsOddCount + halfDigitsEvenCount\n\
    \            return (evenCount, oddCount)\n        }\n        if (halfDigitsOdd)\
    \ {\n            val halfDigitsEvenCount = halfDigitsEvenMax - halfDigitsEvenMin\
    \ + 1\n            val halfDigitsOddCount = halfDigitsOddMax - halfDigitsOddMin\
    \ + 1\n            val evenCount = halfDigitsEvenCount * halfDigitsOddCount\n\
    \            val oddCount = halfDigitsEvenCount * halfDigitsOddCount + halfDigitsOddCount\n\
    \            return (evenCount, oddCount)\n        }\n        return (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n   \
    \         if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val evens = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odds = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (evens, odds)", "     \
    \   val palindromes = new ArrayBuffer[Long]\n        val evenPalindromes = new\
    \ ArrayBuffer[Long]\n        val oddPalindromes = new ArrayBuffer[Long]\n    \
    \    for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n         \
    \       palindromes += i\n                if (i % 2 == 0) evenPalindromes += i\n\
    \                else oddPalindromes += i\n            }\n        }\n        (evenPalindromes.length,\
    \ oddPalindromes.length)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).length\n        (even, odd)",
  "        def isPalindrome(n : Long) : Boolean = {\n            val s = n.toString\n\
    \            s == s.reverse\n        }\n        val even = (1 to n.toInt).filter(x\
    \ => isPalindrome(x) && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => isPalindrome(x) && x % 2 == 1).length\n        (even, odd)", "        var\
    \ even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n            if\
    \ (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n           \
    \     else odd += 1\n            }\n        }\n        (even, odd)", "       \
    \ val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x\
    \ % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "        var\
    \ even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n            if\
    \ (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n           \
    \     else odd += 1\n            }\n        }\n        (even, odd)", "       \
    \ def isPalindrome(x : Long) : Boolean = {\n            val s = x.toString\n \
    \           s == s.reverse\n        }\n        val even = (1 to n.toInt).filter(x\
    \ => isPalindrome(x) && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => isPalindrome(x) && x % 2 == 1).length\n        (even, odd)", "        val\
    \ s = n.toString\n        val l = s.length\n        val m = pow(10, l - 1).toLong\n\
    \        val d = s.head.toString.toLong\n        val e = s.last.toString.toLong\n\
    \        val f = if (l % 2 == 0) m else m / 10\n        val g = if (l % 2 == 0)\
    \ m else m * 10\n        val h = if (l % 2 == 0) m else m * 10 - 1\n        val\
    \ i = if (l % 2 == 0) m else m * 10 + 1\n        val j = if (l % 2 == 0) m else\
    \ m * 10 + 9\n        val k = if (l % 2 == 0) m else m * 10 + 10\n        val\
    \ a = if (d == 0) 0 else if (d == 1) 1 else if (d == 9) 1 else 2\n        val\
    \ b = if (e == 0) 0 else if (e == 1) 1 else if (e == 9) 1 else 2\n        val\
    \ c = if (l % 2 == 0) 0 else 1\n        val p = if (n < m) 0 else if (n < g) 1\
    \ else if (n < i) 2 else if (n < k) 3 else 4\n        val q = if (n < m) 0 else\
    \ if (n < h) 1 else if (n < j) 2 else if (n < k) 3 else 4\n        val r = if\
    \ (n < m) 0 else if (n < f) 1 else if (n < g) 2 else if (n < h) 3 else if (n <\
    \ i) 4 else if (n < j) 5 else if (n < k) 6 else 7\n        val t = if (n < m)\
    \ 0 else if (n < f) 1 else if (n < g) 2 else if (n < h) 3 else if (n < i) 4 else\
    \ if (n < j) 5 else if (n < k) 6 else 7\n        val u = if (n < m) 0 else if\
    \ (n < f) 1 else if (n < g) 2 else if (n < h) 3 else if (n < i) 4 else if (n <\
    \ j) 5 else if (n < k) 6", "        var even = 0L\n        var odd = 0L\n    \
    \    for (i <- 1L to n) {\n            if (i.toString == i.toString.reverse) {\n\
    \                if (i % 2 == 0) even += 1 else odd += 1\n            }\n    \
    \    }\n        (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            if (i.toString == i.toString.reverse)\
    \ palindromes += i\n        }\n        var even = 0\n        var odd = 0\n   \
    \     for (p <- palindromes) {\n            if (p % 2 == 0) even += 1\n      \
    \      else odd += 1\n        }\n        (even, odd)", "        var even = 0L\n\
    \        var odd = 0L\n        for (i <- 1L to n) {\n            if (i.toString\
    \ == i.toString.reverse) {\n                if (i % 2 == 0) even += 1\n      \
    \          else odd += 1\n            }\n        }\n        (even, odd)", "  \
    \      val palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) palindromes += i\n        }\n        val\
    \ even = palindromes.filter(x => x % 2 == 0).length\n        val odd = palindromes.filter(x\
    \ => x % 2 == 1).length\n        (even, odd)", "        var even = 0L\n      \
    \  var odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1 else odd += 1\n            }\n\
    \        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).size\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).size\n        return (even,\
    \ odd)", "        def isPalindrome(x : Long) : Boolean = {\n            val s\
    \ = x.toString\n            s == s.reverse\n        }\n        def isEven(x :\
    \ Long) : Boolean = x % 2 == 0\n        val palindromes = (1 to n.toInt).filter(isPalindrome)\n\
    \        val evens = palindromes.filter(isEven)\n        val odds = palindromes.filter(!isEven(_))\n\
    \        (evens.length, odds.length)", "        var even = 0L\n        var odd\
    \ = 0L\n        for (i <- 1L to n) {\n            if (i.toString == i.toString.reverse)\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val even = (1 to 9).map(x\
    \ => (1 to n.toString.length).map(y => pow(10, y - 1).toLong).sum).sum\n     \
    \   val odd = (1 to 9).map(x => (1 to n.toString.length - 1).map(y => pow(10,\
    \ y - 1).toLong).sum).sum\n        (even, odd)", "        val even = (1 to 9).map(x\
    \ => x * pow(10, x - 1).toLong).sum\n        val odd = (1 to 9).map(x => x * pow(10,\
    \ x).toLong).sum\n        val even2 = (1 to 9).map(x => x * pow(10, x - 1).toLong).sum\n\
    \        val odd2 = (1 to 9).map(x => x * pow(10, x).toLong).sum\n        val\
    \ even3 = (1 to 9).map(x => x * pow(10, x - 1).toLong).sum\n        val odd3 =\
    \ (1 to 9).map(x => x * pow(10, x).toLong).sum\n        val even4 = (1 to 9).map(x\
    \ => x * pow(10, x - 1).toLong).sum\n        val odd4 = (1 to 9).map(x => x *\
    \ pow(10, x).toLong).sum\n        val even5 = (1 to 9).map(x => x * pow(10, x\
    \ - 1).toLong).sum\n        val odd5 = (1 to 9).map(x => x * pow(10, x).toLong).sum\n\
    \        val even6 = (1 to 9).map(x => x * pow(10, x - 1).toLong).sum\n      \
    \  val odd6 = (1 to 9).map(x => x * pow(10, x).toLong).sum\n        val even7\
    \ = (1 to 9).map(x => x * pow(10, x - 1).toLong).sum\n        val odd7 = (1 to\
    \ 9).map(x => x * pow(10, x).toLong).sum\n        val even8 = (1 to 9).map(x =>\
    \ x * pow(10, x - 1).toLong).sum\n        val odd8 = (1 to 9).map(x => x * pow(10,\
    \ x).toLong).sum\n        val even9 = (1 to 9).map(x => x * pow(10, x - 1).toLong).sum\n\
    \        val odd9 = (1 to 9).map(x => x * pow(10, x).toLong).sum\n        val\
    \ even10 = (1 to 9", "        def isPalindrome(n : Long) : Boolean = {\n     \
    \       val s = n.toString\n            s == s.reverse\n        }\n        def\
    \ isEven(n : Long) : Boolean = {\n            n % 2 == 0\n        }\n        var\
    \ even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n            if\
    \ (isPalindrome(i)) {\n                if (isEven(i)) even += 1\n            \
    \    else odd += 1\n            }\n        }\n        (even, odd)", "        var\
    \ even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n            if\
    \ (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n           \
    \     else odd += 1\n            }\n        }\n        (even, odd)", "       \
    \ val palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n \
    \           if (isPalindrome(i)) palindromes += i\n        }\n        val evens\
    \ = palindromes.filter(x => x % 2 == 0).size\n        val odds = palindromes.filter(x\
    \ => x % 2 == 1).size\n        (evens, odds)", "        var even = 0L\n      \
    \  var odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).length\n        (even, odd)",
  "        val palindromes = new ArrayBuffer[Long]\n        for (i <- 1 to n.toInt)\
    \ {\n            val s = i.toString\n            if (s == s.reverse) palindromes\
    \ += i\n        }\n        val evens = palindromes.filter(_ % 2 == 0).length\n\
    \        val odds = palindromes.length - evens\n        (evens, odds)", "    \
    \    var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n     \
    \       if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1 else\
    \ odd += 1\n            }\n        }\n        (even, odd)", "        val even\
    \ = (1 to 9).map(x => x * pow(10, x - 1).toLong).sum\n        val odd = (1 to\
    \ 9).map(x => x * pow(10, x).toLong).sum\n        var result = (0L, 0L)\n    \
    \    var num = n\n        while (num > 0) {\n            val digit = num % 10\n\
    \            num /= 10\n            val power = pow(10, num.toInt).toLong\n  \
    \          if (digit == 0) result = (result._1 + even, result._2 + odd)\n    \
    \        else if (digit == 1) result = (result._1 + even, result._2 + odd + power)\n\
    \            else if (digit == 2) result = (result._1 + even + power, result._2\
    \ + odd)\n            else if (digit == 3) result = (result._1 + even + power,\
    \ result._2 + odd + power)\n            else if (digit == 4) result = (result._1\
    \ + even + power, result._2 + odd + power)\n            else if (digit == 5) result\
    \ = (result._1 + even + power, result._2 + odd + power)\n            else if (digit\
    \ == 6) result = (result._1 + even + power, result._2 + odd + power)\n       \
    \     else if (digit == 7) result = (result._1 + even + power, result._2 + odd\
    \ + power)\n            else if (digit == 8) result = (result._1 + even + power,\
    \ result._2 + odd + power)\n            else if (digit == 9) result = (result._1\
    \ + even + power, result._2 + odd + power)\n        }\n        result", "    \
    \    val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse &&\
    \ x % 2 == 0).size\n        val odd = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 1).size\n        (even, odd)", "        val even\
    \ = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 0).length\n\
    \        val odd = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 1).length\n        return (even, odd)", "        var even = 0L\n\
    \        var odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        var even = 0L\n    \
    \    var odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        val palindromes = new ArrayBuffer[Long]\n    \
    \    for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes +=\
    \ i\n        }\n        val even = palindromes.filter(x => x % 2 == 0).length\n\
    \        val odd = palindromes.filter(x => x % 2 == 1).length\n        (even,\
    \ odd)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to\
    \ n) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) even\
    \ += 1\n                else odd += 1\n            }\n        }\n        (even,\
    \ odd)", "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n        \
    \    if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n     \
    \           else odd += 1\n            }\n        }\n        (even, odd)", " \
    \       val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x\
    \ % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "        var\
    \ even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n            if\
    \ (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n           \
    \     else odd += 1\n            }\n        }\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n        \
    \    if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1 else odd\
    \ += 1\n            }\n        }\n        (even, odd)", "        val even = (1\
    \ to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 0).length\n\
    \        val odd = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 1).length\n        (even, odd)", "        var even = 0L\n      \
    \  var odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        return (even, odd)", "        var even = 0L\n\
    \        var odd = 0L\n        for (i <- 1L to n) {\n            if (i.toString.reverse\
    \ == i.toString) {\n                if (i % 2 == 0) even += 1\n              \
    \  else odd += 1\n            }\n        }\n        (even, odd)", "        val\
    \ palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n     \
    \       if (isPalindrome(i)) palindromes += i\n        }\n        val even = palindromes.filter(x\
    \ => x % 2 == 0).length\n        val odd = palindromes.filter(x => x % 2 == 1).length\n\
    \        (even, odd)", "        // if n is even, then the number of even palindromes\
    \ is n / 2 + 1\n        // if n is odd, then the number of even palindromes is\
    \ (n - 1) / 2 + 1\n        val even = if (n % 2 == 0) n / 2 + 1 else (n - 1) /\
    \ 2 + 1\n        val odd = n - even\n        (even, odd)", "        var even =\
    \ 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        var even = 0L\n    \
    \    var odd = 0L\n        for (i <- 1L to n) {\n            if (i.toString ==\
    \ i.toString.reverse) {\n                if (i % 2 == 0) even += 1\n         \
    \       else odd += 1\n            }\n        }\n        (even, odd)", "     \
    \   var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n      \
    \      if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n   \
    \             else odd += 1\n            }\n        }\n        (even, odd)", " \
    \       var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n  \
    \          if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n   \
    \         if (i.toString == i.toString.reverse) {\n                if (i % 2 ==\
    \ 0) even += 1\n                else odd += 1\n            }\n        }\n    \
    \    (even, odd)", "        val even = (1 to n.toInt).filter(x => isPalindrome(x)\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => isPalindrome(x)\
    \ && x % 2 == 1).length\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).size\n        val odd = (1\
    \ to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).size\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1L to n) {\n            if (i.toString == i.toString.reverse) {\n    \
    \            if (i % 2 == 0) even += 1\n                else odd += 1\n      \
    \      }\n        }\n        (even, odd)", "        var even = 0L\n        var\
    \ odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n\
    \                if (i % 2 == 0) even += 1\n                else odd += 1\n  \
    \          }\n        }\n        (even, odd)", "        val digits = n.toString.length\n\
    \        val evens = (1 to digits / 2).map(i => pow(10, i).toLong).sum\n     \
    \   val odds = (1 to digits / 2).map(i => 9 * pow(10, i - 1).toLong).sum\n   \
    \     if (digits % 2 == 0) (evens, odds)\n        else (evens + pow(10, digits\
    \ / 2).toLong, odds)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).length\n        (even, odd)",
  "        val even = (1 to n.toInt).map(x => x.toString).filter(x => x.length % 2\
    \ == 0 && x.reverse == x).length\n        val odd = (1 to n.toInt).map(x => x.toString).filter(x\
    \ => x.length % 2 == 1 && x.reverse == x).length\n        (even, odd)", "    \
    \    val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse &&\
    \ x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x\
    \ % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "        val\
    \ palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n     \
    \       if (isPalindrome(i)) palindromes += i\n        }\n        val even = palindromes.filter(x\
    \ => x % 2 == 0).length\n        val odd = palindromes.filter(x => x % 2 == 1).length\n\
    \        (even, odd)", "        val palindromes = new ListBuffer[Long]\n     \
    \   for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes +=\
    \ i\n        }\n        val evens = palindromes.filter(x => x % 2 == 0).length\n\
    \        val odds = palindromes.filter(x => x % 2 == 1).length\n        (evens,\
    \ odds)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to\
    \ n) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) even\
    \ += 1 else odd += 1\n            }\n        }\n        (even, odd)", "      \
    \  val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x\
    \ % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "        var\
    \ even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n            if\
    \ (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1 else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).size\n        val odd = (1\
    \ to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).size\n\
    \        (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n      \
    \  for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes +=\
    \ i\n        }\n        val evens = palindromes.filter(x => x % 2 == 0).length\n\
    \        val odds = palindromes.filter(x => x % 2 == 1).length\n        (evens,\
    \ odds)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to\
    \ n) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) even\
    \ += 1\n                else odd += 1\n            }\n        }\n        (even,\
    \ odd)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to\
    \ n) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) even\
    \ += 1\n                else odd += 1\n            }\n        }\n        (even,\
    \ odd)", "        val even = (1 to n.toInt).filter(i => i.toString == i.toString.reverse\
    \ && i % 2 == 0).length\n        val odd = (1 to n.toInt).filter(i => i.toString\
    \ == i.toString.reverse && i % 2 == 1).length\n        (even, odd)", "       \
    \ val palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n \
    \           if (isPalindrome(i)) palindromes += i\n        }\n        val evens\
    \ = palindromes.filter(x => x % 2 == 0).length\n        val odds = palindromes.filter(x\
    \ => x % 2 == 1).length\n        (evens, odds)", "        val even = (1 to n.toInt).filter(i\
    \ => isPalindrome(i) && i % 2 == 0).length\n        val odd = (1 to n.toInt).filter(i\
    \ => isPalindrome(i) && i % 2 == 1).length\n        return (even, odd)", "   \
    \     val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse &&\
    \ x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ val even = (1L to n).filter(x => x.toString == x.toString.reverse && x % 2 ==\
    \ 0).size\n        val odd = (1L to n).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 1).size\n        (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            if (i.toString == i.toString.reverse)\
    \ palindromes += i\n        }\n        var even = 0\n        var odd = 0\n   \
    \     for (i <- palindromes) {\n            if (i % 2 == 0) even += 1\n      \
    \      else odd += 1\n        }\n        (even, odd)", "        var even = 0L\n\
    \        var odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        return (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes\
    \ += i\n        }\n        val even = palindromes.filter(x => x % 2 == 0).length\n\
    \        val odd = palindromes.filter(x => x % 2 == 1).length\n        (even,\
    \ odd)", "        // 1 <= n <= 10^3\n        val nDigits = n.toString.length\n\
    \        val nDigits2 = nDigits / 2\n        val nDigits2_1 = nDigits2 + 1\n \
    \       val nDigits2_2 = nDigits2 * 2\n        val nDigits2_3 = nDigits2_2 + 1\n\
    \        val nDigits2_4 = nDigits2_3 + 1\n        val nDigits2_5 = nDigits2_4\
    \ + 1\n        val nDigits2_6 = nDigits2_5 + 1\n        val nDigits2_7 = nDigits2_6\
    \ + 1\n        val nDigits2_8 = nDigits2_7 + 1\n        val nDigits2_9 = nDigits2_8\
    \ + 1\n        val nDigits2_10 = nDigits2_9 + 1\n        val nDigits2_11 = nDigits2_10\
    \ + 1\n        val nDigits2_12 = nDigits2_11 + 1\n        val nDigits2_13 = nDigits2_12\
    \ + 1\n        val nDigits2_14 = nDigits2_13 + 1\n        val nDigits2_15 = nDigits2_14\
    \ + 1\n        val nDigits2_16 = nDigits2_15 + 1\n        val nDigits2_17 = nDigits2_16\
    \ + 1\n        val nDigits2_18 = nDigits2_17 + 1\n        val nDigits2_19 = nDigits2_18\
    \ + 1\n        val nDigits2_20 = nDigits2_19 + 1\n        val nDigits2_21 = nDigits2_20\
    \ + 1\n        val nDigits2_22 = nDigits2_21 + 1\n        val nDigits2_23 = nDigits2_22\
    \ + 1\n        val nDigits2_24 = nDigits2_23 + 1\n        val nDigits2_25 = nDigits2_24\
    \ + 1\n        val nDigits2_26 = nDigits2_25 + 1\n        val nDigits2_27 = nDig",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n   \
    \         if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to 9).map(x => (1 to n.toString.length).map(y => pow(10,\
    \ y - 1).toLong).sum).sum\n        val odd = (1 to 9).map(x => (1 to n.toString.length\
    \ - 1).map(y => pow(10, y - 1).toLong).sum).sum\n        (even, odd)", "     \
    \   val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse &&\
    \ x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n        \
    \    if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n     \
    \           else odd += 1\n            }\n        }\n        (even, odd)", " \
    \       var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n  \
    \          if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) palindromes += i\n        }\n        val\
    \ even = palindromes.count(_ % 2 == 0)\n        val odd = palindromes.count(_\
    \ % 2 == 1)\n        (even, odd)", "        val palindromes = new ArrayBuffer[Long]\n\
    \        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes\
    \ += i\n        }\n        val evens = palindromes.filter(x => x % 2 == 0).length\n\
    \        val odds = palindromes.filter(x => x % 2 == 1).length\n        (evens,\
    \ odds)", "        val palindromes = ArrayBuffer[Long]()\n        for (i <- 1\
    \ to n.toInt) {\n            if (isPalindrome(i)) palindromes += i\n        }\n\
    \        val evens = palindromes.filter(x => x % 2 == 0).length\n        val odds\
    \ = palindromes.filter(x => x % 2 == 1).length\n        (evens, odds)", "    \
    \    val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse &&\
    \ x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n        \
    \    if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n     \
    \           else odd += 1\n            }\n        }\n        (even, odd)", " \
    \       val palindromes = new ArrayBuffer[Long]\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) palindromes += i\n        }\n        val\
    \ evens = palindromes.filter(x => x % 2 == 0).length\n        val odds = palindromes.filter(x\
    \ => x % 2 == 1).length\n        (evens, odds)", "        var even = 0L\n    \
    \    var odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).size\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).size\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n   \
    \         if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        return (even,\
    \ odd)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to\
    \ n) {\n            if (i.toString == i.toString.reverse) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        (even, odd)", "        val sqrt = sqrt(n).toLong\n        val even\
    \ = (1L to sqrt).filter(x => x % 2 == 0 && x * x <= n).length\n        val odd\
    \ = (1L to sqrt).filter(x => x % 2 == 1 && x * x <= n).length\n        return\
    \ (even, odd)", "        var odd = 0L\n        var even = 0L\n        for (i <-\
    \ 1L to n) {\n            if (isPalindrome(i)) {\n                if (i % 2 ==\
    \ 0) even += 1\n                else odd += 1\n            }\n        }\n    \
    \    (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 0).size\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).size\n        (even, odd)",
  "        val palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) palindromes += i\n        }\n        val\
    \ even = palindromes.filter(_ % 2 == 0).length\n        val odd = palindromes.filter(_\
    \ % 2 == 1).length\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        return (even, odd)", "        var even = 0L\n        var odd = 0L\n \
    \       for (i <- 1L to n) {\n            if (i.toString == i.toString.reverse)\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        return (even, odd)", "        val (even, odd)\
    \ = (0L, 0L)\n        var i = 1L\n        while (i <= n) {\n            if (i.toString\
    \ == i.toString.reverse) {\n                if (i % 2 == 0) even += 1 else odd\
    \ += 1\n            }\n            i += 1\n        }\n        (even, odd)", " \
    \       var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n  \
    \          if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x\
    \ % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "        val\
    \ palindromes = (1 to n.toInt).filter(x => x.toString == x.toString.reverse)\n\
    \        val even = palindromes.filter(x => x % 2 == 0).length\n        val odd\
    \ = palindromes.filter(x => x % 2 == 1).length\n        (even, odd)", "      \
    \  var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n       \
    \     if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n    \
    \            else odd += 1\n            }\n        }\n        (even, odd)", " \
    \       var even = 0\n        var odd = 0\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n        \
    \    if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n     \
    \           else odd += 1\n            }\n        }\n        (even, odd)", " \
    \       val palindromes = new ArrayBuffer[Long]\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) palindromes += i\n        }\n        val\
    \ even = palindromes.filter(x => x % 2 == 0).length\n        val odd = palindromes.filter(x\
    \ => x % 2 == 1).length\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).length\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n   \
    \         if (i.toString == i.toString.reverse) {\n                if (i % 2 ==\
    \ 0) even += 1\n                else odd += 1\n            }\n        }\n    \
    \    (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes += i\n \
    \       }\n        val evens = palindromes.filter(x => x % 2 == 0).length\n  \
    \      val odds = palindromes.filter(x => x % 2 == 1).length\n        (evens,\
    \ odds)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to\
    \ n) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) even\
    \ += 1\n                else odd += 1\n            }\n        }\n        (even,\
    \ odd)", "        val evens = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).size\n        val odds = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).size\n        (evens, odds)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n        \
    \    if (i.toString == i.toString.reverse) {\n                if (i % 2 == 0)\
    \ even += 1\n                else odd += 1\n            }\n        }\n       \
    \ (even, odd)", "        def isPalindrome(x : Long) : Boolean = {\n          \
    \  val s = x.toString\n            s == s.reverse\n        }\n        def isEven(x\
    \ : Long) : Boolean = {\n            x % 2 == 0\n        }\n        val palindromes\
    \ = (1 to n.toInt).filter(isPalindrome)\n        val evens = palindromes.filter(isEven)\n\
    \        val odds = palindromes.filter(!isEven(_))\n        (evens.length, odds.length)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n   \
    \         if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n   \
    \         if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val palindromes = (1 to n.toInt).filter(x => x.toString == x.toString.reverse)\n\
    \        val even = palindromes.filter(x => x % 2 == 0).length\n        val odd\
    \ = palindromes.filter(x => x % 2 == 1).length\n        (even, odd)", "      \
    \  var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n       \
    \     if (i.toString == i.toString.reverse) {\n                if (i % 2 == 0)\
    \ even += 1\n                else odd += 1\n            }\n        }\n       \
    \ (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n        \
    \    if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n     \
    \           else odd += 1\n            }\n        }\n        (even, odd)", " \
    \       def isPalindrome(x : Long) : Boolean = {\n            val s = x.toString\n\
    \            s == s.reverse\n        }\n        val palindromes = (1 to n.toInt).filter(x\
    \ => isPalindrome(x))\n        val evens = palindromes.filter(x => x % 2 == 0)\n\
    \        val odds = palindromes.filter(x => x % 2 == 1)\n        (evens.length,\
    \ odds.length)", "        val even = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 0).size\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).size\n        (even, odd)",
  "        // 1. 1 <= n <= 10^3\n        // 2. returned tuple has the number of even\
    \ and odd integer palindromes respectively.\n        // 3. Integer palindrome\
    \ are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are\
    \ odd.\n        // 4. Integer palindrome are 1, 2, 3. one of them is even, and\
    \ two of them are odd.\n        // 5. Integer palindrome are 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n        // 6. Integer\
    \ palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of\
    \ them are odd.\n        // 7. Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 11. four of them are even, and 6 of them are odd.\n        // 8. Integer\
    \ palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of\
    \ them are odd.\n        // 9. Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 11. four of them are even, and 6 of them are odd.\n        // 10. Integer\
    \ palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of\
    \ them are odd.\n        // 11. Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 11. four of them are even, and 6 of them are odd.\n        // 12. Integer\
    \ palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of\
    \ them are odd.\n        // 13. Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 11. four of them are even, and 6 of them are odd.\n        // 14. Integer\
    \ palindrome are 1, 2, 3, 4, 5,", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        return (even, odd)", "        var even = 0L\n        var odd = 0L\n \
    \       for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n           \
    \     if (i % 2 == 0) even += 1\n                else odd += 1\n            }\n\
    \        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        val even = (1 to 9).map(x => (1 to (n - 1).toString.length).map(y\
    \ => pow(10, y).toLong).sum).sum\n        val odd = (1 to 9).map(x => (1 to (n\
    \ - 1).toString.length - 1).map(y => pow(10, y).toLong).sum).sum\n        (even,\
    \ odd)", "        val even = (1 to n.toInt).filter(x => isPalindrome(x) && x %\
    \ 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => isPalindrome(x)\
    \ && x % 2 == 1).length\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n      \
    \  for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes +=\
    \ i\n        }\n        val even = palindromes.filter(x => x % 2 == 0).length\n\
    \        val odd = palindromes.filter(x => x % 2 == 1).length\n        (even,\
    \ odd)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to\
    \ n) {\n            if (i.toString == i.toString.reverse) {\n                if\
    \ (i % 2 == 0) even += 1 else odd += 1\n            }\n        }\n        (even,\
    \ odd)", "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ val even = (1 to 9).map(x => x.toLong).toList\n        val odd = (1 to 9).map(x\
    \ => x.toLong * 10 + x).toList\n        val evenOdd = even.map(x => (x, x)) ++\
    \ odd.map(x => (x, x))\n        def helper(n : Long, evenOdd : List[Tuple2[Long,\
    \ Long]]) : Tuple2[Long, Long] = {\n            if (n <= 10) {\n             \
    \   val (even, odd) = evenOdd.partition(x => x._1 % 2 == 0)\n                (even.length,\
    \ odd.length)\n            } else {\n                val (even, odd) = evenOdd.partition(x\
    \ => x._1 % 2 == 0)\n                val (even2, odd2) = (even.map(x => (x._1\
    \ * 10 + x._2, x._2)), odd.map(x => (x._1 * 10 + x._2, x._2)))\n             \
    \   val (even3, odd3) = (even.map(x => (x._1 * 10 + x._2 + 1, x._2 + 1)), odd.map(x\
    \ => (x._1 * 10 + x._2 + 1, x._2 + 1)))\n                val (even4, odd4) = (even.map(x\
    \ => (x._1 * 10 + x._2 - 1, x._2 - 1)), odd.map(x => (x._1 * 10 + x._2 - 1, x._2\
    \ - 1)))\n                val (even5, odd5) = (even.map(x => (x._1 * 10 + x._2,\
    \ x._2)), odd.map(x => (x._1 * 10 + x._2, x._2)))\n                val (even6,\
    \ odd6) = (even.map(x => (x._1 * 10 + x._2 + 1, x._2 + 1)), odd.map(x => (x._1\
    \ * 10 + x._2 + 1, x._2 + 1)))\n                val (even7, odd7) = (even.map(x\
    \ => (x._1 * 10 + x._2 - 1", "        var even = 0L\n        var odd = 0L\n  \
    \      for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n            \
    \    if (i % 2 == 0) even += 1\n                else odd += 1\n            }\n\
    \        }\n        (even, odd)", "        var even = 0L\n        var odd = 0L\n\
    \        for (i <- 1L to n) {\n            if (i.toString == i.toString.reverse)\
    \ {\n                if (i % 2 == 0) even += 1 else odd += 1\n            }\n\
    \        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(i\
    \ => i.toString == i.toString.reverse && i % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(i => i.toString == i.toString.reverse && i % 2 == 1).length\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1L to n) {\n            if (isPalindrome(i)) {\n                if (i\
    \ % 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n      \
    \  for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes +=\
    \ i\n        }\n        val even = palindromes.filter(x => x % 2 == 0).length\n\
    \        val odd = palindromes.filter(x => x % 2 == 1).length\n        (even,\
    \ odd)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1L to\
    \ n) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) even\
    \ += 1\n                else odd += 1\n            }\n        }\n        (even,\
    \ odd)", "        val isPalindrome = (x : Long) => {\n            val s = x.toString\n\
    \            s == s.reverse\n        }\n        val isEven = (x : Long) => x %\
    \ 2 == 0\n        val isOdd = (x : Long) => x % 2 == 1\n        val even = (1L\
    \ to n).filter(isPalindrome).filter(isEven).size\n        val odd = (1L to n).filter(isPalindrome).filter(isOdd).size\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1L to n) {\n            if (isPalindrome(i)) {\n                if (i\
    \ % 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1L to n) {\n            if (isPalindrome(i)) {\n                if (i\
    \ % 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1L to n) {\n            if (isPalindrome(i)) {\n                if (i\
    \ % 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1L to n) {\n            if (isPalindrome(i)) {\n                if (i\
    \ % 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).length\n        (even, odd)",
  "        val palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) palindromes += i\n        }\n        val\
    \ even = palindromes.filter(x => x % 2 == 0).length\n        val odd = palindromes.filter(x\
    \ => x % 2 == 1).length\n        (even, odd)", "        var even = 0L\n      \
    \  var odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        var even = 0L\n    \
    \    var odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        var even = 0L\n    \
    \    var odd = 0L\n        for (i <- 1L to n) {\n            if (i.toString ==\
    \ i.toString.reverse) {\n                if (i % 2 == 0) even += 1\n         \
    \       else odd += 1\n            }\n        }\n        (even, odd)", "     \
    \   var even = 0L\n        var odd = 0L\n        for (i <- 1L to n) {\n      \
    \      if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n   \
    \             else odd += 1\n            }\n        }\n        (even, odd)", " \
    \       val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x\
    \ % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "        val\
    \ even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2\
    \ == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 1).length\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1L to n) {\n            if (isPalindrome(i)) {\n                if (i\
    \ % 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).length\n        (even, odd)",
  "        val evens = (1 to n.toInt).filter(x => isPalindrome(x) && x % 2 == 0).size\n\
    \        val odds = (1 to n.toInt).filter(x => isPalindrome(x) && x % 2 == 1).size\n\
    \        (evens, odds)", "        var even = 0L\n        var odd = 0L\n      \
    \  for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        (even, odd)", "        var even = 0L\n        var odd = 0L\n  \
    \      for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n            \
    \    if (i % 2 == 0) even += 1\n                else odd += 1\n            }\n\
    \        }\n        (even, odd)", "        var even = 0L\n        var odd = 0L\n\
    \        for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n          \
    \      if (i % 2 == 0) even += 1\n                else odd += 1\n            }\n\
    \        }\n        (even, odd)", "        def isPalindrome(x : Long) : Boolean\
    \ = {\n            val s = x.toString\n            s == s.reverse\n        }\n\
    \        def isEven(x : Long) : Boolean = x % 2 == 0\n        var even = 0L\n\
    \        var odd = 0L\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (isEven(i)) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val even = (1 to 9).map(x\
    \ => (1 to n.toString.length).map(y => pow(10, y - 1).toLong).sum).sum\n     \
    \   val odd = (1 to 9).map(x => (1 to n.toString.length - 1).map(y => pow(10,\
    \ y - 1).toLong).sum).sum\n        (even, odd)"]
stop_tokens:
- "\n    }\n"
