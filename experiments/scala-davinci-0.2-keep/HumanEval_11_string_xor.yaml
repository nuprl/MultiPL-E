name: HumanEval_11_string_xor
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform\
  \ binary XOR on these inputs and return result also as a string.\n    // >>> string_xor('010',\
  \ '110')\n    // '100'\n    def stringXor(a : String, b : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
  ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
  0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n   \
  \ }\n\n}\n"
completions: ["        val a_int = Integer.parseInt(a, 2)\n        val b_int = Integer.parseInt(b,\
    \ 2)\n        val xor_int = a_int ^ b_int\n        val xor_string = Integer.toBinaryString(xor_int)\n\
    \        return xor_string", "        val result = new StringBuilder\n       \
    \ for (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString", " \
    \       var result = \"\"\n        for (i <- 0 until a.length) {\n           \
    \ if (a(i) == b(i)) result += \"0\"\n            else result += \"1\"\n      \
    \  }\n        return result", "        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(i => i.toString).reduceLeft(_ + _)", " \
    \       val aBits = a.toList.map(x => x.toString.toInt)\n        val bBits = b.toList.map(x\
    \ => x.toString.toInt)\n        val cBits = aBits.zip(bBits).map(x => x._1 ^ x._2)\n\
    \        cBits.map(x => x.toString).mkString", "        var result = \"\"\n  \
    \      for (i <- 0 until a.length) {\n            if (a(i) == b(i)) result +=\
    \ \"0\"\n            else result += \"1\"\n        }\n        return result",
  "        val aa = a.toList.map(_.toString.toInt)\n        val bb = b.toList.map(_.toString.toInt)\n\
    \        val cc = aa.zip(bb).map(x => x._1 ^ x._2)\n        cc.map(_.toString).reduceLeft(_\
    \ + _)", "        val result = new StringBuilder\n        for (i <- 0 until a.length)\
    \ {\n            result += ((a(i) - '0') ^ (b(i) - '0') + '0').toChar\n      \
    \  }\n        result.toString", "        val result = new StringBuilder\n    \
    \    for (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append('0')\n\
    \            else result.append('1')\n        }\n        result.toString", " \
    \       val sb = new StringBuilder\n        for (i <- 0 until a.length) {\n  \
    \          sb.append((a(i) - '0') ^ (b(i) - '0'))\n        }\n        sb.toString",
  "        val a_array = a.toCharArray\n        val b_array = b.toCharArray\n    \
    \    var result = \"\"\n        for (i <- 0 until a_array.length) {\n        \
    \    if (a_array(i) == b_array(i)) result += \"0\"\n            else result +=\
    \ \"1\"\n        }\n        result", "        var result = \"\"\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) result += \"0\"\n    \
    \        else result += \"1\"\n        }\n        return result", "        val\
    \ n = a.length\n        val m = b.length\n        if (n != m) throw new IllegalArgumentException\n\
    \        val sb = new StringBuilder\n        for (i <- 0 until n) {\n        \
    \    if (a(i) == b(i)) sb.append('0')\n            else sb.append('1')\n     \
    \   }\n        sb.toString", "        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            result += (if (a(i) == b(i)) \"0\" else \"1\")\n  \
    \      }\n        return result", "        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val result = aBits.zip(bBits).map(c\
    \ => c._1 ^ c._2)\n        result.map(c => c.toString).mkString", "        var\
    \ result = \"\"\n        for (i <- 0 until a.length) {\n            if (a(i) ==\
    \ b(i)) result += \"0\"\n            else result += \"1\"\n        }\n       \
    \ return result", "        val result = new StringBuilder\n        for (i <- 0\
    \ until a.length) {\n            if (a(i) == b(i)) result.append('0')\n      \
    \      else result.append('1')\n        }\n        result.toString", "       \
    \ var result = \"\"\n        for (i <- 0 until a.length) {\n            if (a(i)\
    \ == b(i)) result += \"0\"\n            else result += \"1\"\n        }\n    \
    \    return result", "        val aa = a.toCharArray\n        val bb = b.toCharArray\n\
    \        val cc = new Array[Char](aa.length)\n        for (i <- 0 until aa.length)\
    \ {\n            if (aa(i) == bb(i)) cc(i) = '0'\n            else cc(i) = '1'\n\
    \        }\n        return cc.mkString", "        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(i => i.toString).reduceLeft(_ + _)"]
stop_tokens:
- "\n    }\n"
