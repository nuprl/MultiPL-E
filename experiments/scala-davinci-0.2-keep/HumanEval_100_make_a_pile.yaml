name: HumanEval_100_make_a_pile
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, you have to make a pile of n levels of stones.\n\
  \    // The first level has n stones.\n    // The number of stones in the next level\
  \ is:\n    // - the next odd number if n is odd.\n    // - the next even number\
  \ if n is even.\n    // Return the number of stones in each level in a list, where\
  \ element at index\n    // i represents the number of stones in the level (i+1).\n\
  \    // Examples:\n    // >>> make_a_pile(3)\n    // [3, 5, 7]\n    def makeAPile(n\
  \ : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(makeAPile((3l)).equals((List[Long](3l.toLong,\
  \ 5l.toLong, 7l.toLong))));\n    assert(makeAPile((4l)).equals((List[Long](4l.toLong,\
  \ 6l.toLong, 8l.toLong, 10l.toLong))));\n    assert(makeAPile((5l)).equals((List[Long](5l.toLong,\
  \ 7l.toLong, 9l.toLong, 11l.toLong, 13l.toLong))));\n    assert(makeAPile((6l)).equals((List[Long](6l.toLong,\
  \ 8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong))));\n    assert(makeAPile((8l)).equals((List[Long](8l.toLong,\
  \ 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong, 18l.toLong, 20l.toLong, 22l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        var result = List[Long]()\n        var i = n\n        while\
    \ (i > 0) {\n            result = i :: result\n            if (i % 2 == 0) i +=\
    \ 1 else i += 2\n        }\n        result", "        var stones = ListBuffer[Long]()\n\
    \        var current = n\n        while (current > 0) {\n            stones +=\
    \ current\n            current = if (current % 2 == 0) current + 1 else current\
    \ + 2\n        }\n        stones.toList", "        var result = List[Long]()\n\
    \        var i = n\n        while (i > 0) {\n            result = i :: result\n\
    \            if (i % 2 == 0) i += 1 else i += 2\n        }\n        result", " \
    \       var result = List[Long]()\n        var current = n\n        while (current\
    \ > 0) {\n            result = current :: result\n            if (current % 2\
    \ == 0) current -= 1\n            current /= 2\n        }\n        result", " \
    \       var result = List[Long]()\n        var i = n\n        while (i > 0) {\n\
    \            result = i :: result\n            if (i % 2 == 0) i = i / 2\n   \
    \         else i = (i - 1) / 2\n        }\n        result", "        val l = new\
    \ ListBuffer[Long]\n        var i = n\n        while (i > 0) {\n            l\
    \ += i\n            i = if (i % 2 == 0) i / 2 else (i + 1) / 2\n        }\n  \
    \      l.toList", "        val l = ListBuffer[Long]()\n        var i = n\n   \
    \     while (i > 0) {\n            l += i\n            i = if (i % 2 == 0) i /\
    \ 2 else i / 2 + 1\n        }\n        l.toList", "        var result = List[Long]()\n\
    \        var num = n\n        while (num > 0) {\n            result = num :: result\n\
    \            if (num % 2 == 0) num -= 1\n            num /= 2\n        }\n   \
    \     result", "        var result = List[Long]()\n        var i = n\n       \
    \ while (i > 0) {\n            result = i :: result\n            if (i % 2 ==\
    \ 0) i += 1 else i += 2\n        }\n        result", "        def makeAPile(n\
    \ : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n  \
    \          else if (n % 2 == 0) makeAPile(n - 1, (n + 1) :: acc)\n           \
    \ else makeAPile(n - 1, (n + 2) :: acc)\n        }\n        makeAPile(n, List(n)).reverse",
  "        var result = List[Long]()\n        var current = n\n        while (current\
    \ > 0) {\n            result = current :: result\n            if (current % 2\
    \ == 0) current += 1 else current += 2\n        }\n        result", "        var\
    \ result = ListBuffer[Long]()\n        var i = n\n        while (i > 0) {\n  \
    \          result += i\n            i = if (i % 2 == 0) i / 2 else (i + 1) / 2\n\
    \        }\n        result.toList", "        var result = List[Long]()\n     \
    \   var current = n\n        while (current > 0) {\n            result = current\
    \ :: result\n            if (current % 2 == 0) current = current / 2 - 1\n   \
    \         else current = current / 2\n        }\n        result", "        val\
    \ result = new ListBuffer[Long]\n        var current = n\n        while (current\
    \ > 0) {\n            result += current\n            current = if (current % 2\
    \ == 0) current + 1 else current + 2\n        }\n        result.toList", "   \
    \     val l = new ListBuffer[Long]\n        var i = n\n        while (i > 0) {\n\
    \            l += i\n            i = if (i % 2 == 0) i / 2 else (i + 1) / 2\n\
    \        }\n        l.toList", "        def makeAPile(n : Long, level : Long,\
    \ acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n          \
    \  else makeAPile(n - 1, level + 2, acc :+ level)\n        }\n        makeAPile(n,\
    \ n, List())", "        var l = List[Long]()\n        var i = n\n        while\
    \ (i > 0) {\n            l = i :: l\n            if (i % 2 == 0) i = i / 2 else\
    \ i = i / 2 + 1\n        }\n        l", "        def makeAPile(n : Long, acc :\
    \ List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else\
    \ {\n                val next = if (n % 2 == 0) n + 2 else n + 1\n           \
    \     makeAPile(next, n :: acc)\n            }\n        }\n        makeAPile(n,\
    \ Nil).reverse", "        val l = ListBuffer[Long]()\n        var m = n\n    \
    \    while (m > 0) {\n            l += m\n            if (m % 2 == 0) m -= 1\n\
    \            m /= 2\n        }\n        l.toList", "        var result = List[Long]()\n\
    \        var current = n\n        while (current > 0) {\n            result =\
    \ current :: result\n            if (current % 2 == 0) current = current / 2 -\
    \ 1\n            else current = current / 2\n        }\n        result"]
stop_tokens:
- "\n    }\n"
