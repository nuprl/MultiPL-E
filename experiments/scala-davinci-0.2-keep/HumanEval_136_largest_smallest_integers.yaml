name: HumanEval_136_largest_smallest_integers
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that returns a tuple (a, b), where 'a' is\n    // the\
  \ largest of negative integers, and 'b' is the smallest\n    // of positive integers\
  \ in a list.\n    // If there is no negative or positive integers, return them as\
  \ None.\n    // Examples:\n    // largest_smallest_integers([2, 4, 1, 3, 5, 7])\
  \ == (None, 1)\n    // largest_smallest_integers([]) == (None, None)\n    // largest_smallest_integers([0])\
  \ == (None, None)\n    def largestSmallestIntegers(lst : List[Long]) : Tuple2[Option[Long],\
  \ Option[Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
  \ 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n    assert(largestSmallestIntegers((List[Long](4l.toLong,\
  \ 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l,\
  \ 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong,\
  \ 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));\n\
  \    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
  \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
  \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
  \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
  \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
  \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));\n\
  \    }\n\n}\n"
completions: ["        var maxNeg = None : Option[Long]\n        var minPos = None\
    \ : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n       \
    \         if (maxNeg == None || i > maxNeg.get) maxNeg = Some(i)\n           \
    \ } else if (i > 0) {\n                if (minPos == None || i < minPos.get) minPos\
    \ = Some(i)\n            }\n        }\n        return (maxNeg, minPos)", "   \
    \     val negatives = lst.filter(x => x < 0)\n        val positives = lst.filter(x\
    \ => x > 0)\n        val largestNegative = if (negatives.length > 0) Some(negatives.max)\
    \ else None\n        val smallestPositive = if (positives.length > 0) Some(positives.min)\
    \ else None\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var maxNegative : Option[Long] = None\n        var minPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (maxNegative == None || i > maxNegative.get) maxNegative = Some(i)\n    \
    \        } else if (i > 0) {\n                if (minPositive == None || i < minPositive.get)\
    \ minPositive = Some(i)\n            }\n        }\n        (maxNegative, minPositive)",
  "        val negative = lst.filter(_ < 0).sortWith(_ > _)\n        val positive\
    \ = lst.filter(_ > 0).sortWith(_ < _)\n        val largestNegative = if (negative.isEmpty)\
    \ None else Some(negative.head)\n        val smallestPositive = if (positive.isEmpty)\
    \ None else Some(positive.head)\n        (largestNegative, smallestPositive)",
  "        val negs = lst.filter(_ < 0)\n        val poss = lst.filter(_ > 0)\n  \
    \      val neg = if (negs.isEmpty) None else Some(negs.max)\n        val pos =\
    \ if (poss.isEmpty) None else Some(poss.min)\n        (neg, pos)", "        val\
    \ positives = lst.filter(_ > 0)\n        val negatives = lst.filter(_ < 0)\n \
    \       (negatives.length match {\n            case 0 => None\n            case\
    \ _ => Some(negatives.max)\n        }, positives.length match {\n            case\
    \ 0 => None\n            case _ => Some(positives.min)\n        })", "       \
    \ var largestNegative = None : Option[Long]\n        var smallestPositive = None\
    \ : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n       \
    \         if (largestNegative == None) largestNegative = Some(i)\n           \
    \     else if (i > largestNegative.get) largestNegative = Some(i)\n          \
    \  }\n            else if (i > 0) {\n                if (smallestPositive == None)\
    \ smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val neg = lst.filter(x => x < 0).sorted\n     \
    \   val pos = lst.filter(x => x > 0).sorted\n        if (neg.isEmpty && pos.isEmpty)\
    \ (None, None)\n        else if (neg.isEmpty) (None, Some(pos.head))\n       \
    \ else if (pos.isEmpty) (Some(neg.last), None)\n        else (Some(neg.last),\
    \ Some(pos.head))", "        val neg = lst.filter(_ < 0).sorted\n        val pos\
    \ = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty) None else Some(neg.last),\
    \ if (pos.isEmpty) None else Some(pos.head))", "        var largestNegative :\
    \ Option[Long] = None\n        var smallestPositive : Option[Long] = None\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var largest = None : Option[Long]\n        var smallest = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largest\
    \ == None) largest = Some(i)\n                else if (i > largest.get) largest\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallest == None) smallest = Some(i)\n                else if (i < smallest.get)\
    \ smallest = Some(i)\n            }\n        }\n        return (largest, smallest)",
  "        val neg = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n\
    \        (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty) None else\
    \ Some(pos.head))", "        var largestNegative = None : Option[Long]\n     \
    \   var smallestPositive = None : Option[Long]\n        for (x <- lst) {\n   \
    \         if (x < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(x)\n                else largestNegative = Some(max(largestNegative.get,\
    \ x))\n            }\n            else if (x > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(x)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, x))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        return (largestNegative, smallestPositive)", "        if (lst.length\
    \ == 0) return (None, None)\n        var min = Long.MaxValue\n        var max\
    \ = Long.MinValue\n        for (i <- lst) {\n            if (i < 0) max = max\
    \ max i\n            if (i > 0) min = min min i\n        }\n        if (min ==\
    \ Long.MaxValue) min = None else min = Some(min)\n        if (max == Long.MinValue)\
    \ max = None else max = Some(max)\n        return (max, min)", "        val neg\
    \ = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n   \
    \     (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty) None else Some(pos.head))",
  "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (x <- lst) {\n            if (x < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(x)\n    \
    \            else if (x > largestNegative.get) largestNegative = Some(x)\n   \
    \         }\n            else if (x > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(x)\n                else if (x < smallestPositive.get)\
    \ smallestPositive = Some(x)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val neg = lst.filter(_ < 0).sorted\n        val\
    \ pos = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty) None else Some(neg.last),\
    \ if (pos.isEmpty) None else Some(pos.head))", "        var largestNegative :\
    \ Option[Long] = None\n        var smallestPositive : Option[Long] = None\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)"]
stop_tokens:
- "\n    }\n"
