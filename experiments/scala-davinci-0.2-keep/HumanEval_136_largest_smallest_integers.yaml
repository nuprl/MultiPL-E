name: HumanEval_136_largest_smallest_integers
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that returns a tuple (a, b), where 'a' is\n    // the\
  \ largest of negative integers, and 'b' is the smallest\n    // of positive integers\
  \ in a list.\n    // If there is no negative or positive integers, return them as\
  \ None.\n    // Examples:\n    // largest_smallest_integers([2, 4, 1, 3, 5, 7])\
  \ == (None, 1)\n    // largest_smallest_integers([]) == (None, None)\n    // largest_smallest_integers([0])\
  \ == (None, None)\n    def largestSmallestIntegers(lst : List[Long]) : Tuple2[Option[Long],\
  \ Option[Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
  \ 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n    assert(largestSmallestIntegers((List[Long](4l.toLong,\
  \ 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l,\
  \ 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong,\
  \ 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));\n\
  \    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
  \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
  \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
  \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
  \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
  \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));\n\
  \    }\n\n}\n"
completions: ["        var maxNeg = None : Option[Long]\n        var minPos = None\
    \ : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n       \
    \         if (maxNeg == None || i > maxNeg.get) maxNeg = Some(i)\n           \
    \ } else if (i > 0) {\n                if (minPos == None || i < minPos.get) minPos\
    \ = Some(i)\n            }\n        }\n        return (maxNeg, minPos)", "   \
    \     val negatives = lst.filter(x => x < 0)\n        val positives = lst.filter(x\
    \ => x > 0)\n        val largestNegative = if (negatives.length > 0) Some(negatives.max)\
    \ else None\n        val smallestPositive = if (positives.length > 0) Some(positives.min)\
    \ else None\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var maxNegative : Option[Long] = None\n        var minPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (maxNegative == None || i > maxNegative.get) maxNegative = Some(i)\n    \
    \        } else if (i > 0) {\n                if (minPositive == None || i < minPositive.get)\
    \ minPositive = Some(i)\n            }\n        }\n        (maxNegative, minPositive)",
  "        val negative = lst.filter(_ < 0).sortWith(_ > _)\n        val positive\
    \ = lst.filter(_ > 0).sortWith(_ < _)\n        val largestNegative = if (negative.isEmpty)\
    \ None else Some(negative.head)\n        val smallestPositive = if (positive.isEmpty)\
    \ None else Some(positive.head)\n        (largestNegative, smallestPositive)",
  "        val negs = lst.filter(_ < 0)\n        val poss = lst.filter(_ > 0)\n  \
    \      val neg = if (negs.isEmpty) None else Some(negs.max)\n        val pos =\
    \ if (poss.isEmpty) None else Some(poss.min)\n        (neg, pos)", "        val\
    \ positives = lst.filter(_ > 0)\n        val negatives = lst.filter(_ < 0)\n \
    \       (negatives.length match {\n            case 0 => None\n            case\
    \ _ => Some(negatives.max)\n        }, positives.length match {\n            case\
    \ 0 => None\n            case _ => Some(positives.min)\n        })", "       \
    \ var largestNegative = None : Option[Long]\n        var smallestPositive = None\
    \ : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n       \
    \         if (largestNegative == None) largestNegative = Some(i)\n           \
    \     else if (i > largestNegative.get) largestNegative = Some(i)\n          \
    \  }\n            else if (i > 0) {\n                if (smallestPositive == None)\
    \ smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val neg = lst.filter(x => x < 0).sorted\n     \
    \   val pos = lst.filter(x => x > 0).sorted\n        if (neg.isEmpty && pos.isEmpty)\
    \ (None, None)\n        else if (neg.isEmpty) (None, Some(pos.head))\n       \
    \ else if (pos.isEmpty) (Some(neg.last), None)\n        else (Some(neg.last),\
    \ Some(pos.head))", "        val neg = lst.filter(_ < 0).sorted\n        val pos\
    \ = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty) None else Some(neg.last),\
    \ if (pos.isEmpty) None else Some(pos.head))", "        var largestNegative :\
    \ Option[Long] = None\n        var smallestPositive : Option[Long] = None\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var largest = None : Option[Long]\n        var smallest = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largest\
    \ == None) largest = Some(i)\n                else if (i > largest.get) largest\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallest == None) smallest = Some(i)\n                else if (i < smallest.get)\
    \ smallest = Some(i)\n            }\n        }\n        return (largest, smallest)",
  "        val neg = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n\
    \        (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty) None else\
    \ Some(pos.head))", "        var largestNegative = None : Option[Long]\n     \
    \   var smallestPositive = None : Option[Long]\n        for (x <- lst) {\n   \
    \         if (x < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(x)\n                else largestNegative = Some(max(largestNegative.get,\
    \ x))\n            }\n            else if (x > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(x)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, x))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        return (largestNegative, smallestPositive)", "        if (lst.length\
    \ == 0) return (None, None)\n        var min = Long.MaxValue\n        var max\
    \ = Long.MinValue\n        for (i <- lst) {\n            if (i < 0) max = max\
    \ max i\n            if (i > 0) min = min min i\n        }\n        if (min ==\
    \ Long.MaxValue) min = None else min = Some(min)\n        if (max == Long.MinValue)\
    \ max = None else max = Some(max)\n        return (max, min)", "        val neg\
    \ = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n   \
    \     (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty) None else Some(pos.head))",
  "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (x <- lst) {\n            if (x < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(x)\n    \
    \            else if (x > largestNegative.get) largestNegative = Some(x)\n   \
    \         }\n            else if (x > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(x)\n                else if (x < smallestPositive.get)\
    \ smallestPositive = Some(x)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val neg = lst.filter(_ < 0).sorted\n        val\
    \ pos = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty) None else Some(neg.last),\
    \ if (pos.isEmpty) None else Some(pos.head))", "        var largestNegative :\
    \ Option[Long] = None\n        var smallestPositive : Option[Long] = None\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    val neg = lst.filter(_ < 0).sortWith(_ > _)\n        val pos = lst.filter(_\
    \ > 0).sortWith(_ < _)\n        val a = if (neg.isEmpty) None else Some(neg.head)\n\
    \        val b = if (pos.isEmpty) None else Some(pos.head)\n        (a, b)", " \
    \       var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        var maxNeg = Option.empty[Long]\n        var minPos\
    \ = Option.empty[Long]\n        for (i <- lst) {\n            if (i < 0) {\n \
    \               if (maxNeg.isEmpty || i > maxNeg.get) maxNeg = Some(i)\n     \
    \       } else if (i > 0) {\n                if (minPos.isEmpty || i < minPos.get)\
    \ minPos = Some(i)\n            }\n        }\n        (maxNeg, minPos)", "   \
    \     val negatives = lst.filter(_ < 0)\n        val positives = lst.filter(_\
    \ > 0)\n        if (negatives.isEmpty) (None, positives.min)\n        else if\
    \ (positives.isEmpty) (negatives.max, None)\n        else (negatives.max, positives.min)",
  "        val (neg, pos) = lst.partition(_ < 0)\n        (if (neg.isEmpty) None else\
    \ Some(neg.max), if (pos.isEmpty) None else Some(pos.min))", "        val neg\
    \ = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n   \
    \     (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty) None else Some(pos.head))",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var min : Option[Long] = None\n        var max\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i > 0) {\n\
    \                if (min == None) min = Some(i)\n                else min = Some(min.get\
    \ min i)\n            }\n            else if (i < 0) {\n                if (max\
    \ == None) max = Some(i)\n                else max = Some(max.get max i)\n   \
    \         }\n        }\n        return (max, min)", "        val negative = lst.filter(_\
    \ < 0).sorted\n        val positive = lst.filter(_ > 0).sorted\n        (if (negative.isEmpty)\
    \ None else Some(negative.last), if (positive.isEmpty) None else Some(positive.head))",
  "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        if (lst.length\
    \ == 0) return (None, None)\n        var min = Long.MaxValue\n        var max\
    \ = Long.MinValue\n        for (i <- lst) {\n            if (i > 0) {\n      \
    \          if (i < min) min = i\n            } else if (i < 0) {\n           \
    \     if (i > max) max = i\n            }\n        }\n        if (min == Long.MaxValue)\
    \ min = None else min = Some(min)\n        if (max == Long.MinValue) max = None\
    \ else max = Some(max)\n        return (max, min)", "        var largestNegative\
    \ = None : Option[Long]\n        var smallestPositive = None : Option[Long]\n\
    \        for (num <- lst) {\n            if (num < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(num)\n                else if (num > largestNegative.get)\
    \ largestNegative = Some(num)\n            }\n            else if (num > 0) {\n\
    \                if (smallestPositive == None) smallestPositive = Some(num)\n\
    \                else if (num < smallestPositive.get) smallestPositive = Some(num)\n\
    \            }\n        }\n        (largestNegative, smallestPositive)", "   \
    \     var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        if (lst.length == 0) return (None, None)\n    \
    \    var min = Long.MaxValue\n        var max = Long.MinValue\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (i > max) max = i\n\
    \            } else if (i > 0) {\n                if (i < min) min = i\n     \
    \       }\n        }\n        if (min == Long.MaxValue) min = None else min =\
    \ Some(min)\n        if (max == Long.MinValue) max = None else max = Some(max)\n\
    \        return (max, min)", "        if (lst.isEmpty) return (None, None)\n \
    \       var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (x <- lst) {\n            if (x < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(x)\n    \
    \            else if (x > largestNegative.get) largestNegative = Some(x)\n   \
    \         }\n            else if (x > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(x)\n                else if (x < smallestPositive.get)\
    \ smallestPositive = Some(x)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        if (lst.isEmpty) return (None, None)\n        var\
    \ largestNegative = None : Option[Long]\n        var smallestPositive = None :\
    \ Option[Long]\n        for (x <- lst) {\n            if (x < 0) {\n         \
    \       if (largestNegative == None) largestNegative = Some(x)\n             \
    \   else largestNegative = Some(max(largestNegative.get, x))\n            }\n\
    \            else if (x > 0) {\n                if (smallestPositive == None)\
    \ smallestPositive = Some(x)\n                else smallestPositive = Some(min(smallestPositive.get,\
    \ x))\n            }\n        }\n        return (largestNegative, smallestPositive)",
  "        val positive = lst.filter(x => x > 0).sorted\n        val negative = lst.filter(x\
    \ => x < 0).sorted\n        (if (negative.isEmpty) None else Some(negative.last),\
    \ if (positive.isEmpty) None else Some(positive.head))", "        val neg = lst.filter(_\
    \ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty)\
    \ None else Some(neg.last), if (pos.isEmpty) None else Some(pos.head))", "   \
    \     val (neg, pos) = lst.partition(_ < 0)\n        (if (neg.isEmpty) None else\
    \ Some(neg.max), if (pos.isEmpty) None else Some(pos.min))", "        if (lst.isEmpty)\
    \ return (None, None)\n        var min = Long.MaxValue\n        var max = Long.MinValue\n\
    \        for (i <- lst) {\n            if (i > 0) {\n                if (i < min)\
    \ min = i\n            } else if (i < 0) {\n                if (i > max) max =\
    \ i\n            }\n        }\n        if (min == Long.MaxValue) min = None else\
    \ min = Some(min)\n        if (max == Long.MinValue) max = None else max = Some(max)\n\
    \        return (max, min)", "        var largestNegative = None : Option[Long]\n\
    \        var smallestPositive = None : Option[Long]\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (x <- lst) {\n            if (x < 0) {\n                if (largestNegative\
    \ == None || x > largestNegative.get) largestNegative = Some(x)\n            }\
    \ else if (x > 0) {\n                if (smallestPositive == None || x < smallestPositive.get)\
    \ smallestPositive = Some(x)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var smallest = None : Option[Long]\n        var\
    \ largest = None : Option[Long]\n        for (i <- lst) {\n            if (i >\
    \ 0) {\n                if (smallest == None) smallest = Some(i)\n           \
    \     else if (i < smallest.get) smallest = Some(i)\n            }\n         \
    \   else if (i < 0) {\n                if (largest == None) largest = Some(i)\n\
    \                else if (i > largest.get) largest = Some(i)\n            }\n\
    \        }\n        (largest, smallest)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var largestNegative = None : Option[Long]\n        var smallestPositive =\
    \ None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (largestNegative == None) largestNegative = Some(i)\n      \
    \          else if (i > largestNegative.get) largestNegative = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (x <- lst) {\n \
    \           if (x < 0) {\n                if (largestNegative == None || x > largestNegative.get)\
    \ largestNegative = Some(x)\n            } else if (x > 0) {\n               \
    \ if (smallestPositive == None || x < smallestPositive.get) smallestPositive =\
    \ Some(x)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var min = None : Option[Long]\n        var max\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i > 0) {\n\
    \                if (min == None) min = Some(i)\n                else if (i <\
    \ min.get) min = Some(i)\n            }\n            else if (i < 0) {\n     \
    \           if (max == None) max = Some(i)\n                else if (i > max.get)\
    \ max = Some(i)\n            }\n        }\n        return (max, min)", "     \
    \   val negs = lst.filter(_ < 0)\n        val poss = lst.filter(_ > 0)\n     \
    \   (if (negs.isEmpty) None else Some(negs.max), if (poss.isEmpty) None else Some(poss.min))",
  "        val neg = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n\
    \        (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty) None else\
    \ Some(pos.head))", "        val negs = lst.filter(_ < 0)\n        val poss =\
    \ lst.filter(_ > 0)\n        if (negs.isEmpty) (None, poss.min)\n        else\
    \ if (poss.isEmpty) (negs.max, None)\n        else (negs.max, poss.min)", "  \
    \      if (lst.length == 0) return (None, None)\n        var maxNegative = None\
    \ : Option[Long]\n        var minPositive = None : Option[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNegative == None)\
    \ maxNegative = Some(i)\n                else maxNegative = Some(max(maxNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (minPositive\
    \ == None) minPositive = Some(i)\n                else minPositive = Some(min(minPositive.get,\
    \ i))\n            }\n        }\n        return (maxNegative, minPositive)", " \
    \       val negs = lst.filter(_ < 0)\n        val poss = lst.filter(_ > 0)\n \
    \       if (negs.isEmpty && poss.isEmpty) (None, None)\n        else if (negs.isEmpty)\
    \ (None, Some(poss.min))\n        else if (poss.isEmpty) (Some(negs.max), None)\n\
    \        else (Some(negs.max), Some(poss.min))", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var largestNegative : Option[Long] = None\n        var smallestPositive :\
    \ Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (largestNegative == None) largestNegative = Some(i)\n      \
    \          else if (i > largestNegative.get) largestNegative = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val neg = lst.filter(_ < 0).sorted\n        val\
    \ pos = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty) None else Some(neg.last),\
    \ if (pos.isEmpty) None else Some(pos.head))", "        var largestNegative :\
    \ Option[Long] = None\n        var smallestPositive : Option[Long] = None\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var min = None : Option[Long]\n        var max = None : Option[Long]\n  \
    \      for (i <- lst) {\n            if (i > 0) {\n                if (min ==\
    \ None) min = Some(i)\n                else min = Some(min.get min i)\n      \
    \      }\n            else if (i < 0) {\n                if (max == None) max\
    \ = Some(i)\n                else max = Some(max.get max i)\n            }\n \
    \       }\n        (max, min)", "        val negatives = lst.filter(_ < 0)\n \
    \       val positives = lst.filter(_ > 0)\n        (if (negatives.isEmpty) None\
    \ else Some(negatives.max), if (positives.isEmpty) None else Some(positives.min))",
  "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else largestNegative = Some(max(largestNegative.get, i))\n      \
    \      }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        val (neg, pos)\
    \ = lst.partition(_ < 0)\n        (if (neg.isEmpty) None else Some(neg.max), if\
    \ (pos.isEmpty) None else Some(pos.min))", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    val neg = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n\
    \        (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty) None else\
    \ Some(pos.head))", "        var largestNegative : Option[Long] = None\n     \
    \   var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n   \
    \         if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        val neg = lst.filter(_\
    \ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n        if (neg.isEmpty)\
    \ (None, if (pos.isEmpty) None else Some(pos.head))\n        else if (pos.isEmpty)\
    \ (Some(neg.last), None)\n        else (Some(neg.last), Some(pos.head))", "  \
    \      var maxNegative : Option[Long] = None\n        var minPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (maxNegative == None || i > maxNegative.get) maxNegative = Some(i)\n    \
    \        } else if (i > 0) {\n                if (minPositive == None || i < minPositive.get)\
    \ minPositive = Some(i)\n            }\n        }\n        (maxNegative, minPositive)",
  "        val negative = lst.filter(_ < 0).sortWith(_ > _)\n        val positive\
    \ = lst.filter(_ > 0).sortWith(_ < _)\n        val largestNegative = if (negative.isEmpty)\
    \ None else Some(negative.head)\n        val smallestPositive = if (positive.isEmpty)\
    \ None else Some(positive.head)\n        (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        val negative = lst.filter(_ < 0).sortWith(_ > _)\n\
    \        val positive = lst.filter(_ > 0).sortWith(_ < _)\n        if (negative.isEmpty)\
    \ (None, if (positive.isEmpty) None else Some(positive.head))\n        else if\
    \ (positive.isEmpty) (Some(negative.head), None)\n        else (Some(negative.head),\
    \ Some(positive.head))", "        var min = None : Option[Long]\n        var max\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i > 0) {\n\
    \                if (min == None) min = Some(i)\n                else if (i <\
    \ min.get) min = Some(i)\n            }\n            else if (i < 0) {\n     \
    \           if (max == None) max = Some(i)\n                else if (i > max.get)\
    \ max = Some(i)\n            }\n        }\n        (max, min)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        var min = Option.empty[Long]\n        var max = Option.empty[Long]\n  \
    \      for (x <- lst) {\n            if (x > 0) {\n                if (min.isEmpty\
    \ || x < min.get) min = Some(x)\n            } else if (x < 0) {\n           \
    \     if (max.isEmpty || x > max.get) max = Some(x)\n            }\n        }\n\
    \        (max, min)", "        val (neg, pos) = lst.partition(_ < 0)\n       \
    \ (if (neg.isEmpty) None else Some(neg.max), if (pos.isEmpty) None else Some(pos.min))",
  "        var maxNeg : Option[Long] = None\n        var minPos : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg\
    \ == None || i > maxNeg.get) maxNeg = Some(i)\n            } else if (i > 0) {\n\
    \                if (minPos == None || i < minPos.get) minPos = Some(i)\n    \
    \        }\n        }\n        (maxNeg, minPos)", "        val negative = lst.filter(_\
    \ < 0).sorted\n        val positive = lst.filter(_ > 0).sorted\n        (negative.lastOption,\
    \ positive.headOption)", "        val negatives = lst.filter(x => x < 0)\n   \
    \     val positives = lst.filter(x => x > 0)\n        if (negatives.isEmpty) (None,\
    \ positives.min)\n        else if (positives.isEmpty) (negatives.max, None)\n\
    \        else (negatives.max, positives.min)", "        var largestNegative =\
    \ None : Option[Long]\n        var smallestPositive = None : Option[Long]\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val negative = lst.filter(_ < 0).sorted\n     \
    \   val positive = lst.filter(_ > 0).sorted\n        (if (negative.isEmpty) None\
    \ else Some(negative.last), if (positive.isEmpty) None else Some(positive.head))",
  "        var maxNeg : Option[Long] = None\n        var minPos : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg\
    \ == None || i > maxNeg.get) maxNeg = Some(i)\n            } else if (i > 0) {\n\
    \                if (minPos == None || i < minPos.get) minPos = Some(i)\n    \
    \        }\n        }\n        (maxNeg, minPos)", "        var largestNegative\
    \ = None : Option[Long]\n        var smallestPositive = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    val min = lst.filter(_ > 0).min\n        val max = lst.filter(_ < 0).max\n\
    \        (if (max == Long.MinValue) None else Some(max), if (min == Long.MaxValue)\
    \ None else Some(min))", "        var largestNegative : Option[Long] = None\n\
    \        var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        return\
    \ (largestNegative, smallestPositive)", "        val negatives = lst.filter(_\
    \ < 0)\n        val positives = lst.filter(_ > 0)\n        val largestNegative\
    \ = if (negatives.isEmpty) None else Some(negatives.max)\n        val smallestPositive\
    \ = if (positives.isEmpty) None else Some(positives.min)\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (x <- lst) {\n \
    \           if (x < 0) {\n                if (largestNegative == None || x > largestNegative.get)\
    \ largestNegative = Some(x)\n            } else if (x > 0) {\n               \
    \ if (smallestPositive == None || x < smallestPositive.get) smallestPositive =\
    \ Some(x)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ = None : Option[Long]\n        var smallestPositive = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        var min = None : Option[Long]\n        var max = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i > 0) {\n                if (min ==\
    \ None) min = Some(i)\n                else min = Some(min.get min i)\n      \
    \      }\n            else if (i < 0) {\n                if (max == None) max\
    \ = Some(i)\n                else max = Some(max.get max i)\n            }\n \
    \       }\n        (max, min)", "        // Fill in the code here\n        return\
    \ (None, None)", "        var largestNegative : Option[Long] = None\n        var\
    \ smallestPositive : Option[Long] = None\n        for (i <- lst) {\n         \
    \   if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var maxNeg :\
    \ Option[Long] = None\n        var minPos : Option[Long] = None\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNeg == None || i\
    \ > maxNeg.get) maxNeg = Some(i)\n            } else if (i > 0) {\n          \
    \      if (minPos == None || i < minPos.get) minPos = Some(i)\n            }\n\
    \        }\n        return (maxNeg, minPos)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var largestNegative : Option[Long] = None\n        var smallestPositive :\
    \ Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (largestNegative == None) largestNegative = Some(i)\n      \
    \          else if (i > largestNegative.get) largestNegative = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        return (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var largestNegative : Option[Long] = None\n        var smallestPositive :\
    \ Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (largestNegative == None) largestNegative = Some(i)\n      \
    \          else if (i > largestNegative.get) largestNegative = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        if (lst.isEmpty)\
    \ return (None, None)\n        var maxNeg : Option[Long] = None\n        var minPos\
    \ : Option[Long] = None\n        for (x <- lst) {\n            if (x < 0) {\n\
    \                if (maxNeg == None || x > maxNeg.get) maxNeg = Some(x)\n    \
    \        } else if (x > 0) {\n                if (minPos == None || x < minPos.get)\
    \ minPos = Some(x)\n            }\n        }\n        return (maxNeg, minPos)",
  "        val negs = lst.filter(_ < 0)\n        val poss = lst.filter(_ > 0)\n  \
    \      (if (negs.isEmpty) None else Some(negs.max), if (poss.isEmpty) None else\
    \ Some(poss.min))", "        var largestNegative : Option[Long] = None\n     \
    \   var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n   \
    \         if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val negs = lst.filter(_ < 0)\n        val poss\
    \ = lst.filter(_ > 0)\n        val neg = if (negs.isEmpty) None else Some(negs.max)\n\
    \        val pos = if (poss.isEmpty) None else Some(poss.min)\n        (neg, pos)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative = None : Option[Long]\n   \
    \     var smallestPositive = None : Option[Long]\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        val neg = lst.filter(_\
    \ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty)\
    \ None else Some(neg.last), if (pos.isEmpty) None else Some(pos.head))", "   \
    \     var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else largestNegative = Some(max(largestNegative.get, i))\n      \
    \      }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative = None : Option[Long]\n   \
    \     var smallestPositive = None : Option[Long]\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        val negatives\
    \ = lst.filter(_ < 0)\n        val positives = lst.filter(_ > 0)\n        val\
    \ negativeMax = if (negatives.isEmpty) None else Some(negatives.max)\n       \
    \ val positiveMin = if (positives.isEmpty) None else Some(positives.min)\n   \
    \     (negativeMax, positiveMin)", "        var largestNegative = None : Option[Long]\n\
    \        var smallestPositive = None : Option[Long]\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (x <- lst) {\n            if (x < 0) {\n                if (largestNegative\
    \ == None || x > largestNegative.get) largestNegative = Some(x)\n            }\
    \ else if (x > 0) {\n                if (smallestPositive == None || x < smallestPositive.get)\
    \ smallestPositive = Some(x)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val negative = lst.filter(_ < 0).sortWith(_ > _)\n\
    \        val positive = lst.filter(_ > 0).sortWith(_ < _)\n        val largest\
    \ = if (negative.isEmpty) None else Some(negative.head)\n        val smallest\
    \ = if (positive.isEmpty) None else Some(positive.head)\n        (largest, smallest)",
  "        val neg = lst.filter(x => x < 0).sorted\n        val pos = lst.filter(x\
    \ => x > 0).sorted\n        (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty)\
    \ None else Some(pos.head))", "        var largestNegative : Option[Long] = None\n\
    \        var smallestPositive : Option[Long] = None\n        for (x <- lst) {\n\
    \            if (x < 0) {\n                if (largestNegative == None || x >\
    \ largestNegative.get) largestNegative = Some(x)\n            } else if (x > 0)\
    \ {\n                if (smallestPositive == None || x < smallestPositive.get)\
    \ smallestPositive = Some(x)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var maxNeg : Option[Long] = None\n        var minPos\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (maxNeg == None || i > maxNeg.get) maxNeg = Some(i)\n    \
    \        } else if (i > 0) {\n                if (minPos == None || i < minPos.get)\
    \ minPos = Some(i)\n            }\n        }\n        (maxNeg, minPos)", "   \
    \     val neg = lst.filter(x => x < 0).sorted\n        val pos = lst.filter(x\
    \ => x > 0).sorted\n        (if (neg.length == 0) None else Some(neg.last), if\
    \ (pos.length == 0) None else Some(pos.head))", "        val neg = lst.filter(_\
    \ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty)\
    \ None else Some(neg.last), if (pos.isEmpty) None else Some(pos.head))", "   \
    \     var largestNegative = Option.empty[Long]\n        var smallestPositive =\
    \ Option.empty[Long]\n        for (i <- lst) {\n            if (i < 0) {\n   \
    \             if (largestNegative.isEmpty || largestNegative.get < i) largestNegative\
    \ = Some(i)\n            } else if (i > 0) {\n                if (smallestPositive.isEmpty\
    \ || smallestPositive.get > i) smallestPositive = Some(i)\n            }\n   \
    \     }\n        (largestNegative, smallestPositive)", "        val (neg, pos)\
    \ = lst.partition(_ < 0)\n        val largestNeg = if (neg.isEmpty) None else\
    \ Some(neg.max)\n        val smallestPos = if (pos.isEmpty) None else Some(pos.min)\n\
    \        (largestNeg, smallestPos)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val neg = lst.filter(x => x < 0).sorted\n     \
    \   val pos = lst.filter(x => x > 0).sorted\n        if (neg.isEmpty) (None, if\
    \ (pos.isEmpty) None else Some(pos.head))\n        else if (pos.isEmpty) (Some(neg.last),\
    \ None)\n        else (Some(neg.last), Some(pos.head))", "        var min = Long.MaxValue\n\
    \        var max = Long.MinValue\n        for (i <- lst) {\n            if (i\
    \ > 0) {\n                if (i < min) min = i\n            } else if (i < 0)\
    \ {\n                if (i > max) max = i\n            }\n        }\n        if\
    \ (min == Long.MaxValue) min = 0\n        if (max == Long.MinValue) max = 0\n\
    \        return (if (max == 0) None else Some(max), if (min == 0) None else Some(min))",
  "        val neg = lst.filter(_ < 0).sortWith(_ > _)\n        val pos = lst.filter(_\
    \ > 0).sortWith(_ < _)\n        val a = if (neg.isEmpty) None else Some(neg.head)\n\
    \        val b = if (pos.isEmpty) None else Some(pos.head)\n        (a, b)", " \
    \       val neg = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n\
    \        (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty) None else\
    \ Some(pos.head))", "        val neg = lst.filter(_ < 0).sorted\n        val pos\
    \ = lst.filter(_ > 0).sorted\n        if (neg.length == 0) (None, if (pos.length\
    \ == 0) None else Some(pos.head))\n        else if (pos.length == 0) (Some(neg.last),\
    \ None)\n        else (Some(neg.last), Some(pos.head))", "        var min = Option.empty[Long]\n\
    \        var max = Option.empty[Long]\n        for (i <- lst) {\n            if\
    \ (i > 0) {\n                if (min.isEmpty || i < min.get) min = Some(i)\n \
    \           } else if (i < 0) {\n                if (max.isEmpty || i > max.get)\
    \ max = Some(i)\n            }\n        }\n        (max, min)", "        if (lst.isEmpty)\
    \ return (None, None)\n        var maxNeg = None : Option[Long]\n        var minPos\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (maxNeg == None) maxNeg = Some(i)\n                else maxNeg\
    \ = Some(max(maxNeg.get, i))\n            }\n            else if (i > 0) {\n \
    \               if (minPos == None) minPos = Some(i)\n                else minPos\
    \ = Some(min(minPos.get, i))\n            }\n        }\n        return (maxNeg,\
    \ minPos)", "        val (neg, pos) = lst.partition(_ < 0)\n        (if (neg.isEmpty)\
    \ None else Some(neg.max), if (pos.isEmpty) None else Some(pos.min))", "     \
    \   var largestNegative : Option[Long] = None\n        var smallestPositive :\
    \ Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (largestNegative == None) largestNegative = Some(i)\n      \
    \          else if (i > largestNegative.get) largestNegative = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        return\
    \ (largestNegative, smallestPositive)", "        val negatives = lst.filter(_\
    \ < 0)\n        val positives = lst.filter(_ > 0)\n        val largestNegative\
    \ = if (negatives.isEmpty) None else Some(negatives.max)\n        val smallestPositive\
    \ = if (positives.isEmpty) None else Some(positives.min)\n        (largestNegative,\
    \ smallestPositive)", "        val negatives = lst.filter(x => x < 0)\n      \
    \  val positives = lst.filter(x => x > 0)\n        val largestNegative = if (negatives.isEmpty)\
    \ None else Some(negatives.max)\n        val smallestPositive = if (positives.isEmpty)\
    \ None else Some(positives.min)\n        (largestNegative, smallestPositive)",
  "        val negatives = lst.filter(_ < 0)\n        val positives = lst.filter(_\
    \ > 0)\n        val largestNegative = if (negatives.isEmpty) None else Some(negatives.max)\n\
    \        val smallestPositive = if (positives.isEmpty) None else Some(positives.min)\n\
    \        (largestNegative, smallestPositive)", "        val negatives = lst.filter(_\
    \ < 0)\n        val positives = lst.filter(_ > 0)\n        val largestNegative\
    \ = if (negatives.length > 0) Some(negatives.max) else None\n        val smallestPositive\
    \ = if (positives.length > 0) Some(positives.min) else None\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var min = Option.empty[Long]\n        var max = Option.empty[Long]\n    \
    \    for (i <- lst) {\n            if (i > 0) {\n                if (min.isEmpty\
    \ || i < min.get) min = Some(i)\n            } else if (i < 0) {\n           \
    \     if (max.isEmpty || i > max.get) max = Some(i)\n            }\n        }\n\
    \        (max, min)", "        var min = Option.empty[Long]\n        var max =\
    \ Option.empty[Long]\n        for (i <- lst) {\n            if (i > 0) {\n   \
    \             if (min.isEmpty || i < min.get) min = Some(i)\n            } else\
    \ if (i < 0) {\n                if (max.isEmpty || i > max.get) max = Some(i)\n\
    \            }\n        }\n        (max, min)", "        var largestNegative =\
    \ None : Option[Long]\n        var smallestPositive = None : Option[Long]\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        var min = None : Option[Long]\n        var max = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i > 0) {\n                if (min ==\
    \ None) min = Some(i)\n                else if (i < min.get) min = Some(i)\n \
    \           }\n            else if (i < 0) {\n                if (max == None)\
    \ max = Some(i)\n                else if (i > max.get) max = Some(i)\n       \
    \     }\n        }\n        (max, min)", "        var maxNeg = None : Option[Long]\n\
    \        var minPos = None : Option[Long]\n        for (i <- lst) {\n        \
    \    if (i < 0) {\n                if (maxNeg == None || i > maxNeg.get) maxNeg\
    \ = Some(i)\n            } else if (i > 0) {\n                if (minPos == None\
    \ || i < minPos.get) minPos = Some(i)\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        var min = None : Option[Long]\n        var max = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i > 0) {\n                if (min ==\
    \ None) min = Some(i)\n                else if (i < min.get) min = Some(i)\n \
    \           }\n            else if (i < 0) {\n                if (max == None)\
    \ max = Some(i)\n                else if (i > max.get) max = Some(i)\n       \
    \     }\n        }\n        return (max, min)", "        var maxNeg : Option[Long]\
    \ = None\n        var minPos : Option[Long] = None\n        for (x <- lst) {\n\
    \            if (x < 0) {\n                if (maxNeg == None || x > maxNeg.get)\
    \ maxNeg = Some(x)\n            } else if (x > 0) {\n                if (minPos\
    \ == None || x < minPos.get) minPos = Some(x)\n            }\n        }\n    \
    \    (maxNeg, minPos)", "        var largestNegative : Option[Long] = None\n \
    \       var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val negative = lst.filter(_ < 0).sorted\n     \
    \   val positive = lst.filter(_ > 0).sorted\n        (if (negative.length > 0)\
    \ Some(negative.last) else None, if (positive.length > 0) Some(positive.head)\
    \ else None)", "        var largestNegative : Option[Long] = None\n        var\
    \ smallestPositive : Option[Long] = None\n        for (i <- lst) {\n         \
    \   if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val neg = lst.filter(_ < 0).sorted\n        val\
    \ pos = lst.filter(_ > 0).sorted\n        if (neg.isEmpty && pos.isEmpty) (None,\
    \ None)\n        else if (neg.isEmpty) (None, Some(pos.head))\n        else if\
    \ (pos.isEmpty) (Some(neg.last), None)\n        else (Some(neg.last), Some(pos.head))",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        var largestNegative = None : Option[Long]\n   \
    \     var smallestPositive = None : Option[Long]\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    val negatives = lst.filter(_ < 0)\n        val positives = lst.filter(_ >\
    \ 0)\n        val largestNegative = if (negatives.isEmpty) None else Some(negatives.max)\n\
    \        val smallestPositive = if (positives.isEmpty) None else Some(positives.min)\n\
    \        (largestNegative, smallestPositive)", "        var largestNegative :\
    \ Option[Long] = None\n        var smallestPositive : Option[Long] = None\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        return\
    \ (largestNegative, smallestPositive)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var min = None : Option[Long]\n        var max = None : Option[Long]\n  \
    \      for (i <- lst) {\n            if (i > 0) {\n                if (min ==\
    \ None) min = Some(i)\n                else if (i < min.get) min = Some(i)\n \
    \           }\n            else if (i < 0) {\n                if (max == None)\
    \ max = Some(i)\n                else if (i > max.get) max = Some(i)\n       \
    \     }\n        }\n        (max, min)", "        var min = None : Option[Long]\n\
    \        var max = None : Option[Long]\n        for (i <- lst) {\n           \
    \ if (i > 0) {\n                if (min == None) min = Some(i)\n             \
    \   else min = Some(min.get min i)\n            }\n            else if (i < 0)\
    \ {\n                if (max == None) max = Some(i)\n                else max\
    \ = Some(max.get max i)\n            }\n        }\n        (max, min)", "    \
    \    val (neg, pos) = lst.partition(_ < 0)\n        (if (neg.isEmpty) None else\
    \ Some(neg.max), if (pos.isEmpty) None else Some(pos.min))", "        val negatives\
    \ = lst.filter(_ < 0)\n        val positives = lst.filter(_ > 0)\n        val\
    \ largestNegative = if (negatives.isEmpty) None else Some(negatives.max)\n   \
    \     val smallestPositive = if (positives.isEmpty) None else Some(positives.min)\n\
    \        (largestNegative, smallestPositive)", "        var largestNegative :\
    \ Option[Long] = None\n        var smallestPositive : Option[Long] = None\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    val (neg, pos) = lst.partition(_ < 0)\n        (if (neg.isEmpty) None else\
    \ Some(neg.max), if (pos.isEmpty) None else Some(pos.min))", "        var max\
    \ = None : Option[Long]\n        var min = None : Option[Long]\n        for (i\
    \ <- lst) {\n            if (i > 0) {\n                if (min == None || i <\
    \ min.get) min = Some(i)\n            } else if (i < 0) {\n                if\
    \ (max == None || i > max.get) max = Some(i)\n            }\n        }\n     \
    \   (max, min)", "        var maxNeg = None : Option[Long]\n        var minPos\
    \ = None : Option[Long]\n        for (x <- lst) {\n            if (x < 0) {\n\
    \                if (maxNeg == None || x > maxNeg.get) maxNeg = Some(x)\n    \
    \        } else if (x > 0) {\n                if (minPos == None || x < minPos.get)\
    \ minPos = Some(x)\n            }\n        }\n        return (maxNeg, minPos)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        var min = None : Option[Long]\n        var max\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i > 0) {\n\
    \                if (min == None) min = Some(i)\n                else min = Some(min.get\
    \ min i)\n            }\n            else if (i < 0) {\n                if (max\
    \ == None) max = Some(i)\n                else max = Some(max.get max i)\n   \
    \         }\n        }\n        (max, min)", "        var min = Option.empty[Long]\n\
    \        var max = Option.empty[Long]\n        for (x <- lst) {\n            if\
    \ (x > 0) {\n                if (min.isEmpty || x < min.get) min = Some(x)\n \
    \           } else if (x < 0) {\n                if (max.isEmpty || x > max.get)\
    \ max = Some(x)\n            }\n        }\n        (max, min)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        return\
    \ (largestNegative, smallestPositive)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        return\
    \ (largestNegative, smallestPositive)", "        val negs = lst.filter(_ < 0)\n\
    \        val poss = lst.filter(_ > 0)\n        val neg = if (negs.isEmpty) None\
    \ else Some(negs.max)\n        val pos = if (poss.isEmpty) None else Some(poss.min)\n\
    \        (neg, pos)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (x <- lst) {\n \
    \           if (x < 0) {\n                if (largestNegative == None || x > largestNegative.get)\
    \ largestNegative = Some(x)\n            } else if (x > 0) {\n               \
    \ if (smallestPositive == None || x < smallestPositive.get) smallestPositive =\
    \ Some(x)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        val negative = lst.filter(_ < 0).sortWith(_ > _)\n        val positive\
    \ = lst.filter(_ > 0).sortWith(_ < _)\n        (if (negative.isEmpty) None else\
    \ Some(negative.head), if (positive.isEmpty) None else Some(positive.head))",
  "        val neg = lst.filter(x => x < 0).sortWith(_ > _)\n        val pos = lst.filter(x\
    \ => x > 0).sortWith(_ < _)\n        if (neg.length == 0) (None, if (pos.length\
    \ == 0) None else Some(pos(0)))\n        else if (pos.length == 0) (Some(neg(0)),\
    \ None)\n        else (Some(neg(0)), Some(pos(0)))", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var largestNegative = None : Option[Long]\n        var smallestPositive =\
    \ None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (largestNegative == None) largestNegative = Some(i)\n      \
    \          else if (i > largestNegative.get) largestNegative = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val negatives = lst.filter(_ < 0)\n        val\
    \ positives = lst.filter(_ > 0)\n        val largestNegative = if (negatives.isEmpty)\
    \ None else Some(negatives.max)\n        val smallestPositive = if (positives.isEmpty)\
    \ None else Some(positives.min)\n        (largestNegative, smallestPositive)",
  "        var maxNeg = None : Option[Long]\n        var minPos = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg\
    \ == None || i > maxNeg.get) maxNeg = Some(i)\n            } else if (i > 0) {\n\
    \                if (minPos == None || i < minPos.get) minPos = Some(i)\n    \
    \        }\n        }\n        (maxNeg, minPos)", "        var min = None : Option[Long]\n\
    \        var max = None : Option[Long]\n        for (i <- lst) {\n           \
    \ if (i > 0) {\n                if (min == None) min = Some(i)\n             \
    \   else if (i < min.get) min = Some(i)\n            }\n            else if (i\
    \ < 0) {\n                if (max == None) max = Some(i)\n                else\
    \ if (i > max.get) max = Some(i)\n            }\n        }\n        (max, min)",
  "        var maxNeg = None : Option[Long]\n        var minPos = None : Option[Long]\n\
    \        for (x <- lst) {\n            if (x < 0) {\n                if (maxNeg\
    \ == None || x > maxNeg.get) maxNeg = Some(x)\n            } else if (x > 0) {\n\
    \                if (minPos == None || x < minPos.get) minPos = Some(x)\n    \
    \        }\n        }\n        (maxNeg, minPos)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var largestNegative : Option[Long] = None\n        var smallestPositive :\
    \ Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (largestNegative == None) largestNegative = Some(i)\n      \
    \          else largestNegative = Some(max(largestNegative.get, i))\n        \
    \    }\n            else if (i > 0) {\n                if (smallestPositive ==\
    \ None) smallestPositive = Some(i)\n                else smallestPositive = Some(min(smallestPositive.get,\
    \ i))\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val (neg, pos) = lst.partition(_ < 0)\n       \
    \ (if (neg.isEmpty) None else Some(neg.max), if (pos.isEmpty) None else Some(pos.min))",
  "        val neg = lst.filter(x => x < 0).sorted\n        val pos = lst.filter(x\
    \ => x > 0).sorted\n        if (neg.length == 0) (None, if (pos.length == 0) None\
    \ else Some(pos(0)))\n        else if (pos.length == 0) (Some(neg(neg.length -\
    \ 1)), None)\n        else (Some(neg(neg.length - 1)), Some(pos(0)))", "     \
    \   val negatives = lst.filter(x => x < 0)\n        val positives = lst.filter(x\
    \ => x > 0)\n        val largestNegative = if (negatives.isEmpty) None else Some(negatives.max)\n\
    \        val smallestPositive = if (positives.isEmpty) None else Some(positives.min)\n\
    \        (largestNegative, smallestPositive)", "        var largestNegative :\
    \ Option[Long] = None\n        var smallestPositive : Option[Long] = None\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var largestNegative = None : Option[Long]\n        var smallestPositive =\
    \ None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (largestNegative == None) largestNegative = Some(i)\n      \
    \          else if (i > largestNegative.get) largestNegative = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var min = Option.empty[Long]\n\
    \        var max = Option.empty[Long]\n        for (i <- lst) {\n            if\
    \ (i > 0) {\n                if (min.isEmpty || i < min.get) min = Some(i)\n \
    \           } else if (i < 0) {\n                if (max.isEmpty || i > max.get)\
    \ max = Some(i)\n            }\n        }\n        (max, min)", "        val negatives\
    \ = lst.filter(x => x < 0)\n        val positives = lst.filter(x => x > 0)\n \
    \       val largestNegative = if (negatives.isEmpty) None else Some(negatives.max)\n\
    \        val smallestPositive = if (positives.isEmpty) None else Some(positives.min)\n\
    \        (largestNegative, smallestPositive)", "        val negatives = lst.filter(_\
    \ < 0)\n        val positives = lst.filter(_ > 0)\n        (if (negatives.isEmpty)\
    \ None else Some(negatives.max), if (positives.isEmpty) None else Some(positives.min))",
  "        val negative = lst.filter(_ < 0).sortWith(_ > _)\n        val positive\
    \ = lst.filter(_ > 0).sortWith(_ < _)\n        (if (negative.isEmpty) None else\
    \ Some(negative.head), if (positive.isEmpty) None else Some(positive.head))"]
stop_tokens:
- "\n    }\n"
