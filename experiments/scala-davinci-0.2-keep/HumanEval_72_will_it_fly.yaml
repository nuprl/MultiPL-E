name: HumanEval_72_will_it_fly
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that returns True if the object q will fly, and False otherwise.\n\
  \    // The object q will fly if it's balanced (it is a palindromic list) and the\
  \ sum of its elements is less than or equal the maximum possible weight w.\n   \
  \ // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n    // # 1+2 is less\
  \ than the maximum possible weight, but it's unbalanced.\n    // will_it_fly([3,\
  \ 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3 is more than the maximum\
  \ possible weight.\n    // will_it_fly([3, 2, 3], 9) \u279E True\n    // # 3+2+3\
  \ is less than the maximum possible weight, and it's balanced.\n    // will_it_fly([3],\
  \ 5) \u279E True\n    // # 3 is less than the maximum possible weight, and it's\
  \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
  \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
  \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
  \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
  \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
  \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
  \    }\n\n}\n"
completions: ["        val sum = q.sum\n        val isPalindrome = q.zip(q.reverse).forall(x\
    \ => x._1 == x._2)\n        sum <= w && isPalindrome", "        val sum = q.sum\n\
    \        val isBalanced = q == q.reverse\n        sum <= w && isBalanced", " \
    \       val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced", "        val sum = q.sum\n        if (sum > w) return false\n\
    \        val half = q.length / 2\n        val firstHalf = q.slice(0, half)\n \
    \       val secondHalf = q.slice(half, q.length)\n        val reversedSecondHalf\
    \ = secondHalf.reverse\n        if (firstHalf == reversedSecondHalf) return true\n\
    \        return false", '        if (q.sum <= w && q == q.reverse) true else false',
  "        val sum = q.sum\n        if (sum > w) return false\n        val q_rev =\
    \ q.reverse\n        for (i <- 0 until q.length) {\n            if (q(i) != q_rev(i))\
    \ return false\n        }\n        return true", '        if (q.sum <= w && q
    == q.reverse) true else false', "        val sum = q.sum\n        val isBalanced\
    \ = q == q.reverse\n        sum <= w && isBalanced", "        val sum = q.sum\n\
    \        val isBalanced = q == q.reverse\n        sum <= w && isBalanced", " \
    \       val sum = q.sum\n        if (sum > w) return false\n        val half =\
    \ q.length / 2\n        val left = q.slice(0, half)\n        val right = q.slice(half,\
    \ q.length)\n        if (q.length % 2 == 1) right.tail.reverse == left else right.reverse\
    \ == left", '        if (q.sum <= w && q == q.reverse) true else false', "   \
    \     if (q.length == 1) return true\n        if (q.sum <= w && q == q.reverse)\
    \ return true\n        return false", "        val sum = q.sum\n        val max\
    \ = w\n        val isPalindrome = q.equals(q.reverse)\n        if (sum <= max\
    \ && isPalindrome) true else false", "        val sum = q.sum\n        val isPalindrome\
    \ = q.reverse == q\n        sum <= w && isPalindrome", "        val sum = q.sum\n\
    \        if (sum > w) return false\n        val half = q.length / 2\n        for\
    \ (i <- 0 until half) {\n            if (q(i) != q(q.length - 1 - i)) return false\n\
    \        }\n        return true", "        val sum = q.sum\n        val isPalindrome\
    \ = q.reverse == q\n        sum <= w && isPalindrome", "        val sum = q.sum\n\
    \        val palindrome = q.reverse == q\n        sum <= w && palindrome", " \
    \       val sum = q.sum\n        if (sum > w) return false\n        val half =\
    \ q.length / 2\n        val left = q.slice(0, half)\n        val right = q.slice(half,\
    \ q.length)\n        if (q.length % 2 == 1) right.tail else right\n        left\
    \ == right.reverse", "        if (q.length == 1) return true\n        if (q.length\
    \ % 2 == 0) return false\n        if (q.sum <= w) {\n            val half = q.length\
    \ / 2\n            val firstHalf = q.slice(0, half)\n            val secondHalf\
    \ = q.slice(half + 1, q.length)\n            if (firstHalf == secondHalf.reverse)\
    \ return true\n        }\n        return false", '        if (q.sum <= w && q
    == q.reverse) true else false']
stop_tokens:
- "\n    }\n"
