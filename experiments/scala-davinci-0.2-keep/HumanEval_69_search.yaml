name: HumanEval_69_search
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a non-empty list of positive integers. Return the greatest\
  \ integer that is greater than \n    // zero, and has a frequency greater than or\
  \ equal to the value of the integer itself. \n    // The frequency of an integer\
  \ is the number of times it appears in the list.\n    // If no such a value exist,\
  \ return -1.\n    // Examples:\n    // search([4, 1, 2, 2, 3, 1]) == 2\n    // search([1,\
  \ 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n    // search([5, 5, 4, 4, 4]) == -1\n    def search(lst\
  \ : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(search((List[Long](5l.toLong,\
  \ 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));\n    assert(search((List[Long](4l.toLong,\
  \ 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](3l.toLong,\
  \ 3l.toLong))) == (-1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong,\
  \ 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));\n    assert(search((List[Long](2l.toLong,\
  \ 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](2l.toLong,\
  \ 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong,\
  \ 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));\n\
  \    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) ==\
  \ (2l));\n    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong,\
  \ 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong,\
  \ 7l.toLong, 9l.toLong))) == (1l));\n    assert(search((List[Long](1l.toLong, 9l.toLong,\
  \ 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong,\
  \ 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong,\
  \ 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (5l));\n    assert(search((List[Long](1l.toLong))) == (1l));\n    assert(search((List[Long](8l.toLong,\
  \ 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong,\
  \ 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong,\
  \ 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
  \ 5l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong,\
  \ 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong,\
  \ 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong,\
  \ 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong,\
  \ 3l.toLong))) == (1l));\n    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong,\
  \ 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong,\
  \ 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong,\
  \ 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong,\
  \ 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong,\
  \ 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong,\
  \ 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong)))\
  \ == (4l));\n    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong,\
  \ 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong,\
  \ 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong,\
  \ 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong,\
  \ 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong,\
  \ 10l.toLong, 8l.toLong))) == (-1l));\n    assert(search((List[Long](10l.toLong)))\
  \ == (-1l));\n    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong,\
  \ 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong,\
  \ 7l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](5l.toLong, 4l.toLong,\
  \ 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong,\
  \ 1l.toLong, 8l.toLong))) == (1l));\n    assert(search((List[Long](7l.toLong, 9l.toLong,\
  \ 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong,\
  \ 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong,\
  \ 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));\n    assert(search((List[Long](3l.toLong,\
  \ 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));\n    }\n\n}\n"
completions: ["        val freq = lst.groupBy(identity).mapValues(_.size)\n      \
    \  val max = freq.keys.max\n        if (freq(max) >= max) max else -1", "    \
    \    val freq = lst.groupBy(identity).mapValues(_.size)\n        val max = freq.keys.max\n\
    \        if (freq(max) >= max) max else -1", "        val freq = lst.groupBy(identity).mapValues(_.size)\n\
    \        val max = freq.keys.max\n        if (freq(max) >= max) max else -1",
  "        val map = new HashMap[Long, Long]\n        for (e <- lst) {\n         \
    \   if (map.contains(e)) map(e) += 1\n            else map(e) = 1\n        }\n\
    \        var result = -1L\n        for (e <- lst) {\n            if (map(e) >=\
    \ e && e > result) result = e\n        }\n        result", "        val map =\
    \ new HashMap[Long, Long]\n        for (i <- lst) {\n            if (map.contains(i))\
    \ map(i) += 1 else map(i) = 1\n        }\n        val sorted = map.toList.sortBy(_._1)\n\
    \        for (i <- sorted) {\n            if (i._1 <= i._2) return i._1\n    \
    \    }\n        return -1", "        val freq = lst.groupBy(identity).mapValues(_.size)\n\
    \        val maxFreq = freq.values.max\n        val maxFreqKeys = freq.filter(x\
    \ => x._2 == maxFreq).keys\n        val maxFreqKey = maxFreqKeys.max\n       \
    \ if (maxFreq >= maxFreqKey) maxFreqKey else -1", "        val freq = lst.groupBy(identity).mapValues(_.size)\n\
    \        val maxFreq = freq.values.max\n        val maxFreqKeys = freq.filter(_._2\
    \ == maxFreq).keys\n        if (maxFreqKeys.exists(freq(_) >= _)) maxFreqKeys.max\
    \ else -1", "        val freq = new HashMap[Long, Long]\n        for (x <- lst)\
    \ {\n            if (freq.contains(x)) freq(x) += 1\n            else freq(x)\
    \ = 1\n        }\n        for (x <- lst) {\n            if (freq(x) >= x) return\
    \ x\n        }\n        return -1", "        val map = new HashMap[Long, Long]\n\
    \        for (x <- lst) {\n            if (map.contains(x)) map(x) += 1\n    \
    \        else map(x) = 1\n        }\n        var max = -1L\n        for (x <-\
    \ map.keys) {\n            if (x <= map(x) && x > max) max = x\n        }\n  \
    \      max", "        val map = new HashMap[Long, Long]\n        for (i <- lst)\
    \ {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n\
    \        }\n        var max = -1L\n        for (i <- map.keys) {\n           \
    \ if (i <= map(i) && i > max) max = i\n        }\n        max", "        val m\
    \ = lst.groupBy(x => x).mapValues(_.size)\n        val max = m.keys.max\n    \
    \    val maxFreq = m(max)\n        if (maxFreq >= max) max else -1", "       \
    \ val map = new HashMap[Long, Long]\n        for (i <- lst) {\n            if\
    \ (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n    \
    \    var max = -1L\n        for (i <- map.keys) {\n            if (i <= map(i)\
    \ && i > max) max = i\n        }\n        max", "        val m = lst.groupBy(x\
    \ => x).mapValues(_.size)\n        val max = m.keys.max\n        for (i <- max\
    \ to 1 by -1) {\n            if (m.contains(i) && m(i) >= i) return i\n      \
    \  }\n        return -1", "        val map = HashMap[Long, Long]()\n        for\
    \ (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n            else\
    \ map(i) = 1\n        }\n        var max = -1L\n        for (i <- map.keys) {\n\
    \            if (i <= map(i) && i > max) max = i\n        }\n        max", " \
    \       val map = new HashMap[Long, Long]\n        for (i <- lst) {\n        \
    \    if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n\
    \        var max = -1L\n        for (i <- lst) {\n            if (i > 0 && map(i)\
    \ >= i && i > max) max = i\n        }\n        max", "        val freq = new HashMap[Long,\
    \ Long]()\n        for (i <- lst) {\n            if (freq.contains(i)) freq(i)\
    \ += 1\n            else freq(i) = 1\n        }\n        var max = -1L\n     \
    \   for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max = i\n\
    \        }\n        max", "        val map = new HashMap[Long, Long]\n       \
    \ for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n           \
    \ else map(i) = 1\n        }\n        var max = -1L\n        for (i <- map.keys)\
    \ {\n            if (i <= map(i) && i > max) max = i\n        }\n        max",
  "        var map = Map[Long, Long]()\n        for (i <- lst) {\n            if (map.contains(i))\
    \ map(i) += 1\n            else map(i) = 1\n        }\n        var max = -1L\n\
    \        for (i <- map.keys) {\n            if (i <= map(i) && i > max) max =\
    \ i\n        }\n        return max", "        val freq = new HashMap[Long, Long]\n\
    \        for (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1 else\
    \ freq(i) = 1\n        }\n        var max = -1L\n        for (i <- freq.keys)\
    \ {\n            if (i <= freq(i) && i > max) max = i\n        }\n        max",
  "        val freq = new HashMap[Long, Long]\n        for (x <- lst) {\n        \
    \    if (freq.contains(x)) freq(x) += 1\n            else freq(x) = 1\n      \
    \  }\n        var max = -1L\n        for (x <- freq.keys) {\n            if (x\
    \ <= freq(x) && x > max) max = x\n        }\n        max"]
stop_tokens:
- "\n    }\n"
