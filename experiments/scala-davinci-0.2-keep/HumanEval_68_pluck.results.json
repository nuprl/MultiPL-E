{
  "language": "scala",
  "name": "HumanEval_68_pluck",
  "results": [
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n            List(min, index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        else return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n            List(min, index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n            List(min, index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) List() else List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) return List()\n        return List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n            List(min, index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n            List(min, index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        else return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) return List()\n        return List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List[Long]()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List[Long]()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val minIndex = arr.indexOf(min)\n        List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) List() else List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) return List()\n        return List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) List() else List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n            List(min, index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0) return List[Long]()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List[Long]()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) return List()\n        return List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n            List(min, index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n            List(min, index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n            List(min, index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (min == Long.MaxValue) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n            List(min, index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) return List()\n        return List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var minEven = Long.MaxValue\n        var minEvenIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < minEven) {\n                minEven = arr(i)\n                minEvenIndex = i\n            }\n        }\n        if (minEvenIndex == -1) return List()\n        return List(minEven, minEvenIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) List() else List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var minEven = Long.MaxValue\n        var minEvenIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < minEven) {\n                minEven = arr(i)\n                minEvenIndex = i\n            }\n        }\n        if (minEvenIndex == -1) return List()\n        return List(minEven, minEvenIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val minIndex = arr.indexOf(min)\n        List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        return List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val minEven = evens.min\n            val index = arr.indexOf(minEven)\n            List(minEven, index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        return List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = Long.MaxValue\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (min == Long.MaxValue) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) List() else List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n            List(min, index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val minEven = evens.min\n        val index = arr.indexOf(minEven)\n        List(minEven, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var minEven = Long.MaxValue\n        var minEvenIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < minEven) {\n                minEven = arr(i)\n                minEvenIndex = i\n            }\n        }\n        if (minEvenIndex == -1) List() else List(minEven, minEvenIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798559
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (min == Long.MaxValue) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798559
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) return List()\n        return List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798559
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) return List()\n        return List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798559
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val minIndex = arr.indexOf(min)\n        List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798559
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) return List()\n        return List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List[Long]()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List[Long]()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798559
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) return List()\n        else return List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798559
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) return List()\n        return List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798559
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) List() else List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        // 1. Find the smallest even value in the array\n        // 2. Find the index of the smallest even value\n        // 3. Return the smallest even value and its index\n        // 4. If there are no even values, return []\n        // 5. If the array is empty, return []\n        // 6. If there are multiple nodes with the same smallest even value, return the node that has smallest index\n        // 7. If there are no even values, return []\n        // 8. If the array is empty, return []\n        // 9. If there are multiple nodes with the same smallest even value, return the node that has smallest index\n        // 10. If there are no even values, return []\n        // 11. If the array is empty, return []\n        // 12. If there are multiple nodes with the same smallest even value, return the node that has smallest index\n        // 13. If there are no even values, return []\n        // 14. If the array is empty, return []\n        // 15. If there are multiple nodes with the same smallest even value, return the node that has smallest index\n        // 16. If there are no even values, return []\n        // 17. If the array is empty, return []\n        // 18. If there are multiple nodes with the same smallest even value, return the node that has smallest index\n        // 19. If there are no even values, return []\n        // 20. If the array is empty, return []\n        // 21. If there are multiple nodes with the same smallest even value, return the node that has smallest index\n        // 22. If there are no even values, return []\n        // 23. If the array is empty, return []\n        // 24. If there are multiple nodes with the same smallest even value, return the node that has smallest index\n        // 25. If there are no even values, return []\n        // 26. If the array is empty, return []\n        // 27. If there are multiple nodes with the same smallest even value, return the node that has smallest index\n        // 28. If there are no even values, return []\n        // 29. If the array is empty, return []\n        // 30. If there are multiple nodes with the same smallest even value, return the node that has smallest index\n        // 31. If there are no even values, return []\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpph8eix_d.scala:29:47 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mpluck\u001b[0m(\u001b[36marr\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m]) : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Found:    Unit\n\u001b[31m   |\u001b[0m                                               Required: List[Long]\n\u001b[31m30 |\u001b[0m        \u001b[34m// 1. Find the smallest even value in the array\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[34m// 2. Find the index of the smallest even value\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[34m// 3. Return the smallest even value and its index\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[34m// 4. If there are no even values, return []\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[34m// 5. If the array is empty, return []\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[34m// 6. If there are multiple nodes with the same smallest even value, return the node that has smallest index\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[34m// 7. If there are no even values, return []\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[34m// 8. If the array is empty, return []\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[34m// 9. If there are multiple nodes with the same smallest even value, return the node that has smallest index\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[34m// 10. If there are no even values, return []\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[34m// 11. If the array is empty, return []\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[34m// 12. If there are multiple nodes with the same smallest even value, return the node that has smallest index\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[34m// 13. If there are no even values, return []\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[34m// 14. If the array is empty, return []\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[34m// 15. If there are multiple nodes with the same smallest even value, return the node that has smallest index\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[34m// 16. If there are no even values, return []\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[34m// 17. If the array is empty, return []\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[34m// 18. If there are multiple nodes with the same s",
      "stdout": "",
      "timestamp": 1659798559
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) List() else List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var minEven = Long.MaxValue\n        var minEvenIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < minEven) {\n                minEven = arr(i)\n                minEvenIndex = i\n            }\n        }\n        if (minEvenIndex == -1) return List()\n        return List(minEven, minEvenIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798559
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index = i\n            }\n        }\n        if (index == -1) List() else List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val minEven = evens.min\n        val index = arr.indexOf(minEven)\n        List(minEven, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798559
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n            List(min, index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659798553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        var min = arr.min\n        if (min % 2 == 1) {\n            min = arr.filter(x => x % 2 == 0).min\n            if (min % 2 == 1) return List()\n        }\n        List(min, arr.indexOf(min).toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\tat Problem$.pluck(tmp68raigar.scala:33)\n\tat Problem$.main(tmp68raigar.scala:46)\n\tat Problem.main(tmp68raigar.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798559
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given an array representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n        val min = arr.filter(_ % 2 == 0).min\n        val index = arr.indexOf(min)\n        return List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\tat Problem$.pluck(tmp6w3563fz.scala:31)\n\tat Problem$.main(tmp6w3563fz.scala:43)\n\tat Problem.main(tmp6w3563fz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798559
    }
  ]
}