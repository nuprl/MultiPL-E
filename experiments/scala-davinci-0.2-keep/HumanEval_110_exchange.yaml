name: HumanEval_110_exchange
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // In this problem, you will implement a function that takes two lists of numbers,\n\
  \    // and determines whether it is possible to perform an exchange of elements\n\
  \    // between them to make lst1 a list of only even numbers.\n    // There is\
  \ no limit on the number of exchanged elements between lst1 and lst2.\n    // If\
  \ it is possible to exchange elements between the lst1 and lst2 to make\n    //\
  \ all the elements of lst1 to be even, return \"YES\".\n    // Otherwise, return\
  \ \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"\
  YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    // It is assumed\
  \ that the input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2\
  \ : List[Long]) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
  \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
  NO\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
  \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
  \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
  \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
  \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
  NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
  \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
  \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
  \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n \
  \   }\n\n}\n"
completions: ["        val odds1 = lst1.filter(x => x % 2 == 1)\n        val odds2\
    \ = lst2.filter(x => x % 2 == 1)\n        if (odds1.length == odds2.length) \"\
    YES\" else \"NO\"", "        val lst1Even = lst1.filter(_ % 2 == 0)\n        val\
    \ lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size + lst2Even.size\
    \ >= lst1.size) \"YES\" else \"NO\"", "        val evens = lst1.filter(_ % 2 ==\
    \ 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length + odds.length\
    \ == lst1.length + lst2.length) \"YES\" else \"NO\"", "        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length == lst1.length + lst2.length) \"YES\" else \"NO\"", "        val\
    \ lst1Odd = lst1.filter(_ % 2 == 1)\n        val lst2Even = lst2.filter(_ % 2\
    \ == 0)\n        if (lst1Odd.size <= lst2Even.size) \"YES\" else \"NO\"", "  \
    \      val lst1Odd = lst1.filter(x => x % 2 == 1)\n        val lst2Even = lst2.filter(x\
    \ => x % 2 == 0)\n        if (lst1Odd.length <= lst2Even.length) \"YES\" else\
    \ \"NO\"", "        val odd1 = lst1.filter(_ % 2 == 1)\n        val odd2 = lst2.filter(_\
    \ % 2 == 1)\n        if (odd1.size == odd2.size) \"YES\" else \"NO\"", "     \
    \   val odds1 = lst1.filter(x => x % 2 == 1)\n        val odds2 = lst2.filter(x\
    \ => x % 2 == 1)\n        if (odds1.size == odds2.size) \"YES\" else \"NO\"",
  "        val evens = lst1.filter(_ % 2 == 0)\n        val odds = lst2.filter(_ %\
    \ 2 == 1)\n        if (evens.length + odds.length == lst1.length + lst2.length)\
    \ \"YES\" else \"NO\"", "        val evens = lst1.filter(_ % 2 == 0)\n       \
    \ val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length + odds.length ==\
    \ lst1.length + lst2.length) \"YES\" else \"NO\"", "        val evens = lst1.filter(x\
    \ => x % 2 == 0)\n        val odds = lst2.filter(x => x % 2 == 1)\n        if\
    \ (evens.length == 0) return \"NO\"\n        if (odds.length == 0) return \"YES\"\
    \n        if (evens.length >= odds.length) return \"YES\"\n        return \"NO\"",
  "        val lst1Even = lst1.filter(x => x % 2 == 0)\n        val lst1Odd = lst1.filter(x\
    \ => x % 2 == 1)\n        val lst2Even = lst2.filter(x => x % 2 == 0)\n      \
    \  val lst2Odd = lst2.filter(x => x % 2 == 1)\n        if (lst1Even.length + lst2Even.length\
    \ >= lst1.length) \"YES\"\n        else \"NO\"", "        val odd1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odd2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odd1.size == odd2.size) \"YES\" else \"NO\"", "        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"", "        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\"", "        val odd1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odd2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odd1.size == odd2.size) \"YES\" else \"NO\"", "        val lst1Even = lst1.filter(_\
    \ % 2 == 0)\n        val lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.size\
    \ == lst1.size) \"YES\"\n        else if (lst2Even.size == lst2.size) \"YES\"\n\
    \        else \"NO\"", "        val lst1Odd = lst1.filter(x => x % 2 == 1)\n \
    \       val lst2Even = lst2.filter(x => x % 2 == 0)\n        if (lst1Odd.length\
    \ <= lst2Even.length) \"YES\" else \"NO\"", "        val odds1 = lst1.filter(x\
    \ => x % 2 == 1)\n        val odds2 = lst2.filter(x => x % 2 == 1)\n        if\
    \ (odds1.size == odds2.size) \"YES\" else \"NO\"", "        val evens = lst1.filter(_\
    \ % 2 == 0)\n        val odds = lst2.filter(_ % 2 == 1)\n        if (evens.length\
    \ + odds.length >= lst1.length) \"YES\" else \"NO\""]
stop_tokens:
- "\n    }\n"
