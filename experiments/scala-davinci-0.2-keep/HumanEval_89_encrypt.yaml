name: HumanEval_89_encrypt
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function encrypt that takes a string as an argument and\n    //\
  \ returns a string encrypted with the alphabet being rotated. \n    // The alphabet\
  \ should be rotated in a manner such that the letters \n    // shift down by two\
  \ multiplied to two places.\n    // For example:\n    // encrypt('hi') returns 'lm'\n\
  \    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf') returns 'kj'\n\
  \    // encrypt('et') returns 'ix'\n    def encrypt(s : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
  lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
  gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n   \
  \ assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
  hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
  )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
  a\")).equals((\"e\")));\n    }\n\n}\n"
completions: ["        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val\
    \ shift = 2 * 2\n        val shiftedAlphabet = alphabet.drop(shift) + alphabet.take(shift)\n\
    \        s.map(c => shiftedAlphabet(alphabet.indexOf(c)))", "        var result\
    \ = \"\"\n        for (i <- 0 until s.length) {\n            result += ((s(i)\
    \ - 'a' + 2 * 2) % 26 + 'a').toChar\n        }\n        result", "        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        var encrypted = \"\"\n  \
    \      for (i <- 0 until s.length) {\n            val index = alphabet.indexOf(s(i))\n\
    \            encrypted += alphabet((index + 4) % 26)\n        }\n        encrypted",
  "        var result = \"\"\n        for (i <- 0 until s.length) {\n            result\
    \ += ((s(i) - 'a' + 2 * 2) % 26 + 'a').toChar\n        }\n        result", " \
    \       val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        var result = \"\
    \"\n        for (c <- s) {\n            var index = alphabet.indexOf(c)\n    \
    \        index = (index + 2) * 2\n            result += alphabet(index)\n    \
    \    }\n        result", "        // TODO\n        \"\"", "        var result\
    \ = \"\"\n        for (i <- 0 until s.length) {\n            result += (s(i) +\
    \ 2 * 2).toChar\n        }\n        return result", "        var result = \"\"\
    \n        for (i <- 0 until s.length) {\n            var c = s(i)\n          \
    \  if (c >= 'a' && c <= 'z') {\n                c = ((c - 'a' + 2) % 26 + 'a').toChar\n\
    \            }\n            result += c\n        }\n        result", "       \
    \ val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        var result = \"\"\n \
    \       for (i <- 0 until s.length) {\n            val index = alphabet.indexOf(s(i))\n\
    \            val newIndex = (index + 2 * (index + 1)) % 26\n            result\
    \ += alphabet(newIndex)\n        }\n        result", "        val alphabet = \"\
    abcdefghijklmnopqrstuvwxyz\"\n        var encrypted = \"\"\n        for (c <-\
    \ s) {\n            val index = alphabet.indexOf(c)\n            val newIndex\
    \ = (index + 2 * 2) % alphabet.length\n            encrypted += alphabet(newIndex)\n\
    \        }\n        encrypted", "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        s.map(x => alphabetMap2((alphabetMap(x)\
    \ + 2 * 2) % 26))", "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n \
    \       val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetSize\
    \ = alphabet.size\n        val encrypted = s.map(c => {\n            val index\
    \ = alphabetMap(c)\n            val newIndex = (index + 2 * 2) % alphabetSize\n\
    \            alphabet(newIndex)\n        })\n        encrypted", "        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(_.swap).toMap\n        val\
    \ alphabetMap3 = alphabet.zipWithIndex.map(_.swap).toMap\n        val alphabetMap4\
    \ = alphabet.zipWithIndex.map(_.swap).toMap\n        val alphabetMap5 = alphabet.zipWithIndex.map(_.swap).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(_.swap).toMap\n        val\
    \ alphabetMap7 = alphabet.zipWithIndex.map(_.swap).toMap\n        val alphabetMap8\
    \ = alphabet.zipWithIndex.map(_.swap).toMap\n        val alphabetMap9 = alphabet.zipWithIndex.map(_.swap).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(_.swap).toMap\n       \
    \ val alphabetMap11 = alphabet.zipWithIndex.map(_.swap).toMap\n        val alphabetMap12\
    \ = alphabet.zipWithIndex.map(_.swap).toMap\n        val alphabetMap13 = alphabet.zipWithIndex.map(_.swap).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(_.swap).toMap\n       \
    \ val alphabetMap15 = alphabet.zipWithIndex.map(_.swap).toMap\n        val alphabetMap16\
    \ = alphabet.zipWithIndex.map(_.swap).toMap\n        val alphabetMap17 = alphabet.zipWithIndex.map(_.swap).toMap\n\
    \        val alphabetMap18 = alphabet.zipWithIndex.map(_.swap).toMap\n       \
    \ val alphabetMap19 = alphabet.zipWithIndex.map(_.swap).toMap\n        val alphabetMap20\
    \ = alphabet.zipWithIndex.map(_.swap).toMap\n        val alphabetMap21 = alphabet.zipWithIndex.map(_.swap).toMap\n\
    \        val alphabetMap22 = alphabet.zipWithIndex.map(_.swap).toMap\n       \
    \ val alphabetMap23 = alphabet.zipWithIndex.map(_.swap).toMap\n        val alphabetMap24\
    \ = alphabet.zipWithIndex.map(_", "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val map = alphabet.zipWithIndex.toMap\n        s.map(x => {\n      \
    \      val index = map(x)\n            val newIndex = (index + 4) % 26\n     \
    \       alphabet(newIndex)\n        })", "        var result = \"\"\n        for\
    \ (i <- 0 until s.length) {\n            result += ((s(i) - 'a' + 2 * 2) % 26\
    \ + 'a').toChar\n        }\n        result", "        var result = \"\"\n    \
    \    for (i <- 0 until s.length) {\n            result += (s(i).toInt + 2 * 2).toChar\n\
    \        }\n        return result", "        var result = \"\"\n        for (c\
    \ <- s) {\n            result += (c + 2 * 2).toChar\n        }\n        result",
  "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val map = alphabet.zipWithIndex.toMap\n\
    \        val map2 = alphabet.zipWithIndex.toMap\n        val map3 = alphabet.zipWithIndex.toMap\n\
    \        val map4 = alphabet.zipWithIndex.toMap\n        val map5 = alphabet.zipWithIndex.toMap\n\
    \        val map6 = alphabet.zipWithIndex.toMap\n        val map7 = alphabet.zipWithIndex.toMap\n\
    \        val map8 = alphabet.zipWithIndex.toMap\n        val map9 = alphabet.zipWithIndex.toMap\n\
    \        val map10 = alphabet.zipWithIndex.toMap\n        val map11 = alphabet.zipWithIndex.toMap\n\
    \        val map12 = alphabet.zipWithIndex.toMap\n        val map13 = alphabet.zipWithIndex.toMap\n\
    \        val map14 = alphabet.zipWithIndex.toMap\n        val map15 = alphabet.zipWithIndex.toMap\n\
    \        val map16 = alphabet.zipWithIndex.toMap\n        val map17 = alphabet.zipWithIndex.toMap\n\
    \        val map18 = alphabet.zipWithIndex.toMap\n        val map19 = alphabet.zipWithIndex.toMap\n\
    \        val map20 = alphabet.zipWithIndex.toMap\n        val map21 = alphabet.zipWithIndex.toMap\n\
    \        val map22 = alphabet.zipWithIndex.toMap\n        val map23 = alphabet.zipWithIndex.toMap\n\
    \        val map24 = alphabet.zipWithIndex.toMap\n        val map25 = alphabet.zipWithIndex.toMap\n\
    \        val map26 = alphabet.zipWithIndex.toMap\n        val map27 = alphabet.zipWithIndex.toMap\n\
    \        val map28 = alphabet.zipWithIndex.toMap\n        val map29 = alphabet.zipWithIndex.toMap\n\
    \        val map30 = alphabet.zipWithIndex.toMap\n        val map31 = alphabet.zipWithIndex.toMap\n\
    \        val map32 = alphabet.zipWithIndex.toMap\n        val map33 = alphabet.zipWithIndex.toMap\n\
    \        val map34 = alphabet.zipWithIndex.toMap\n        val map35 = alphabet.zipWithIndex.toMap\n\
    \       ", "        var result = \"\"\n        for (i <- 0 until s.length) {\n\
    \            var c = s(i)\n            if (c >= 'a' && c <= 'z') {\n         \
    \       var x = c - 'a'\n                x = (x + 2) % 26\n                c =\
    \ (x + 'a').toChar\n            }\n            result += c\n        }\n      \
    \  return result", '        s.map(x => (x + 2 * 2).toChar)']
stop_tokens:
- "\n    }\n"
