name: HumanEval_129_minPath
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a grid with N rows and N columns (N >= 2) and a positive integer k,\
  \ \n    // each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n    // inclusive appears exactly once on the cells of the grid.\n    //\
  \ You have to find the minimum path of length k in the grid. You can start\n   \
  \ // from any cell, and in each step you can move to any of the neighbor cells,\n\
  \    // in other words, you can go to cells which share an edge with you current\n\
  \    // cell.\n    // Please note that a path of length k means visiting exactly\
  \ k cells (not\n    // necessarily distinct).\n    // You CANNOT go off the grid.\n\
  \    // A path A (of length k) is considered less than a path B (of length k) if\n\
  \    // after making the ordered lists of the values on the cells that A and B go\n\
  \    // through (let's call them lst_A and lst_B), lst_A is lexicographically less\n\
  \    // than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n\
  \    // such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    //\
  \ lst_A[j] = lst_B[j].\n    // It is guaranteed that the answer is unique.\n   \
  \ // Return an ordered list of the values on the cells that the minimum path go\
  \ through.\n    // Examples:\n    // Input: grid = [ [1,2,3], [4,5,6], [7,8,9]],\
  \ k = 3\n    // Output: [1, 2, 1]\n    // Input: grid = [ [5,9,3], [4,1,6], [7,8,2]],\
  \ k = 1\n    // Output: [1]\n    def minPath(grid : List[List[Long]], k : Long)\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong,\
  \ 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong),\
  \ List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong,\
  \ 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong,\
  \ 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong,\
  \ 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong,\
  \ 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong,\
  \ 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong,\
  \ 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](11l.toLong,\
  \ 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong,\
  \ 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong,\
  \ 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong,\
  \ 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong,\
  \ 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong,\
  \ 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong),\
  \ List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong,\
  \ 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong,\
  \ 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong,\
  \ 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
  \ 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong),\
  \ List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        val n = grid.length\n        val m = grid(0).length\n     \
    \   val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length < k) {\n                   \
    \ val newPath = dp(i - 1)(j) :+ grid(i)(j)\n                    if (newPath.length\
    \ == k) {\n                        if (dp(i)(j).length == k) {\n             \
    \               if (newPath < dp(i)(j)) dp(i)(j) = newPath\n                 \
    \       } else dp(i)(j) = newPath\n                    } else if (newPath.length\
    \ < k) dp(i)(j) = newPath\n                }\n                if (j > 0 && dp(i)(j\
    \ - 1).length < k) {\n                    val newPath = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    if (newPath.length == k) {\n                        if (dp(i)(j).length\
    \ == k) {\n                            if (newPath < dp(i)(j)) dp(i)(j) = newPath\n\
    \                        } else dp(i)(j) = newPath\n                    } else\
    \ if (newPath.length < k) dp(i)(j) = newPath\n                }\n            }\n\
    \        }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n     \
    \   val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n     \
    \   pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val (cost,\
    \ i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n                dp(i)(j)\
    \ = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j), i - 1,\
    \ j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), i + 1,\
    \ j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i, j - 1))\n\
    \                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i, j + 1))\n\
    \            }\n        }\n        val pq2 = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq2.enqueue((0, 0, 0))\n        val visited = Array.fill(n, m)(false)\n\
    \        while (pq2.nonEmpty) {\n            val (cost, i, j) = pq2.dequeue\n\
    \            if (!visited(i)(j)) {\n                visited(i)(j) = true\n   \
    \             if (i > 0 && dp(i - 1)(j) == cost + grid(i - 1)(j)) pq2.enqueue((cost\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1 && dp(i + 1)(j)\
    \ == cost + grid(i + 1)(j)) pq2.enqueue((cost + grid(i + 1)(j), i + 1, j))\n \
    \               if (j > 0 && dp(i)(j - 1) == cost + grid(i)(j - 1)) pq2.enqueue((cost\
    \ +", "        val n = grid.length\n        val m = grid(0).length\n        val\
    \ dp = Array.fill(n, m)(Long.MaxValue)\n        val prev = Array.fill(n, m)(-1)\n\
    \        val q = new Queue[(Int, Int)]\n        val dx = List(-1, 0, 1, 0)\n \
    \       val dy = List(0, 1, 0, -1)\n        for (i <- 0 until n; j <- 0 until\
    \ m) {\n            dp(i)(j) = grid(i)(j)\n            q.enqueue((i, j))\n   \
    \     }\n        while (!q.isEmpty) {\n            val (x, y) = q.dequeue\n  \
    \          for (i <- 0 until 4) {\n                val nx = x + dx(i)\n      \
    \          val ny = y + dy(i)\n                if (nx >= 0 && nx < n && ny >=\
    \ 0 && ny < m) {\n                    if (dp(nx)(ny) > dp(x)(y) + grid(nx)(ny))\
    \ {\n                        dp(nx)(ny) = dp(x)(y) + grid(nx)(ny)\n          \
    \              prev(nx)(ny) = (x, y)\n                        q.enqueue((nx, ny))\n\
    \                    }\n                }\n            }\n        }\n        val\
    \ res = new ListBuffer[Long]\n        var x = 0\n        var y = 0\n        for\
    \ (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j) < dp(x)(y)) {\n\
    \                x = i\n                y = j\n            }\n        }\n    \
    \    for (i <- 0 until k.toInt) {\n            res += grid(x)(y)\n           \
    \ val (nx, ny) = prev(x)(y)\n            x = nx\n            y = ny\n        }\n\
    \        res.toList", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val path = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) {\n                    dp(i)(j)\
    \ = grid(i)(j)\n                    path(i)(j) = List(grid(i)(j))\n          \
    \      }\n                else {\n                    if (i > 0 && dp(i - 1)(j)\
    \ < dp(i)(j)) {\n                        dp(i)(j) = dp(i - 1)(j)\n           \
    \             path(i)(j) = path(i - 1)(j)\n                    }\n           \
    \         if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                        dp(i)(j)\
    \ = dp(i)(j - 1)\n                        path(i)(j) = path(i)(j - 1)\n      \
    \              }\n                    if (i > 0 && j > 0 && dp(i - 1)(j - 1) <\
    \ dp(i)(j)) {\n                        dp(i)(j) = dp(i - 1)(j - 1)\n         \
    \               path(i)(j) = path(i - 1)(j - 1)\n                    }\n     \
    \               dp(i)(j) += grid(i)(j)\n                    path(i)(j) = (path(i)(j)\
    \ :+ grid(i)(j)).sorted\n                }\n            }\n        }\n       \
    \ var i = n - 1\n        var j = m - 1\n        while (k > 1) {\n            if\
    \ (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -= 1\n            }\n\
    \            else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                j -=\
    \ 1\n            }\n            else {\n                i -= 1\n             \
    \   j -= 1\n            }\n            k -= 1\n        }\n        path(i)(j",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                val lst = List(grid(i)(j))\n                if (i == 0\
    \ && j == 0) dp(i)(j) = lst\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else {\n                    val\
    \ lst1 = dp(i - 1)(j) :+ grid(i)(j)\n                    val lst2 = dp(i)(j -\
    \ 1) :+ grid(i)(j)\n                    if (lst1.sorted < lst2.sorted) dp(i)(j)\
    \ = lst1.sorted\n                    else dp(i)(j) = lst2.sorted\n           \
    \     }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n           \
    \ for (j <- 0 until m) {\n                val lst = List(grid(i)(j))\n       \
    \         if (i == 0 && j == 0) dp(i)(j) = lst\n                else if (i ==\
    \ 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                else if (j\
    \ == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n                else {\n\
    \                    val lst1 = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n        \
    \            val lst2 = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n                \
    \    if (lst1 < lst2) dp(i)(j) = lst1\n                    else dp(i)(j) = lst2\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val prev = Array.fill(n, m)(List[Long]())\n     \
    \   for (i <- 0 until n) {\n            for (j <- 0 until m) {\n             \
    \   if (i == 0 && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n     \
    \               prev(i)(j) = List(grid(i)(j))\n                }\n           \
    \     else {\n                    if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n  \
    \                      dp(i)(j) = dp(i - 1)(j)\n                        prev(i)(j)\
    \ = prev(i - 1)(j)\n                    }\n                    if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                        dp(i)(j) = dp(i)(j - 1)\n      \
    \                  prev(i)(j) = prev(i)(j - 1)\n                    }\n      \
    \              dp(i)(j) += grid(i)(j)\n                    prev(i)(j) = prev(i)(j)\
    \ :+ grid(i)(j)\n                }\n            }\n        }\n        val result\
    \ = prev(n - 1)(m - 1)\n        result.drop(result.length - k.toInt)", "     \
    \   val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    if (i > 0) {\n                    \
    \    val lst = dp(i - 1)(j)\n                        if (lst.length < k) dp(i)(j)\
    \ = (grid(i)(j) :: lst).sorted\n                        else if (lst.length ==\
    \ k) {\n                            val lst2 = (grid(i)(j) :: lst).sorted\n  \
    \                          if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n            \
    \            }\n                    }\n                    if (j > 0) {\n    \
    \                    val lst = dp(i)(j - 1)\n                        if (lst.length\
    \ < k) {\n                            val lst2 = (grid(i)(j) :: lst).sorted\n\
    \                            if (lst2.length == k) {\n                       \
    \         if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n                            }\n\
    \                            else dp(i)(j) = lst2\n                        }\n\
    \                        else if (lst.length == k) {\n                       \
    \     val lst2 = (grid(i)(j) :: lst).sorted\n                            if (lst2\
    \ < dp(i)(j)) dp(i)(j) = lst2\n                        }\n                   \
    \ }\n                }\n            }\n        }\n        dp(n - 1)(m - 1)", " \
    \       // dp(i)(j)(k) = the minimum path of length k starting from (i, j)\n \
    \       val dp = Array.fill(grid.length, grid.length, k.toInt + 1)(Long.MaxValue)\n\
    \        // Initialization\n        for (i <- 0 until grid.length; j <- 0 until\
    \ grid.length) {\n            dp(i)(j)(1) = grid(i)(j)\n        }\n        //\
    \ Recurrence\n        for (i <- 0 until grid.length; j <- 0 until grid.length;\
    \ l <- 2 to k.toInt) {\n            for (x <- 0 until grid.length; y <- 0 until\
    \ grid.length) {\n                if (abs(x - i) + abs(y - j) == 1) {\n      \
    \              dp(i)(j)(l) = min(dp(i)(j)(l), dp(x)(y)(l - 1) + grid(i)(j))\n\
    \                }\n            }\n        }\n        // Find the minimum path\n\
    \        var min = Long.MaxValue\n        var minPath = List[Long]()\n       \
    \ for (i <- 0 until grid.length; j <- 0 until grid.length) {\n            if (dp(i)(j)(k.toInt)\
    \ < min) {\n                min = dp(i)(j)(k.toInt)\n                minPath =\
    \ List[Long]()\n                var curr = (i, j)\n                var currK =\
    \ k.toInt\n                while (currK > 0) {\n                    minPath =\
    \ grid(curr._1)(curr._2) :: minPath\n                    var next = (0, 0)\n \
    \                   var min = Long.MaxValue\n                    for (x <- 0 until\
    \ grid.length; y <- 0 until grid.length) {\n                        if (abs(x\
    \ - curr._1) + abs(y - curr._2) == 1) {\n                            if (dp(x)(y)(currK\
    \ - 1) + grid(curr._1)(curr._2) < min) {\n                                min\
    \ = dp(x)(y)(currK - 1) + grid(curr._1)(curr._2)\n                           \
    \     next =", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq.enqueue((0, 0, 0))\n        while\
    \ (pq.nonEmpty) {\n            val (d, i, j) = pq.dequeue\n            if (dp(i)(j)\
    \ > d) {\n                dp(i)(j) = d\n                if (i > 0) pq.enqueue((d\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1) pq.enqueue((d +\
    \ grid(i + 1)(j), i + 1, j))\n                if (j > 0) pq.enqueue((d + grid(i)(j\
    \ - 1), i, j - 1))\n                if (j < m - 1) pq.enqueue((d + grid(i)(j +\
    \ 1), i, j + 1))\n            }\n        }\n        val pq2 = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq2.enqueue((0, 0, 0))\n        val\
    \ dp2 = Array.fill(n, m)(Long.MaxValue)\n        dp2(0)(0) = 0\n        val parent\
    \ = Array.fill(n, m)((-1, -1))\n        val path = ListBuffer[Long]()\n      \
    \  while (pq2.nonEmpty) {\n            val (d, i, j) = pq2.dequeue\n         \
    \   if (dp2(i)(j) == d) {\n                if (k == 1) {\n                   \
    \ path += grid(i)(j)\n                    var (x, y) = parent(i)(j)\n        \
    \            while (x != -1) {\n                        path += grid(x)(y)\n \
    \                       val (xx, yy) = parent(x)(y)\n                        x\
    \ = xx\n                        y = yy\n                    }\n              \
    \      return path.reverse.toList\n                }\n                if (i",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x\
    \ => x._1))\n        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n  \
    \          val (cost, i, j) = pq.dequeue\n            if (dp(i)(j) <= cost) {\n\
    \                if (i == n - 1 && j == m - 1 && cost <= k) return reconstruct(dp,\
    \ i, j, k)\n                if (i + 1 < n && dp(i + 1)(j) > cost + grid(i + 1)(j))\
    \ {\n                    dp(i + 1)(j) = cost + grid(i + 1)(j)\n              \
    \      pq.enqueue((dp(i + 1)(j), i + 1, j))\n                }\n             \
    \   if (j + 1 < m && dp(i)(j + 1) > cost + grid(i)(j + 1)) {\n               \
    \     dp(i)(j + 1) = cost + grid(i)(j + 1)\n                    pq.enqueue((dp(i)(j\
    \ + 1), i, j + 1))\n                }\n            }\n        }\n        return\
    \ List()", "        val n = grid.length\n        val m = grid(0).length\n    \
    \    val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        for (i <- 0 until n) {\n         \
    \   for (j <- 0 until m) {\n                dp(i)(j) = grid(i)(j)\n          \
    \      pq.enqueue((dp(i)(j), i, j))\n            }\n        }\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i >\
    \ 0) {\n                    dp(i)(j) = min(dp(i)(j), dp(i - 1)(j) + grid(i)(j))\n\
    \                    pq.enqueue((dp(i)(j), i, j))\n                }\n       \
    \         if (j > 0) {\n                    dp(i)(j) = min(dp(i)(j), dp(i)(j -\
    \ 1) + grid(i)(j))\n                    pq.enqueue((dp(i)(j), i, j))\n       \
    \         }\n            }\n        }\n        val result = new ListBuffer[Long]()\n\
    \        while (result.length < k) {\n            val (value, i, j) = pq.dequeue()\n\
    \            result += value\n            if (i > 0) {\n                dp(i)(j)\
    \ = min(dp(i)(j), dp(i - 1)(j) + grid(i)(j))\n                pq.enqueue((dp(i)(j),\
    \ i, j))\n            }\n            if (j > 0) {\n                dp(i)(j) =\
    \ min(dp(i)(j), dp(i)(j - 1) + grid(i)(j))\n                pq.enqueue((dp(i)(j),\
    \ i, j))\n            }\n        }\n        result.toList", "        val n = grid.length\n\
    \        val dp = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until n) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length + 1 <= k && dp(i - 1)(j) < dp(i)(j))\
    \ dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                if (j > 0 && dp(i)(j\
    \ - 1).length + 1 <= k && dp(i)(j - 1) < dp(i)(j)) dp(i)(j) = dp(i)(j - 1) :+\
    \ grid(i)(j)\n            }\n        }\n        dp(n - 1)(n - 1)", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    if (i > 0) {\n                    \
    \    val lst = dp(i - 1)(j)\n                        if (lst.length < k) dp(i)(j)\
    \ = grid(i)(j) :: lst\n                        else if (lst.length == k) dp(i)(j)\
    \ = grid(i)(j) :: lst.dropRight(1)\n                    }\n                  \
    \  if (j > 0) {\n                        val lst = dp(i)(j - 1)\n            \
    \            if (lst.length < k) {\n                            if (dp(i)(j).length\
    \ < k) dp(i)(j) = grid(i)(j) :: lst\n                            else if (lst.length\
    \ < dp(i)(j).length) dp(i)(j) = grid(i)(j) :: lst.dropRight(1)\n             \
    \           }\n                        else if (lst.length == k) {\n         \
    \                   if (dp(i)(j).length < k) dp(i)(j) = grid(i)(j) :: lst.dropRight(1)\n\
    \                            else if (lst.length < dp(i)(j).length) dp(i)(j) =\
    \ grid(i)(j) :: lst.dropRight(1)\n                        }\n                \
    \    }\n                }\n            }\n        }\n        dp(n - 1)(m - 1)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val pq2 = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(_._1))\n        pq2.enqueue((0, 0, 0))\n        val\
    \ visited = Array.fill(n, m)(false)\n        visited(0)(0) = true\n        var\
    \ ans = List[Long]()\n        while (!pq2.isEmpty) {\n            val (cost, i,\
    \ j) = pq2.dequeue\n            ans = ans :+ grid(i)(j)\n            if (ans.length\
    \ == k) return ans\n            if (i > 0 && !visited(i - 1)(j) && dp(i - 1)(j)\
    \ == cost + grid(i - 1)(j)) {\n                pq2.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                visited(i - 1)(j) = true\n            }\n      \
    \      if (i < n - 1 && !visited(i + 1)(j) && dp(i + 1)(j) == cost + grid(i +\
    \ 1)(j", "        val n = grid.length\n        val m = grid(0).length\n      \
    \  val dp = Array.fill(n, m)(0L)\n        val prev = Array.fill(n, m)(0L)\n  \
    \      for (i <- 0 until n) {\n            for (j <- 0 until m) {\n          \
    \      dp(i)(j) = grid(i)(j)\n                prev(i)(j) = -1\n            }\n\
    \        }\n        for (i <- 1 until n) {\n            for (j <- 0 until m) {\n\
    \                if (dp(i - 1)(j) < dp(i)(j)) {\n                    dp(i)(j)\
    \ = dp(i - 1)(j)\n                    prev(i)(j) = 0\n                }\n    \
    \        }\n        }\n        for (j <- 1 until m) {\n            for (i <- 0\
    \ until n) {\n                if (dp(i)(j - 1) < dp(i)(j)) {\n               \
    \     dp(i)(j) = dp(i)(j - 1)\n                    prev(i)(j) = 1\n          \
    \      }\n            }\n        }\n        for (j <- 1 until m) {\n         \
    \   for (i <- 1 until n) {\n                if (dp(i - 1)(j - 1) < dp(i)(j)) {\n\
    \                    dp(i)(j) = dp(i - 1)(j - 1)\n                    prev(i)(j)\
    \ = 2\n                }\n            }\n        }\n        var i = n - 1\n  \
    \      var j = m - 1\n        var path = List[Long]()\n        while (k > 0) {\n\
    \            path = grid(i)(j) :: path\n            k -= 1\n            if (prev(i)(j)\
    \ == 0) i -= 1\n            else if (prev(i)(j) == 1) j -= 1\n            else\
    \ {\n                i -= 1\n                j -= 1\n            }\n        }\n\
    \        path", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val prev = Array.fill(n,\
    \ m)((0, 0))\n        val q = new Queue[(Int, Int)]\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j) ==\
    \ 1) {\n                    dp(i)(j) = 0\n                    q.enqueue((i, j))\n\
    \                }\n            }\n        }\n        while (!q.isEmpty) {\n \
    \           val (x, y) = q.dequeue\n            for (i <- -1 to 1) {\n       \
    \         for (j <- -1 to 1) {\n                    if (i == 0 && j == 0) {\n\
    \                        // do nothing\n                    } else if (x + i >=\
    \ 0 && x + i < n && y + j >= 0 && y + j < m) {\n                        if (dp(x\
    \ + i)(y + j) > dp(x)(y) + 1) {\n                            dp(x + i)(y + j)\
    \ = dp(x)(y) + 1\n                            prev(x + i)(y + j) = (x, y)\n  \
    \                          q.enqueue((x + i, y + j))\n                       \
    \ }\n                    }\n                }\n            }\n        }\n    \
    \    var (x, y) = (0, 0)\n        var min = Long.MaxValue\n        for (i <- 0\
    \ until n) {\n            for (j <- 0 until m) {\n                if (dp(i)(j)\
    \ < min) {\n                    min = dp(i)(j)\n                    x = i\n  \
    \                  y = j\n                }\n            }\n        }\n      \
    \  var result = List[Long]()\n        for (i <- 0 until k) {\n            result\
    \ = grid(x)(y) :: result\n            val (x1, y1) = prev(x)(y)\n            x\
    \ = x1\n            y = y1\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val lst = ListBuffer[List[Long]]()\n                \
    \    if (i > 0) lst += dp(i - 1)(j)\n                    if (j > 0) lst += dp(i)(j\
    \ - 1)\n                    if (lst.isEmpty) dp(i)(j) = List(grid(i)(j))\n   \
    \                 else {\n                        val min = lst.minBy(l => (l\
    \ :+ grid(i)(j)).mkString(\"\"))\n                        dp(i)(j) = min :+ grid(i)(j)\n\
    \                    }\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until m) {\n                dp(i)(j) = grid(i)(j)\n      \
    \          if (i > 0) dp(i)(j) = min(dp(i)(j), dp(i - 1)(j))\n               \
    \ if (j > 0) dp(i)(j) = min(dp(i)(j), dp(i)(j - 1))\n            }\n        }\n\
    \        val result = ListBuffer[Long]()\n        var i = 0\n        var j = 0\n\
    \        while (k > 0) {\n            result += grid(i)(j)\n            k -= 1\n\
    \            if (i == n - 1 && j == m - 1) return result.toList\n            if\
    \ (i == n - 1) {\n                j += 1\n            } else if (j == m - 1) {\n\
    \                i += 1\n            } else {\n                if (dp(i + 1)(j)\
    \ < dp(i)(j + 1)) {\n                    i += 1\n                } else {\n  \
    \                  j += 1\n                }\n            }\n        }\n     \
    \   result.toList", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(Long.MaxValue)\n        val prev = Array.fill(n, n)(List[Long]())\n     \
    \   dp(0)(0) = grid(0)(0)\n        prev(0)(0) = List(grid(0)(0))\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                if (i\
    \ > 0) {\n                    if (dp(i - 1)(j) + grid(i)(j) < dp(i)(j)) {\n  \
    \                      dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n                \
    \        prev(i)(j) = prev(i - 1)(j) :+ grid(i)(j)\n                    }\n  \
    \                  else if (dp(i - 1)(j) + grid(i)(j) == dp(i)(j)) {\n       \
    \                 val lst = prev(i - 1)(j) :+ grid(i)(j)\n                   \
    \     if (lst < prev(i)(j)) {\n                            prev(i)(j) = lst\n\
    \                        }\n                    }\n                }\n       \
    \         if (j > 0) {\n                    if (dp(i)(j - 1) + grid(i)(j) < dp(i)(j))\
    \ {\n                        dp(i)(j) = dp(i)(j - 1) + grid(i)(j)\n          \
    \              prev(i)(j) = prev(i)(j - 1) :+ grid(i)(j)\n                   \
    \ }\n                    else if (dp(i)(j - 1) + grid(i)(j) == dp(i)(j)) {\n \
    \                       val lst = prev(i)(j - 1) :+ grid(i)(j)\n             \
    \           if (lst < prev(i)(j)) {\n                            prev(i)(j) =\
    \ lst\n                        }\n                    }\n                }\n \
    \           }\n        }\n        val lst = prev(n - 1)(n - 1)\n        lst.take(lst.length\
    \ - 1)"]
stop_tokens:
- "\n    }\n"
