name: HumanEval_129_minPath
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a grid with N rows and N columns (N >= 2) and a positive integer k,\
  \ \n    // each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n    // inclusive appears exactly once on the cells of the grid.\n    //\
  \ You have to find the minimum path of length k in the grid. You can start\n   \
  \ // from any cell, and in each step you can move to any of the neighbor cells,\n\
  \    // in other words, you can go to cells which share an edge with you current\n\
  \    // cell.\n    // Please note that a path of length k means visiting exactly\
  \ k cells (not\n    // necessarily distinct).\n    // You CANNOT go off the grid.\n\
  \    // A path A (of length k) is considered less than a path B (of length k) if\n\
  \    // after making the ordered lists of the values on the cells that A and B go\n\
  \    // through (let's call them lst_A and lst_B), lst_A is lexicographically less\n\
  \    // than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n\
  \    // such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    //\
  \ lst_A[j] = lst_B[j].\n    // It is guaranteed that the answer is unique.\n   \
  \ // Return an ordered list of the values on the cells that the minimum path go\
  \ through.\n    // Examples:\n    // Input: grid = [ [1,2,3], [4,5,6], [7,8,9]],\
  \ k = 3\n    // Output: [1, 2, 1]\n    // Input: grid = [ [5,9,3], [4,1,6], [7,8,2]],\
  \ k = 1\n    // Output: [1]\n    def minPath(grid : List[List[Long]], k : Long)\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong,\
  \ 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong),\
  \ List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong,\
  \ 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong,\
  \ 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong,\
  \ 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong,\
  \ 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong,\
  \ 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong,\
  \ 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](11l.toLong,\
  \ 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong,\
  \ 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong,\
  \ 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong,\
  \ 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong,\
  \ 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong,\
  \ 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong),\
  \ List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong,\
  \ 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong,\
  \ 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong,\
  \ 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
  \ 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong),\
  \ List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        val n = grid.length\n        val m = grid(0).length\n     \
    \   val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length < k) {\n                   \
    \ val newPath = dp(i - 1)(j) :+ grid(i)(j)\n                    if (newPath.length\
    \ == k) {\n                        if (dp(i)(j).length == k) {\n             \
    \               if (newPath < dp(i)(j)) dp(i)(j) = newPath\n                 \
    \       } else dp(i)(j) = newPath\n                    } else if (newPath.length\
    \ < k) dp(i)(j) = newPath\n                }\n                if (j > 0 && dp(i)(j\
    \ - 1).length < k) {\n                    val newPath = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    if (newPath.length == k) {\n                        if (dp(i)(j).length\
    \ == k) {\n                            if (newPath < dp(i)(j)) dp(i)(j) = newPath\n\
    \                        } else dp(i)(j) = newPath\n                    } else\
    \ if (newPath.length < k) dp(i)(j) = newPath\n                }\n            }\n\
    \        }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n     \
    \   val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n     \
    \   pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val (cost,\
    \ i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n                dp(i)(j)\
    \ = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j), i - 1,\
    \ j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), i + 1,\
    \ j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i, j - 1))\n\
    \                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i, j + 1))\n\
    \            }\n        }\n        val pq2 = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq2.enqueue((0, 0, 0))\n        val visited = Array.fill(n, m)(false)\n\
    \        while (pq2.nonEmpty) {\n            val (cost, i, j) = pq2.dequeue\n\
    \            if (!visited(i)(j)) {\n                visited(i)(j) = true\n   \
    \             if (i > 0 && dp(i - 1)(j) == cost + grid(i - 1)(j)) pq2.enqueue((cost\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1 && dp(i + 1)(j)\
    \ == cost + grid(i + 1)(j)) pq2.enqueue((cost + grid(i + 1)(j), i + 1, j))\n \
    \               if (j > 0 && dp(i)(j - 1) == cost + grid(i)(j - 1)) pq2.enqueue((cost\
    \ +", "        val n = grid.length\n        val m = grid(0).length\n        val\
    \ dp = Array.fill(n, m)(Long.MaxValue)\n        val prev = Array.fill(n, m)(-1)\n\
    \        val q = new Queue[(Int, Int)]\n        val dx = List(-1, 0, 1, 0)\n \
    \       val dy = List(0, 1, 0, -1)\n        for (i <- 0 until n; j <- 0 until\
    \ m) {\n            dp(i)(j) = grid(i)(j)\n            q.enqueue((i, j))\n   \
    \     }\n        while (!q.isEmpty) {\n            val (x, y) = q.dequeue\n  \
    \          for (i <- 0 until 4) {\n                val nx = x + dx(i)\n      \
    \          val ny = y + dy(i)\n                if (nx >= 0 && nx < n && ny >=\
    \ 0 && ny < m) {\n                    if (dp(nx)(ny) > dp(x)(y) + grid(nx)(ny))\
    \ {\n                        dp(nx)(ny) = dp(x)(y) + grid(nx)(ny)\n          \
    \              prev(nx)(ny) = (x, y)\n                        q.enqueue((nx, ny))\n\
    \                    }\n                }\n            }\n        }\n        val\
    \ res = new ListBuffer[Long]\n        var x = 0\n        var y = 0\n        for\
    \ (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j) < dp(x)(y)) {\n\
    \                x = i\n                y = j\n            }\n        }\n    \
    \    for (i <- 0 until k.toInt) {\n            res += grid(x)(y)\n           \
    \ val (nx, ny) = prev(x)(y)\n            x = nx\n            y = ny\n        }\n\
    \        res.toList", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val path = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) {\n                    dp(i)(j)\
    \ = grid(i)(j)\n                    path(i)(j) = List(grid(i)(j))\n          \
    \      }\n                else {\n                    if (i > 0 && dp(i - 1)(j)\
    \ < dp(i)(j)) {\n                        dp(i)(j) = dp(i - 1)(j)\n           \
    \             path(i)(j) = path(i - 1)(j)\n                    }\n           \
    \         if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                        dp(i)(j)\
    \ = dp(i)(j - 1)\n                        path(i)(j) = path(i)(j - 1)\n      \
    \              }\n                    if (i > 0 && j > 0 && dp(i - 1)(j - 1) <\
    \ dp(i)(j)) {\n                        dp(i)(j) = dp(i - 1)(j - 1)\n         \
    \               path(i)(j) = path(i - 1)(j - 1)\n                    }\n     \
    \               dp(i)(j) += grid(i)(j)\n                    path(i)(j) = (path(i)(j)\
    \ :+ grid(i)(j)).sorted\n                }\n            }\n        }\n       \
    \ var i = n - 1\n        var j = m - 1\n        while (k > 1) {\n            if\
    \ (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -= 1\n            }\n\
    \            else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                j -=\
    \ 1\n            }\n            else {\n                i -= 1\n             \
    \   j -= 1\n            }\n            k -= 1\n        }\n        path(i)(j",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                val lst = List(grid(i)(j))\n                if (i == 0\
    \ && j == 0) dp(i)(j) = lst\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else {\n                    val\
    \ lst1 = dp(i - 1)(j) :+ grid(i)(j)\n                    val lst2 = dp(i)(j -\
    \ 1) :+ grid(i)(j)\n                    if (lst1.sorted < lst2.sorted) dp(i)(j)\
    \ = lst1.sorted\n                    else dp(i)(j) = lst2.sorted\n           \
    \     }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n           \
    \ for (j <- 0 until m) {\n                val lst = List(grid(i)(j))\n       \
    \         if (i == 0 && j == 0) dp(i)(j) = lst\n                else if (i ==\
    \ 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                else if (j\
    \ == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n                else {\n\
    \                    val lst1 = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n        \
    \            val lst2 = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n                \
    \    if (lst1 < lst2) dp(i)(j) = lst1\n                    else dp(i)(j) = lst2\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val prev = Array.fill(n, m)(List[Long]())\n     \
    \   for (i <- 0 until n) {\n            for (j <- 0 until m) {\n             \
    \   if (i == 0 && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n     \
    \               prev(i)(j) = List(grid(i)(j))\n                }\n           \
    \     else {\n                    if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n  \
    \                      dp(i)(j) = dp(i - 1)(j)\n                        prev(i)(j)\
    \ = prev(i - 1)(j)\n                    }\n                    if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                        dp(i)(j) = dp(i)(j - 1)\n      \
    \                  prev(i)(j) = prev(i)(j - 1)\n                    }\n      \
    \              dp(i)(j) += grid(i)(j)\n                    prev(i)(j) = prev(i)(j)\
    \ :+ grid(i)(j)\n                }\n            }\n        }\n        val result\
    \ = prev(n - 1)(m - 1)\n        result.drop(result.length - k.toInt)", "     \
    \   val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    if (i > 0) {\n                    \
    \    val lst = dp(i - 1)(j)\n                        if (lst.length < k) dp(i)(j)\
    \ = (grid(i)(j) :: lst).sorted\n                        else if (lst.length ==\
    \ k) {\n                            val lst2 = (grid(i)(j) :: lst).sorted\n  \
    \                          if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n            \
    \            }\n                    }\n                    if (j > 0) {\n    \
    \                    val lst = dp(i)(j - 1)\n                        if (lst.length\
    \ < k) {\n                            val lst2 = (grid(i)(j) :: lst).sorted\n\
    \                            if (lst2.length == k) {\n                       \
    \         if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n                            }\n\
    \                            else dp(i)(j) = lst2\n                        }\n\
    \                        else if (lst.length == k) {\n                       \
    \     val lst2 = (grid(i)(j) :: lst).sorted\n                            if (lst2\
    \ < dp(i)(j)) dp(i)(j) = lst2\n                        }\n                   \
    \ }\n                }\n            }\n        }\n        dp(n - 1)(m - 1)", " \
    \       // dp(i)(j)(k) = the minimum path of length k starting from (i, j)\n \
    \       val dp = Array.fill(grid.length, grid.length, k.toInt + 1)(Long.MaxValue)\n\
    \        // Initialization\n        for (i <- 0 until grid.length; j <- 0 until\
    \ grid.length) {\n            dp(i)(j)(1) = grid(i)(j)\n        }\n        //\
    \ Recurrence\n        for (i <- 0 until grid.length; j <- 0 until grid.length;\
    \ l <- 2 to k.toInt) {\n            for (x <- 0 until grid.length; y <- 0 until\
    \ grid.length) {\n                if (abs(x - i) + abs(y - j) == 1) {\n      \
    \              dp(i)(j)(l) = min(dp(i)(j)(l), dp(x)(y)(l - 1) + grid(i)(j))\n\
    \                }\n            }\n        }\n        // Find the minimum path\n\
    \        var min = Long.MaxValue\n        var minPath = List[Long]()\n       \
    \ for (i <- 0 until grid.length; j <- 0 until grid.length) {\n            if (dp(i)(j)(k.toInt)\
    \ < min) {\n                min = dp(i)(j)(k.toInt)\n                minPath =\
    \ List[Long]()\n                var curr = (i, j)\n                var currK =\
    \ k.toInt\n                while (currK > 0) {\n                    minPath =\
    \ grid(curr._1)(curr._2) :: minPath\n                    var next = (0, 0)\n \
    \                   var min = Long.MaxValue\n                    for (x <- 0 until\
    \ grid.length; y <- 0 until grid.length) {\n                        if (abs(x\
    \ - curr._1) + abs(y - curr._2) == 1) {\n                            if (dp(x)(y)(currK\
    \ - 1) + grid(curr._1)(curr._2) < min) {\n                                min\
    \ = dp(x)(y)(currK - 1) + grid(curr._1)(curr._2)\n                           \
    \     next =", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq.enqueue((0, 0, 0))\n        while\
    \ (pq.nonEmpty) {\n            val (d, i, j) = pq.dequeue\n            if (dp(i)(j)\
    \ > d) {\n                dp(i)(j) = d\n                if (i > 0) pq.enqueue((d\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1) pq.enqueue((d +\
    \ grid(i + 1)(j), i + 1, j))\n                if (j > 0) pq.enqueue((d + grid(i)(j\
    \ - 1), i, j - 1))\n                if (j < m - 1) pq.enqueue((d + grid(i)(j +\
    \ 1), i, j + 1))\n            }\n        }\n        val pq2 = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq2.enqueue((0, 0, 0))\n        val\
    \ dp2 = Array.fill(n, m)(Long.MaxValue)\n        dp2(0)(0) = 0\n        val parent\
    \ = Array.fill(n, m)((-1, -1))\n        val path = ListBuffer[Long]()\n      \
    \  while (pq2.nonEmpty) {\n            val (d, i, j) = pq2.dequeue\n         \
    \   if (dp2(i)(j) == d) {\n                if (k == 1) {\n                   \
    \ path += grid(i)(j)\n                    var (x, y) = parent(i)(j)\n        \
    \            while (x != -1) {\n                        path += grid(x)(y)\n \
    \                       val (xx, yy) = parent(x)(y)\n                        x\
    \ = xx\n                        y = yy\n                    }\n              \
    \      return path.reverse.toList\n                }\n                if (i",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x\
    \ => x._1))\n        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n  \
    \          val (cost, i, j) = pq.dequeue\n            if (dp(i)(j) <= cost) {\n\
    \                if (i == n - 1 && j == m - 1 && cost <= k) return reconstruct(dp,\
    \ i, j, k)\n                if (i + 1 < n && dp(i + 1)(j) > cost + grid(i + 1)(j))\
    \ {\n                    dp(i + 1)(j) = cost + grid(i + 1)(j)\n              \
    \      pq.enqueue((dp(i + 1)(j), i + 1, j))\n                }\n             \
    \   if (j + 1 < m && dp(i)(j + 1) > cost + grid(i)(j + 1)) {\n               \
    \     dp(i)(j + 1) = cost + grid(i)(j + 1)\n                    pq.enqueue((dp(i)(j\
    \ + 1), i, j + 1))\n                }\n            }\n        }\n        return\
    \ List()", "        val n = grid.length\n        val m = grid(0).length\n    \
    \    val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        for (i <- 0 until n) {\n         \
    \   for (j <- 0 until m) {\n                dp(i)(j) = grid(i)(j)\n          \
    \      pq.enqueue((dp(i)(j), i, j))\n            }\n        }\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i >\
    \ 0) {\n                    dp(i)(j) = min(dp(i)(j), dp(i - 1)(j) + grid(i)(j))\n\
    \                    pq.enqueue((dp(i)(j), i, j))\n                }\n       \
    \         if (j > 0) {\n                    dp(i)(j) = min(dp(i)(j), dp(i)(j -\
    \ 1) + grid(i)(j))\n                    pq.enqueue((dp(i)(j), i, j))\n       \
    \         }\n            }\n        }\n        val result = new ListBuffer[Long]()\n\
    \        while (result.length < k) {\n            val (value, i, j) = pq.dequeue()\n\
    \            result += value\n            if (i > 0) {\n                dp(i)(j)\
    \ = min(dp(i)(j), dp(i - 1)(j) + grid(i)(j))\n                pq.enqueue((dp(i)(j),\
    \ i, j))\n            }\n            if (j > 0) {\n                dp(i)(j) =\
    \ min(dp(i)(j), dp(i)(j - 1) + grid(i)(j))\n                pq.enqueue((dp(i)(j),\
    \ i, j))\n            }\n        }\n        result.toList", "        val n = grid.length\n\
    \        val dp = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until n) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length + 1 <= k && dp(i - 1)(j) < dp(i)(j))\
    \ dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                if (j > 0 && dp(i)(j\
    \ - 1).length + 1 <= k && dp(i)(j - 1) < dp(i)(j)) dp(i)(j) = dp(i)(j - 1) :+\
    \ grid(i)(j)\n            }\n        }\n        dp(n - 1)(n - 1)", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    if (i > 0) {\n                    \
    \    val lst = dp(i - 1)(j)\n                        if (lst.length < k) dp(i)(j)\
    \ = grid(i)(j) :: lst\n                        else if (lst.length == k) dp(i)(j)\
    \ = grid(i)(j) :: lst.dropRight(1)\n                    }\n                  \
    \  if (j > 0) {\n                        val lst = dp(i)(j - 1)\n            \
    \            if (lst.length < k) {\n                            if (dp(i)(j).length\
    \ < k) dp(i)(j) = grid(i)(j) :: lst\n                            else if (lst.length\
    \ < dp(i)(j).length) dp(i)(j) = grid(i)(j) :: lst.dropRight(1)\n             \
    \           }\n                        else if (lst.length == k) {\n         \
    \                   if (dp(i)(j).length < k) dp(i)(j) = grid(i)(j) :: lst.dropRight(1)\n\
    \                            else if (lst.length < dp(i)(j).length) dp(i)(j) =\
    \ grid(i)(j) :: lst.dropRight(1)\n                        }\n                \
    \    }\n                }\n            }\n        }\n        dp(n - 1)(m - 1)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val pq2 = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(_._1))\n        pq2.enqueue((0, 0, 0))\n        val\
    \ visited = Array.fill(n, m)(false)\n        visited(0)(0) = true\n        var\
    \ ans = List[Long]()\n        while (!pq2.isEmpty) {\n            val (cost, i,\
    \ j) = pq2.dequeue\n            ans = ans :+ grid(i)(j)\n            if (ans.length\
    \ == k) return ans\n            if (i > 0 && !visited(i - 1)(j) && dp(i - 1)(j)\
    \ == cost + grid(i - 1)(j)) {\n                pq2.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                visited(i - 1)(j) = true\n            }\n      \
    \      if (i < n - 1 && !visited(i + 1)(j) && dp(i + 1)(j) == cost + grid(i +\
    \ 1)(j", "        val n = grid.length\n        val m = grid(0).length\n      \
    \  val dp = Array.fill(n, m)(0L)\n        val prev = Array.fill(n, m)(0L)\n  \
    \      for (i <- 0 until n) {\n            for (j <- 0 until m) {\n          \
    \      dp(i)(j) = grid(i)(j)\n                prev(i)(j) = -1\n            }\n\
    \        }\n        for (i <- 1 until n) {\n            for (j <- 0 until m) {\n\
    \                if (dp(i - 1)(j) < dp(i)(j)) {\n                    dp(i)(j)\
    \ = dp(i - 1)(j)\n                    prev(i)(j) = 0\n                }\n    \
    \        }\n        }\n        for (j <- 1 until m) {\n            for (i <- 0\
    \ until n) {\n                if (dp(i)(j - 1) < dp(i)(j)) {\n               \
    \     dp(i)(j) = dp(i)(j - 1)\n                    prev(i)(j) = 1\n          \
    \      }\n            }\n        }\n        for (j <- 1 until m) {\n         \
    \   for (i <- 1 until n) {\n                if (dp(i - 1)(j - 1) < dp(i)(j)) {\n\
    \                    dp(i)(j) = dp(i - 1)(j - 1)\n                    prev(i)(j)\
    \ = 2\n                }\n            }\n        }\n        var i = n - 1\n  \
    \      var j = m - 1\n        var path = List[Long]()\n        while (k > 0) {\n\
    \            path = grid(i)(j) :: path\n            k -= 1\n            if (prev(i)(j)\
    \ == 0) i -= 1\n            else if (prev(i)(j) == 1) j -= 1\n            else\
    \ {\n                i -= 1\n                j -= 1\n            }\n        }\n\
    \        path", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val prev = Array.fill(n,\
    \ m)((0, 0))\n        val q = new Queue[(Int, Int)]\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j) ==\
    \ 1) {\n                    dp(i)(j) = 0\n                    q.enqueue((i, j))\n\
    \                }\n            }\n        }\n        while (!q.isEmpty) {\n \
    \           val (x, y) = q.dequeue\n            for (i <- -1 to 1) {\n       \
    \         for (j <- -1 to 1) {\n                    if (i == 0 && j == 0) {\n\
    \                        // do nothing\n                    } else if (x + i >=\
    \ 0 && x + i < n && y + j >= 0 && y + j < m) {\n                        if (dp(x\
    \ + i)(y + j) > dp(x)(y) + 1) {\n                            dp(x + i)(y + j)\
    \ = dp(x)(y) + 1\n                            prev(x + i)(y + j) = (x, y)\n  \
    \                          q.enqueue((x + i, y + j))\n                       \
    \ }\n                    }\n                }\n            }\n        }\n    \
    \    var (x, y) = (0, 0)\n        var min = Long.MaxValue\n        for (i <- 0\
    \ until n) {\n            for (j <- 0 until m) {\n                if (dp(i)(j)\
    \ < min) {\n                    min = dp(i)(j)\n                    x = i\n  \
    \                  y = j\n                }\n            }\n        }\n      \
    \  var result = List[Long]()\n        for (i <- 0 until k) {\n            result\
    \ = grid(x)(y) :: result\n            val (x1, y1) = prev(x)(y)\n            x\
    \ = x1\n            y = y1\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val lst = ListBuffer[List[Long]]()\n                \
    \    if (i > 0) lst += dp(i - 1)(j)\n                    if (j > 0) lst += dp(i)(j\
    \ - 1)\n                    if (lst.isEmpty) dp(i)(j) = List(grid(i)(j))\n   \
    \                 else {\n                        val min = lst.minBy(l => (l\
    \ :+ grid(i)(j)).mkString(\"\"))\n                        dp(i)(j) = min :+ grid(i)(j)\n\
    \                    }\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(0L)\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until m) {\n                dp(i)(j) = grid(i)(j)\n      \
    \          if (i > 0) dp(i)(j) = min(dp(i)(j), dp(i - 1)(j))\n               \
    \ if (j > 0) dp(i)(j) = min(dp(i)(j), dp(i)(j - 1))\n            }\n        }\n\
    \        val result = ListBuffer[Long]()\n        var i = 0\n        var j = 0\n\
    \        while (k > 0) {\n            result += grid(i)(j)\n            k -= 1\n\
    \            if (i == n - 1 && j == m - 1) return result.toList\n            if\
    \ (i == n - 1) {\n                j += 1\n            } else if (j == m - 1) {\n\
    \                i += 1\n            } else {\n                if (dp(i + 1)(j)\
    \ < dp(i)(j + 1)) {\n                    i += 1\n                } else {\n  \
    \                  j += 1\n                }\n            }\n        }\n     \
    \   result.toList", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(Long.MaxValue)\n        val prev = Array.fill(n, n)(List[Long]())\n     \
    \   dp(0)(0) = grid(0)(0)\n        prev(0)(0) = List(grid(0)(0))\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                if (i\
    \ > 0) {\n                    if (dp(i - 1)(j) + grid(i)(j) < dp(i)(j)) {\n  \
    \                      dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n                \
    \        prev(i)(j) = prev(i - 1)(j) :+ grid(i)(j)\n                    }\n  \
    \                  else if (dp(i - 1)(j) + grid(i)(j) == dp(i)(j)) {\n       \
    \                 val lst = prev(i - 1)(j) :+ grid(i)(j)\n                   \
    \     if (lst < prev(i)(j)) {\n                            prev(i)(j) = lst\n\
    \                        }\n                    }\n                }\n       \
    \         if (j > 0) {\n                    if (dp(i)(j - 1) + grid(i)(j) < dp(i)(j))\
    \ {\n                        dp(i)(j) = dp(i)(j - 1) + grid(i)(j)\n          \
    \              prev(i)(j) = prev(i)(j - 1) :+ grid(i)(j)\n                   \
    \ }\n                    else if (dp(i)(j - 1) + grid(i)(j) == dp(i)(j)) {\n \
    \                       val lst = prev(i)(j - 1) :+ grid(i)(j)\n             \
    \           if (lst < prev(i)(j)) {\n                            prev(i)(j) =\
    \ lst\n                        }\n                    }\n                }\n \
    \           }\n        }\n        val lst = prev(n - 1)(n - 1)\n        lst.take(lst.length\
    \ - 1)", "        val n = grid.length\n        val m = grid(0).length\n      \
    \  val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(grid(i)(j))\n                else {\n                    val up = if\
    \ (i > 0) dp(i - 1)(j) else List[Long]()\n                    val left = if (j\
    \ > 0) dp(i)(j - 1) else List[Long]()\n                    if (up.length == 0)\
    \ dp(i)(j) = left :+ grid(i)(j)\n                    else if (left.length == 0)\
    \ dp(i)(j) = up :+ grid(i)(j)\n                    else if (up.length < left.length)\
    \ dp(i)(j) = up :+ grid(i)(j)\n                    else if (up.length > left.length)\
    \ dp(i)(j) = left :+ grid(i)(j)\n                    else if (up < left) dp(i)(j)\
    \ = up :+ grid(i)(j)\n                    else dp(i)(j) = left :+ grid(i)(j)\n\
    \                }\n            }\n        }\n        val result = dp(n - 1)(m\
    \ - 1)\n        result.take(k.toInt)", "        val n = grid.length\n        val\
    \ dp = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until n) {\n      \
    \      for (j <- 0 until n) {\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(grid(i)(j))\n                else {\n                    var min = List[Long]()\n\
    \                    if (i > 0) {\n                        val lst = dp(i - 1)(j)\n\
    \                        if (lst.length < k) min = lst :+ grid(i)(j)\n       \
    \                 else if (lst.length == k) min = lst.updated(k - 1, min(k - 1)\
    \ min grid(i)(j))\n                    }\n                    if (j > 0) {\n \
    \                       val lst = dp(i)(j - 1)\n                        if (lst.length\
    \ < k) {\n                            if (min.length == 0) min = lst :+ grid(i)(j)\n\
    \                            else if (lst.length < min.length) min = lst :+ grid(i)(j)\n\
    \                            else if (lst.length == min.length) min = (lst :+\
    \ grid(i)(j)).updated(k - 1, min(k - 1) min (lst :+ grid(i)(j))(k - 1))\n    \
    \                    }\n                        else if (lst.length == k) {\n\
    \                            if (min.length == 0) min = lst.updated(k - 1, min(k\
    \ - 1) min grid(i)(j))\n                            else if (lst.length < min.length)\
    \ min = lst.updated(k - 1, min(k - 1) min grid(i)(j))\n                      \
    \      else if (lst.length == min.length) min = min.updated(k - 1, min(k - 1)\
    \ min lst.updated(k - 1, min(k - 1) min grid(i)(j))(k - 1))\n                \
    \        }\n                    }\n                    dp(i)(j) = min\n      \
    \          }\n            }\n        }\n        dp(n - 1)(n - 1)", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x\
    \ => x._1))\n        for (i <- 0 until n) {\n            for (j <- 0 until m)\
    \ {\n                pq.enqueue((grid(i)(j), i, j))\n            }\n        }\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = pq.dequeue()._1\n            }\n        }\n        val result\
    \ = Array.fill(k.toInt)(0L)\n        val visited = Array.fill(n, m)(false)\n \
    \       val q = new Queue[(Int, Int)]()\n        q.enqueue((0, 0))\n        visited(0)(0)\
    \ = true\n        var count = 0\n        while (count < k) {\n            val\
    \ (i, j) = q.dequeue()\n            result(count) = dp(i)(j)\n            count\
    \ += 1\n            if (i + 1 < n && !visited(i + 1)(j)) {\n                q.enqueue((i\
    \ + 1, j))\n                visited(i + 1)(j) = true\n            }\n        \
    \    if (j + 1 < m && !visited(i)(j + 1)) {\n                q.enqueue((i, j +\
    \ 1))\n                visited(i)(j + 1) = true\n            }\n            if\
    \ (i - 1 >= 0 && !visited(i - 1)(j)) {\n                q.enqueue((i - 1, j))\n\
    \                visited(i - 1)(j) = true\n            }\n            if (j -\
    \ 1 >= 0 && !visited(i)(j - 1)) {\n                q.enqueue((i, j - 1))\n   \
    \             visited(i)(j - 1) = true\n            }\n        }\n        result.toList",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n\
    \        val prev = Array.fill(n, n)(-1)\n        val next = Array.fill(n, n)(-1)\n\
    \        val queue = new Queue[(Int, Int)]\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until n) {\n                dp(i)(j) = grid(i)(j)\n  \
    \              queue.enqueue((i, j))\n            }\n        }\n        while\
    \ (queue.nonEmpty) {\n            val (i, j) = queue.dequeue\n            for\
    \ (d <- 0 until 4) {\n                val (ni, nj) = (i + \"2101\".charAt(d) -\
    \ '1', j + \"1210\".charAt(d) - '1')\n                if (ni >= 0 && ni < n &&\
    \ nj >= 0 && nj < n) {\n                    if (dp(ni)(nj) > dp(i)(j) + grid(ni)(nj))\
    \ {\n                        dp(ni)(nj) = dp(i)(j) + grid(ni)(nj)\n          \
    \              prev(ni)(nj) = i * n + j\n                        queue.enqueue((ni,\
    \ nj))\n                    }\n                }\n            }\n        }\n \
    \       var (i, j) = (0, 0)\n        for (i <- 0 until n; j <- 0 until n) {\n\
    \            if (dp(i)(j) == dp(0)(0)) {\n                break\n            }\n\
    \        }\n        var (ni, nj) = (i, j)\n        var count = 0\n        while\
    \ (count < k) {\n            count += 1\n            next(i)(j) = ni * n + nj\n\
    \            val (ti, tj) = (ni, nj)\n            ni = i\n            nj = j\n\
    \            i = ti\n            j = tj\n        }\n        val result = new ListBuffer[Long]\n\
    \        result += grid(i)(j)\n        while (count > 0) {\n            count\
    \ -= 1\n            val (ni, nj", "        val n = grid.length\n        val m\
    \ = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i\
    \ == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else {\n      \
    \              val l = if (i > 0) dp(i - 1)(j) else List[Long]()\n           \
    \         val r = if (j > 0) dp(i)(j - 1) else List[Long]()\n                \
    \    val lr = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n       \
    \             val lr_ = if (i > 0 && j > 0) dp(i - 1)(j - 1) :+ grid(i)(j) else\
    \ List[Long]()\n                    val l_ = if (i > 0) dp(i - 1)(j) :+ grid(i)(j)\
    \ else List[Long]()\n                    val r_ = if (j > 0) dp(i)(j - 1) :+ grid(i)(j)\
    \ else List[Long]()\n                    val lr_l = if (i > 0 && j > 0) lr_.length\
    \ else 0\n                    val l_l = if (i > 0) l_.length else 0\n        \
    \            val r_l = if (j > 0) r_.length else 0\n                    val lr_l_\
    \ = if (i > 0 && j > 0) lr_.length else 0\n                    val l_l_ = if (i\
    \ > 0) l_.length else 0\n                    val r_l_ = if (j > 0) r_.length else\
    \ 0\n                    if (lr_l > 0 && lr_l <= k) {\n                      \
    \  if (l_l > 0 && l_l <= k && l_ < lr_) dp(i)(j) = l_\n                      \
    \  else if (r_l > 0 && r_l <= k && r_ < lr_) dp(i)(j) = r_\n                 \
    \       else dp(i)(j) = lr_\n                   ", "        val n = grid.length\n\
    \        val dp = Array.fill(n, n)(List[Long]())\n        val visited = Array.fill(n,\
    \ n)(false)\n        val queue = Queue[(Int, Int)]()\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until n) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                queue.enqueue((i, j))\n                visited(i)(j) = true\n\
    \            }\n        }\n        while (!queue.isEmpty) {\n            val (i,\
    \ j) = queue.dequeue\n            val lst = dp(i)(j)\n            if (lst.length\
    \ == k) return lst\n            if (i > 0 && !visited(i - 1)(j)) {\n         \
    \       val newLst = lst :+ grid(i - 1)(j)\n                dp(i - 1)(j) = newLst\n\
    \                visited(i - 1)(j) = true\n                queue.enqueue((i -\
    \ 1, j))\n            }\n            if (i < n - 1 && !visited(i + 1)(j)) {\n\
    \                val newLst = lst :+ grid(i + 1)(j)\n                dp(i + 1)(j)\
    \ = newLst\n                visited(i + 1)(j) = true\n                queue.enqueue((i\
    \ + 1, j))\n            }\n            if (j > 0 && !visited(i)(j - 1)) {\n  \
    \              val newLst = lst :+ grid(i)(j - 1)\n                dp(i)(j - 1)\
    \ = newLst\n                visited(i)(j - 1) = true\n                queue.enqueue((i,\
    \ j - 1))\n            }\n            if (j < n - 1 && !visited(i)(j + 1)) {\n\
    \                val newLst = lst :+ grid(i)(j + 1)\n                dp(i)(j +\
    \ 1) = newLst\n                visited(i)(j + 1) = true\n                queue.enqueue((i,\
    \ j + 1))\n            }\n        }\n        List[Long]()\n", "        val n =\
    \ grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n        val pq\
    \ = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n        pq.enqueue((0,\
    \ 0, 0))\n        while (!pq.isEmpty) {\n            val (cost, i, j) = pq.dequeue\n\
    \            if (dp(i)(j) > cost) {\n                dp(i)(j) = cost\n       \
    \         if (i > 0) pq.enqueue((cost + grid(i - 1)(j), i - 1, j))\n         \
    \       if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), i + 1, j))\n       \
    \         if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i, j - 1))\n         \
    \       if (j < n - 1) pq.enqueue((cost + grid(i)(j + 1), i, j + 1))\n       \
    \     }\n        }\n        val ans = new ListBuffer[Long]()\n        var i =\
    \ 0\n        var j = 0\n        while (k > 0) {\n            ans += grid(i)(j)\n\
    \            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -= 1\n\
    \            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n            \
    \    i += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n    \
    \            j -= 1\n            } else {\n                j += 1\n          \
    \  }\n            k -= 1\n        }\n        ans.toList", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val path = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                if (i == 0 && j ==\
    \ 0) {\n                    dp(i)(j) = grid(i)(j)\n                    path(i)(j)\
    \ = List(grid(i)(j))\n                }\n                else {\n            \
    \        if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                        dp(i)(j)\
    \ = dp(i - 1)(j)\n                        path(i)(j) = path(i - 1)(j)\n      \
    \              }\n                    if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n\
    \                        dp(i)(j) = dp(i)(j - 1)\n                        path(i)(j)\
    \ = path(i)(j - 1)\n                    }\n                    dp(i)(j) += grid(i)(j)\n\
    \                    path(i)(j) = path(i)(j) :+ grid(i)(j)\n                }\n\
    \            }\n        }\n        val result = path(n - 1)(m - 1)\n        if\
    \ (result.length > k) result.slice(0, k.toInt) else result", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val result = new ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        var cost = 0L\n        while (result.length\
    \ < k) {\n            result += grid(i)(j)\n            val next = List((i - 1,\
    \ j), (i + 1, j), (i, j - 1), (i, j + 1)).filter(x => x._1 >= 0 && x._1 < n &&\
    \ x._2 >= 0 && x._2 < m).map(x => (dp(x._1)(x._2) + grid(x._1)(x._2), x._1, x._2)).minBy(_._1)\n\
    \            i = next._2\n            j = next._3\n            cost = next._1\n\
    \        }\n        result.toList", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n     \
    \   val prev = Array.fill(n, m)(-1)\n        for (i <- 0 until n) {\n        \
    \    for (j <- 0 until m) {\n                if (i == 0 && j == 0) {\n       \
    \             dp(i)(j) = grid(i)(j)\n                } else {\n              \
    \      if (i > 0) {\n                        if (dp(i - 1)(j) < dp(i)(j)) {\n\
    \                            dp(i)(j) = dp(i - 1)(j)\n                       \
    \     prev(i)(j) = 0\n                        }\n                    }\n     \
    \               if (j > 0) {\n                        if (dp(i)(j - 1) < dp(i)(j))\
    \ {\n                            dp(i)(j) = dp(i)(j - 1)\n                   \
    \         prev(i)(j) = 1\n                        }\n                    }\n \
    \                   dp(i)(j) += grid(i)(j)\n                }\n            }\n\
    \        }\n        val result = ListBuffer[Long]()\n        var i = n - 1\n \
    \       var j = m - 1\n        while (k > 0) {\n            result += grid(i)(j)\n\
    \            k -= 1\n            if (prev(i)(j) == 0) {\n                i -=\
    \ 1\n            } else if (prev(i)(j) == 1) {\n                j -= 1\n     \
    \       }\n        }\n        result.toList", "        val n = grid.length\n \
    \       val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        val lst = List[Long](grid(i)(j))\n                if (i == 0 && j ==\
    \ 0) dp(i)(j) = lst\n                else if (i == 0) dp(i)(j) = lst ::: dp(i)(j\
    \ - 1)\n                else if (j == 0) dp(i)(j) = lst ::: dp(i - 1)(j)\n   \
    \             else {\n                    val lst1 = lst ::: dp(i - 1)(j)\n  \
    \                  val lst2 = lst ::: dp(i)(j - 1)\n                    if (lst1\
    \ < lst2) dp(i)(j) = lst1\n                    else dp(i)(j) = lst2\n        \
    \        }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        // dp(i)(j)(k) = the minimum path of length k starting from (i, j)\n  \
    \      val dp = Array.fill(grid.length, grid.length, k.toInt + 1)(Long.MaxValue)\n\
    \        for (i <- 0 until grid.length; j <- 0 until grid.length) {\n        \
    \    dp(i)(j)(1) = grid(i)(j)\n        }\n        for (l <- 2 to k.toInt) {\n\
    \            for (i <- 0 until grid.length; j <- 0 until grid.length) {\n    \
    \            if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n\
    \                if (i < grid.length - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i\
    \ + 1)(j)(l - 1))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j\
    \ - 1)(l - 1))\n                if (j < grid.length - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j + 1)(l - 1))\n            }\n        }\n        var min = Long.MaxValue\n\
    \        var minI = -1\n        var minJ = -1\n        for (i <- 0 until grid.length;\
    \ j <- 0 until grid.length) {\n            if (dp(i)(j)(k.toInt) < min) {\n  \
    \              min = dp(i)(j)(k.toInt)\n                minI = i\n           \
    \     minJ = j\n            }\n        }\n        var result = List[Long]()\n\
    \        var i = minI\n        var j = minJ\n        for (l <- k.toInt to 1 by\
    \ -1) {\n            result = grid(i)(j) :: result\n            if (i > 0 && dp(i)(j)(l)\
    \ == dp(i - 1)(j)(l - 1)) {\n                i -= 1\n            } else if (i\
    \ < grid.length -", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        for (i <- 0 until n) {\n         \
    \   for (j <- 0 until m) {\n                pq.enqueue((grid(i)(j), i, j))\n \
    \           }\n        }\n        while (pq.nonEmpty) {\n            val (v, i,\
    \ j) = pq.dequeue\n            if (dp(i)(j) > v) {\n                dp(i)(j) =\
    \ v\n                if (i > 0) pq.enqueue((v + grid(i - 1)(j), i - 1, j))\n \
    \               if (i < n - 1) pq.enqueue((v + grid(i + 1)(j), i + 1, j))\n  \
    \              if (j > 0) pq.enqueue((v + grid(i)(j - 1), i, j - 1))\n       \
    \         if (j < m - 1) pq.enqueue((v + grid(i)(j + 1), i, j + 1))\n        \
    \    }\n        }\n        val result = ArrayBuffer[Long]()\n        var i = 0\n\
    \        var j = 0\n        for (l <- 0 until k.toInt) {\n            result +=\
    \ grid(i)(j)\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n          \
    \      i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n\
    \                i += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j))\
    \ {\n                j -= 1\n            } else if (j < m - 1 && dp(i)(j + 1)\
    \ < dp(i)(j)) {\n                j += 1\n            }\n        }\n        result.toList",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, (Int, Int))]()(Ordering.by(_._1))\n\
    \        pq.enqueue((0, (0, 0)))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, (i, j)) = pq.dequeue\n            if (dp(i)(j) > cost) {\n          \
    \      dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i -\
    \ 1)(j), (i - 1, j)))\n                if (i < n - 1) pq.enqueue((cost + grid(i\
    \ + 1)(j), (i + 1, j)))\n                if (j > 0) pq.enqueue((cost + grid(i)(j\
    \ - 1), (i, j - 1)))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j\
    \ + 1), (i, j + 1)))\n            }\n        }\n        val path = new ArrayBuffer[Long]()\n\
    \        var (i, j) = (0, 0)\n        while (path.length < k) {\n            path\
    \ += grid(i)(j)\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n       \
    \         i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j))\
    \ {\n                i += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j))\
    \ {\n                j -= 1\n            } else if (j < m - 1 && dp(i)(j + 1)\
    \ < dp(i)(j)) {\n                j += 1\n            }\n        }\n        path.toList",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    if (i > 0) {\n                        val lst = dp(i\
    \ - 1)(j)\n                        if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n\
    \                        else {\n                            val lst2 = lst.drop(1)\
    \ :+ grid(i)(j)\n                            if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n\
    \                        }\n                    }\n                    if (j >\
    \ 0) {\n                        val lst = dp(i)(j - 1)\n                     \
    \   if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n                       \
    \ else {\n                            val lst2 = lst.drop(1) :+ grid(i)(j)\n \
    \                           if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n           \
    \             }\n                    }\n                }\n            }\n   \
    \     }\n        dp(n - 1)(n - 1)", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else {\n\
    \                    val up = if (i > 0) dp(i - 1)(j) else List[Long]()\n    \
    \                val left = if (j > 0) dp(i)(j - 1) else List[Long]()\n      \
    \              if (up.length == 0 && left.length == 0) dp(i)(j) = List(grid(i)(j))\n\
    \                    else if (up.length == 0) dp(i)(j) = left :+ grid(i)(j)\n\
    \                    else if (left.length == 0) dp(i)(j) = up :+ grid(i)(j)\n\
    \                    else {\n                        val up_comp = up.compare(left\
    \ :+ grid(i)(j))\n                        val left_comp = left.compare(up :+ grid(i)(j))\n\
    \                        if (up_comp < 0) dp(i)(j) = up :+ grid(i)(j)\n      \
    \                  else if (left_comp < 0) dp(i)(j) = left :+ grid(i)(j)\n   \
    \                     else dp(i)(j) = if (up(0) < left(0)) up :+ grid(i)(j) else\
    \ left :+ grid(i)(j)\n                    }\n                }\n            }\n\
    \        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val prev = Array.fill(n, m)(-1)\n        for (i <- 0 until n) {\n   \
    \         for (j <- 0 until m) {\n                if (i == 0 && j == 0) {\n  \
    \                  dp(i)(j) = grid(i)(j)\n                } else {\n         \
    \           if (i > 0) {\n                        if (dp(i - 1)(j) < dp(i)(j))\
    \ {\n                            dp(i)(j) = dp(i - 1)(j)\n                   \
    \         prev(i)(j) = 0\n                        }\n                    }\n \
    \                   if (j > 0) {\n                        if (dp(i)(j - 1) < dp(i)(j))\
    \ {\n                            dp(i)(j) = dp(i)(j - 1)\n                   \
    \         prev(i)(j) = 1\n                        }\n                    }\n \
    \                   dp(i)(j) += grid(i)(j)\n                }\n            }\n\
    \        }\n        var i = n - 1\n        var j = m - 1\n        val path = ListBuffer[Long]()\n\
    \        while (k > 0) {\n            path += grid(i)(j)\n            k -= 1\n\
    \            if (prev(i)(j) == 0) {\n                i -= 1\n            } else\
    \ if (prev(i)(j) == 1) {\n                j -= 1\n            }\n        }\n \
    \       path.toList", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length > 0 && dp(i - 1)(j).length <\
    \ k) {\n                    if (dp(i - 1)(j).length + 1 == k) {\n            \
    \            if (dp(i - 1)(j).last < grid(i)(j)) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                    } else {\n                        if (dp(i - 1)(j).last <\
    \ grid(i)(j)) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                        else\
    \ dp(i)(j) = dp(i - 1)(j)\n                    }\n                }\n        \
    \        if (j > 0 && dp(i)(j - 1).length > 0 && dp(i)(j - 1).length < k) {\n\
    \                    if (dp(i)(j - 1).length + 1 == k) {\n                   \
    \     if (dp(i)(j - 1).last < grid(i)(j)) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    } else {\n                        if (dp(i)(j - 1).last <\
    \ grid(i)(j)) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                        else\
    \ dp(i)(j) = dp(i)(j - 1)\n                    }\n                }\n        \
    \    }\n        }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n \
    \       val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val prev = ListBuffer[List[Long]]()\n               \
    \     if (i > 0) prev += dp(i - 1)(j)\n                    if (j > 0) prev +=\
    \ dp(i)(j - 1)\n                    if (prev.isEmpty) dp(i)(j) = List(grid(i)(j))\n\
    \                    else {\n                        val min = prev.minBy(x =>\
    \ (x :+ grid(i)(j)).mkString)\n                        dp(i)(j) = min :+ grid(i)(j)\n\
    \                    }\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(x => x._1))\n        pq.enqueue((0, 0, 0))\n      \
    \  while (pq.nonEmpty) {\n            val (cost, i, j) = pq.dequeue\n        \
    \    if (dp(i)(j) > cost) {\n                dp(i)(j) = cost\n               \
    \ if (i > 0) pq.enqueue((cost + grid(i - 1)(j), i - 1, j))\n                if\
    \ (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), i + 1, j))\n                if\
    \ (j > 0) pq.enqueue((cost + grid(i)(j - 1), i, j - 1))\n                if (j\
    \ < m - 1) pq.enqueue((cost + grid(i)(j + 1), i, j + 1))\n            }\n    \
    \    }\n        val result = new ListBuffer[Long]()\n        var i = 0\n     \
    \   var j = 0\n        while (k > 0) {\n            result += grid(i)(j)\n   \
    \         k -= 1\n            if (i > 0 && dp(i - 1)(j) < dp(i + 1)(j) && dp(i\
    \ - 1)(j) < dp(i)(j - 1) && dp(i - 1)(j) < dp(i)(j + 1)) {\n                i\
    \ -= 1\n            } else if (i < n - 1 && dp(i + 1)(j) < dp(i - 1)(j) && dp(i\
    \ + 1)(j) < dp(i)(j - 1) && dp(i + 1)(j) < dp(i)(j + 1)) {\n                i\
    \ += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i - 1)(j) && dp(i)(j\
    \ - 1) < dp(i + 1)(j) && d", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val prev = Array.fill(n,\
    \ m)(-1)\n        val queue = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = grid(i)(j)\n                queue.enqueue((dp(i)(j), i, j))\n\
    \            }\n        }\n        for (i <- 0 until k - 1) {\n            val\
    \ (cost, x, y) = queue.dequeue\n            if (x - 1 >= 0) {\n              \
    \  if (dp(x - 1)(y) > cost + grid(x - 1)(y)) {\n                    dp(x - 1)(y)\
    \ = cost + grid(x - 1)(y)\n                    prev(x - 1)(y) = x * m + y\n  \
    \                  queue.enqueue((dp(x - 1)(y), x - 1, y))\n                }\n\
    \            }\n            if (x + 1 < n) {\n                if (dp(x + 1)(y)\
    \ > cost + grid(x + 1)(y)) {\n                    dp(x + 1)(y) = cost + grid(x\
    \ + 1)(y)\n                    prev(x + 1)(y) = x * m + y\n                  \
    \  queue.enqueue((dp(x + 1)(y), x + 1, y))\n                }\n            }\n\
    \            if (y - 1 >= 0) {\n                if (dp(x)(y - 1) > cost + grid(x)(y\
    \ - 1)) {\n                    dp(x)(y - 1) = cost + grid(x)(y - 1)\n        \
    \            prev(x)(y - 1) = x * m + y\n                    queue.enqueue((dp(x)(y\
    \ - 1), x, y - 1))\n                }\n            }\n            if (y + 1 <\
    \ m) {\n                if (dp(x)(y + 1) > cost + grid(x)(y + 1)) {\n        \
    \            dp(x)(y", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    val\
    \ lst = ListBuffer[List[Long]]()\n                    if (i > 0) lst += dp(i -\
    \ 1)(j)\n                    if (j > 0) lst += dp(i)(j - 1)\n                \
    \    if (lst.isEmpty) dp(i)(j) = List(grid(i)(j))\n                    else {\n\
    \                        val min = lst.minBy(x => (x :+ grid(i)(j)).mkString)\n\
    \                        dp(i)(j) = min :+ grid(i)(j)\n                    }\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val lst = ListBuffer[Long]()\n    \
    \                if (i > 0) lst ++= dp(i - 1)(j)\n                    if (j >\
    \ 0) lst ++= dp(i)(j - 1)\n                    dp(i)(j) = (lst.toList :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1)", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (d, i, j) = pq.dequeue\n            if (d < dp(i)(j)) {\n                dp(i)(j)\
    \ = d\n                if (i > 0) pq.enqueue((d - grid(i - 1)(j), i - 1, j))\n\
    \                if (i < n - 1) pq.enqueue((d - grid(i + 1)(j), i + 1, j))\n \
    \               if (j > 0) pq.enqueue((d - grid(i)(j - 1), i, j - 1))\n      \
    \          if (j < m - 1) pq.enqueue((d - grid(i)(j + 1), i, j + 1))\n       \
    \     }\n        }\n        val res = ArrayBuffer[Long]()\n        var i = 0\n\
    \        var j = 0\n        while (res.length < k) {\n            res += grid(i)(j)\n\
    \            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -= 1\n\
    \            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n            \
    \    i += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n    \
    \            j -= 1\n            } else if (j < m - 1 && dp(i)(j + 1) < dp(i)(j))\
    \ {\n                j += 1\n            }\n        }\n        res.toList", " \
    \       val n = grid.length\n        val dp = Array.fill(n, n)(0L)\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                dp(i)(j)\
    \ = grid(i)(j)\n                if (i > 0) dp(i)(j) = min(dp(i)(j), dp(i - 1)(j))\n\
    \                if (j > 0) dp(i)(j) = min(dp(i)(j), dp(i)(j - 1))\n         \
    \   }\n        }\n        val result = ArrayBuffer[Long]()\n        var i = 0\n\
    \        var j = 0\n        while (k > 0) {\n            result += grid(i)(j)\n\
    \            k -= 1\n            if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n\
    \                i += 1\n            } else if (j < n - 1 && dp(i)(j + 1) < dp(i)(j))\
    \ {\n                j += 1\n            } else {\n                i += 1\n  \
    \              j += 1\n            }\n        }\n        result.toList", "   \
    \     val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n \
    \       for (i <- 0 until n) {\n            for (j <- 0 until n) {\n         \
    \       dp(i)(j) = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length\
    \ <= k && dp(i - 1)(j).length + 1 <= k && dp(i - 1)(j).length + 1 < dp(i)(j).length)\
    \ {\n                    dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n             \
    \   }\n                if (j > 0 && dp(i)(j - 1).length <= k && dp(i)(j - 1).length\
    \ + 1 <= k && dp(i)(j - 1).length + 1 < dp(i)(j).length) {\n                 \
    \   dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                }\n            }\n\
    \        }\n        dp(n - 1)(n - 1)", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n     \
    \   val path = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (i == 0 && j == 0) {\n\
    \                    dp(i)(j) = grid(i)(j)\n                    path(i)(j) = List(grid(i)(j))\n\
    \                }\n                else {\n                    if (i > 0 && dp(i\
    \ - 1)(j) < dp(i)(j)) {\n                        dp(i)(j) = dp(i - 1)(j)\n   \
    \                     path(i)(j) = path(i - 1)(j)\n                    }\n   \
    \                 if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                  \
    \      dp(i)(j) = dp(i)(j - 1)\n                        path(i)(j) = path(i)(j\
    \ - 1)\n                    }\n                    dp(i)(j) += grid(i)(j)\n  \
    \                  path(i)(j) = path(i)(j) :+ grid(i)(j)\n                }\n\
    \            }\n        }\n        var i = n - 1\n        var j = m - 1\n    \
    \    while (k > 1) {\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n  \
    \              i -= 1\n            }\n            else if (j > 0 && dp(i)(j -\
    \ 1) < dp(i)(j)) {\n                j -= 1\n            }\n            else {\n\
    \                i -= 1\n                j -= 1\n            }\n            k\
    \ -= 1\n        }\n        path(i)(j)", "        val n = grid.length\n       \
    \ val dp = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until n) for (j\
    \ <- 0 until n) {\n            if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n\
    \            else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \            else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \            else {\n                val left = dp(i)(j - 1) :+ grid(i)(j)\n \
    \               val up = dp(i - 1)(j) :+ grid(i)(j)\n                if (left.length\
    \ > up.length) dp(i)(j) = left.sorted\n                else if (left.length <\
    \ up.length) dp(i)(j) = up.sorted\n                else {\n                  \
    \  var flag = false\n                    for (i <- 0 until left.length) {\n  \
    \                      if (left(i) < up(i)) {\n                            dp(i)(j)\
    \ = left\n                            flag = true\n                          \
    \  break\n                        }\n                        else if (left(i)\
    \ > up(i)) {\n                            dp(i)(j) = up\n                    \
    \        flag = true\n                            break\n                    \
    \    }\n                    }\n                    if (!flag) dp(i)(j) = left\n\
    \                }\n            }\n        }\n        dp(n - 1)(n - 1).take(k.toInt)",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    if (i > 0) {\n                        val lst = dp(i\
    \ - 1)(j)\n                        if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n\
    \                        else if (lst.length == k) {\n                       \
    \     if (lst.last > grid(i)(j)) dp(i)(j) = lst.init :+ grid(i)(j)\n         \
    \               }\n                    }\n                    if (j > 0) {\n \
    \                       val lst = dp(i)(j - 1)\n                        if (lst.length\
    \ < k) {\n                            if (dp(i)(j).length < k) dp(i)(j) = lst\
    \ :+ grid(i)(j)\n                            else if (dp(i)(j).length == k) {\n\
    \                                if (dp(i)(j).last > grid(i)(j)) dp(i)(j) = lst\
    \ :+ grid(i)(j)\n                            }\n                        }\n  \
    \                      else if (lst.length == k) {\n                         \
    \   if (lst.last > grid(i)(j)) {\n                                if (dp(i)(j).length\
    \ < k) dp(i)(j) = lst.init :+ grid(i)(j)\n                                else\
    \ if (dp(i)(j).length == k) {\n                                    if (dp(i)(j).last\
    \ > grid(i)(j)) dp(i)(j) = lst.init :+ grid(i)(j)\n                          \
    \      }\n                            }\n                        }\n         \
    \           }\n                }\n            }\n        }\n        dp(n - 1)(n\
    \ - 1)", "        val n = grid.length\n        val m = grid(0).length\n      \
    \  val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq.enqueue((0, 0, 0))\n        while\
    \ (pq.nonEmpty) {\n            val (cost, i, j) = pq.dequeue\n            if (dp(i)(j)\
    \ <= cost) {\n                if (i == n - 1 && j == m - 1 && cost <= k) return\
    \ List(grid(i)(j))\n                if (i + 1 < n && dp(i + 1)(j) > cost + grid(i\
    \ + 1)(j)) {\n                    dp(i + 1)(j) = cost + grid(i + 1)(j)\n     \
    \               pq.enqueue((dp(i + 1)(j), i + 1, j))\n                }\n    \
    \            if (j + 1 < m && dp(i)(j + 1) > cost + grid(i)(j + 1)) {\n      \
    \              dp(i)(j + 1) = cost + grid(i)(j + 1)\n                    pq.enqueue((dp(i)(j\
    \ + 1), i, j + 1))\n                }\n            }\n        }\n        return\
    \ List()", "        val n = grid.length\n        val m = grid(0).length\n    \
    \    val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(_._1))\n        pq.enqueue((0, 0, 0))\n        while\
    \ (pq.nonEmpty) {\n            val (cost, i, j) = pq.dequeue\n            if (dp(i)(j)\
    \ > cost) {\n                dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1) pq.enqueue((cost\
    \ + grid(i + 1)(j), i + 1, j))\n                if (j > 0) pq.enqueue((cost +\
    \ grid(i)(j - 1), i, j - 1))\n                if (j < m - 1) pq.enqueue((cost\
    \ + grid(i)(j + 1), i, j + 1))\n            }\n        }\n        val result =\
    \ new ListBuffer[Long]()\n        var i = 0\n        var j = 0\n        while\
    \ (k > 0) {\n            result += grid(i)(j)\n            k -= 1\n          \
    \  if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -= 1\n         \
    \   } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n                i += 1\n\
    \            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                j\
    \ -= 1\n            } else if (j < m - 1 && dp(i)(j + 1) < dp(i)(j)) {\n     \
    \           j += 1\n            }\n        }\n        result.toList", "      \
    \  val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val up = if (i > 0) dp(i - 1)(j) else\
    \ List[Long]()\n                    val left = if (j > 0) dp(i)(j - 1) else List[Long]()\n\
    \                    val up_left = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val up_left_up = if (i > 1 && j > 0) dp(i - 2)(j - 1) else\
    \ List[Long]()\n                    val up_left_left = if (i > 0 && j > 1) dp(i\
    \ - 1)(j - 2) else List[Long]()\n                    val up_left_up_left = if\
    \ (i > 1 && j > 1) dp(i - 2)(j - 2) else List[Long]()\n                    val\
    \ up_left_up_left_up = if (i > 2 && j > 1) dp(i - 3)(j - 2) else List[Long]()\n\
    \                    val up_left_up_left_left = if (i > 1 && j > 2) dp(i - 2)(j\
    \ - 3) else List[Long]()\n                    val up_left_up_left_up_left = if\
    \ (i > 2 && j > 2) dp(i - 3)(j - 3) else List[Long]()\n                    val\
    \ up_left_up_left_up_left_up = if (i > 3 && j > 2) dp(i - 4)(j - 3) else List[Long]()\n\
    \                    val up_left_up_left_up_left_left = if (i > 2 && j > 3) dp(i\
    \ - 3)(j - 4) else List[Long]()\n                    val up_left_up_left_up_left_",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val result = new ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while (k > 0) {\n            result\
    \ += grid(i)(j)\n            k -= 1\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j))\
    \ {\n                i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j)\
    \ < dp(i)(j)) {\n                i += 1\n            } else if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                j -= 1\n            } else if (j < m - 1\
    \ && dp(i)(j + 1) < dp(i)(j)) {\n                j += 1\n            }\n     \
    \   }\n        result.toList", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ (Int, Int))]()(Ordering.by(-_._1))\n        pq.enqueue((0, (0, 0)))\n      \
    \  while (pq.nonEmpty) {\n            val (cost, (i, j)) = pq.dequeue\n      \
    \      if (dp(i)(j) > cost) {\n                dp(i)(j) = cost\n             \
    \   if (i > 0) pq.enqueue((cost + grid(i - 1)(j), (i - 1, j)))\n             \
    \   if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), (i + 1, j)))\n         \
    \       if (j > 0) pq.enqueue((cost + grid(i)(j - 1), (i, j - 1)))\n         \
    \       if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), (i, j + 1)))\n     \
    \       }\n        }\n        val result = new ListBuffer[Long]()\n        var\
    \ i = 0\n        var j = 0\n        while (k > 0) {\n            result += grid(i)(j)\n\
    \            k -= 1\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n   \
    \             i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j))\
    \ {\n                i += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j))\
    \ {\n                j -= 1\n            } else if (j < m - 1 && dp(i)(j + 1)\
    \ < dp(i)(j)) {\n                j += 1\n            }\n        }\n        result.toList",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val result = new ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while (k > 0) {\n            result\
    \ += grid(i)(j)\n            k -= 1\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j))\
    \ {\n                i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j)\
    \ < dp(i)(j)) {\n                i += 1\n            } else if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                j -= 1\n            } else if (j < m - 1\
    \ && dp(i)(j + 1) < dp(i)(j)) {\n                j += 1\n            }\n     \
    \   }\n        result.toList", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    val\
    \ lst = ListBuffer[Long]()\n                    if (i > 0) lst ++= dp(i - 1)(j)\n\
    \                    if (j > 0) lst ++= dp(i)(j - 1)\n                    dp(i)(j)\
    \ = (lst.toList :+ grid(i)(j)).sorted.take(k.toInt)\n                }\n     \
    \       }\n        }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val visited = Array.fill(n, m)(false)\n        val queue = new Queue[(Int,\
    \ Int)]\n        queue.enqueue((0, 0))\n        dp(0)(0) = 0\n        visited(0)(0)\
    \ = true\n        while (!queue.isEmpty) {\n            val (i, j) = queue.dequeue\n\
    \            for (d <- 0 until 4) {\n                val (ni, nj) = (i + \"2101\"\
    .charAt(d) - '1', j + \"1210\".charAt(d) - '1')\n                if (ni >= 0 &&\
    \ ni < n && nj >= 0 && nj < m && !visited(ni)(nj)) {\n                    dp(ni)(nj)\
    \ = min(dp(ni)(nj), dp(i)(j) + grid(ni)(nj))\n                    visited(ni)(nj)\
    \ = true\n                    queue.enqueue((ni, nj))\n                }\n   \
    \         }\n        }\n        val result = new ListBuffer[Long]\n        var\
    \ (i, j) = (n - 1, m - 1)\n        while (k > 0) {\n            result += grid(i)(j)\n\
    \            k -= 1\n            var (ni, nj) = (i, j)\n            for (d <-\
    \ 0 until 4) {\n                val (ti, tj) = (i + \"2101\".charAt(d) - '1',\
    \ j + \"1210\".charAt(d) - '1')\n                if (ti >= 0 && ti < n && tj >=\
    \ 0 && tj < m && dp(ti)(tj) + grid(ti)(tj) == dp(i)(j)) {\n                  \
    \  ni = ti\n                    nj = tj\n                }\n            }\n  \
    \          i = ni\n            j = nj\n        }\n        result.toList", "  \
    \      val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        dp(i)(j) = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length\
    \ <= k && dp(i - 1)(j).length + 1 < dp(i)(j).length) {\n                    dp(i)(j)\
    \ = grid(i)(j) :: dp(i - 1)(j)\n                }\n                if (j > 0 &&\
    \ dp(i)(j - 1).length <= k && dp(i)(j - 1).length + 1 < dp(i)(j).length) {\n \
    \                   dp(i)(j) = grid(i)(j) :: dp(i)(j - 1)\n                }\n\
    \            }\n        }\n        dp(n - 1)(n - 1)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val prev = Array.fill(n, m)(-1)\n        for (i <- 0 until n) {\n   \
    \         for (j <- 0 until m) {\n                if (i == 0 && j == 0) {\n  \
    \                  dp(i)(j) = grid(i)(j)\n                } else {\n         \
    \           if (i > 0) {\n                        if (dp(i - 1)(j) + grid(i)(j)\
    \ < dp(i)(j)) {\n                            dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n\
    \                            prev(i)(j) = 0\n                        }\n     \
    \               }\n                    if (j > 0) {\n                        if\
    \ (dp(i)(j - 1) + grid(i)(j) < dp(i)(j)) {\n                            dp(i)(j)\
    \ = dp(i)(j - 1) + grid(i)(j)\n                            prev(i)(j) = 1\n  \
    \                      }\n                    }\n                }\n         \
    \   }\n        }\n        val path = ListBuffer[Long]()\n        var i = n - 1\n\
    \        var j = m - 1\n        while (k > 0) {\n            path += grid(i)(j)\n\
    \            if (prev(i)(j) == 0) {\n                i -= 1\n            } else\
    \ {\n                j -= 1\n            }\n            k -= 1\n        }\n  \
    \      path.toList", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        dp(i)(j) = grid(i)(j)\n                pq.enqueue((dp(i)(j), i, j))\n\
    \            }\n        }\n        for (i <- 1 until k.toInt) {\n            val\
    \ (v, x, y) = pq.dequeue\n            if (x > 0) {\n                dp(x - 1)(y)\
    \ = min(dp(x - 1)(y), v + grid(x - 1)(y))\n                pq.enqueue((dp(x -\
    \ 1)(y), x - 1, y))\n            }\n            if (x < n - 1) {\n           \
    \     dp(x + 1)(y) = min(dp(x + 1)(y), v + grid(x + 1)(y))\n                pq.enqueue((dp(x\
    \ + 1)(y), x + 1, y))\n            }\n            if (y > 0) {\n             \
    \   dp(x)(y - 1) = min(dp(x)(y - 1), v + grid(x)(y - 1))\n                pq.enqueue((dp(x)(y\
    \ - 1), x, y - 1))\n            }\n            if (y < n - 1) {\n            \
    \    dp(x)(y + 1) = min(dp(x)(y + 1), v + grid(x)(y + 1))\n                pq.enqueue((dp(x)(y\
    \ + 1), x, y + 1))\n            }\n        }\n        val (v, x, y) = pq.dequeue\n\
    \        val path = ListBuffer[Long]()\n        path += grid(x)(y)\n        for\
    \ (i <- 1 until k.toInt) {\n            if (x > 0 && dp(x - 1)(y) == v + grid(x\
    \ - 1)(y)) {\n                path += grid(x - 1)(y)\n                v", "  \
    \      val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x\
    \ => x._1))\n        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n  \
    \          val (d, i, j) = pq.dequeue\n            if (dp(i)(j) > d) {\n     \
    \           dp(i)(j) = d\n                if (i > 0) pq.enqueue((d + grid(i -\
    \ 1)(j), i - 1, j))\n                if (i < n - 1) pq.enqueue((d + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((d + grid(i)(j - 1), i, j\
    \ - 1))\n                if (j < m - 1) pq.enqueue((d + grid(i)(j + 1), i, j +\
    \ 1))\n            }\n        }\n        val pq2 = new PriorityQueue[(Long, Int,\
    \ Int)]()(Ordering.by(x => x._1))\n        pq2.enqueue((0, 0, 0))\n        val\
    \ dp2 = Array.fill(n, m)(Long.MaxValue)\n        val parent = Array.fill(n, m)((0,\
    \ 0))\n        while (!pq2.isEmpty) {\n            val (d, i, j) = pq2.dequeue\n\
    \            if (dp2(i)(j) > d) {\n                dp2(i)(j) = d\n           \
    \     if (i > 0) {\n                    pq2.enqueue((d + grid(i - 1)(j), i - 1,\
    \ j))\n                    parent(i - 1)(j) = (i, j)\n                }\n    \
    \            if (i < n - 1) {\n                    pq2.enqueue((d + grid(i + 1)(j),\
    \ i + 1, j))\n                    parent(i + 1)(j) = (i, j)\n                }\n",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val lst = ListBuffer[List[Long]]()\n                \
    \    if (i > 0) lst += (grid(i)(j) :: dp(i - 1)(j))\n                    if (j\
    \ > 0) lst += (grid(i)(j) :: dp(i)(j - 1))\n                    if (lst.isEmpty)\
    \ dp(i)(j) = List(grid(i)(j))\n                    else dp(i)(j) = lst.minBy(x\
    \ => x)\n                }\n            }\n        }\n        dp(n - 1)(n - 1).take(k.toInt)",
  "        // Solution 1:\n        // Let's say we have a path of length k, and let's\
    \ say the path is\n        // (x1, y1) -> (x2, y2) -> ... -> (xk, yk).\n     \
    \   // We can see that the path is uniquely determined by the sequence\n     \
    \   // (x1, y1, x2, y2, ..., xk, yk).\n        // Let's say we have two paths\
    \ (x1, y1, x2, y2, ..., xk, yk) and\n        // (x1', y1', x2', y2', ..., xk',\
    \ yk').\n        // If (x1, y1, x2, y2, ..., xk, yk) is lexicographically less\
    \ than\n        // (x1', y1', x2', y2', ..., xk', yk'), then the path\n      \
    \  // (x1, y1) -> (x2, y2) -> ... -> (xk, yk) is less than the path\n        //\
    \ (x1', y1') -> (x2', y2') -> ... -> (xk', yk').\n        // So we can use dynamic\
    \ programming to find the minimum path.\n        // Let dp(i, j, k) be the minimum\
    \ path starting from (i, j) of length k.\n        // dp(i, j, k) = min(dp(i -\
    \ 1, j, k - 1), dp(i + 1, j, k - 1), dp(i, j - 1, k - 1), dp(i, j + 1, k - 1))\n\
    \        // dp(i, j, 0) = (i, j)\n        // dp(i, j, k) = (i, j) + dp(i - 1,\
    \ j, k - 1) if dp(i - 1, j, k - 1) is lexicographically less than\n        //\
    \ dp(i + 1, j, k - 1), dp(i, j - 1, k - 1), dp(i, j + 1, k - 1).\n        // dp(i,\
    \ j, k) = (i, j) + dp(", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(Long.MaxValue)\n        val prev = Array.fill(n, n)(-1)\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until n) {\n                if (i == 0\
    \ && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n                } else\
    \ {\n                    if (i > 0) {\n                        if (dp(i - 1)(j)\
    \ < dp(i)(j)) {\n                            dp(i)(j) = dp(i - 1)(j)\n       \
    \                     prev(i)(j) = 0\n                        }\n            \
    \        }\n                    if (j > 0) {\n                        if (dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                            dp(i)(j) = dp(i)(j - 1)\n  \
    \                          prev(i)(j) = 1\n                        }\n       \
    \             }\n                    dp(i)(j) += grid(i)(j)\n                }\n\
    \            }\n        }\n        var i = n - 1\n        var j = n - 1\n    \
    \    var path = List[Long]()\n        for (l <- 0 until k.toInt) {\n         \
    \   path = grid(i)(j) :: path\n            if (prev(i)(j) == 0) {\n          \
    \      i -= 1\n            } else if (prev(i)(j) == 1) {\n                j -=\
    \ 1\n            }\n        }\n        path", "        val n = grid.length\n \
    \       val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val result = ArrayBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while (k > 0) {\n            result\
    \ += grid(i)(j)\n            k -= 1\n            if (i > 0 && dp(i - 1)(j) < dp(i\
    \ + 1)(j) && dp(i - 1)(j) < dp(i)(j - 1) && dp(i - 1)(j) < dp(i)(j + 1)) {\n \
    \               i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j) < dp(i\
    \ - 1)(j) && dp(i + 1)(j) < dp(i)(j - 1) && dp(i + 1)(j) < dp(i)(j + 1)) {\n \
    \               i += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i -\
    \ 1)(j) && dp(i)(j - 1) < dp(i + 1)(j) && dp(i", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    if (i > 0) {\n                        val lst = dp(i\
    \ - 1)(j)\n                        if (lst.length < k) {\n                   \
    \         dp(i)(j) = (grid(i)(j) :: lst).sorted\n                        } else\
    \ if (lst.length == k) {\n                            val lst2 = (grid(i)(j) ::\
    \ lst).sorted\n                            if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n\
    \                        }\n                    }\n                    if (j >\
    \ 0) {\n                        val lst = dp(i)(j - 1)\n                     \
    \   if (lst.length < k) {\n                            dp(i)(j) = (grid(i)(j)\
    \ :: lst).sorted\n                        } else if (lst.length == k) {\n    \
    \                        val lst2 = (grid(i)(j) :: lst).sorted\n             \
    \               if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n                       \
    \ }\n                    }\n                }\n            }\n        }\n    \
    \    dp(n - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val path = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) {\n                    dp(i)(j)\
    \ = grid(i)(j)\n                    path(i)(j) = List(grid(i)(j))\n          \
    \      }\n                else {\n                    if (i > 0 && dp(i - 1)(j)\
    \ < dp(i)(j)) {\n                        dp(i)(j) = dp(i - 1)(j)\n           \
    \             path(i)(j) = path(i - 1)(j)\n                    }\n           \
    \         if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                        dp(i)(j)\
    \ = dp(i)(j - 1)\n                        path(i)(j) = path(i)(j - 1)\n      \
    \              }\n                    dp(i)(j) += grid(i)(j)\n               \
    \     path(i)(j) = path(i)(j) :+ grid(i)(j)\n                }\n            }\n\
    \        }\n        path(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n\
    \        val dp = Array.fill(n, n)(Long.MaxValue)\n        val q = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        for (i <- 0 until n) {\n         \
    \   for (j <- 0 until n) {\n                dp(i)(j) = grid(i)(j)\n          \
    \      q.enqueue((grid(i)(j), i, j))\n            }\n        }\n        val dx\
    \ = Array(-1, 1, 0, 0)\n        val dy = Array(0, 0, -1, 1)\n        for (i <-\
    \ 0 until k - 1) {\n            val (v, x, y) = q.dequeue\n            for (j\
    \ <- 0 until 4) {\n                val nx = x + dx(j)\n                val ny\
    \ = y + dy(j)\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n\
    \                    if (dp(nx)(ny) > v + grid(nx)(ny)) {\n                  \
    \      dp(nx)(ny) = v + grid(nx)(ny)\n                        q.enqueue((dp(nx)(ny),\
    \ nx, ny))\n                    }\n                }\n            }\n        }\n\
    \        val (v, x, y) = q.dequeue\n        List(grid(x)(y))", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val prev = Array.fill(n, m)(-1)\n        val q =\
    \ Queue[(Int, Int)]()\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                if (grid(i)(j) == 1) {\n                    dp(i)(j)\
    \ = 0\n                    q.enqueue((i, j))\n                }\n            }\n\
    \        }\n        val dx = Array(-1, 1, 0, 0)\n        val dy = Array(0, 0,\
    \ -1, 1)\n        while (!q.isEmpty) {\n            val (x, y) = q.dequeue\n \
    \           for (i <- 0 until 4) {\n                val nx = x + dx(i)\n     \
    \           val ny = y + dy(i)\n                if (nx >= 0 && nx < n && ny >=\
    \ 0 && ny < m && dp(nx)(ny) > dp(x)(y) + 1) {\n                    dp(nx)(ny)\
    \ = dp(x)(y) + 1\n                    prev(nx)(ny) = i\n                    q.enqueue((nx,\
    \ ny))\n                }\n            }\n        }\n        val result = ListBuffer[Long]()\n\
    \        var x = 0\n        var y = 0\n        var p = prev(x)(y)\n        while\
    \ (k > 0) {\n            result += grid(x)(y)\n            k -= 1\n          \
    \  x += dx(p)\n            y += dy(p)\n            p = prev(x)(y)\n        }\n\
    \        result.toList", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    val\
    \ l = if (i > 0) dp(i - 1)(j) else List[Long]()\n                    val u = if\
    \ (j > 0) dp(i)(j - 1) else List[Long]()\n                    if (l.length ==\
    \ 0 && u.length == 0) dp(i)(j) = List(grid(i)(j))\n                    else if\
    \ (l.length == 0) dp(i)(j) = (grid(i)(j) :: u).sorted\n                    else\
    \ if (u.length == 0) dp(i)(j) = (grid(i)(j) :: l).sorted\n                   \
    \ else {\n                        val lu = (grid(i)(j) :: l).sorted\n        \
    \                val ul = (grid(i)(j) :: u).sorted\n                        if\
    \ (lu.compare(ul) < 0) dp(i)(j) = lu\n                        else dp(i)(j) =\
    \ ul\n                    }\n                }\n            }\n        }\n   \
    \     dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n     \
    \   val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n     \
    \   for (i <- 0 until n) {\n            for (j <- 0 until m) {\n             \
    \   dp(i)(j) = grid(i)(j)\n                pq.enqueue((dp(i)(j), i, j))\n    \
    \        }\n        }\n        val dirs = List((0, 1), (0, -1), (1, 0), (-1, 0))\n\
    \        val visited = Array.fill(n, m)(false)\n        var result = List[Long]()\n\
    \        for (i <- 0 until k) {\n            while (visited(pq.head._2)(pq.head._3))\
    \ pq.dequeue\n            val (x, y) = (pq.head._2, pq.head._3)\n            result\
    \ = result :+ grid(x)(y)\n            visited(x)(y) = true\n            for (dir\
    \ <- dirs) {\n                val (dx, dy) = dir\n                val (nx, ny)\
    \ = (x + dx, y + dy)\n                if (nx >= 0 && nx < n && ny >= 0 && ny <\
    \ m && !visited(nx)(ny)) {\n                    dp(nx)(ny) = min(dp(nx)(ny), dp(x)(y)\
    \ + grid(nx)(ny))\n                    pq.enqueue((dp(nx)(ny), nx, ny))\n    \
    \            }\n            }\n        }\n        result", "        val n = grid.length\n\
    \        val dp = Array.fill(n, n)(Long.MaxValue)\n        val prev = Array.fill(n,\
    \ n)((0, 0))\n        for (i <- 0 until n) {\n            for (j <- 0 until n)\
    \ {\n                if (i == 0 && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n\
    \                } else {\n                    if (i > 0 && dp(i - 1)(j) < dp(i)(j))\
    \ {\n                        dp(i)(j) = dp(i - 1)(j)\n                       \
    \ prev(i)(j) = (i - 1, j)\n                    }\n                    if (j >\
    \ 0 && dp(i)(j - 1) < dp(i)(j)) {\n                        dp(i)(j) = dp(i)(j\
    \ - 1)\n                        prev(i)(j) = (i, j - 1)\n                    }\n\
    \                    dp(i)(j) += grid(i)(j)\n                }\n            }\n\
    \        }\n        val result = ListBuffer[Long]()\n        var cur = (n - 1,\
    \ n - 1)\n        while (k > 0) {\n            result += grid(cur._1)(cur._2)\n\
    \            cur = prev(cur._1)(cur._2)\n            k -= 1\n        }\n     \
    \   result.toList", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(x => x._1))\n        pq.enqueue((0, 0, 0))\n      \
    \  while (pq.nonEmpty) {\n            val (cost, i, j) = pq.dequeue\n        \
    \    if (dp(i)(j) > cost) {\n                dp(i)(j) = cost\n               \
    \ if (i > 0) pq.enqueue((cost + grid(i - 1)(j), i - 1, j))\n                if\
    \ (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), i + 1, j))\n                if\
    \ (j > 0) pq.enqueue((cost + grid(i)(j - 1), i, j - 1))\n                if (j\
    \ < m - 1) pq.enqueue((cost + grid(i)(j + 1), i, j + 1))\n            }\n    \
    \    }\n        val result = new ListBuffer[Long]()\n        var i = 0\n     \
    \   var j = 0\n        for (k <- 1 to k.toInt) {\n            result += grid(i)(j)\n\
    \            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -= 1\n\
    \            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n            \
    \    i += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n    \
    \            j -= 1\n            } else if (j < m - 1 && dp(i)(j + 1) < dp(i)(j))\
    \ {\n                j += 1\n            }\n        }\n        result.toList",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                dp(i)(j) = List(grid(i)(j))\n                if (i > 0\
    \ && dp(i - 1)(j).length > 0 && dp(i - 1)(j).length < k) {\n                 \
    \   val newPath = dp(i - 1)(j) :+ grid(i)(j)\n                    if (dp(i)(j).length\
    \ == 0 || newPath < dp(i)(j)) dp(i)(j) = newPath\n                }\n        \
    \        if (j > 0 && dp(i)(j - 1).length > 0 && dp(i)(j - 1).length < k) {\n\
    \                    val newPath = dp(i)(j - 1) :+ grid(i)(j)\n              \
    \      if (dp(i)(j).length == 0 || newPath < dp(i)(j)) dp(i)(j) = newPath\n  \
    \              }\n            }\n        }\n        dp(n - 1)(m - 1)", "     \
    \   val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val lst = ListBuffer[Long]()\n    \
    \                if (i > 0) lst ++= dp(i - 1)(j)\n                    if (j >\
    \ 0) lst ++= dp(i)(j - 1)\n                    dp(i)(j) = (lst.toList :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1)", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val res = ArrayBuffer[Long]()\n \
    \       var i = 0\n        var j = 0\n        while (res.length < k) {\n     \
    \       res += grid(i)(j)\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n\
    \                i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j))\
    \ {\n                i += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j))\
    \ {\n                j -= 1\n            } else if (j < m - 1 && dp(i)(j + 1)\
    \ < dp(i)(j)) {\n                j += 1\n            }\n        }\n        res.toList",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        val v = grid(i)(j)\n                if (i == 0 && j == 0) dp(i)(j) =\
    \ List(v)\n                else if (i == 0) {\n                    val lst = dp(i)(j\
    \ - 1)\n                    if (lst.length < k) dp(i)(j) = v :: lst\n        \
    \            else if (lst.head > v) dp(i)(j) = v :: lst.tail\n               \
    \     else dp(i)(j) = lst\n                }\n                else if (j == 0)\
    \ {\n                    val lst = dp(i - 1)(j)\n                    if (lst.length\
    \ < k) dp(i)(j) = v :: lst\n                    else if (lst.head > v) dp(i)(j)\
    \ = v :: lst.tail\n                    else dp(i)(j) = lst\n                }\n\
    \                else {\n                    val lst1 = dp(i - 1)(j)\n       \
    \             val lst2 = dp(i)(j - 1)\n                    if (lst1.length < k\
    \ && lst2.length < k) {\n                        if (lst1.head < lst2.head) dp(i)(j)\
    \ = v :: lst1\n                        else dp(i)(j) = v :: lst2\n           \
    \         }\n                    else if (lst1.length < k) {\n               \
    \         if (lst1.head < lst2.head) dp(i)(j) = v :: lst1\n                  \
    \      else dp(i)(j) = v :: lst2.tail\n                    }\n               \
    \     else if (lst2.length < k) {\n                        if (lst1.head < lst2.head)\
    \ dp(i)(j) = v :: lst1.tail\n                        else dp(i)(j) = v :: lst2\n\
    \                    }\n                    else {\n                        if\
    \ (lst1.head < l", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)((Long.MaxValue, List[Long]()))\n        val\
    \ q = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x => x._1))\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                dp(i)(j)\
    \ = (grid(i)(j), List(grid(i)(j)))\n                q.enqueue((grid(i)(j), i,\
    \ j))\n            }\n        }\n        while (q.nonEmpty) {\n            val\
    \ (v, i, j) = q.dequeue\n            if (v > dp(i)(j)._1) continue\n         \
    \   if (dp(i)(j)._2.length == k) return dp(i)(j)._2\n            for (d <- 0 until\
    \ 4) {\n                val (ni, nj) = (i + \"2101\".charAt(d) - '1', j + \"1210\"\
    .charAt(d) - '1')\n                if (ni >= 0 && ni < n && nj >= 0 && nj < m)\
    \ {\n                    val nv = dp(i)(j)._1 + grid(ni)(nj)\n               \
    \     if (nv < dp(ni)(nj)._1) {\n                        dp(ni)(nj) = (nv, dp(i)(j)._2\
    \ :+ grid(ni)(nj))\n                        q.enqueue((nv, ni, nj))\n        \
    \            }\n                }\n            }\n        }\n        List[Long]()",
  "        // This problem is equivalent to finding the minimum path of length k in\n\
    \        // the graph with N * N vertices, where the vertices are the cells of\
    \ the\n        // grid, and two vertices are connected if and only if they share\
    \ an edge.\n        // The value of a vertex is the value of the corresponding\
    \ cell.\n        // The problem can be solved using Dijkstra's algorithm.\n  \
    \      // The time complexity is O(N * N * log(N * N)) = O(N^2 * log(N)).\n  \
    \      // The space complexity is O(N * N).\n        val n = grid.length\n   \
    \     val graph = Array.ofDim[List[(Int, Long)]](n * n)\n        for (i <- 0 until\
    \ n; j <- 0 until n) {\n            val index = i * n + j\n            graph(index)\
    \ = List()\n            if (i > 0) graph(index) = (index - n, grid(i - 1)(j))\
    \ :: graph(index)\n            if (i < n - 1) graph(index) = (index + n, grid(i\
    \ + 1)(j)) :: graph(index)\n            if (j > 0) graph(index) = (index - 1,\
    \ grid(i)(j - 1)) :: graph(index)\n            if (j < n - 1) graph(index) = (index\
    \ + 1, grid(i)(j + 1)) :: graph(index)\n        }\n        val dist = Array.fill(n\
    \ * n)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0))\n        dist(0) = 0\n        while (!pq.isEmpty)\
    \ {\n            val (d, u) = pq.dequeue\n            if (d > dist(u)) continue\n\
    \            for ((v, w) <- graph(u)) {\n                val newDist = d + w\n\
    \                if (newDist < dist(v)) {\n                    dist(v) = newDist\n\
    \                    pq.enqueue((newDist, v))\n                }\n           \
    \ }\n        }\n        val result = ArrayBuffer[Long]()\n        var index =\
    \ n", "        val n = grid.length\n        val m = grid(0).length\n        val\
    \ dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n      \
    \      for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(grid(i)(j))\n                else {\n                    val candidates\
    \ = ListBuffer[List[Long]]()\n                    if (i > 0) candidates += dp(i\
    \ - 1)(j)\n                    if (j > 0) candidates += dp(i)(j - 1)\n       \
    \             if (candidates.isEmpty) dp(i)(j) = List(grid(i)(j))\n          \
    \          else dp(i)(j) = (grid(i)(j) :: candidates.minBy(_.mkString)).take(k.toInt)\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1)", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val prev = Array.fill(n, m)(-1)\n        val q =\
    \ new Queue[(Int, Int)]\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (grid(i)(j) == 1) {\n                    dp(i)(j)\
    \ = 0\n                    q.enqueue((i, j))\n                }\n            }\n\
    \        }\n        val dirs = List((-1, 0), (1, 0), (0, -1), (0, 1))\n      \
    \  while (!q.isEmpty) {\n            val (i, j) = q.dequeue\n            for ((di,\
    \ dj) <- dirs) {\n                val ii = i + di\n                val jj = j\
    \ + dj\n                if (ii >= 0 && ii < n && jj >= 0 && jj < m && dp(ii)(jj)\
    \ > dp(i)(j) + 1) {\n                    dp(ii)(jj) = dp(i)(j) + 1\n         \
    \           prev(ii)(jj) = i * m + j\n                    q.enqueue((ii, jj))\n\
    \                }\n            }\n        }\n        var i = 0\n        var j\
    \ = 0\n        var min = Long.MaxValue\n        for (ii <- 0 until n) {\n    \
    \        for (jj <- 0 until m) {\n                if (dp(ii)(jj) < min) {\n  \
    \                  min = dp(ii)(jj)\n                    i = ii\n            \
    \        j = jj\n                }\n            }\n        }\n        val path\
    \ = new ListBuffer[Long]\n        var cur = i * m + j\n        while (cur != -1)\
    \ {\n            path += grid(cur / m)(cur % m)\n            cur = prev(cur /\
    \ m)(cur % m)\n        }\n        path.reverse.toList", "        // dp(i)(j)(k)\
    \ = minimum path of length k starting from (i, j)\n        val dp = Array.fill(grid.length,\
    \ grid.length, k.toInt + 1)(Long.MaxValue)\n        for (i <- 0 until grid.length;\
    \ j <- 0 until grid.length) {\n            dp(i)(j)(1) = grid(i)(j)\n        }\n\
    \        for (l <- 2 to k.toInt) {\n            for (i <- 0 until grid.length;\
    \ j <- 0 until grid.length) {\n                if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i - 1)(j)(l - 1))\n                if (i < grid.length - 1) dp(i)(j)(l) =\
    \ min(dp(i)(j)(l), dp(i + 1)(j)(l - 1))\n                if (j > 0) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n                if (j < grid.length\
    \ - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1))\n                dp(i)(j)(l)\
    \ += grid(i)(j)\n            }\n        }\n        var min = Long.MaxValue\n \
    \       var min_i = -1\n        var min_j = -1\n        for (i <- 0 until grid.length;\
    \ j <- 0 until grid.length) {\n            if (dp(i)(j)(k.toInt) < min) {\n  \
    \              min = dp(i)(j)(k.toInt)\n                min_i = i\n          \
    \      min_j = j\n            }\n        }\n        var result = List[Long]()\n\
    \        var cur_i = min_i\n        var cur_j = min_j\n        for (l <- k.toInt\
    \ to 1 by -1) {\n            result = grid(cur_i)(cur_j) :: result\n         \
    \   if (cur_i > 0 && dp(cur_i)(cur", "        // dp(i)(j)(k) = the minimum path\
    \ of length k starting from (i, j)\n        val dp = Array.fill(grid.length, grid.length,\
    \ k.toInt + 1)(Long.MaxValue)\n        for (i <- 0 until grid.length; j <- 0 until\
    \ grid.length) {\n            dp(i)(j)(1) = grid(i)(j)\n        }\n        for\
    \ (i <- 0 until grid.length; j <- 0 until grid.length) {\n            for (l <-\
    \ 2 to k.toInt) {\n                if (i + 1 < grid.length) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i + 1)(j)(l - 1))\n                if (i - 1 >= 0) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i - 1)(j)(l - 1))\n                if (j + 1 < grid.length) dp(i)(j)(l) =\
    \ min(dp(i)(j)(l), dp(i)(j + 1)(l - 1))\n                if (j - 1 >= 0) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n            }\n        }\n        var\
    \ min = Long.MaxValue\n        var minI = -1\n        var minJ = -1\n        for\
    \ (i <- 0 until grid.length; j <- 0 until grid.length) {\n            if (dp(i)(j)(k.toInt)\
    \ < min) {\n                min = dp(i)(j)(k.toInt)\n                minI = i\n\
    \                minJ = j\n            }\n        }\n        var result = List[Long]()\n\
    \        var i = minI\n        var j = minJ\n        for (l <- k.toInt to 1 by\
    \ -1) {\n            result = grid(i)(j) :: result\n            if (i + 1 < grid.length\
    \ && dp(i)(j)(l) == dp(i + 1)(j)(l - 1)) {\n                i += 1\n         \
    \   } else", "        val n = grid.length\n        val m = grid(0).length\n  \
    \      val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(grid(i)(j))\n                else {\n                    if (i > 0) {\n\
    \                        val lst = dp(i - 1)(j)\n                        if (lst.length\
    \ < k) dp(i)(j) = lst :+ grid(i)(j)\n                        else if (lst.length\
    \ == k) {\n                            if (lst.last > grid(i)(j)) dp(i)(j) = lst.init\
    \ :+ grid(i)(j)\n                        }\n                    }\n          \
    \          if (j > 0) {\n                        val lst = dp(i)(j - 1)\n    \
    \                    if (lst.length < k) {\n                            if (dp(i)(j).length\
    \ < k) dp(i)(j) = lst :+ grid(i)(j)\n                            else if (dp(i)(j).length\
    \ == k) {\n                                if (dp(i)(j).last > grid(i)(j)) dp(i)(j)\
    \ = lst :+ grid(i)(j)\n                            }\n                       \
    \ }\n                        else if (lst.length == k) {\n                   \
    \         if (lst.last > grid(i)(j)) {\n                                if (dp(i)(j).length\
    \ < k) dp(i)(j) = lst.init :+ grid(i)(j)\n                                else\
    \ if (dp(i)(j).length == k) {\n                                    if (dp(i)(j).last\
    \ > grid(i)(j)) dp(i)(j) = lst.init :+ grid(i)(j)\n                          \
    \      }\n                            }\n                        }\n         \
    \           }\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1)", "        val n = grid.length\n        val m = grid(0).length\n      \
    \  val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(grid(i)(j))\n                else {\n                    val lst = ListBuffer[Long]()\n\
    \                    if (i > 0) lst ++= dp(i - 1)(j)\n                    if (j\
    \ > 0) lst ++= dp(i)(j - 1)\n                    dp(i)(j) = (lst.toList :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1)", "   \
    \     val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n\
    \        val visited = Array.fill(n, n)(false)\n        val queue = new Queue[(Int,\
    \ Int)]\n        queue.enqueue((0, 0))\n        dp(0)(0) = grid(0)(0)\n      \
    \  visited(0)(0) = true\n        while (!queue.isEmpty) {\n            val (x,\
    \ y) = queue.dequeue\n            for (i <- -1 to 1; j <- -1 to 1) {\n       \
    \         if (i == 0 && j == 0) {\n                    if (x == 0 && y == 0) {\n\
    \                        for (i <- -1 to 1; j <- -1 to 1) {\n                \
    \            if (i == 0 && j == 0) {\n                                if (x +\
    \ i >= 0 && x + i < n && y + j >= 0 && y + j < n && !visited(x + i)(y + j)) {\n\
    \                                    dp(x + i)(y + j) = min(dp(x + i)(y + j),\
    \ dp(x)(y) + grid(x + i)(y + j))\n                                    visited(x\
    \ + i)(y + j) = true\n                                    queue.enqueue((x + i,\
    \ y + j))\n                                }\n                            }\n\
    \                        }\n                    }\n                } else {\n\
    \                    if (x + i >= 0 && x + i < n && y + j >= 0 && y + j < n &&\
    \ !visited(x + i)(y + j)) {\n                        dp(x + i)(y + j) = min(dp(x\
    \ + i)(y + j), dp(x)(y) + grid(x + i)(y + j))\n                        visited(x\
    \ + i)(y + j) = true\n                        queue.enqueue((x + i, y + j))\n\
    \                    }\n                }\n            }\n        }\n        var\
    \ lst = List[Long]()\n        var x = 0\n        var y = 0\n        for (i <-\
    \ 0 until k.toInt) {\n            var min = Long.MaxValue\n            var minx\
    \ = 0\n           ", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(x => x._1))\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until m) {\n                dp(i)(j) = grid(i)(j)\n      \
    \          pq.enqueue((dp(i)(j), i, j))\n            }\n        }\n        for\
    \ (i <- 0 until k - 1) {\n            val (v, x, y) = pq.dequeue\n           \
    \ if (x > 0) {\n                val newV = v + grid(x - 1)(y)\n              \
    \  if (newV < dp(x - 1)(y)) {\n                    dp(x - 1)(y) = newV\n     \
    \               pq.enqueue((newV, x - 1, y))\n                }\n            }\n\
    \            if (x < n - 1) {\n                val newV = v + grid(x + 1)(y)\n\
    \                if (newV < dp(x + 1)(y)) {\n                    dp(x + 1)(y)\
    \ = newV\n                    pq.enqueue((newV, x + 1, y))\n                }\n\
    \            }\n            if (y > 0) {\n                val newV = v + grid(x)(y\
    \ - 1)\n                if (newV < dp(x)(y - 1)) {\n                    dp(x)(y\
    \ - 1) = newV\n                    pq.enqueue((newV, x, y - 1))\n            \
    \    }\n            }\n            if (y < m - 1) {\n                val newV\
    \ = v + grid(x)(y + 1)\n                if (newV < dp(x)(y + 1)) {\n         \
    \           dp(x)(y + 1) = newV\n                    pq.enqueue((newV, x, y +\
    \ 1))\n                }\n            }\n        }\n        val (v, x, y) = pq.dequeue\n\
    \        val result = new ListBuffer[Long]()\n        result", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val up = if (i > 0) dp(i - 1)(j) else\
    \ List[Long]()\n                    val left = if (j > 0) dp(i)(j - 1) else List[Long]()\n\
    \                    if (up.length == 0) dp(i)(j) = left :+ grid(i)(j)\n     \
    \               else if (left.length == 0) dp(i)(j) = up :+ grid(i)(j)\n     \
    \               else {\n                        val up_min = up.min\n        \
    \                val left_min = left.min\n                        if (up_min <\
    \ left_min) dp(i)(j) = up :+ grid(i)(j)\n                        else if (up_min\
    \ > left_min) dp(i)(j) = left :+ grid(i)(j)\n                        else {\n\
    \                            val up_index = up.indexOf(up_min)\n             \
    \               val left_index = left.indexOf(left_min)\n                    \
    \        if (up_index < left_index) dp(i)(j) = up :+ grid(i)(j)\n            \
    \                else if (up_index > left_index) dp(i)(j) = left :+ grid(i)(j)\n\
    \                            else {\n                                val up_list\
    \ = up.slice(up_index, up.length)\n                                val left_list\
    \ = left.slice(left_index, left.length)\n                                if (up_list\
    \ < left_list) dp(i)(j) = up :+ grid(i)(j)\n                                else\
    \ dp(i)(j) = left :+ grid(i)(j)\n                            }\n             \
    \           }\n                    }\n                }\n            }\n     \
    \   }\n        dp(n - 1)(m - 1).slice(0,", "        val n = grid.length\n    \
    \    val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length\
    \ < k) {\n                    val lst = dp(i - 1)(j) :+ grid(i)(j)\n         \
    \           if (lst.length == k) {\n                        if (dp(i)(j).length\
    \ == k) {\n                            if (lst < dp(i)(j)) dp(i)(j) = lst\n  \
    \                      } else dp(i)(j) = lst\n                    } else if (lst.length\
    \ < k) dp(i)(j) = lst\n                }\n                if (j > 0 && dp(i)(j\
    \ - 1).length < k) {\n                    val lst = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    if (lst.length == k) {\n                        if (dp(i)(j).length\
    \ == k) {\n                            if (lst < dp(i)(j)) dp(i)(j) = lst\n  \
    \                      } else dp(i)(j) = lst\n                    } else if (lst.length\
    \ < k) dp(i)(j) = lst\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    val\
    \ left = if (j > 0) dp(i)(j - 1) else List[Long]()\n                    val up\
    \ = if (i > 0) dp(i - 1)(j) else List[Long]()\n                    if (left.length\
    \ == 0 && up.length == 0) dp(i)(j) = List(grid(i)(j))\n                    else\
    \ if (left.length == 0) dp(i)(j) = up :+ grid(i)(j)\n                    else\
    \ if (up.length == 0) dp(i)(j) = left :+ grid(i)(j)\n                    else\
    \ if (left.length < up.length) dp(i)(j) = left :+ grid(i)(j)\n               \
    \     else if (left.length > up.length) dp(i)(j) = up :+ grid(i)(j)\n        \
    \            else {\n                        var flag = false\n              \
    \          for (l <- 0 until left.length) {\n                            if (left(l)\
    \ < up(l)) {\n                                dp(i)(j) = left :+ grid(i)(j)\n\
    \                                flag = true\n                               \
    \ break\n                            }\n                            else if (left(l)\
    \ > up(l)) {\n                                dp(i)(j) = up :+ grid(i)(j)\n  \
    \                              flag = true\n                                break\n\
    \                            }\n                        }\n                  \
    \      if (!flag) dp(i)(j) = left :+ grid(i)(j)\n                    }\n     \
    \           }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) <= cost) {\n           \
    \     if (i > 0) pq.enqueue((cost + grid(i - 1)(j), i - 1, j))\n             \
    \   if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), i + 1, j))\n           \
    \     if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i, j - 1))\n             \
    \   if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i, j + 1))\n           \
    \ }\n        }\n        List()", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n        val\
    \ pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n        pq.enqueue((0,\
    \ 0, 0))\n        while (!pq.isEmpty) {\n            val (d, i, j) = pq.dequeue\n\
    \            if (dp(i)(j) > d) {\n                dp(i)(j) = d\n             \
    \   if (i > 0) pq.enqueue((d + grid(i - 1)(j), i - 1, j))\n                if\
    \ (i < n - 1) pq.enqueue((d + grid(i + 1)(j), i + 1, j))\n                if (j\
    \ > 0) pq.enqueue((d + grid(i)(j - 1), i, j - 1))\n                if (j < m -\
    \ 1) pq.enqueue((d + grid(i)(j + 1), i, j + 1))\n            }\n        }\n  \
    \      val pq2 = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n \
    \       pq2.enqueue((0, 0, 0))\n        val visited = Array.fill(n, m)(false)\n\
    \        while (!pq2.isEmpty) {\n            val (d, i, j) = pq2.dequeue\n   \
    \         if (visited(i)(j)) {\n                if (i > 0 && !visited(i - 1)(j))\
    \ pq2.enqueue((d + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1 &&\
    \ !visited(i + 1)(j)) pq2.enqueue((d + grid(i + 1)(j), i + 1, j))\n          \
    \      if (j > 0 && !visited(i)(j - 1)) pq2.enqueue((d + grid(i)(j - 1), i, j\
    \ - 1))\n                if (j < m - 1 && !visited(i)(j + 1)) pq2.enqueue", " \
    \       val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        dp(i)(j) = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length\
    \ <= k && dp(i - 1)(j).length < dp(i)(j).length) dp(i)(j) = dp(i - 1)(j)\n   \
    \             if (j > 0 && dp(i)(j - 1).length <= k && dp(i)(j - 1).length < dp(i)(j).length)\
    \ dp(i)(j) = dp(i)(j - 1)\n                if (dp(i)(j).length < k) dp(i)(j) =\
    \ dp(i)(j) :+ grid(i)(j)\n            }\n        }\n        dp(n - 1)(n - 1)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, (Int, Int))]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, (0, 0)))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, (i, j)) = pq.dequeue\n            if (dp(i)(j) > cost) {\n          \
    \      dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i -\
    \ 1)(j), (i - 1, j)))\n                if (i < n - 1) pq.enqueue((cost + grid(i\
    \ + 1)(j), (i + 1, j)))\n                if (j > 0) pq.enqueue((cost + grid(i)(j\
    \ - 1), (i, j - 1)))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j\
    \ + 1), (i, j + 1)))\n            }\n        }\n        val pq2 = new PriorityQueue[(Long,\
    \ (Int, Int))]()(Ordering.by(-_._1))\n        pq2.enqueue((0, (0, 0)))\n     \
    \   val visited = Array.fill(n, m)(false)\n        while (!pq2.isEmpty) {\n  \
    \          val (cost, (i, j)) = pq2.dequeue\n            if (visited(i)(j)) {\n\
    \                if (cost == dp(i)(j)) {\n                    val res = ListBuffer[Long]()\n\
    \                    var (x, y) = (i, j)\n                    for (l <- 0 until\
    \ k.toInt) {\n                        res += grid(x)(y)\n                    \
    \    if (x > 0 && dp(x - 1)(y) == cost - grid(x)(y)) {\n                     \
    \       x -= 1\n                        } else if (x < n - 1 && dp(x + 1)(y) ==\
    \ cost - grid(x)(y)) {\n                            x += 1\n                 \
    \       } else if (", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq.enqueue((0, 0, 0))\n        while\
    \ (!pq.isEmpty) {\n            val (cost, i, j) = pq.dequeue\n            if (i\
    \ < 0 || i >= n || j < 0 || j >= m) {\n                //println(\"Out of bound\"\
    )\n                continue\n            }\n            if (dp(i)(j) <= cost)\
    \ {\n                //println(\"Not better\")\n                continue\n   \
    \         }\n            dp(i)(j) = cost\n            if (cost == k) {\n     \
    \           //println(\"Found\")\n                val result = new ListBuffer[Long]()\n\
    \                result += grid(i)(j)\n                var x = i\n           \
    \     var y = j\n                while (cost > 0) {\n                    if (x\
    \ > 0 && dp(x - 1)(y) == cost - 1) {\n                        x -= 1\n       \
    \                 result += grid(x)(y)\n                    } else if (x < n -\
    \ 1 && dp(x + 1)(y) == cost - 1) {\n                        x += 1\n         \
    \               result += grid(x)(y)\n                    } else if (y > 0 &&\
    \ dp(x)(y - 1) == cost - 1) {\n                        y -= 1\n              \
    \          result += grid(x)(y)\n                    } else if (y < m - 1 && dp(x)(y\
    \ + 1) == cost - 1) {\n                        y += 1\n                      \
    \  result += grid(x)(y)\n                    }\n                    cost -= 1\n\
    \                }\n                return result.toList\n            }\n    \
    \        pq.enqueue((cost + 1, i - 1, j))\n            pq.enqueue((cost + 1, i\
    \ + 1, j))\n            pq.enqueue((cost + 1, i, j - 1))\n            pq.enqueue((cost\
    \ + 1, i, j + 1))\n        }\n        return List()", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val path = Array.fill(n, m)(List[Long]())\n        val queue = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        for (i <- 0 until n) {\n         \
    \   for (j <- 0 until m) {\n                dp(i)(j) = grid(i)(j)\n          \
    \      path(i)(j) = List(grid(i)(j))\n                queue.enqueue((dp(i)(j),\
    \ i, j))\n            }\n        }\n        for (l <- 1 until k.toInt) {\n   \
    \         val (min, i, j) = queue.dequeue\n            if (i > 0) {\n        \
    \        if (dp(i - 1)(j) > min + grid(i - 1)(j)) {\n                    dp(i\
    \ - 1)(j) = min + grid(i - 1)(j)\n                    path(i - 1)(j) = path(i)(j)\
    \ :+ grid(i - 1)(j)\n                    queue.enqueue((dp(i - 1)(j), i - 1, j))\n\
    \                }\n            }\n            if (i < n - 1) {\n            \
    \    if (dp(i + 1)(j) > min + grid(i + 1)(j)) {\n                    dp(i + 1)(j)\
    \ = min + grid(i + 1)(j)\n                    path(i + 1)(j) = path(i)(j) :+ grid(i\
    \ + 1)(j)\n                    queue.enqueue((dp(i + 1)(j), i + 1, j))\n     \
    \           }\n            }\n            if (j > 0) {\n                if (dp(i)(j\
    \ - 1) > min + grid(i)(j - 1)) {\n                    dp(i)(j - 1) = min + grid(i)(j\
    \ - 1)\n                    path(i)(j - 1) = path(i)(j) :+ grid(i)(j - 1)\n  \
    \                  queue.enqueue((dp(i)(j - 1), i, j - 1))", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val l = if (i > 0) dp(i - 1)(j) else\
    \ List[Long]()\n                    val u = if (j > 0) dp(i)(j - 1) else List[Long]()\n\
    \                    val lu = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val lu_ = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val l_ = if (i > 0) dp(i - 1)(j) else List[Long]()\n    \
    \                val u_ = if (j > 0) dp(i)(j - 1) else List[Long]()\n        \
    \            val lu__ = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    if (l.length < k) dp(i)(j) = l :+ grid(i)(j)\n          \
    \          if (u.length < k) dp(i)(j) = min(dp(i)(j), u :+ grid(i)(j))\n     \
    \               if (lu.length < k) dp(i)(j) = min(dp(i)(j), lu :+ grid(i)(j))\n\
    \                    if (lu_.length < k) dp(i)(j) = min(dp(i)(j), lu_ :+ grid(i)(j))\n\
    \                    if (l_.length < k) dp(i)(j) = min(dp(i)(j), l_ :+ grid(i)(j))\n\
    \                    if (u_.length < k) dp(i)(j) = min(dp(i)(j), u_ :+ grid(i)(j))\n\
    \                    if (lu__.", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n        val\
    \ pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n        pq.enqueue((0,\
    \ 0, 0))\n        while (!pq.isEmpty) {\n            val (cost, i, j) = pq.dequeue\n\
    \            if (i < 0 || i >= n || j < 0 || j >= m) continue\n            if\
    \ (dp(i)(j) <= cost) continue\n            dp(i)(j) = cost\n            if (i\
    \ == n - 1 && j == m - 1) {\n                val res = new ListBuffer[Long]()\n\
    \                var i = n - 1\n                var j = m - 1\n              \
    \  var cost = dp(i)(j)\n                while (cost > 0) {\n                 \
    \   res += grid(i)(j)\n                    if (i > 0 && dp(i - 1)(j) < cost) {\n\
    \                        i -= 1\n                        cost = dp(i)(j)\n   \
    \                 } else if (j > 0 && dp(i)(j - 1) < cost) {\n               \
    \         j -= 1\n                        cost = dp(i)(j)\n                  \
    \  } else {\n                        i += 1\n                        j += 1\n\
    \                        cost = dp(i)(j)\n                    }\n            \
    \    }\n                res += grid(0)(0)\n                return res.toList\n\
    \            }\n            pq.enqueue((cost + abs(grid(i)(j) - grid(i + 1)(j)),\
    \ i + 1, j))\n            pq.enqueue((cost + abs(grid(i)(j) - grid(i - 1)(j)),\
    \ i - 1, j))\n            pq.enqueue((cost + abs(grid(i)(j) - grid(i)(j + 1)),\
    \ i, j + 1))\n            pq.enqueue((cost + abs(grid(i)(j) - grid(i)(j - 1)),\
    \ i, j - 1))\n        }\n        return List()", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val neighbors = List((i - 1, j), (i, j - 1)).filter(p\
    \ => p._1 >= 0 && p._2 >= 0)\n                    if (neighbors.isEmpty) dp(i)(j)\
    \ = List(grid(i)(j))\n                    else {\n                        val\
    \ neighborDps = neighbors.map(p => dp(p._1)(p._2))\n                        val\
    \ minDp = neighborDps.minBy(lst => lst :+ grid(i)(j))\n                      \
    \  dp(i)(j) = minDp :+ grid(i)(j)\n                    }\n                }\n\
    \            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val prev = Array.fill(n, m)(-1)\n        val queue\
    \ = new Queue[(Int, Int)]\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                if (grid(i)(j) == 1) {\n                  \
    \  dp(i)(j) = 0\n                    queue.enqueue((i, j))\n                }\n\
    \            }\n        }\n        while (!queue.isEmpty) {\n            val (i,\
    \ j) = queue.dequeue\n            val v = dp(i)(j)\n            if (i > 0 && dp(i\
    \ - 1)(j) > v + 1) {\n                dp(i - 1)(j) = v + 1\n                prev(i\
    \ - 1)(j) = i * m + j\n                queue.enqueue((i - 1, j))\n           \
    \ }\n            if (i < n - 1 && dp(i + 1)(j) > v + 1) {\n                dp(i\
    \ + 1)(j) = v + 1\n                prev(i + 1)(j) = i * m + j\n              \
    \  queue.enqueue((i + 1, j))\n            }\n            if (j > 0 && dp(i)(j\
    \ - 1) > v + 1) {\n                dp(i)(j - 1) = v + 1\n                prev(i)(j\
    \ - 1) = i * m + j\n                queue.enqueue((i, j - 1))\n            }\n\
    \            if (j < m - 1 && dp(i)(j + 1) > v + 1) {\n                dp(i)(j\
    \ + 1) = v + 1\n                prev(i)(j + 1) = i * m + j\n                queue.enqueue((i,\
    \ j + 1))\n            }\n        }\n        var min = Long.MaxValue\n       \
    \ var min_i = -1\n        var min_j = -1\n        for (i <- 0 until n) {\n   \
    \         for (j <- 0 until m) {\n                if (dp(i", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val up = if (i == 0) List[Long]() else\
    \ dp(i - 1)(j)\n                    val left = if (j == 0) List[Long]() else dp(i)(j\
    \ - 1)\n                    if (up.length == 0) dp(i)(j) = left :+ grid(i)(j)\n\
    \                    else if (left.length == 0) dp(i)(j) = up :+ grid(i)(j)\n\
    \                    else if (up.length < left.length) dp(i)(j) = up :+ grid(i)(j)\n\
    \                    else if (up.length > left.length) dp(i)(j) = left :+ grid(i)(j)\n\
    \                    else {\n                        val up_last = up.last\n \
    \                       val left_last = left.last\n                        if\
    \ (up_last < left_last) dp(i)(j) = up :+ grid(i)(j)\n                        else\
    \ if (up_last > left_last) dp(i)(j) = left :+ grid(i)(j)\n                   \
    \     else {\n                            val up_second_last = up(up.length -\
    \ 2)\n                            val left_second_last = left(left.length - 2)\n\
    \                            if (up_second_last < left_second_last) dp(i)(j) =\
    \ up :+ grid(i)(j)\n                            else dp(i)(j) = left :+ grid(i)(j)\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (i < 0 || i >= n || j < 0 || j >=\
    \ m) {\n                //println(\"out of bound\")\n                continue\n\
    \            }\n            if (dp(i)(j) <= cost) {\n                //println(\"\
    already visited\")\n                continue\n            }\n            dp(i)(j)\
    \ = cost\n            //println(i + \" \" + j + \" \" + cost)\n            if\
    \ (cost == k) {\n                //println(\"found\")\n                val result\
    \ = new ListBuffer[Long]()\n                var i = 0\n                var j =\
    \ 0\n                for (k <- 0 until cost.toInt) {\n                    result\
    \ += grid(i)(j)\n                    if (i + 1 < n && dp(i + 1)(j) == cost - k\
    \ - 1) {\n                        i += 1\n                    } else if (j + 1\
    \ < m && dp(i)(j + 1) == cost - k - 1) {\n                        j += 1\n   \
    \                 } else if (i - 1 >= 0 && dp(i - 1)(j) == cost - k - 1) {\n \
    \                       i -= 1\n                    } else if (j - 1 >= 0 && dp(i)(j\
    \ - 1) == cost - k - 1) {\n                        j -= 1\n                  \
    \  }\n                }\n                return result.toList\n            }\n\
    \            pq.enqueue((cost + 1, i + 1, j))\n            pq.enqueue((cost +\
    \ 1, i - 1, j))\n            pq.enqueue((cost + 1, i, j + 1))\n            pq.enqueue((cost\
    \ + 1, i, j - 1))\n        }\n        return List()", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = grid(i)(j)\n                pq.enqueue((dp(i)(j), i, j))\n\
    \            }\n        }\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                if (i > 0) {\n                    dp(i)(j)\
    \ = min(dp(i)(j), dp(i - 1)(j) + grid(i)(j))\n                    pq.enqueue((dp(i)(j),\
    \ i, j))\n                }\n                if (j > 0) {\n                  \
    \  dp(i)(j) = min(dp(i)(j), dp(i)(j - 1) + grid(i)(j))\n                    pq.enqueue((dp(i)(j),\
    \ i, j))\n                }\n            }\n        }\n        val result = ListBuffer[Long]()\n\
    \        for (i <- 0 until k.toInt) {\n            val (value, x, y) = pq.dequeue()\n\
    \            result += grid(x)(y)\n            if (x > 0) {\n                dp(x)(y)\
    \ = min(dp(x)(y), dp(x - 1)(y) + grid(x)(y))\n                pq.enqueue((dp(x)(y),\
    \ x, y))\n            }\n            if (y > 0) {\n                dp(x)(y) =\
    \ min(dp(x)(y), dp(x)(y - 1) + grid(x)(y))\n                pq.enqueue((dp(x)(y),\
    \ x, y))\n            }\n        }\n        result.toList", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val pq2 = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq2.enqueue((0, 0, 0))\n        val\
    \ visited = Array.fill(n, m)(false)\n        visited(0)(0) = true\n        var\
    \ result = List[Long]()\n        while (!pq2.isEmpty) {\n            val (cost,\
    \ i, j) = pq2.dequeue\n            result = grid(i)(j) :: result\n           \
    \ if (result.length == k) return result\n            if (i > 0 && !visited(i -\
    \ 1)(j) && dp(i - 1)(j) == cost + grid(i - 1)(j)) {\n                pq2.enqueue((cost\
    \ + grid(i - 1)(j), i - 1, j))\n                visited(i - 1)(j) = true\n   \
    \         }\n            if (i < n - 1 && !visited(i + 1)(j) && dp(i + 1)(j) ==\
    \ cost + grid(i + 1)(", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                val lst = List(grid(i)(j))\n\
    \                if (i == 0 && j == 0) dp(i)(j) = lst\n                else if\
    \ (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                else\
    \ if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n               \
    \ else {\n                    val lst1 = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                    val lst2 = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n        \
    \            if (lst1 < lst2) dp(i)(j) = lst1\n                    else dp(i)(j)\
    \ = lst2\n                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x\
    \ => x._1))\n        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n  \
    \          val (d, i, j) = pq.dequeue\n            if (dp(i)(j) > d) {\n     \
    \           dp(i)(j) = d\n                if (i > 0) pq.enqueue((d + grid(i -\
    \ 1)(j), i - 1, j))\n                if (i < n - 1) pq.enqueue((d + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((d + grid(i)(j - 1), i, j\
    \ - 1))\n                if (j < m - 1) pq.enqueue((d + grid(i)(j + 1), i, j +\
    \ 1))\n            }\n        }\n        val pq2 = new PriorityQueue[(Long, Int,\
    \ Int)]()(Ordering.by(x => x._1))\n        pq2.enqueue((0, 0, 0))\n        val\
    \ visited = Array.fill(n, m)(false)\n        while (!pq2.isEmpty) {\n        \
    \    val (d, i, j) = pq2.dequeue\n            if (!visited(i)(j)) {\n        \
    \        visited(i)(j) = true\n                if (i > 0 && dp(i - 1)(j) == d\
    \ + grid(i - 1)(j)) pq2.enqueue((d + grid(i - 1)(j), i - 1, j))\n            \
    \    if (i < n - 1 && dp(i + 1)(j) == d + grid(i + 1)(j)) pq2.enqueue((d + grid(i\
    \ + 1)(j), i + 1, j))\n                if (j > 0 && dp(i)(j - 1) == d + grid(i)(j\
    \ - 1)) pq2.en", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val path = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) {\n                    dp(i)(j)\
    \ = grid(i)(j)\n                    path(i)(j) = List(grid(i)(j))\n          \
    \      }\n                else {\n                    if (i > 0 && dp(i - 1)(j)\
    \ < dp(i)(j)) {\n                        dp(i)(j) = dp(i - 1)(j)\n           \
    \             path(i)(j) = path(i - 1)(j)\n                    }\n           \
    \         if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                        dp(i)(j)\
    \ = dp(i)(j - 1)\n                        path(i)(j) = path(i)(j - 1)\n      \
    \              }\n                    if (i > 0 && j > 0 && dp(i - 1)(j - 1) <\
    \ dp(i)(j)) {\n                        dp(i)(j) = dp(i - 1)(j - 1)\n         \
    \               path(i)(j) = path(i - 1)(j - 1)\n                    }\n     \
    \               dp(i)(j) += grid(i)(j)\n                    path(i)(j) = (path(i)(j)\
    \ :+ grid(i)(j)).sorted\n                }\n            }\n        }\n       \
    \ var i = n - 1\n        var j = m - 1\n        var cur = path(i)(j)\n       \
    \ while (cur.length < k) {\n            if (i > 0 && path(i - 1)(j).length < cur.length)\
    \ {\n                i -= 1\n                cur = path(i)(j)\n            }\n\
    \            else if (j > 0 && path(i)(j - 1).length < cur.length) {\n       \
    \         j -= 1\n                cur = path(i)(j)\n            }\n          \
    \  else if (", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(x => x._1))\n        pq.enqueue((0, 0, 0))\n      \
    \  while (!pq.isEmpty) {\n            val (cost, i, j) = pq.dequeue\n        \
    \    if (dp(i)(j) > cost) {\n                dp(i)(j) = cost\n               \
    \ if (i > 0) pq.enqueue((cost + grid(i - 1)(j), i - 1, j))\n                if\
    \ (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), i + 1, j))\n                if\
    \ (j > 0) pq.enqueue((cost + grid(i)(j - 1), i, j - 1))\n                if (j\
    \ < m - 1) pq.enqueue((cost + grid(i)(j + 1), i, j + 1))\n            }\n    \
    \    }\n        val q = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x =>\
    \ x._1))\n        q.enqueue((0, 0, 0))\n        val visited = Array.fill(n, m)(false)\n\
    \        while (!q.isEmpty) {\n            val (cost, i, j) = q.dequeue\n    \
    \        if (!visited(i)(j)) {\n                visited(i)(j) = true\n       \
    \         if (i > 0 && dp(i - 1)(j) == cost + grid(i - 1)(j)) q.enqueue((cost\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1 && dp(i + 1)(j)\
    \ == cost + grid(i + 1)(j)) q.enqueue((cost + grid(i + 1)(j), i + 1, j))\n   \
    \             if (j > 0 && dp(i)(j - 1) == cost + grid(i)(j - 1)) q.enqueue((cost\
    \ + grid(i)(j - 1), i,", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    val\
    \ up = if (i > 0) dp(i - 1)(j) else List[Long]()\n                    val left\
    \ = if (j > 0) dp(i)(j - 1) else List[Long]()\n                    if (up.length\
    \ == 0 && left.length == 0) dp(i)(j) = List(grid(i)(j))\n                    else\
    \ if (up.length == 0) dp(i)(j) = grid(i)(j) :: left\n                    else\
    \ if (left.length == 0) dp(i)(j) = grid(i)(j) :: up\n                    else\
    \ {\n                        val up_min = up.min\n                        val\
    \ left_min = left.min\n                        if (up_min < left_min) dp(i)(j)\
    \ = grid(i)(j) :: up\n                        else if (up_min > left_min) dp(i)(j)\
    \ = grid(i)(j) :: left\n                        else dp(i)(j) = grid(i)(j) ::\
    \ (if (up < left) up else left)\n                    }\n                }\n  \
    \          }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    var min = List[Long]()\n          \
    \          if (i > 0) {\n                        val lst = dp(i - 1)(j)\n    \
    \                    if (lst.length < k) min = lst :+ grid(i)(j)\n           \
    \             else if (lst.length == k) min = lst\n                    }\n   \
    \                 if (j > 0) {\n                        val lst = dp(i)(j - 1)\n\
    \                        if (lst.length < k) {\n                            if\
    \ (min.length == 0 || lst.length < min.length || (lst.length == min.length &&\
    \ lst < min)) min = lst :+ grid(i)(j)\n                        }\n           \
    \             else if (lst.length == k) {\n                            if (min.length\
    \ == 0 || lst < min) min = lst\n                        }\n                  \
    \  }\n                    dp(i)(j) = min\n                }\n            }\n \
    \       }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n     \
    \   val prev = Array.fill(n, m)(-1)\n        val pq = new mutable.PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        for (i <- 0 until n) {\n         \
    \   for (j <- 0 until m) {\n                dp(i)(j) = grid(i)(j)\n          \
    \      pq.enqueue((dp(i)(j), i, j))\n            }\n        }\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i >\
    \ 0) {\n                    if (dp(i - 1)(j) > dp(i)(j) + grid(i - 1)(j)) {\n\
    \                        dp(i - 1)(j) = dp(i)(j) + grid(i - 1)(j)\n          \
    \              prev(i - 1)(j) = i * m + j\n                        pq.enqueue((dp(i\
    \ - 1)(j), i - 1, j))\n                    }\n                }\n            \
    \    if (i < n - 1) {\n                    if (dp(i + 1)(j) > dp(i)(j) + grid(i\
    \ + 1)(j)) {\n                        dp(i + 1)(j) = dp(i)(j) + grid(i + 1)(j)\n\
    \                        prev(i + 1)(j) = i * m + j\n                        pq.enqueue((dp(i\
    \ + 1)(j), i + 1, j))\n                    }\n                }\n            \
    \    if (j > 0) {\n                    if (dp(i)(j - 1) > dp(i)(j) + grid(i)(j\
    \ - 1)) {\n                        dp(i)(j - 1) = dp(i)(j) + grid(i)(j - 1)\n\
    \                        prev(i)(j - 1) = i * m + j\n                        pq.enqueue((dp(i)(j\
    \ - 1), i, j - 1))\n                    }\n                }\n               \
    \ if (j < m -", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val prev = Array.fill(n,\
    \ m)((0, 0))\n        val q = Queue[(Int, Int)]()\n        q.enqueue((0, 0))\n\
    \        dp(0)(0) = grid(0)(0)\n        while (!q.isEmpty) {\n            val\
    \ (x, y) = q.dequeue\n            for (i <- 0 until 4) {\n                val\
    \ (nx, ny) = (x + dx(i), y + dy(i))\n                if (nx >= 0 && nx < n &&\
    \ ny >= 0 && ny < m && dp(nx)(ny) > dp(x)(y) + grid(nx)(ny)) {\n             \
    \       dp(nx)(ny) = dp(x)(y) + grid(nx)(ny)\n                    prev(nx)(ny)\
    \ = (x, y)\n                    q.enqueue((nx, ny))\n                }\n     \
    \       }\n        }\n        val path = ArrayBuffer[Long]()\n        var (x,\
    \ y) = (n - 1, m - 1)\n        while (k > 0) {\n            path += grid(x)(y)\n\
    \            val (px, py) = prev(x)(y)\n            x = px\n            y = py\n\
    \            k -= 1\n        }\n        path.toList", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x => x._1))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        pq.enqueue((grid(i)(j), i, j))\n            }\n        }\n        while\
    \ (pq.nonEmpty) {\n            val (v, i, j) = pq.dequeue\n            if (dp(i)(j)\
    \ > v) {\n                dp(i)(j) = v\n                if (i > 0) pq.enqueue((dp(i\
    \ - 1)(j) + v, i - 1, j))\n                if (i < n - 1) pq.enqueue((dp(i + 1)(j)\
    \ + v, i + 1, j))\n                if (j > 0) pq.enqueue((dp(i)(j - 1) + v, i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((dp(i)(j + 1) + v, i, j +\
    \ 1))\n            }\n        }\n        val result = ArrayBuffer[Long]()\n  \
    \      var i = 0\n        var j = 0\n        while (k > 0) {\n            result\
    \ += grid(i)(j)\n            k -= 1\n            if (i > 0 && dp(i - 1)(j) + grid(i)(j)\
    \ == dp(i)(j)) i -= 1\n            else if (i < n - 1 && dp(i + 1)(j) + grid(i)(j)\
    \ == dp(i)(j)) i += 1\n            else if (j > 0 && dp(i)(j - 1) + grid(i)(j)\
    \ == dp(i)(j)) j -= 1\n            else if (j < m - 1 && dp(i)(j + 1) + grid(i)(j)\
    \ == dp(i)(j)) j += 1\n        }\n        result.toList", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val pq2 = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq2.enqueue((0, 0, 0))\n        val\
    \ visited = Array.fill(n, m)(false)\n        while (pq2.nonEmpty) {\n        \
    \    val (cost, i, j) = pq2.dequeue\n            if (!visited(i)(j)) {\n     \
    \           visited(i)(j) = true\n                if (i > 0 && dp(i - 1)(j) ==\
    \ cost + grid(i - 1)(j)) pq2.enqueue((cost + grid(i - 1)(j), i - 1, j))\n    \
    \            if (i < n - 1 && dp(i + 1)(j) == cost + grid(i + 1)(j)) pq2.enqueue((cost\
    \ + grid(i + 1)(j), i + 1, j))\n                if (j > 0 && dp(i)(j - 1) == cost\
    \ + grid(i)(j - 1)) pq2.enqueue((cost +", "        val n = grid.length\n     \
    \   val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        val dp2 = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ {\n                    dp(i)(j) = List(grid(i)(j))\n                    dp2(i)(j)\
    \ = List(grid(i)(j))\n                } else if (i == 0) {\n                 \
    \   dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                    dp2(i)(j) = dp2(i)(j\
    \ - 1) :+ grid(i)(j)\n                } else if (j == 0) {\n                 \
    \   dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                    dp2(i)(j) = dp2(i\
    \ - 1)(j) :+ grid(i)(j)\n                } else {\n                    val l1\
    \ = dp(i - 1)(j) :+ grid(i)(j)\n                    val l2 = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    if (l1 < l2) {\n                        dp(i)(j) = l1\n \
    \                       dp2(i)(j) = l2\n                    } else {\n       \
    \                 dp(i)(j) = l2\n                        dp2(i)(j) = l1\n    \
    \                }\n                }\n            }\n        }\n        if (k\
    \ % 2 == 0) dp(n - 1)(m - 1) else dp2(n - 1)(m - 1)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, (Int, Int))]()(Ordering.by(_._1))\n\
    \        pq.enqueue((0, (0, 0)))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, (i, j)) = pq.dequeue\n            if (dp(i)(j) > cost) {\n          \
    \      dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i -\
    \ 1)(j), (i - 1, j)))\n                if (i < n - 1) pq.enqueue((cost + grid(i\
    \ + 1)(j), (i + 1, j)))\n                if (j > 0) pq.enqueue((cost + grid(i)(j\
    \ - 1), (i, j - 1)))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j\
    \ + 1), (i, j + 1)))\n            }\n        }\n        val pq2 = new PriorityQueue[(Long,\
    \ (Int, Int))]()(Ordering.by(_._1))\n        pq2.enqueue((0, (0, 0)))\n      \
    \  val visited = Array.fill(n, m)(false)\n        visited(0)(0) = true\n     \
    \   var result = List[Long]()\n        while (pq2.nonEmpty) {\n            val\
    \ (cost, (i, j)) = pq2.dequeue\n            result = result :+ grid(i)(j)\n  \
    \          if (result.length == k) return result\n            if (i > 0 && !visited(i\
    \ - 1)(j) && dp(i - 1)(j) == cost + grid(i - 1)(j)) {\n                pq2.enqueue((cost\
    \ + grid(i - 1)(j), (i - 1, j)))\n                visited(i - 1)(j) = true\n \
    \           }\n            if (i < n - 1 && !visited(i + 1)(j) && dp(i + 1", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.fill(n, m)(Long.MaxValue)\n        val prev = Array.fill(n, m)(-1)\n \
    \       val queue = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = grid(i)(j)\n                queue.enqueue((dp(i)(j), i, j))\n\
    \            }\n        }\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                if (i > 0) {\n                    if (dp(i\
    \ - 1)(j) > dp(i)(j) + grid(i - 1)(j)) {\n                        dp(i - 1)(j)\
    \ = dp(i)(j) + grid(i - 1)(j)\n                        prev(i - 1)(j) = 1\n  \
    \                      queue.enqueue((dp(i - 1)(j), i - 1, j))\n             \
    \       }\n                }\n                if (i < n - 1) {\n             \
    \       if (dp(i + 1)(j) > dp(i)(j) + grid(i + 1)(j)) {\n                    \
    \    dp(i + 1)(j) = dp(i)(j) + grid(i + 1)(j)\n                        prev(i\
    \ + 1)(j) = 0\n                        queue.enqueue((dp(i + 1)(j), i + 1, j))\n\
    \                    }\n                }\n                if (j > 0) {\n    \
    \                if (dp(i)(j - 1) > dp(i)(j) + grid(i)(j - 1)) {\n           \
    \             dp(i)(j - 1) = dp(i)(j) + grid(i)(j - 1)\n                     \
    \   prev(i)(j - 1) = 3\n                        queue.enqueue((dp(i)(j - 1), i,\
    \ j - 1))\n                    }\n                }\n                if (j < m\
    \ - 1) {\n                    if (dp(i)(j + 1) > dp(i)(", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val up = if (i > 0) dp(i - 1)(j) else List[Long]()\n\
    \                    val left = if (j > 0) dp(i)(j - 1) else List[Long]()\n  \
    \                  val up_left = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val up_left_up = if (i > 1 && j > 0) dp(i - 2)(j - 1) else\
    \ List[Long]()\n                    val up_left_left = if (i > 0 && j > 1) dp(i\
    \ - 1)(j - 2) else List[Long]()\n                    val up_left_up_left = if\
    \ (i > 1 && j > 1) dp(i - 2)(j - 2) else List[Long]()\n                    val\
    \ up_left_up_left_up = if (i > 2 && j > 1) dp(i - 3)(j - 2) else List[Long]()\n\
    \                    val up_left_up_left_left = if (i > 1 && j > 2) dp(i - 2)(j\
    \ - 3) else List[Long]()\n                    val up_left_up_left_up_left = if\
    \ (i > 2 && j > 2) dp(i - 3)(j - 3) else List[Long]()\n                    val\
    \ up_left_up_left_up_left_up = if (i > 3 && j > 2) dp(i - 4)(j - 2) else List[Long]()\n\
    \                    val up_left_up_left_up_left_left = if (i > 2 && j > 3) dp(i\
    \ - 3)(j - 4) else List[Long]()\n                    val up_left_up_left_up_left_",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val up = if (i > 0) dp(i - 1)(j) else\
    \ List[Long]()\n                    val left = if (j > 0) dp(i)(j - 1) else List[Long]()\n\
    \                    val up_left = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val up_left_up = if (i > 1 && j > 0) dp(i - 2)(j - 1) else\
    \ List[Long]()\n                    val up_left_left = if (i > 0 && j > 1) dp(i\
    \ - 1)(j - 2) else List[Long]()\n                    val up_left_up_left = if\
    \ (i > 1 && j > 1) dp(i - 2)(j - 2) else List[Long]()\n                    val\
    \ up_left_up_left_up = if (i > 2 && j > 1) dp(i - 3)(j - 2) else List[Long]()\n\
    \                    val up_left_up_left_left = if (i > 1 && j > 2) dp(i - 2)(j\
    \ - 3) else List[Long]()\n                    val up_left_up_left_up_left = if\
    \ (i > 2 && j > 2) dp(i - 3)(j - 3) else List[Long]()\n                    val\
    \ up_left_up_left_up_left_up = if (i > 3 && j > 2) dp(i - 4)(j - 2) else List[Long]()\n\
    \                    val up_left_up_left_up_left_left = if (i > 2 && j > 3) dp(i\
    \ - 3)(j - 4) else List[Long]()\n                    val up_left_up_left_up_left_",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val pq2 = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq2.enqueue((0, 0, 0))\n        val\
    \ dp2 = Array.fill(n, m)(Long.MaxValue)\n        dp2(0)(0) = 0\n        val path\
    \ = ListBuffer[Long]()\n        while (pq2.nonEmpty) {\n            val (cost,\
    \ i, j) = pq2.dequeue\n            if (dp2(i)(j) == cost) {\n                path\
    \ += grid(i)(j)\n                if (path.length == k) return path.toList\n  \
    \              if (i > 0 && dp2(i - 1)(j) > cost + dp(i - 1)(j)) {\n         \
    \           dp2(i - 1)(j) = cost + dp(i - 1)(j)\n                    pq2.enqueue((dp2(i\
    \ - 1)(j), i - 1, j))\n                }\n                if (i < n - 1 && dp2",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i + 1 < n) pq.enqueue((cost + grid(i\
    \ + 1)(j), i + 1, j))\n                if (j + 1 < m) pq.enqueue((cost + grid(i)(j\
    \ + 1), i, j + 1))\n                if (i - 1 >= 0) pq.enqueue((cost + grid(i\
    \ - 1)(j), i - 1, j))\n                if (j - 1 >= 0) pq.enqueue((cost + grid(i)(j\
    \ - 1), i, j - 1))\n            }\n        }\n        val res = new ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while (k > 0) {\n            res\
    \ += grid(i)(j)\n            k -= 1\n            if (i + 1 < n && dp(i + 1)(j)\
    \ < dp(i)(j)) {\n                i += 1\n            } else if (j + 1 < m && dp(i)(j\
    \ + 1) < dp(i)(j)) {\n                j += 1\n            } else if (i - 1 >=\
    \ 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -= 1\n            } else\
    \ if (j - 1 >= 0 && dp(i)(j - 1) < dp(i)(j)) {\n                j -= 1\n     \
    \       }\n        }\n        res.toList", "        val n = grid.length\n    \
    \    val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (d, i, j) = pq.dequeue\n            if (dp(i)(j) <= d) {\n                if\
    \ (i == n - 1 && j == m - 1 && dp(i)(j) == d) {\n                    var result\
    \ = List[Long]()\n                    var x = i\n                    var y = j\n\
    \                    while (x != 0 || y != 0) {\n                        result\
    \ = grid(x)(y) :: result\n                        val (x1, y1) = if (x == 0) (x,\
    \ y - 1) else if (y == 0) (x - 1, y) else if (dp(x - 1)(y) < dp(x)(y - 1)) (x\
    \ - 1, y) else (x, y - 1)\n                        x = x1\n                  \
    \      y = y1\n                    }\n                    result = grid(0)(0)\
    \ :: result\n                    return result\n                }\n          \
    \      if (i < n - 1 && dp(i + 1)(j) > d + grid(i + 1)(j)) {\n               \
    \     dp(i + 1)(j) = d + grid(i + 1)(j)\n                    pq.enqueue((dp(i\
    \ + 1)(j), i + 1, j))\n                }\n                if (j < m - 1 && dp(i)(j\
    \ + 1) > d + grid(i)(j + 1)) {\n                    dp(i)(j + 1) = d + grid(i)(j\
    \ + 1)\n                    pq.enqueue((dp(i)(j + 1), i, j + 1))\n           \
    \     }\n            }\n        }\n        return List[Long]()", "        val\
    \ n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                if (i\
    \ == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else {\n      \
    \              val up = if (i > 0) dp(i - 1)(j) else List[Long]()\n          \
    \          val left = if (j > 0) dp(i)(j - 1) else List[Long]()\n            \
    \        val up_left = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val up_left_up = if (i > 1 && j > 0) dp(i - 2)(j - 1) else\
    \ List[Long]()\n                    val up_left_left = if (i > 0 && j > 1) dp(i\
    \ - 1)(j - 2) else List[Long]()\n                    val up_left_up_left = if\
    \ (i > 1 && j > 1) dp(i - 2)(j - 2) else List[Long]()\n                    val\
    \ up_left_up_left_up = if (i > 2 && j > 1) dp(i - 3)(j - 2) else List[Long]()\n\
    \                    val up_left_up_left_left = if (i > 1 && j > 2) dp(i - 2)(j\
    \ - 3) else List[Long]()\n                    val up_left_up_left_up_left = if\
    \ (i > 2 && j > 2) dp(i - 3)(j - 3) else List[Long]()\n                    val\
    \ up_left_up_left_up_left_up = if (i > 3 && j > 2) dp(i - 4)(j - 3) else List[Long]()\n\
    \                    val up_left_up_left_up_left_left = if (i > 2 && j > 3) dp(i\
    \ - 3)(j - 4) else List[Long]()\n                    val up_left_up_left_up_left_up_left\
    \ = if (i > 3 &&", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    val\
    \ candidates = ListBuffer[List[Long]]()\n                    if (i > 0) candidates\
    \ += (grid(i)(j) :: dp(i - 1)(j))\n                    if (j > 0) candidates +=\
    \ (grid(i)(j) :: dp(i)(j - 1))\n                    if (candidates.isEmpty) dp(i)(j)\
    \ = List(grid(i)(j))\n                    else dp(i)(j) = candidates.minBy(x =>\
    \ x.reverse)\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1).take(k.toInt)", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < n - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val result = new ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while (k > 0) {\n            result\
    \ += grid(i)(j)\n            k -= 1\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j))\
    \ {\n                i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j)\
    \ < dp(i)(j)) {\n                i += 1\n            } else if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                j -= 1\n            } else if (j < n - 1\
    \ && dp(i)(j + 1) < dp(i)(j)) {\n                j += 1\n            }\n     \
    \   }\n        result.toList", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(_._1))\n        pq.enqueue((0, 0, 0))\n        while\
    \ (!pq.isEmpty) {\n            val (cost, i, j) = pq.dequeue\n            if (dp(i)(j)\
    \ > cost) {\n                dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1) pq.enqueue((cost\
    \ + grid(i + 1)(j), i + 1, j))\n                if (j > 0) pq.enqueue((cost +\
    \ grid(i)(j - 1), i, j - 1))\n                if (j < m - 1) pq.enqueue((cost\
    \ + grid(i)(j + 1), i, j + 1))\n            }\n        }\n        val pq2 = new\
    \ PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n        pq2.enqueue((0,\
    \ 0, 0))\n        val visited = Array.fill(n, m)(false)\n        visited(0)(0)\
    \ = true\n        var ans = List[Long]()\n        while (!pq2.isEmpty) {\n   \
    \         val (cost, i, j) = pq2.dequeue\n            ans = ans :+ grid(i)(j)\n\
    \            if (ans.length == k) return ans\n            if (i > 0 && !visited(i\
    \ - 1)(j) && dp(i - 1)(j) == cost + grid(i - 1)(j)) {\n                pq2.enqueue((cost\
    \ + grid(i - 1)(j), i - 1, j))\n                visited(i - 1)(j) = true\n   \
    \         }\n            if (i < n - 1 && !visited(i + 1)(j) && dp(i + 1)(j) ==\
    \ cost + grid(i + 1)(j", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    val\
    \ neighbors = List((i - 1, j), (i, j - 1)).filter(p => p._1 >= 0 && p._2 >= 0)\n\
    \                    val paths = neighbors.map(p => dp(p._1)(p._2).map(grid(i)(j)\
    \ :: _)).filter(_.length == k)\n                    if (paths.length > 0) dp(i)(j)\
    \ = paths.minBy(_.reverse)\n                }\n            }\n        }\n    \
    \    dp(n - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val prev = Array.fill(n,\
    \ m)(-1)\n        val q = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        q.enqueue((0, 0, 0))\n        while (!q.isEmpty) {\n            val (cost,\
    \ i, j) = q.dequeue\n            if (dp(i)(j) > cost) {\n                dp(i)(j)\
    \ = cost\n                if (i > 0) {\n                    val newCost = cost\
    \ + grid(i - 1)(j)\n                    if (newCost < dp(i - 1)(j)) {\n      \
    \                  prev(i - 1)(j) = i * m + j\n                        q.enqueue((newCost,\
    \ i - 1, j))\n                    }\n                }\n                if (i\
    \ < n - 1) {\n                    val newCost = cost + grid(i + 1)(j)\n      \
    \              if (newCost < dp(i + 1)(j)) {\n                        prev(i +\
    \ 1)(j) = i * m + j\n                        q.enqueue((newCost, i + 1, j))\n\
    \                    }\n                }\n                if (j > 0) {\n    \
    \                val newCost = cost + grid(i)(j - 1)\n                    if (newCost\
    \ < dp(i)(j - 1)) {\n                        prev(i)(j - 1) = i * m + j\n    \
    \                    q.enqueue((newCost, i, j - 1))\n                    }\n \
    \               }\n                if (j < m - 1) {\n                    val newCost\
    \ = cost + grid(i)(j + 1)\n                    if (newCost < dp(i)(j + 1)) {\n\
    \                        prev(i)(j + 1) = i * m + j\n                        q.enqueue((newCost,\
    \ i, j + 1))\n                    }\n                }\n            }\n      \
    \  }\n        val result = ListBuffer[Long]()\n        var cur = 0\n        for\
    \ (i <- 0 until k) {\n            result += grid(cur / m)(cur", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val prev = Array.fill(n, m)(-1)\n        val queue\
    \ = new Queue[(Int, Int)]\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                if (grid(i)(j) == 1) {\n                  \
    \  dp(i)(j) = 0\n                    queue.enqueue((i, j))\n                }\n\
    \            }\n        }\n        val dirs = List((-1, 0), (1, 0), (0, -1), (0,\
    \ 1))\n        while (!queue.isEmpty) {\n            val (i, j) = queue.dequeue\n\
    \            for ((di, dj) <- dirs) {\n                val ni = i + di\n     \
    \           val nj = j + dj\n                if (ni >= 0 && ni < n && nj >= 0\
    \ && nj < m) {\n                    if (dp(ni)(nj) > dp(i)(j) + 1) {\n       \
    \                 dp(ni)(nj) = dp(i)(j) + 1\n                        prev(ni)(nj)\
    \ = i * m + j\n                        queue.enqueue((ni, nj))\n             \
    \       }\n                }\n            }\n        }\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                if (dp(i)(j) <= k && grid(i)(j) < min) {\n\
    \                    min = grid(i)(j)\n                    minIndex = i * m +\
    \ j\n                }\n            }\n        }\n        val result = new ListBuffer[Long]\n\
    \        while (minIndex != -1) {\n            result += grid(minIndex / m)(minIndex\
    \ % m)\n            minIndex = prev(minIndex / m)(minIndex % m)\n        }\n \
    \       result.reverse.toList", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i\
    \ == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else {\n      \
    \              val neighbors = List((i - 1, j), (i, j - 1), (i + 1, j), (i, j\
    \ + 1)).filter(x => x._1 >= 0 && x._1 < n && x._2 >= 0 && x._2 < m)\n        \
    \            dp(i)(j) = neighbors.map(x => (grid(i)(j) :: dp(x._1)(x._2)).sorted).sortWith((x,\
    \ y) => x.compareTo(y) < 0).head\n                }\n            }\n        }\n\
    \        dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n     \
    \   val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length\
    \ + 1 <= k) {\n                    val lst = dp(i - 1)(j) :+ grid(i)(j)\n    \
    \                if (lst.length == dp(i)(j).length) {\n                      \
    \  if (lst < dp(i)(j)) dp(i)(j) = lst\n                    } else if (lst.length\
    \ < dp(i)(j).length) dp(i)(j) = lst\n                }\n                if (j\
    \ > 0 && dp(i)(j - 1).length + 1 <= k) {\n                    val lst = dp(i)(j\
    \ - 1) :+ grid(i)(j)\n                    if (lst.length == dp(i)(j).length) {\n\
    \                        if (lst < dp(i)(j)) dp(i)(j) = lst\n                \
    \    } else if (lst.length < dp(i)(j).length) dp(i)(j) = lst\n               \
    \ }\n            }\n        }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        if (k == 1) {\n            var min =\
    \ Long.MaxValue\n            var min_i = 0\n            var min_j = 0\n      \
    \      for (i <- 0 until n) {\n                for (j <- 0 until m) {\n      \
    \              if (grid(i)(j) < min) {\n                        min = grid(i)(j)\n\
    \                        min_i = i\n                        min_j = j\n      \
    \              }\n                }\n            }\n            return List(grid(min_i)(min_j))\n\
    \        }\n        val dp = Array.ofDim[Long](n, m, k + 1)\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                dp(i)(j)(1)\
    \ = grid(i)(j)\n            }\n        }\n        for (k_ <- 2 to k.toInt) {\n\
    \            for (i <- 0 until n) {\n                for (j <- 0 until m) {\n\
    \                    var min = Long.MaxValue\n                    if (i > 0) {\n\
    \                        min = min min (dp(i - 1)(j)(k_ - 1) + grid(i)(j))\n \
    \                   }\n                    if (i < n - 1) {\n                \
    \        min = min min (dp(i + 1)(j)(k_ - 1) + grid(i)(j))\n                 \
    \   }\n                    if (j > 0) {\n                        min = min min\
    \ (dp(i)(j - 1)(k_ - 1) + grid(i)(j))\n                    }\n               \
    \     if (j < m - 1) {\n                        min = min min (dp(i)(j + 1)(k_\
    \ - 1) + grid(i)(j))\n                    }\n                    dp(i)(j)(k_)\
    \ = min\n                }\n            }\n        }\n        var min = Long.MaxValue\n\
    \        var min_i = 0\n        var min_j = 0\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (dp(i)(j)(k.toInt) < min)\
    \ {\n                    min = dp(i)(j)(", "        val n = grid.length\n    \
    \    val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val path = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                if (i == 0 && j ==\
    \ 0) {\n                    dp(i)(j) = grid(i)(j)\n                    path(i)(j)\
    \ = List(grid(i)(j))\n                }\n                else {\n            \
    \        if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                        dp(i)(j)\
    \ = dp(i - 1)(j)\n                        path(i)(j) = path(i - 1)(j)\n      \
    \              }\n                    if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n\
    \                        dp(i)(j) = dp(i)(j - 1)\n                        path(i)(j)\
    \ = path(i)(j - 1)\n                    }\n                    if (dp(i)(j) !=\
    \ Long.MaxValue) {\n                        dp(i)(j) += grid(i)(j)\n         \
    \               path(i)(j) = path(i)(j) :+ grid(i)(j)\n                    }\n\
    \                }\n            }\n        }\n        var result = List[Long]()\n\
    \        var i = n - 1\n        var j = m - 1\n        while (k > 0) {\n     \
    \       result = path(i)(j).head :: result\n            k -= 1\n            if\
    \ (i > 0 && dp(i - 1)(j) < dp(i)(j - 1)) {\n                i -= 1\n         \
    \   }\n            else if (j > 0 && dp(i)(j - 1) < dp(i - 1)(j)) {\n        \
    \        j -= 1\n            }\n            else {\n                i -= 1\n \
    \               j -= 1\n            }\n        }\n        result", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val lst = ListBuffer[Long]()\n    \
    \                if (i > 0) lst ++= dp(i - 1)(j)\n                    if (j >\
    \ 0) lst ++= dp(i)(j - 1)\n                    dp(i)(j) = (lst.toList :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1)", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (i < 0 || i >= n || j < 0 || j >=\
    \ m) {\n                // out of bounds\n            } else if (dp(i)(j) <= cost)\
    \ {\n                // already visited\n            } else {\n              \
    \  dp(i)(j) = cost\n                if (cost >= k) {\n                    // done\n\
    \                } else {\n                    pq.enqueue((cost + grid(i)(j),\
    \ i - 1, j))\n                    pq.enqueue((cost + grid(i)(j), i + 1, j))\n\
    \                    pq.enqueue((cost + grid(i)(j), i, j - 1))\n             \
    \       pq.enqueue((cost + grid(i)(j), i, j + 1))\n                }\n       \
    \     }\n        }\n        val result = new ListBuffer[Long]()\n        var i\
    \ = 0\n        var j = 0\n        while (k > 0) {\n            result += grid(i)(j)\n\
    \            k -= 1\n            if (i > 0 && dp(i - 1)(j) < dp(i + 1)(j) && dp(i\
    \ - 1)(j) < dp(i)(j - 1) && dp(i - 1)(j) < dp(i)(j + 1)) {\n                i\
    \ -= 1\n            } else if (i < n - 1 && dp(i + 1)(j) < dp(i - 1)(j) && dp(i\
    \ + 1)(j) < dp(i)(j - 1) && dp(i + 1)(j) < dp(i)(j + 1)) {\n                i\
    \ += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i - 1)(j) &&", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val up = if (i > 0) dp(i - 1)(j) else\
    \ List[Long]()\n                    val left = if (j > 0) dp(i)(j - 1) else List[Long]()\n\
    \                    if (up.length == 0) dp(i)(j) = left :+ grid(i)(j)\n     \
    \               else if (left.length == 0) dp(i)(j) = up :+ grid(i)(j)\n     \
    \               else if (up.length < left.length) dp(i)(j) = up :+ grid(i)(j)\n\
    \                    else if (up.length > left.length) dp(i)(j) = left :+ grid(i)(j)\n\
    \                    else {\n                        var flag = false\n      \
    \                  for (t <- 0 until up.length) {\n                          \
    \  if (up(t) < left(t)) {\n                                dp(i)(j) = up :+ grid(i)(j)\n\
    \                                flag = true\n                               \
    \ break\n                            }\n                            else if (up(t)\
    \ > left(t)) {\n                                dp(i)(j) = left :+ grid(i)(j)\n\
    \                                flag = true\n                               \
    \ break\n                            }\n                        }\n          \
    \              if (!flag) dp(i)(j) = up :+ grid(i)(j)\n                    }\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    var min = List[Long]()\n          \
    \          if (i > 0) {\n                        val lst = dp(i - 1)(j)\n    \
    \                    if (lst.length < k) min = lst :+ grid(i)(j)\n           \
    \             else if (lst.length == k) min = lst\n                    }\n   \
    \                 if (j > 0) {\n                        val lst = dp(i)(j - 1)\n\
    \                        if (lst.length < k) {\n                            if\
    \ (min.length == 0 || lst.length < min.length || (lst.length == min.length &&\
    \ lst.last < min.last)) min = lst :+ grid(i)(j)\n                        }\n \
    \                       else if (lst.length == k) {\n                        \
    \    if (min.length == 0 || (lst.length == min.length && lst.last < min.last))\
    \ min = lst\n                        }\n                    }\n              \
    \      dp(i)(j) = min\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)((Long.MaxValue, List[Long]()))\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i\
    \ == 0 && j == 0) dp(i)(j) = (0, List(grid(i)(j)))\n                else {\n \
    \                   if (i > 0) {\n                        val (x, lst) = dp(i\
    \ - 1)(j)\n                        if (x + 1 < dp(i)(j)._1) dp(i)(j) = (x + 1,\
    \ grid(i)(j) :: lst)\n                        else if (x + 1 == dp(i)(j)._1) {\n\
    \                            val lst2 = grid(i)(j) :: lst\n                  \
    \          if (lst2 < dp(i)(j)._2) dp(i)(j) = (x + 1, lst2)\n                \
    \        }\n                    }\n                    if (j > 0) {\n        \
    \                val (x, lst) = dp(i)(j - 1)\n                        if (x +\
    \ 1 < dp(i)(j)._1) dp(i)(j) = (x + 1, grid(i)(j) :: lst)\n                   \
    \     else if (x + 1 == dp(i)(j)._1) {\n                            val lst2 =\
    \ grid(i)(j) :: lst\n                            if (lst2 < dp(i)(j)._2) dp(i)(j)\
    \ = (x + 1, lst2)\n                        }\n                    }\n        \
    \        }\n            }\n        }\n        val (x, lst) = dp(n - 1)(m - 1)\n\
    \        if (x == k) lst\n        else {\n            val lst2 = ListBuffer[Long]()\n\
    \            var i = n - 1\n            var j = m - 1\n            while (i >\
    \ 0 || j > 0) {\n                if (i > 0 && dp(i - 1)(j)._1 + 1 == dp(i)(j).",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val neighbors = List((i - 1, j), (i, j - 1), (i + 1,\
    \ j), (i, j + 1)).filter(x => x._1 >= 0 && x._1 < n && x._2 >= 0 && x._2 < n)\n\
    \                    val neighborPaths = neighbors.map(x => dp(x._1)(x._2)).filter(x\
    \ => x.length < k)\n                    val minPath = if (neighborPaths.isEmpty)\
    \ List[Long]() else neighborPaths.minBy(x => x :+ grid(i)(j))\n              \
    \      dp(i)(j) = minPath :+ grid(i)(j)\n                }\n            }\n  \
    \      }\n        dp(n - 1)(n - 1)", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n     \
    \   val prev = Array.fill(n, m)((-1, -1))\n        val q = new Queue[(Int, Int)]\n\
    \        q.enqueue((0, 0))\n        dp(0)(0) = grid(0)(0)\n        while (!q.isEmpty)\
    \ {\n            val (i, j) = q.dequeue\n            if (i > 0 && dp(i - 1)(j)\
    \ > dp(i)(j) + grid(i - 1)(j)) {\n                dp(i - 1)(j) = dp(i)(j) + grid(i\
    \ - 1)(j)\n                prev(i - 1)(j) = (i, j)\n                q.enqueue((i\
    \ - 1, j))\n            }\n            if (i < n - 1 && dp(i + 1)(j) > dp(i)(j)\
    \ + grid(i + 1)(j)) {\n                dp(i + 1)(j) = dp(i)(j) + grid(i + 1)(j)\n\
    \                prev(i + 1)(j) = (i, j)\n                q.enqueue((i + 1, j))\n\
    \            }\n            if (j > 0 && dp(i)(j - 1) > dp(i)(j) + grid(i)(j -\
    \ 1)) {\n                dp(i)(j - 1) = dp(i)(j) + grid(i)(j - 1)\n          \
    \      prev(i)(j - 1) = (i, j)\n                q.enqueue((i, j - 1))\n      \
    \      }\n            if (j < m - 1 && dp(i)(j + 1) > dp(i)(j) + grid(i)(j + 1))\
    \ {\n                dp(i)(j + 1) = dp(i)(j) + grid(i)(j + 1)\n              \
    \  prev(i)(j + 1) = (i, j)\n                q.enqueue((i, j + 1))\n          \
    \  }\n        }\n        var (i", "        val n = grid.length\n        val m\
    \ = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n       \
    \ val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n       \
    \ pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val (cost,\
    \ i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n                dp(i)(j)\
    \ = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j), i - 1,\
    \ j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), i + 1,\
    \ j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i, j - 1))\n\
    \                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i, j + 1))\n\
    \            }\n        }\n        val result = new ListBuffer[Long]()\n     \
    \   var i = 0\n        var j = 0\n        while (k > 0) {\n            result\
    \ += grid(i)(j)\n            k -= 1\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j))\
    \ {\n                i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j)\
    \ < dp(i)(j)) {\n                i += 1\n            } else if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                j -= 1\n            } else if (j < m - 1\
    \ && dp(i)(j + 1) < dp(i)(j)) {\n                j += 1\n            }\n     \
    \   }\n        result.toList", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq.enqueue((0, 0, 0))\n        while\
    \ (pq.nonEmpty) {\n            val (cost, x, y) = pq.dequeue\n            if (dp(x)(y)\
    \ > cost) {\n                dp(x)(y) = cost\n                if (x > 0) pq.enqueue((cost\
    \ + grid(x - 1)(y), x - 1, y))\n                if (x < n - 1) pq.enqueue((cost\
    \ + grid(x + 1)(y), x + 1, y))\n                if (y > 0) pq.enqueue((cost +\
    \ grid(x)(y - 1), x, y - 1))\n                if (y < m - 1) pq.enqueue((cost\
    \ + grid(x)(y + 1), x, y + 1))\n            }\n        }\n        val result =\
    \ new ListBuffer[Long]()\n        var x = 0\n        var y = 0\n        var cost\
    \ = 0L\n        for (i <- 0 until k.toInt) {\n            result += grid(x)(y)\n\
    \            if (x > 0 && dp(x - 1)(y) < dp(x)(y)) {\n                x -= 1\n\
    \                cost += grid(x)(y)\n            } else if (x < n - 1 && dp(x\
    \ + 1)(y) < dp(x)(y)) {\n                x += 1\n                cost += grid(x)(y)\n\
    \            } else if (y > 0 && dp(x)(y - 1) < dp(x)(y)) {\n                y\
    \ -= 1\n                cost += grid(x)(y)\n            } else if (y < m - 1 &&\
    \ dp(x)(y + 1) < dp(x)(y)) {\n                y += 1\n                cost +=\
    \ grid(x)(y)\n            }\n        }\n        result.toList", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, (Int, Int))]()(Ordering.by(x\
    \ => x._1))\n        pq.enqueue((0, (0, 0)))\n        while (pq.nonEmpty) {\n\
    \            val (cost, (i, j)) = pq.dequeue\n            if (dp(i)(j) > cost)\
    \ {\n                dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost\
    \ + grid(i - 1)(j), (i - 1, j)))\n                if (i < n - 1) pq.enqueue((cost\
    \ + grid(i + 1)(j), (i + 1, j)))\n                if (j > 0) pq.enqueue((cost\
    \ + grid(i)(j - 1), (i, j - 1)))\n                if (j < m - 1) pq.enqueue((cost\
    \ + grid(i)(j + 1), (i, j + 1)))\n            }\n        }\n        val path =\
    \ Array.fill(k.toInt)(0)\n        var i = 0\n        var j = 0\n        for (l\
    \ <- 0 until k.toInt) {\n            path(l) = grid(i)(j).toInt\n            if\
    \ (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -= 1\n            }\
    \ else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n                i += 1\n \
    \           } else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                j\
    \ -= 1\n            } else {\n                j += 1\n            }\n        }\n\
    \        path.toList", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(Long.MaxValue)\n        val dp2 = Array.fill(n, n)(List[Long]())\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until n) {\n              \
    \  if (i == 0 && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n      \
    \              dp2(i)(j) = List(grid(i)(j))\n                }\n             \
    \   else {\n                    if (i > 0) {\n                        if (dp(i\
    \ - 1)(j) < dp(i)(j)) {\n                            dp(i)(j) = dp(i - 1)(j)\n\
    \                            dp2(i)(j) = dp2(i - 1)(j)\n                     \
    \   }\n                        else if (dp(i - 1)(j) == dp(i)(j)) {\n        \
    \                    if (dp2(i - 1)(j) < dp2(i)(j)) {\n                      \
    \          dp2(i)(j) = dp2(i - 1)(j)\n                            }\n        \
    \                }\n                    }\n                    if (j > 0) {\n\
    \                        if (dp(i)(j - 1) < dp(i)(j)) {\n                    \
    \        dp(i)(j) = dp(i)(j - 1)\n                            dp2(i)(j) = dp2(i)(j\
    \ - 1)\n                        }\n                        else if (dp(i)(j -\
    \ 1) == dp(i)(j)) {\n                            if (dp2(i)(j - 1) < dp2(i)(j))\
    \ {\n                                dp2(i)(j) = dp2(i)(j - 1)\n             \
    \               }\n                        }\n                    }\n        \
    \            dp(i)(j) += grid(i)(j)\n                    dp2(i)(j) = dp2(i)(j)\
    \ :+ grid(i)(j)\n                }\n            }\n        }\n        var x =\
    \ n - 1\n        var y = n - 1\n        var ans = dp2(x)(y)\n", "        val n\
    \ = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                val\
    \ l = List(grid(i)(j))\n                dp(i)(j) = l\n                for (x <-\
    \ 0 until n) {\n                    for (y <- 0 until n) {\n                 \
    \       if (x != i || y != j) {\n                            val l2 = dp(x)(y)\n\
    \                            if (l2.length < k) {\n                          \
    \      val l3 = l2 ::: l\n                                if (l3.length <= k &&\
    \ (dp(i)(j).length > l3.length || l3 < dp(i)(j))) {\n                        \
    \            dp(i)(j) = l3\n                                }\n              \
    \              }\n                        }\n                    }\n         \
    \       }\n            }\n        }\n        var ans = List[Long]()\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                if (ans.length\
    \ > dp(i)(j).length || dp(i)(j) < ans) {\n                    ans = dp(i)(j)\n\
    \                }\n            }\n        }\n        ans", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        def dfs(i : Int, j : Int, k : Long, path : List[Long]) : Unit = {\n \
    \           if (i < 0 || i >= n || j < 0 || j >= m) return\n            if (k\
    \ < 0) return\n            if (dp(i)(j) <= k) return\n            dp(i)(j) = k\n\
    \            dfs(i - 1, j, k - 1, grid(i)(j) :: path)\n            dfs(i + 1,\
    \ j, k - 1, grid(i)(j) :: path)\n            dfs(i, j - 1, k - 1, grid(i)(j) ::\
    \ path)\n            dfs(i, j + 1, k - 1, grid(i)(j) :: path)\n        }\n   \
    \     dfs(0, 0, k, List(grid(0)(0)))\n        var minPath = List[Long]()\n   \
    \     for (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j) <= k) {\n\
    \                val path = dfs2(i, j, k, List(grid(i)(j)))\n                if\
    \ (path < minPath) minPath = path\n            }\n        }\n        minPath",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    var min = List[Long]()\n          \
    \          if (i > 0) {\n                        val lst = dp(i - 1)(j)\n    \
    \                    if (lst.length < k) min = lst :+ grid(i)(j)\n           \
    \             else if (lst.length == k) min = if (lst.last > grid(i)(j)) lst :+\
    \ grid(i)(j) else lst\n                    }\n                    if (j > 0) {\n\
    \                        val lst = dp(i)(j - 1)\n                        if (lst.length\
    \ < k) {\n                            if (min.length == 0 || lst.length < min.length\
    \ || (lst.length == min.length && lst.last < min.last)) min = lst :+ grid(i)(j)\n\
    \                        }\n                        else if (lst.length == k)\
    \ {\n                            if (min.length == 0 || (lst.last < min.last))\
    \ min = if (lst.last > grid(i)(j)) lst :+ grid(i)(j) else lst\n              \
    \          }\n                    }\n                    dp(i)(j) = min\n    \
    \            }\n            }\n        }\n        dp(n - 1)(m - 1)", "       \
    \ val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val result = new ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while (k > 0) {\n            result\
    \ += grid(i)(j)\n            k -= 1\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j))\
    \ {\n                i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j)\
    \ < dp(i)(j)) {\n                i += 1\n            } else if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                j -= 1\n            } else if (j < m - 1\
    \ && dp(i)(j + 1) < dp(i)(j)) {\n                j += 1\n            }\n     \
    \   }\n        result.toList", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val prev = Array.fill(n,\
    \ m)(-1)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (i == 0 && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n\
    \                } else {\n                    if (i > 0) {\n                \
    \        if (dp(i - 1)(j) < dp(i)(j)) {\n                            dp(i)(j)\
    \ = dp(i - 1)(j)\n                            prev(i)(j) = 0\n               \
    \         }\n                    }\n                    if (j > 0) {\n       \
    \                 if (dp(i)(j - 1) < dp(i)(j)) {\n                           \
    \ dp(i)(j) = dp(i)(j - 1)\n                            prev(i)(j) = 1\n      \
    \                  }\n                    }\n                    dp(i)(j) += grid(i)(j)\n\
    \                }\n            }\n        }\n        val result = ListBuffer[Long]()\n\
    \        var i = n - 1\n        var j = m - 1\n        while (k > 0) {\n     \
    \       result += grid(i)(j)\n            k -= 1\n            if (prev(i)(j) ==\
    \ 0) {\n                i -= 1\n            } else if (prev(i)(j) == 1) {\n  \
    \              j -= 1\n            }\n        }\n        result.toList", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val pq2 = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq2.enqueue((0, 0, 0))\n        val\
    \ result = Array.fill(k.toInt)(0L)\n        var index = 0\n        while (!pq2.isEmpty)\
    \ {\n            val (cost, i, j) = pq2.dequeue\n            if (dp(i)(j) == cost)\
    \ {\n                result(index) = grid(i)(j)\n                index += 1\n\
    \                if (index == k) return result.toList\n                if (i >\
    \ 0) pq2.enqueue((cost + grid(i - 1)(j), i - 1, j))\n                if (i < n\
    \ - 1) pq2.enqueue((cost + grid(i + 1)(j), i + 1, j))\n                if (j >\
    \ 0) pq2.enqueue((cost + grid(i)(j - 1), i, j - 1))\n                if (j < m\
    \ - 1) pq2.en", "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val lst = ListBuffer[List[Long]]()\n                \
    \    if (i > 0) lst += (grid(i)(j) :: dp(i - 1)(j))\n                    if (j\
    \ > 0) lst += (grid(i)(j) :: dp(i)(j - 1))\n                    dp(i)(j) = lst.minBy(x\
    \ => x)\n                }\n            }\n        }\n        dp(n - 1)(n - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        pq.enqueue((grid(i)(j), i, j))\n            }\n        }\n        while\
    \ (pq.nonEmpty) {\n            val (v, i, j) = pq.dequeue\n            if (dp(i)(j)\
    \ > v) {\n                dp(i)(j) = v\n                if (i > 0) pq.enqueue((v\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1) pq.enqueue((v +\
    \ grid(i + 1)(j), i + 1, j))\n                if (j > 0) pq.enqueue((v + grid(i)(j\
    \ - 1), i, j - 1))\n                if (j < m - 1) pq.enqueue((v + grid(i)(j +\
    \ 1), i, j + 1))\n            }\n        }\n        val result = ArrayBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        var c = 0L\n        while (c <\
    \ k) {\n            result += grid(i)(j)\n            c += 1\n            if (i\
    \ > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -= 1\n            } else\
    \ if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n                i += 1\n      \
    \      } else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                j -= 1\n\
    \            } else if (j < m - 1 && dp(i)(j + 1) < dp(i)(j)) {\n            \
    \    j += 1\n            } else {\n                return result.toList\n    \
    \        }\n        }\n        result.toList", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    var min = List[Long]()\n                    if (i > 0)\
    \ {\n                        val up = dp(i - 1)(j)\n                        if\
    \ (up.length < k && (min.length == 0 || up < min)) min = up\n                \
    \    }\n                    if (j > 0) {\n                        val left = dp(i)(j\
    \ - 1)\n                        if (left.length < k && (min.length == 0 || left\
    \ < min)) min = left\n                    }\n                    dp(i)(j) = min\
    \ :+ grid(i)(j)\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1)", "        val n = grid.length\n        val m = grid(0).length\n      \
    \  val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(grid(i)(j))\n                else {\n                    if (i > 0) {\n\
    \                        val lst = dp(i - 1)(j)\n                        if (lst.length\
    \ < k) dp(i)(j) = List(grid(i)(j)) ++ lst\n                        else if (lst.length\
    \ == k) {\n                            val lst2 = List(grid(i)(j)) ++ lst\n  \
    \                          if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n            \
    \            }\n                    }\n                    if (j > 0) {\n    \
    \                    val lst = dp(i)(j - 1)\n                        if (lst.length\
    \ < k) dp(i)(j) = List(grid(i)(j)) ++ lst\n                        else if (lst.length\
    \ == k) {\n                            val lst2 = List(grid(i)(j)) ++ lst\n  \
    \                          if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n            \
    \            }\n                    }\n                }\n            }\n    \
    \    }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n        val m\
    \ = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n       \
    \ val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n       \
    \ pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val (cost,\
    \ i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n                dp(i)(j)\
    \ = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j), i - 1,\
    \ j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), i + 1,\
    \ j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i, j - 1))\n\
    \                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i, j + 1))\n\
    \            }\n        }\n        val pq2 = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq2.enqueue((0, 0, 0))\n        val dp2 = Array.fill(n, m)(Long.MaxValue)\n\
    \        dp2(0)(0) = 0\n        val path = new ListBuffer[Long]()\n        while\
    \ (pq2.nonEmpty) {\n            val (cost, i, j) = pq2.dequeue\n            if\
    \ (dp2(i)(j) == cost) {\n                path += grid(i)(j)\n                if\
    \ (path.length == k) return path.toList\n                if (i > 0 && dp2(i -\
    \ 1)(j) > cost + dp(i - 1)(j)) {\n                    dp2(i - 1)(j) = cost + dp(i\
    \ - 1)(j)\n                    pq2.enqueue((dp2(i - 1)(j), i - 1, j))\n      \
    \          }\n                if (i < n - 1 && dp", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val prev = Array.fill(n, m)(-1)\n        val queue = new Queue[(Int,\
    \ Int)]\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (grid(i)(j) == 1) {\n                    dp(i)(j) = 0\n  \
    \                  queue.enqueue((i, j))\n                }\n            }\n \
    \       }\n        val dx = Array(-1, 0, 1, 0)\n        val dy = Array(0, 1, 0,\
    \ -1)\n        while (!queue.isEmpty) {\n            val (x, y) = queue.dequeue\n\
    \            for (i <- 0 until 4) {\n                val nx = x + dx(i)\n    \
    \            val ny = y + dy(i)\n                if (nx >= 0 && nx < n && ny >=\
    \ 0 && ny < m && dp(nx)(ny) > dp(x)(y) + 1) {\n                    dp(nx)(ny)\
    \ = dp(x)(y) + 1\n                    prev(nx)(ny) = i\n                    queue.enqueue((nx,\
    \ ny))\n                }\n            }\n        }\n        var x = 0\n     \
    \   var y = 0\n        val result = new ListBuffer[Long]\n        for (i <- 0\
    \ until k.toInt) {\n            result += grid(x)(y)\n            val nx = x +\
    \ dx(prev(x)(y))\n            val ny = y + dy(prev(x)(y))\n            x = nx\n\
    \            y = ny\n        }\n        result.toList", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val lst = ListBuffer[Long]()\n                    if\
    \ (i > 0) lst ++= dp(i - 1)(j)\n                    if (j > 0) lst ++= dp(i)(j\
    \ - 1)\n                    dp(i)(j) = (lst.toList :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1)", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val path = Array.fill(n, m)(List[Long]())\n     \
    \   for (i <- 0 until n) {\n            for (j <- 0 until m) {\n             \
    \   if (i == 0 && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n     \
    \               path(i)(j) = List(grid(i)(j))\n                }\n           \
    \     else {\n                    if (i > 0 && dp(i - 1)(j) + grid(i)(j) < dp(i)(j))\
    \ {\n                        dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n          \
    \              path(i)(j) = path(i - 1)(j) :+ grid(i)(j)\n                   \
    \ }\n                    if (j > 0 && dp(i)(j - 1) + grid(i)(j) < dp(i)(j)) {\n\
    \                        dp(i)(j) = dp(i)(j - 1) + grid(i)(j)\n              \
    \          path(i)(j) = path(i)(j - 1) :+ grid(i)(j)\n                    }\n\
    \                }\n            }\n        }\n        path(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val lst = ListBuffer[List[Long]]()\n\
    \                    if (i > 0) lst += dp(i - 1)(j)\n                    if (j\
    \ > 0) lst += dp(i)(j - 1)\n                    if (lst.nonEmpty) {\n        \
    \                val min = lst.minBy(x => (x :+ grid(i)(j)).mkString)\n      \
    \                  dp(i)(j) = min :+ grid(i)(j)\n                    }\n     \
    \           }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val prev = Array.fill(n, m)(0)\n        val q = new\
    \ Queue[(Int, Int)]\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (grid(i)(j) == 1) {\n                    dp(i)(j) =\
    \ 0\n                    q.enqueue((i, j))\n                }\n            }\n\
    \        }\n        val dx = Array(-1, 0, 1, 0)\n        val dy = Array(0, 1,\
    \ 0, -1)\n        while (!q.isEmpty) {\n            val (x, y) = q.dequeue\n \
    \           for (i <- 0 until 4) {\n                val nx = x + dx(i)\n     \
    \           val ny = y + dy(i)\n                if (nx >= 0 && nx < n && ny >=\
    \ 0 && ny < m && dp(nx)(ny) > dp(x)(y) + 1) {\n                    dp(nx)(ny)\
    \ = dp(x)(y) + 1\n                    prev(nx)(ny) = i\n                    q.enqueue((nx,\
    \ ny))\n                }\n            }\n        }\n        var x = 0\n     \
    \   var y = 0\n        var min = Long.MaxValue\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (dp(i)(j) < min) {\n \
    \                   min = dp(i)(j)\n                    x = i\n              \
    \      y = j\n                }\n            }\n        }\n        val ans = new\
    \ ListBuffer[Long]\n        for (i <- 0 until k.toInt) {\n            ans += grid(x)(y)\n\
    \            val nx = x + dx(prev(x)(y))\n            val ny = y + dy(prev(x)(y))\n\
    \            x = nx\n            y = ny\n        }\n        ans.toList", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x\
    \ => -x._1))\n        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n \
    \           val (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n\
    \                dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1) pq.enqueue((cost\
    \ + grid(i + 1)(j), i + 1, j))\n                if (j > 0) pq.enqueue((cost +\
    \ grid(i)(j - 1), i, j - 1))\n                if (j < m - 1) pq.enqueue((cost\
    \ + grid(i)(j + 1), i, j + 1))\n            }\n        }\n        val pq2 = new\
    \ PriorityQueue[(Long, Int, Int)]()(Ordering.by(x => -x._1))\n        pq2.enqueue((0,\
    \ 0, 0))\n        val visited = Array.fill(n, m)(false)\n        var result =\
    \ List[Long]()\n        while (!pq2.isEmpty) {\n            val (cost, i, j) =\
    \ pq2.dequeue\n            if (!visited(i)(j)) {\n                visited(i)(j)\
    \ = true\n                result = result :+ grid(i)(j)\n                if (result.length\
    \ == k) return result\n                if (i > 0 && dp(i - 1)(j) == cost + grid(i)(j))\
    \ pq2.enqueue((cost + grid(i)(j), i - 1, j))\n                if (i < n - 1 &&\
    \ dp(i + 1)(j) == cost + grid(i)(j)) pq2.enqueue((cost + grid(i)(j), i + 1, j))\n\
    \                if (", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length <= k && dp(i - 1)(j).length\
    \ + 1 <= dp(i)(j).length) {\n                    if (dp(i - 1)(j).length + 1 <\
    \ dp(i)(j).length) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                   \
    \ else if (dp(i - 1)(j).last < dp(i)(j).last) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                }\n                if (j > 0 && dp(i)(j - 1).length <= k && dp(i)(j\
    \ - 1).length + 1 <= dp(i)(j).length) {\n                    if (dp(i)(j - 1).length\
    \ + 1 < dp(i)(j).length) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n             \
    \       else if (dp(i)(j - 1).last < dp(i)(j).last) dp(i)(j) = dp(i)(j - 1) :+\
    \ grid(i)(j)\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1)", "        val n = grid.length\n        val m = grid(0).length\n      \
    \  val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(grid(i)(j))\n                else {\n                    if (i > 0) {\n\
    \                        val lst = dp(i - 1)(j)\n                        if (lst.length\
    \ < k) {\n                            val newLst = grid(i)(j) :: lst\n       \
    \                     if (dp(i)(j).length == 0 || newLst < dp(i)(j)) dp(i)(j)\
    \ = newLst\n                        }\n                    }\n               \
    \     if (j > 0) {\n                        val lst = dp(i)(j - 1)\n         \
    \               if (lst.length < k) {\n                            val newLst\
    \ = grid(i)(j) :: lst\n                            if (dp(i)(j).length == 0 ||\
    \ newLst < dp(i)(j)) dp(i)(j) = newLst\n                        }\n          \
    \          }\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1)", "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        dp(i)(j) = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length\
    \ <= k && dp(i - 1)(j).length + 1 < dp(i)(j).length) {\n                    dp(i)(j)\
    \ = grid(i)(j) :: dp(i - 1)(j)\n                }\n                if (j > 0 &&\
    \ dp(i)(j - 1).length <= k && dp(i)(j - 1).length + 1 < dp(i)(j).length) {\n \
    \                   dp(i)(j) = grid(i)(j) :: dp(i)(j - 1)\n                }\n\
    \            }\n        }\n        dp(n - 1)(n - 1)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val ans = Array.fill(n)(Array.fill(m)(List[Long]()))\n\
    \        for (i <- 0 until n; j <- 0 until m) {\n            if (i > 0 && dp(i\
    \ - 1)(j) < dp(i)(j)) ans(i)(j) = ans(i - 1)(j) :+ grid(i)(j)\n            else\
    \ if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) ans(i)(j) = ans(i + 1)(j) :+ grid(i)(j)\n\
    \            else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) ans(i)(j) = ans(i)(j -\
    \ 1) :+ grid(i)(j)\n            else if (j < m - 1 && dp(i)(j + 1) < dp(i)(j))\
    \ ans(i)(j) = ans(i)(j + 1) :+ grid(i)(j)\n            else ans(i)(j) = List(",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val lst = ListBuffer[List[Long]]()\n\
    \                    if (i > 0) lst += dp(i - 1)(j)\n                    if (j\
    \ > 0) lst += dp(i)(j - 1)\n                    val min = lst.minBy(x => (x :+\
    \ grid(i)(j)).mkString(\"\"))\n                    dp(i)(j) = min :+ grid(i)(j)\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val prev = Array.fill(n, m)(-1)\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                if (i == 0\
    \ && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n                } else\
    \ {\n                    if (i > 0) {\n                        if (dp(i - 1)(j)\
    \ < dp(i)(j)) {\n                            dp(i)(j) = dp(i - 1)(j)\n       \
    \                     prev(i)(j) = 0\n                        }\n            \
    \        }\n                    if (j > 0) {\n                        if (dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                            dp(i)(j) = dp(i)(j - 1)\n  \
    \                          prev(i)(j) = 1\n                        }\n       \
    \             }\n                    dp(i)(j) += grid(i)(j)\n                }\n\
    \            }\n        }\n        val path = ListBuffer[Long]()\n        var\
    \ i = n - 1\n        var j = m - 1\n        while (k > 0) {\n            path\
    \ += grid(i)(j)\n            k -= 1\n            prev(i)(j) match {\n        \
    \        case 0 => i -= 1\n                case 1 => j -= 1\n            }\n \
    \       }\n        path.toList", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n        val\
    \ pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n        pq.enqueue((0,\
    \ 0, 0))\n        while (!pq.isEmpty) {\n            val (cost, i, j) = pq.dequeue\n\
    \            if (dp(i)(j) > cost) {\n                dp(i)(j) = cost\n       \
    \         if (i > 0) pq.enqueue((cost + grid(i - 1)(j), i - 1, j))\n         \
    \       if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), i + 1, j))\n       \
    \         if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i, j - 1))\n         \
    \       if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i, j + 1))\n       \
    \     }\n        }\n        val path = new ListBuffer[Long]\n        var i = 0\n\
    \        var j = 0\n        while (path.length < k) {\n            path += grid(i)(j)\n\
    \            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -= 1\n\
    \            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n            \
    \    i += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n    \
    \            j -= 1\n            } else if (j < m - 1 && dp(i)(j + 1) < dp(i)(j))\
    \ {\n                j += 1\n            }\n        }\n        path.toList", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int,\
    \ Int)]()(Ordering.by(-_._1))\n        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty)\
    \ {\n            val (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost)\
    \ {\n                dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1) pq.enqueue((cost\
    \ + grid(i + 1)(j), i + 1, j))\n                if (j > 0) pq.enqueue((cost +\
    \ grid(i)(j - 1), i, j - 1))\n                if (j < m - 1) pq.enqueue((cost\
    \ + grid(i)(j + 1), i, j + 1))\n            }\n        }\n        val result =\
    \ new ListBuffer[Long]()\n        var i = 0\n        var j = 0\n        for (k\
    \ <- 1 to k.toInt) {\n            result += grid(i)(j)\n            if (i > 0\
    \ && dp(i - 1)(j) < dp(i)(j)) {\n                i -= 1\n            } else if\
    \ (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n                i += 1\n         \
    \   } else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                j -= 1\n \
    \           } else if (j < m - 1 && dp(i)(j + 1) < dp(i)(j)) {\n             \
    \   j += 1\n            }\n        }\n        result.toList", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, x, y) = pq.dequeue\n            if (dp(x)(y) > cost) {\n            \
    \    dp(x)(y) = cost\n                if (x > 0) pq.enqueue((cost + grid(x - 1)(y),\
    \ x - 1, y))\n                if (x < n - 1) pq.enqueue((cost + grid(x + 1)(y),\
    \ x + 1, y))\n                if (y > 0) pq.enqueue((cost + grid(x)(y - 1), x,\
    \ y - 1))\n                if (y < m - 1) pq.enqueue((cost + grid(x)(y + 1), x,\
    \ y + 1))\n            }\n        }\n        val result = ArrayBuffer[Long]()\n\
    \        var x = 0\n        var y = 0\n        var cost = 0L\n        for (i <-\
    \ 0 until k.toInt) {\n            result += grid(x)(y)\n            if (x > 0\
    \ && dp(x - 1)(y) == cost + grid(x - 1)(y)) {\n                x -= 1\n      \
    \          cost += grid(x)(y)\n            } else if (x < n - 1 && dp(x + 1)(y)\
    \ == cost + grid(x + 1)(y)) {\n                x += 1\n                cost +=\
    \ grid(x)(y)\n            } else if (y > 0 && dp(x)(y - 1) == cost + grid(x)(y\
    \ - 1)) {\n                y -= 1\n                cost += grid(x)(y)\n      \
    \      } else if (y < m - 1 && dp(x)(y + 1) == cost + grid(x)(y + 1)) {\n    \
    \            y += 1\n                cost += grid(x)(y)\n            }\n     \
    \   }\n        result.to", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(_._1))\n        pq.enqueue((0, 0, 0))\n        while\
    \ (!pq.isEmpty) {\n            val (cost, i, j) = pq.dequeue\n            if (i\
    \ == n - 1 && j == m - 1) {\n                val path = new ListBuffer[Long]\n\
    \                var x = i\n                var y = j\n                while (x\
    \ != 0 || y != 0) {\n                    path.append(grid(x)(y))\n           \
    \         val (px, py) = prev(x, y)\n                    x = px\n            \
    \        y = py\n                }\n                path.append(grid(0)(0))\n\
    \                path.reverse\n                return path.toList\n          \
    \  }\n            if (dp(i)(j) > cost) {\n                dp(i)(j) = cost\n  \
    \              for (d <- 0 until 4) {\n                    val (ni, nj) = next(i,\
    \ j, d)\n                    if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n \
    \                       val ncost = cost + grid(ni)(nj)\n                    \
    \    pq.enqueue((ncost, ni, nj))\n                    }\n                }\n \
    \           }\n        }\n        return List()", "        val n = grid.length\n\
    \        val dp = Array.fill(n, n)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ (Int, Int))]()(Ordering.by(-_._1))\n        pq.enqueue((0, (0, 0)))\n      \
    \  while (pq.nonEmpty) {\n            val (cost, (i, j)) = pq.dequeue\n      \
    \      if (dp(i)(j) > cost) {\n                dp(i)(j) = cost\n             \
    \   if (i > 0) pq.enqueue((cost + grid(i - 1)(j), (i - 1, j)))\n             \
    \   if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), (i + 1, j)))\n         \
    \       if (j > 0) pq.enqueue((cost + grid(i)(j - 1), (i, j - 1)))\n         \
    \       if (j < n - 1) pq.enqueue((cost + grid(i)(j + 1), (i, j + 1)))\n     \
    \       }\n        }\n        val ans = ArrayBuffer[Long]()\n        var i = 0;\
    \ var j = 0\n        while (ans.length < k) {\n            ans += grid(i)(j)\n\
    \            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -= 1\n\
    \            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n            \
    \    i += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n    \
    \            j -= 1\n            } else if (j < n - 1 && dp(i)(j + 1) < dp(i)(j))\
    \ {\n                j += 1\n            }\n        }\n        ans.toList", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.fill(n, m)(Long.MaxValue)\n        val path = Array.fill(n, m)(List[Long]())\n\
    \        dp(0)(0) = 0\n        path(0)(0) = List(grid(0)(0))\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                if (i > 0)\
    \ {\n                    if (dp(i - 1)(j) + 1 < dp(i)(j)) {\n                \
    \        dp(i)(j) = dp(i - 1)(j) + 1\n                        path(i)(j) = path(i\
    \ - 1)(j) :+ grid(i)(j)\n                    } else if (dp(i - 1)(j) + 1 == dp(i)(j))\
    \ {\n                        val newPath = path(i - 1)(j) :+ grid(i)(j)\n    \
    \                    if (newPath < path(i)(j)) {\n                           \
    \ path(i)(j) = newPath\n                        }\n                    }\n   \
    \             }\n                if (j > 0) {\n                    if (dp(i)(j\
    \ - 1) + 1 < dp(i)(j)) {\n                        dp(i)(j) = dp(i)(j - 1) + 1\n\
    \                        path(i)(j) = path(i)(j - 1) :+ grid(i)(j)\n         \
    \           } else if (dp(i)(j - 1) + 1 == dp(i)(j)) {\n                     \
    \   val newPath = path(i)(j - 1) :+ grid(i)(j)\n                        if (newPath\
    \ < path(i)(j)) {\n                            path(i)(j) = newPath\n        \
    \                }\n                    }\n                }\n            }\n\
    \        }\n        val result = path(n - 1)(m - 1)\n        if (result.length\
    \ > k) result.slice(0, k.toInt) else result", "        val n = grid.length\n \
    \       val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val up = if (i > 0) dp(i - 1)(j) else List[Long]()\n\
    \                    val left = if (j > 0) dp(i)(j - 1) else List[Long]()\n  \
    \                  val up_left = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val up_left_up = if (i > 1 && j > 0) dp(i - 2)(j - 1) else\
    \ List[Long]()\n                    val up_left_left = if (i > 0 && j > 1) dp(i\
    \ - 1)(j - 2) else List[Long]()\n                    val up_left_up_left = if\
    \ (i > 1 && j > 1) dp(i - 2)(j - 2) else List[Long]()\n                    val\
    \ up_left_up_left_up = if (i > 2 && j > 1) dp(i - 3)(j - 2) else List[Long]()\n\
    \                    val up_left_up_left_left = if (i > 1 && j > 2) dp(i - 2)(j\
    \ - 3) else List[Long]()\n                    val up_left_up_left_up_left = if\
    \ (i > 2 && j > 2) dp(i - 3)(j - 3) else List[Long]()\n                    val\
    \ up_left_up_left_up_left_up = if (i > 3 && j > 2) dp(i - 4)(j - 2) else List[Long]()\n\
    \                    val up_left_up_left_up_left_left = if (i > 2 && j > 3) dp(i\
    \ - 3)(j - 4) else List[Long]()\n                    val up_left_up_left_up_left_",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val prev = Array.fill(n, m)(-1)\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                if (i == 0\
    \ && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n                } else\
    \ {\n                    if (i > 0) {\n                        if (dp(i - 1)(j)\
    \ < dp(i)(j)) {\n                            dp(i)(j) = dp(i - 1)(j)\n       \
    \                     prev(i)(j) = 0\n                        }\n            \
    \        }\n                    if (j > 0) {\n                        if (dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                            dp(i)(j) = dp(i)(j - 1)\n  \
    \                          prev(i)(j) = 1\n                        }\n       \
    \             }\n                    dp(i)(j) += grid(i)(j)\n                }\n\
    \            }\n        }\n        val path = ListBuffer[Long]()\n        var\
    \ i = n - 1\n        var j = m - 1\n        while (k > 0) {\n            path\
    \ += grid(i)(j)\n            k -= 1\n            prev(i)(j) match {\n        \
    \        case 0 => i -= 1\n                case 1 => j -= 1\n            }\n \
    \       }\n        path.toList", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n        val\
    \ pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n        pq.enqueue((0,\
    \ 0, 0))\n        while (pq.nonEmpty) {\n            val (cost, i, j) = pq.dequeue\n\
    \            if (dp(i)(j) > cost) {\n                dp(i)(j) = cost\n       \
    \         if (i > 0) pq.enqueue((cost + grid(i - 1)(j), i - 1, j))\n         \
    \       if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), i + 1, j))\n       \
    \         if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i, j - 1))\n         \
    \       if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i, j + 1))\n       \
    \     }\n        }\n        val pq2 = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq2.enqueue((0, 0, 0))\n        val visited = Array.fill(n, m)(false)\n\
    \        while (pq2.nonEmpty) {\n            val (cost, i, j) = pq2.dequeue\n\
    \            if (!visited(i)(j)) {\n                visited(i)(j) = true\n   \
    \             if (i > 0 && dp(i - 1)(j) == cost + grid(i - 1)(j)) pq2.enqueue((cost\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1 && dp(i + 1)(j)\
    \ == cost + grid(i + 1)(j)) pq2.enqueue((cost + grid(i + 1)(j), i + 1, j))\n \
    \               if (j > 0 && dp(i)(j - 1) == cost + grid(i)(j - 1)) pq2.enqueue((cost\
    \ +", "        val n = grid.length\n        val m = grid(0).length\n        val\
    \ dp = Array.fill(n, m)(Long.MaxValue)\n        val path = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n\
    \                    path(i)(j) = List(grid(i)(j))\n                }\n      \
    \          else {\n                    if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n\
    \                        dp(i)(j) = dp(i - 1)(j)\n                        path(i)(j)\
    \ = path(i - 1)(j)\n                    }\n                    if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                        dp(i)(j) = dp(i)(j - 1)\n      \
    \                  path(i)(j) = path(i)(j - 1)\n                    }\n      \
    \              dp(i)(j) += grid(i)(j)\n                    path(i)(j) = (path(i)(j)\
    \ :+ grid(i)(j)).sorted\n                }\n            }\n        }\n       \
    \ var i = n - 1\n        var j = m - 1\n        var cur = path(i)(j)\n       \
    \ while (k > 0) {\n            if (i > 0 && path(i - 1)(j) < cur) {\n        \
    \        i -= 1\n            }\n            else if (j > 0 && path(i)(j - 1) <\
    \ cur) {\n                j -= 1\n            }\n            else {\n        \
    \        throw new Exception(\"No solution\")\n            }\n            cur\
    \ = path(i)(j)\n            k -= 1\n        }\n        cur", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0L)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                dp(i)(j) = grid(i)(j)\n                if (i > 0) dp(i)(j) =\
    \ min(dp(i)(j), dp(i - 1)(j))\n                if (j > 0) dp(i)(j) = min(dp(i)(j),\
    \ dp(i)(j - 1))\n            }\n        }\n        var i = 0\n        var j =\
    \ 0\n        var path = List[Long]()\n        while (k > 0) {\n            path\
    \ = grid(i)(j) :: path\n            if (i == n - 1) j += 1\n            else if\
    \ (j == m - 1) i += 1\n            else if (dp(i + 1)(j) < dp(i)(j + 1)) i +=\
    \ 1\n            else j += 1\n            k -= 1\n        }\n        path", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int,\
    \ Int)]()(Ordering.by(_._1))\n        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty)\
    \ {\n            val (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost)\
    \ {\n                dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1) pq.enqueue((cost\
    \ + grid(i + 1)(j), i + 1, j))\n                if (j > 0) pq.enqueue((cost +\
    \ grid(i)(j - 1), i, j - 1))\n                if (j < m - 1) pq.enqueue((cost\
    \ + grid(i)(j + 1), i, j + 1))\n            }\n        }\n        val pq2 = new\
    \ PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n        pq2.enqueue((0,\
    \ 0, 0))\n        val dp2 = Array.fill(n, m)(Long.MaxValue)\n        dp2(0)(0)\
    \ = 0\n        val result = ListBuffer[Long]()\n        while (pq2.nonEmpty) {\n\
    \            val (cost, i, j) = pq2.dequeue\n            if (dp2(i)(j) == cost)\
    \ {\n                result += grid(i)(j)\n                if (result.length ==\
    \ k) return result.toList\n                if (i > 0 && dp2(i - 1)(j) > cost +\
    \ dp(i - 1)(j)) {\n                    dp2(i - 1)(j) = cost + dp(i - 1)(j)\n \
    \                   pq2.enqueue((dp2(i - 1)(j), i - 1, j))\n                }\n\
    \                if (i < n - 1 && dp2(i", "        val n = grid.length\n     \
    \   val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    if (i > 0) {\n                        val lst = dp(i\
    \ - 1)(j)\n                        if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n\
    \                        else if (lst.length == k) {\n                       \
    \     if (lst.last > grid(i)(j)) dp(i)(j) = lst.init :+ grid(i)(j)\n         \
    \               }\n                    }\n                    if (j > 0) {\n \
    \                       val lst = dp(i)(j - 1)\n                        if (lst.length\
    \ < k) {\n                            if (dp(i)(j).length < k) dp(i)(j) = lst\
    \ :+ grid(i)(j)\n                            else if (dp(i)(j).length == k) {\n\
    \                                if (dp(i)(j).last > grid(i)(j)) dp(i)(j) = lst\
    \ :+ grid(i)(j)\n                            }\n                        }\n  \
    \                      else if (lst.length == k) {\n                         \
    \   if (lst.last > grid(i)(j)) {\n                                if (dp(i)(j).length\
    \ < k) dp(i)(j) = lst.init :+ grid(i)(j)\n                                else\
    \ if (dp(i)(j).length == k) {\n                                    if (dp(i)(j).last\
    \ > grid(i)(j)) dp(i)(j) = lst.init :+ grid(i)(j)\n                          \
    \      }\n                            }\n                        }\n         \
    \           }\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1)", "        val n = grid.length\n        val m = grid(0).length\n      \
    \  val dp = Array.fill(n, m)(Long.MaxValue)\n        val path = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) {\n                    dp(i)(j)\
    \ = grid(i)(j)\n                    path(i)(j) = List(grid(i)(j))\n          \
    \      }\n                else {\n                    if (i > 0 && dp(i - 1)(j)\
    \ < dp(i)(j)) {\n                        dp(i)(j) = dp(i - 1)(j)\n           \
    \             path(i)(j) = path(i - 1)(j)\n                    }\n           \
    \         if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                        dp(i)(j)\
    \ = dp(i)(j - 1)\n                        path(i)(j) = path(i)(j - 1)\n      \
    \              }\n                    dp(i)(j) += grid(i)(j)\n               \
    \     path(i)(j) = path(i)(j) :+ grid(i)(j)\n                }\n            }\n\
    \        }\n        var i = n - 1\n        var j = m - 1\n        while (k > 1)\
    \ {\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -=\
    \ 1\n            }\n            else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n\
    \                j -= 1\n            }\n            else {\n                i\
    \ -= 1\n                j -= 1\n            }\n            k -= 1\n        }\n\
    \        path(i)(j)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq.enqueue((0, 0, 0))\n        while\
    \ (pq.nonEmpty) {\n            val (d, i, j) = pq.dequeue\n            if (dp(i)(j)\
    \ > d) {\n                dp(i)(j) = d\n                if (i > 0) pq.enqueue((d\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1) pq.enqueue((d +\
    \ grid(i + 1)(j), i + 1, j))\n                if (j > 0) pq.enqueue((d + grid(i)(j\
    \ - 1), i, j - 1))\n                if (j < m - 1) pq.enqueue((d + grid(i)(j +\
    \ 1), i, j + 1))\n            }\n        }\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = 0\n        while (result.length < k) {\n \
    \           result += grid(i)(j)\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j))\
    \ {\n                i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j)\
    \ < dp(i)(j)) {\n                i += 1\n            } else if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                j -= 1\n            } else if (j < m - 1\
    \ && dp(i)(j + 1) < dp(i)(j)) {\n                j += 1\n            }\n     \
    \   }\n        result.toList", "        // dp(i)(j)(k) = the minimum path of length\
    \ k starting from (i, j)\n        val dp = Array.fill(grid.length, grid.length,\
    \ k.toInt + 1)(Long.MaxValue)\n        for (i <- 0 until grid.length; j <- 0 until\
    \ grid.length) {\n            dp(i)(j)(1) = grid(i)(j)\n        }\n        for\
    \ (l <- 2 to k.toInt) {\n            for (i <- 0 until grid.length; j <- 0 until\
    \ grid.length) {\n                if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i\
    \ - 1)(j)(l - 1))\n                if (i < grid.length - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i + 1)(j)(l - 1))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j - 1)(l - 1))\n                if (j < grid.length - 1) dp(i)(j)(l) =\
    \ min(dp(i)(j)(l), dp(i)(j + 1)(l - 1))\n            }\n        }\n        var\
    \ min = Long.MaxValue\n        var minI = -1\n        var minJ = -1\n        for\
    \ (i <- 0 until grid.length; j <- 0 until grid.length) {\n            if (dp(i)(j)(k.toInt)\
    \ < min) {\n                min = dp(i)(j)(k.toInt)\n                minI = i\n\
    \                minJ = j\n            }\n        }\n        var result = List[Long]()\n\
    \        var i = minI\n        var j = minJ\n        for (l <- k.toInt to 1 by\
    \ -1) {\n            result = grid(i)(j) :: result\n            if (i > 0 && dp(i)(j)(l)\
    \ == dp(i - 1)(j)(l - 1)) {\n                i -= 1\n            } else if (i\
    \ < grid.length -", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(0)\n        for (i <- 0 until n) {\n      \
    \      for (j <- 0 until m) {\n                dp(i)(j) = grid(i)(j)\n       \
    \     }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i > 0) dp(i)(j) = min(dp(i)(j), dp(i - 1)(j))\n  \
    \              if (j > 0) dp(i)(j) = min(dp(i)(j), dp(i)(j - 1))\n           \
    \ }\n        }\n        val result = new ListBuffer[Long]\n        var i = 0\n\
    \        var j = 0\n        for (x <- 0 until k.toInt) {\n            result +=\
    \ dp(i)(j)\n            if (i == n - 1 && j == m - 1) {\n                i = 0\n\
    \                j = 0\n            } else if (i == n - 1) {\n               \
    \ j += 1\n            } else if (j == m - 1) {\n                i += 1\n     \
    \       } else if (dp(i + 1)(j) < dp(i)(j + 1)) {\n                i += 1\n  \
    \          } else {\n                j += 1\n            }\n        }\n      \
    \  result.toList", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length + 1 <= k) {\n              \
    \      val tmp = dp(i - 1)(j) :+ grid(i)(j)\n                    if (tmp.length\
    \ == k) dp(i)(j) = tmp\n                    else if (tmp.length < k && tmp < dp(i)(j))\
    \ dp(i)(j) = tmp\n                }\n                if (j > 0 && dp(i)(j - 1).length\
    \ + 1 <= k) {\n                    val tmp = dp(i)(j - 1) :+ grid(i)(j)\n    \
    \                if (tmp.length == k) dp(i)(j) = tmp\n                    else\
    \ if (tmp.length < k && tmp < dp(i)(j)) dp(i)(j) = tmp\n                }\n  \
    \          }\n        }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val lst = ListBuffer[List[Long]]()\n                \
    \    if (i > 0) lst += dp(i - 1)(j)\n                    if (j > 0) lst += dp(i)(j\
    \ - 1)\n                    if (lst.isEmpty) dp(i)(j) = List(grid(i)(j))\n   \
    \                 else {\n                        val min = lst.minBy(x => x :+\
    \ grid(i)(j))\n                        dp(i)(j) = min :+ grid(i)(j)\n        \
    \            }\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1).take(k.toInt)", "        // Let's use dynamic programming.\n        //\
    \ Let dp(i, j, l) be the minimum path of length l starting from cell (i, j).\n\
    \        // dp(i, j, l) = min(dp(i + 1, j, l - 1), dp(i - 1, j, l - 1), dp(i,\
    \ j + 1, l - 1), dp(i, j - 1, l - 1))\n        // dp(i, j, l) = grid(i)(j) + dp(i\
    \ + 1, j, l - 1), dp(i - 1, j, l - 1), dp(i, j + 1, l - 1), dp(i, j - 1, l - 1)\n\
    \        // dp(i, j, l) = grid(i)(j) + min(dp(i + 1, j, l - 1), dp(i - 1, j, l\
    \ - 1), dp(i, j + 1, l - 1), dp(i, j - 1, l - 1))\n        // dp(i, j, l) = grid(i)(j)\
    \ + min(dp(i + 1, j, l - 1), dp(i - 1, j, l - 1), dp(i, j + 1, l - 1), dp(i, j\
    \ - 1, l - 1))\n        // dp(i, j, l) = grid(i)(j) + min(dp(i + 1, j, l - 1),\
    \ dp(i - 1, j, l - 1), dp(i, j + 1, l - 1), dp(i, j - 1, l - 1))\n        // dp(i,\
    \ j, l) = grid(i)(j) + min(dp(i + 1, j, l - 1), dp(i - 1, j, l - 1), dp(i, j +\
    \ 1, l - 1), dp(i, j - 1, l - 1))\n        // dp(i, j, l) = grid(i)(j) + min(dp(i\
    \ + 1, j, l - 1), dp(i - 1, j, l -", "        val n = grid.length\n        val\
    \ dp = Array.fill(n, n)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(x => x._1))\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until n) {\n                dp(i)(j) = grid(i)(j)\n      \
    \          pq.enqueue((dp(i)(j), i, j))\n            }\n        }\n        val\
    \ dirs = List((-1, 0), (1, 0), (0, -1), (0, 1))\n        while (pq.nonEmpty) {\n\
    \            val (v, i, j) = pq.dequeue\n            for (dir <- dirs) {\n   \
    \             val (di, dj) = dir\n                val ni = i + di\n          \
    \      val nj = j + dj\n                if (ni >= 0 && ni < n && nj >= 0 && nj\
    \ < n) {\n                    val nv = v + grid(ni)(nj)\n                    if\
    \ (nv < dp(ni)(nj)) {\n                        dp(ni)(nj) = nv\n             \
    \           pq.enqueue((nv, ni, nj))\n                    }\n                }\n\
    \            }\n        }\n        val ans = ArrayBuffer[Long]()\n        var\
    \ i = 0\n        var j = 0\n        while (ans.length < k) {\n            ans\
    \ += grid(i)(j)\n            var min = Long.MaxValue\n            var minDir =\
    \ (0, 0)\n            for (dir <- dirs) {\n                val (di, dj) = dir\n\
    \                val ni = i + di\n                val nj = j + dj\n          \
    \      if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                    val\
    \ nv = dp(ni)(nj)\n                    if (nv < min) {\n                     \
    \   min = nv\n                        minDir = dir\n                    }\n  \
    \              }\n            }\n            val (di, dj) = minDir\n         \
    \   i += di\n            j += dj\n        }\n        ans.toList", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val up = if (i > 0) dp(i - 1)(j) else\
    \ List[Long]()\n                    val left = if (j > 0) dp(i)(j - 1) else List[Long]()\n\
    \                    if (up.length == 0 && left.length == 0) dp(i)(j) = List(grid(i)(j))\n\
    \                    else if (up.length == 0) dp(i)(j) = grid(i)(j) :: left\n\
    \                    else if (left.length == 0) dp(i)(j) = grid(i)(j) :: up\n\
    \                    else {\n                        val up_min = up.min\n   \
    \                     val left_min = left.min\n                        if (up_min\
    \ < left_min) dp(i)(j) = grid(i)(j) :: up\n                        else if (up_min\
    \ > left_min) dp(i)(j) = grid(i)(j) :: left\n                        else dp(i)(j)\
    \ = grid(i)(j) :: (if (up < left) up else left)\n                    }\n     \
    \           }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val result = new ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        var cost = dp(0)(0)\n        for\
    \ (k <- 1 to k.toInt) {\n            result += grid(i)(j)\n            if (i >\
    \ 0 && dp(i - 1)(j) + grid(i)(j) == cost) {\n                i -= 1\n        \
    \        cost -= grid(i)(j)\n            } else if (i < n - 1 && dp(i + 1)(j)\
    \ + grid(i)(j) == cost) {\n                i += 1\n                cost -= grid(i)(j)\n\
    \            } else if (j > 0 && dp(i)(j - 1) + grid(i)(j) == cost) {\n      \
    \          j -= 1\n                cost -= grid(i)(j)\n            } else if (j\
    \ < m - 1 && dp(i)(j + 1) + grid(i)(j) == cost) {\n                j += 1\n  \
    \              cost -= grid(i)(j)\n            }\n        }\n        result",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val pq2 = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq2.enqueue((0, 0, 0))\n        val\
    \ visited = Array.fill(n, m)(false)\n        while (!pq2.isEmpty) {\n        \
    \    val (cost, i, j) = pq2.dequeue\n            if (!visited(i)(j)) {\n     \
    \           visited(i)(j) = true\n                if (i > 0 && dp(i - 1)(j) ==\
    \ cost + grid(i - 1)(j)) pq2.enqueue((cost + grid(i - 1)(j), i - 1, j))\n    \
    \            if (i < n - 1 && dp(i + 1)(j) == cost + grid(i + 1)(j)) pq2.enqueue((cost\
    \ + grid(i + 1)(j), i + 1, j))\n                if (j > 0 && dp(i)(j - 1) == cost\
    \ + grid(i)(j - 1)) pq2.enqueue((cost +", "        val n = grid.length\n     \
    \   val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, x, y) = pq.dequeue\n            if (dp(x)(y) > cost) {\n            \
    \    dp(x)(y) = cost\n                if (x > 0) pq.enqueue((cost + grid(x - 1)(y),\
    \ x - 1, y))\n                if (x < n - 1) pq.enqueue((cost + grid(x + 1)(y),\
    \ x + 1, y))\n                if (y > 0) pq.enqueue((cost + grid(x)(y - 1), x,\
    \ y - 1))\n                if (y < m - 1) pq.enqueue((cost + grid(x)(y + 1), x,\
    \ y + 1))\n            }\n        }\n        val result = ArrayBuffer[Long]()\n\
    \        var x = 0\n        var y = 0\n        var cost = dp(0)(0)\n        for\
    \ (i <- 0 until k.toInt) {\n            result += grid(x)(y)\n            if (x\
    \ > 0 && dp(x - 1)(y) < cost) {\n                cost = dp(x - 1)(y)\n       \
    \         x -= 1\n            } else if (x < n - 1 && dp(x + 1)(y) < cost) {\n\
    \                cost = dp(x + 1)(y)\n                x += 1\n            } else\
    \ if (y > 0 && dp(x)(y - 1) < cost) {\n                cost = dp(x)(y - 1)\n \
    \               y -= 1\n            } else if (y < m - 1 && dp(x)(y + 1) < cost)\
    \ {\n                cost = dp(x)(y + 1)\n                y += 1\n           \
    \ }\n        }\n        result.toList", "        val n = grid.length\n       \
    \ val dist = Array.fill(n, n)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq.enqueue((0, 0, 0))\n        while\
    \ (pq.nonEmpty) {\n            val (d, i, j) = pq.dequeue\n            if (dist(i)(j)\
    \ > d) {\n                dist(i)(j) = d\n                if (i > 0) pq.enqueue((d\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1) pq.enqueue((d +\
    \ grid(i + 1)(j), i + 1, j))\n                if (j > 0) pq.enqueue((d + grid(i)(j\
    \ - 1), i, j - 1))\n                if (j < n - 1) pq.enqueue((d + grid(i)(j +\
    \ 1), i, j + 1))\n            }\n        }\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = 0\n        var d = 0L\n        while (result.length\
    \ < k) {\n            result += grid(i)(j)\n            if (i > 0 && dist(i -\
    \ 1)(j) < dist(i)(j)) {\n                i -= 1\n                d = dist(i)(j)\n\
    \            } else if (i < n - 1 && dist(i + 1)(j) < dist(i)(j)) {\n        \
    \        i += 1\n                d = dist(i)(j)\n            } else if (j > 0\
    \ && dist(i)(j - 1) < dist(i)(j)) {\n                j -= 1\n                d\
    \ = dist(i)(j)\n            } else if (j < n - 1 && dist(i)(j + 1) < dist(i)(j))\
    \ {\n                j += 1\n                d = dist(i)(j)\n            }\n \
    \       }\n        result.toList", "        val n = grid.length\n        val m\
    \ = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i\
    \ == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else {\n      \
    \              val lst = ListBuffer[Long]()\n                    if (i > 0) lst\
    \ ++= dp(i - 1)(j)\n                    if (j > 0) lst ++= dp(i)(j - 1)\n    \
    \                dp(i)(j) = (lst.toList :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1)", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (d, i, j) = pq.dequeue\n            if (dp(i)(j) > d) {\n                dp(i)(j)\
    \ = d\n                if (i > 0) pq.enqueue((d + grid(i - 1)(j), i - 1, j))\n\
    \                if (i < n - 1) pq.enqueue((d + grid(i + 1)(j), i + 1, j))\n \
    \               if (j > 0) pq.enqueue((d + grid(i)(j - 1), i, j - 1))\n      \
    \          if (j < m - 1) pq.enqueue((d + grid(i)(j + 1), i, j + 1))\n       \
    \     }\n        }\n        val result = new ListBuffer[Long]()\n        var i\
    \ = 0\n        var j = 0\n        var d = 0L\n        while (d < k) {\n      \
    \      result += grid(i)(j)\n            d += 1\n            if (i > 0 && dp(i\
    \ - 1)(j) < dp(i)(j)) {\n                i -= 1\n            } else if (i < n\
    \ - 1 && dp(i + 1)(j) < dp(i)(j)) {\n                i += 1\n            } else\
    \ if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                j -= 1\n          \
    \  } else if (j < m - 1 && dp(i)(j + 1) < dp(i)(j)) {\n                j += 1\n\
    \            }\n        }\n        result.toList", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = grid(i)(j)\n                pq.enqueue((dp(i)(j), i, j))\n\
    \            }\n        }\n        val dirs = List((-1, 0), (1, 0), (0, -1), (0,\
    \ 1))\n        for (i <- 0 until k - 1) {\n            val (v, x, y) = pq.dequeue\n\
    \            for ((dx, dy) <- dirs) {\n                val nx = x + dx\n     \
    \           val ny = y + dy\n                if (nx >= 0 && nx < n && ny >= 0\
    \ && ny < m) {\n                    val nv = v + grid(nx)(ny)\n              \
    \      if (nv < dp(nx)(ny)) {\n                        dp(nx)(ny) = nv\n     \
    \                   pq.enqueue((nv, nx, ny))\n                    }\n        \
    \        }\n            }\n        }\n        val (v, x, y) = pq.dequeue\n   \
    \     val result = ListBuffer[Long]()\n        result += grid(x)(y)\n        for\
    \ (i <- 0 until k - 1) {\n            var min = Long.MaxValue\n            var\
    \ minx = -1\n            var miny = -1\n            for ((dx, dy) <- dirs) {\n\
    \                val nx = x + dx\n                val ny = y + dy\n          \
    \      if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                    val\
    \ nv = v + grid(nx)(ny)\n                    if (nv < min) {\n               \
    \         min = nv\n                        minx = nx\n                      \
    \  miny = ny\n                    }\n                }\n            }\n      \
    \      v = min\n            x = minx\n            y = min", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) <= cost) {\n           \
    \     if (i == n - 1 && j == m - 1 && cost <= k) return getPath(dp, i, j, k)\n\
    \                if (i + 1 < n && dp(i + 1)(j) > cost + grid(i + 1)(j)) {\n  \
    \                  dp(i + 1)(j) = cost + grid(i + 1)(j)\n                    pq.enqueue((dp(i\
    \ + 1)(j), i + 1, j))\n                }\n                if (j + 1 < m && dp(i)(j\
    \ + 1) > cost + grid(i)(j + 1)) {\n                    dp(i)(j + 1) = cost + grid(i)(j\
    \ + 1)\n                    pq.enqueue((dp(i)(j + 1), i, j + 1))\n           \
    \     }\n            }\n        }\n        return List()", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val prev = Array.fill(n, m)((0, 0))\n        dp(0)(0) = 0\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i\
    \ > 0 && dp(i - 1)(j) + 1 < dp(i)(j)) {\n                    dp(i)(j) = dp(i -\
    \ 1)(j) + 1\n                    prev(i)(j) = (i - 1, j)\n                }\n\
    \                if (j > 0 && dp(i)(j - 1) + 1 < dp(i)(j)) {\n               \
    \     dp(i)(j) = dp(i)(j - 1) + 1\n                    prev(i)(j) = (i, j - 1)\n\
    \                }\n            }\n        }\n        val path = ListBuffer[Long]()\n\
    \        var cur = (n - 1, m - 1)\n        while (k > 0) {\n            path +=\
    \ grid(cur._1)(cur._2)\n            cur = prev(cur._1)(cur._2)\n            k\
    \ -= 1\n        }\n        path.toList", "        val n = grid.length\n      \
    \  val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val pq2 = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq2.enqueue((0, 0, 0))\n        val\
    \ dp2 = Array.fill(n, m)(Long.MaxValue)\n        dp2(0)(0) = 0\n        val path\
    \ = new ListBuffer[Long]\n        while (!pq2.isEmpty) {\n            val (cost,\
    \ i, j) = pq2.dequeue\n            if (dp2(i)(j) == cost) {\n                path\
    \ += grid(i)(j)\n                if (path.length == k) return path.toList\n  \
    \              if (i > 0 && dp2(i - 1)(j) > cost + grid(i - 1)(j)) {\n       \
    \             dp2(i - 1)(j) = cost + grid(i - 1)(j)\n                    pq2.enqueue((cost\
    \ + grid(i - 1)(j), i - 1, j))\n                }\n                if (i < n -\
    \ 1 && dp2(", "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val lst = ListBuffer[Long]()\n                    if\
    \ (i > 0) lst ++= dp(i - 1)(j)\n                    if (j > 0) lst ++= dp(i)(j\
    \ - 1)\n                    dp(i)(j) = (lst :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                }\n            }\n        }\n        dp(n - 1)(n - 1)"]
stop_tokens:
- "\n    }\n"
