name: HumanEval_20_find_closest_elements
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n    // other and return them in order (smaller\
  \ number, larger number).\n    // >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2])\n    // (2.0, 2.2)\n    // >>> find_closest_elements([1.0, 2.0, 3.0,\
  \ 4.0, 5.0, 2.0])\n    // (2.0, 2.0)\n    def findClosestElements(numbers : List[Float])\
  \ : Tuple2[Float, Float] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(findClosestElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((3.9f,\
  \ 4.0f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals(((5.0f, 5.9f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((2.0f,\
  \ 2.2f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))).equals(((2.0f, 2.0f))));\n\
  \    assert(findClosestElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat,\
  \ 4.1f.toFloat, 5.1f.toFloat))).equals(((2.2f, 3.1f))));\n    }\n\n}\n"
completions: ["        val sortedNumbers = numbers.sorted\n        var closest = (sortedNumbers(0),\
    \ sortedNumbers(1))\n        var closestDistance = abs(sortedNumbers(0) - sortedNumbers(1))\n\
    \        for (i <- 0 until sortedNumbers.length - 1) {\n            val distance\
    \ = abs(sortedNumbers(i) - sortedNumbers(i + 1))\n            if (distance < closestDistance)\
    \ {\n                closest = (sortedNumbers(i), sortedNumbers(i + 1))\n    \
    \            closestDistance = distance\n            }\n        }\n        closest",
  "        var minDiff = Float.MaxValue\n        var minPair = (0f, 0f)\n        for\
    \ (i <- 0 until numbers.length - 1) {\n            val diff = abs(numbers(i) -\
    \ numbers(i + 1))\n            if (diff < minDiff) {\n                minDiff\
    \ = diff\n                minPair = (numbers(i), numbers(i + 1))\n           \
    \ }\n        }\n        minPair", "        val sorted = numbers.sorted\n     \
    \   var min = Float.MaxValue\n        var result = (0.0f, 0.0f)\n        for (i\
    \ <- 0 until sorted.length - 1) {\n            val diff = abs(sorted(i) - sorted(i\
    \ + 1))\n            if (diff < min) {\n                min = diff\n         \
    \       result = (sorted(i), sorted(i + 1))\n            }\n        }\n      \
    \  result", "        var min = Float.MaxValue\n        var result = (0.0f, 0.0f)\n\
    \        for (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1\
    \ until numbers.length) {\n                val diff = abs(numbers(i) - numbers(j))\n\
    \                if (diff < min) {\n                    min = diff\n         \
    \           result = (numbers(i), numbers(j))\n                }\n           \
    \ }\n        }\n        result", "        var min = Float.MaxValue\n        var\
    \ minPair = (0.0f, 0.0f)\n        for (i <- 0 until numbers.length - 1) {\n  \
    \          for (j <- i + 1 until numbers.length) {\n                val diff =\
    \ abs(numbers(i) - numbers(j))\n                if (diff < min) {\n          \
    \          min = diff\n                    minPair = (numbers(i), numbers(j))\n\
    \                }\n            }\n        }\n        minPair", "        var minDiff\
    \ = Float.MaxValue\n        var minPair = (0.0f, 0.0f)\n        for (i <- 0 until\
    \ numbers.length - 1) {\n            for (j <- i + 1 until numbers.length) {\n\
    \                val diff = abs(numbers(i) - numbers(j))\n                if (diff\
    \ < minDiff) {\n                    minDiff = diff\n                    minPair\
    \ = (numbers(i), numbers(j))\n                }\n            }\n        }\n  \
    \      minPair", "        var minDiff = abs(numbers(0) - numbers(1))\n       \
    \ var minPair = (numbers(0), numbers(1))\n        for (i <- 0 until numbers.length\
    \ - 1) {\n            for (j <- i + 1 until numbers.length) {\n              \
    \  val diff = abs(numbers(i) - numbers(j))\n                if (diff < minDiff)\
    \ {\n                    minDiff = diff\n                    minPair = (numbers(i),\
    \ numbers(j))\n                }\n            }\n        }\n        minPair",
  "        var min = Float.MaxValue\n        var minTuple = (0.0f, 0.0f)\n       \
    \ for (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                val diff = abs(numbers(i) - numbers(j))\n               \
    \ if (diff < min) {\n                    min = diff\n                    minTuple\
    \ = (numbers(i), numbers(j))\n                }\n            }\n        }\n  \
    \      minTuple", "        var min = Float.MaxValue\n        var result = (0.0f,\
    \ 0.0f)\n        for (i <- 0 until numbers.length - 1) {\n            for (j <-\
    \ i + 1 until numbers.length) {\n                val diff = abs(numbers(i) - numbers(j))\n\
    \                if (diff < min) {\n                    min = diff\n         \
    \           result = (numbers(i), numbers(j))\n                }\n           \
    \ }\n        }\n        result", "        var minDiff = Float.MaxValue\n     \
    \   var minPair = (0f, 0f)\n        for (i <- 0 until numbers.length - 1) {\n\
    \            val diff = abs(numbers(i) - numbers(i + 1))\n            if (diff\
    \ < minDiff) {\n                minDiff = diff\n                minPair = (numbers(i),\
    \ numbers(i + 1))\n            }\n        }\n        minPair", "        var min\
    \ = Float.MaxValue\n        var minTuple = Tuple2(0f, 0f)\n        for (i <- 0\
    \ until numbers.length - 1) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                val diff = abs(numbers(i) - numbers(j))\n               \
    \ if (diff < min) {\n                    min = diff\n                    minTuple\
    \ = Tuple2(numbers(i), numbers(j))\n                }\n            }\n       \
    \ }\n        minTuple", "        var minDiff = Float.MaxValue\n        var minPair\
    \ = (0.0f, 0.0f)\n        for (i <- 0 until numbers.length - 1) {\n          \
    \  val diff = abs(numbers(i) - numbers(i + 1))\n            if (diff < minDiff)\
    \ {\n                minDiff = diff\n                minPair = (numbers(i), numbers(i\
    \ + 1))\n            }\n        }\n        minPair", "        var min = Float.MaxValue\n\
    \        var minPair = (0.0f, 0.0f)\n        for (i <- 0 until numbers.length\
    \ - 1) {\n            for (j <- i + 1 until numbers.length) {\n              \
    \  val diff = abs(numbers(i) - numbers(j))\n                if (diff < min) {\n\
    \                    min = diff\n                    minPair = (numbers(i), numbers(j))\n\
    \                }\n            }\n        }\n        minPair", "        val sorted\
    \ = numbers.sorted\n        var min = abs(sorted(0) - sorted(1))\n        var\
    \ result = (sorted(0), sorted(1))\n        for (i <- 1 until sorted.length - 1)\
    \ {\n            val diff = abs(sorted(i) - sorted(i + 1))\n            if (diff\
    \ < min) {\n                min = diff\n                result = (sorted(i), sorted(i\
    \ + 1))\n            }\n        }\n        result", "        var min = Float.MaxValue\n\
    \        var result = (0.0f, 0.0f)\n        for (i <- 0 until numbers.length -\
    \ 1) {\n            for (j <- i + 1 until numbers.length) {\n                val\
    \ diff = abs(numbers(i) - numbers(j))\n                if (diff < min) {\n   \
    \                 min = diff\n                    result = (numbers(i), numbers(j))\n\
    \                }\n            }\n        }\n        result", "        var minDiff\
    \ = Float.MaxValue\n        var minPair = (0.0f, 0.0f)\n        for (i <- 0 until\
    \ numbers.length - 1) {\n            val diff = abs(numbers(i) - numbers(i + 1))\n\
    \            if (diff < minDiff) {\n                minDiff = diff\n         \
    \       minPair = (numbers(i), numbers(i + 1))\n            }\n        }\n   \
    \     minPair", "        val sortedNumbers = numbers.sorted\n        var closestPair\
    \ = (sortedNumbers(0), sortedNumbers(1))\n        var closestDifference = abs(sortedNumbers(0)\
    \ - sortedNumbers(1))\n        for (i <- 0 until sortedNumbers.length - 1) {\n\
    \            val difference = abs(sortedNumbers(i) - sortedNumbers(i + 1))\n \
    \           if (difference < closestDifference) {\n                closestDifference\
    \ = difference\n                closestPair = (sortedNumbers(i), sortedNumbers(i\
    \ + 1))\n            }\n        }\n        closestPair", "        var minDiff\
    \ = Float.MaxValue\n        var minTuple : Tuple2[Float, Float] = null\n     \
    \   for (i <- 0 until numbers.length - 1) {\n            val diff = abs(numbers(i)\
    \ - numbers(i + 1))\n            if (diff < minDiff) {\n                minDiff\
    \ = diff\n                minTuple = (numbers(i), numbers(i + 1))\n          \
    \  }\n        }\n        minTuple", "        var closest = (numbers(0), numbers(1))\n\
    \        var closestDistance = abs(numbers(0) - numbers(1))\n        for (i <-\
    \ 0 until numbers.length - 1) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                val distance = abs(numbers(i) - numbers(j))\n           \
    \     if (distance < closestDistance) {\n                    closest = (numbers(i),\
    \ numbers(j))\n                    closestDistance = distance\n              \
    \  }\n            }\n        }\n        closest", "        var minDiff = Float.MaxValue\n\
    \        var minPair = (0.0f, 0.0f)\n        for (i <- 0 until numbers.length\
    \ - 1) {\n            for (j <- i + 1 until numbers.length) {\n              \
    \  val diff = abs(numbers(i) - numbers(j))\n                if (diff < minDiff)\
    \ {\n                    minDiff = diff\n                    minPair = (numbers(i),\
    \ numbers(j))\n                }\n            }\n        }\n        minPair"]
stop_tokens:
- "\n    }\n"
