language: scala
name: HumanEval_68_pluck
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n\
    \            val index = arr.indexOf(min)\n            List(min, index)\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       else return List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n\
    \            val index = arr.indexOf(min)\n            List(min, index)\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n\
    \            val index = arr.indexOf(min)\n            List(min, index)\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n\
    \        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) List() else List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) return List()\n    \
    \    return List(min, index)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n\
    \            val index = arr.indexOf(min)\n            List(min, index)\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n\
    \            val index = arr.indexOf(min)\n            List(min, index)\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       else return List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) return List()\n    \
    \    return List(min, index)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List[Long]()\n\
    \        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <-\
    \ 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n\
    \                min = arr(i)\n                minIndex = i\n            }\n \
    \       }\n        if (minIndex == -1) return List[Long]()\n        return List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val minIndex = arr.indexOf(min)\n        List(min, minIndex)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) List() else List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) return List()\n    \
    \    return List(min, index)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) List() else List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n\
    \            val index = arr.indexOf(min)\n            List(min, index)\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.length == 0) return List[Long]()\n\
    \        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <-\
    \ 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n\
    \                min = arr(i)\n                minIndex = i\n            }\n \
    \       }\n        if (minIndex == -1) return List[Long]()\n        return List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) return List()\n    \
    \    return List(min, index)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n\
    \        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n\
    \        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.length == 0) return List()\n\
    \        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <-\
    \ 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n\
    \                min = arr(i)\n                minIndex = i\n            }\n \
    \       }\n        if (minIndex == -1) return List()\n        return List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        if (evens.isEmpty) List()\n        else {\n            val min =\
    \ evens.min\n            val index = arr.indexOf(min)\n            List(min, index)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n\
    \            val index = arr.indexOf(min)\n            List(min, index)\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n\
    \            val index = arr.indexOf(min)\n            List(min, index)\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n\
    \        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.length == 0) return List()\n\
    \        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <-\
    \ 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n\
    \                min = arr(i)\n                minIndex = i\n            }\n \
    \       }\n        if (minIndex == -1) return List()\n        return List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (min == Long.MaxValue) return List()\n\
    \        return List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n\
    \            val index = arr.indexOf(min)\n            List(min, index)\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) return List()\n    \
    \    return List(min, index)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var minEven = Long.MaxValue\n        var minEvenIndex = -1\n        for\
    \ (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < minEven)\
    \ {\n                minEven = arr(i)\n                minEvenIndex = i\n    \
    \        }\n        }\n        if (minEvenIndex == -1) return List()\n       \
    \ return List(minEven, minEvenIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) List() else List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var minEven = Long.MaxValue\n        var minEvenIndex = -1\n        for\
    \ (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < minEven)\
    \ {\n                minEven = arr(i)\n                minEvenIndex = i\n    \
    \        }\n        }\n        if (minEvenIndex == -1) return List()\n       \
    \ return List(minEven, minEvenIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty) return\
    \ List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n\
    \        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val minIndex = arr.indexOf(min)\n        List(min, minIndex)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        return List(min, index)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) List()\n        else {\n            val minEven =\
    \ evens.min\n            val index = arr.indexOf(minEven)\n            List(minEven,\
    \ index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        return\
    \ List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = Long.MaxValue\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (min == Long.MaxValue)\
    \ List() else List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) List() else List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n\
    \            val index = arr.indexOf(min)\n            List(min, index)\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val minEven = evens.min\n        val index = arr.indexOf(minEven)\n \
    \       List(minEven, index)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.length == 0) return List()\n\
    \        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <-\
    \ 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n\
    \                min = arr(i)\n                minIndex = i\n            }\n \
    \       }\n        if (minIndex == -1) return List()\n        return List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var minEven = Long.MaxValue\n      \
    \  var minEvenIndex = -1\n        for (i <- 0 until arr.length) {\n          \
    \  if (arr(i) % 2 == 0 && arr(i) < minEven) {\n                minEven = arr(i)\n\
    \                minEvenIndex = i\n            }\n        }\n        if (minEvenIndex\
    \ == -1) List() else List(minEven, minEvenIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n\
    \        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (min == Long.MaxValue) return List()\n        return List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                index = i\n            }\n        }\n \
    \       if (index == -1) return List()\n        return List(min, index)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) return List()\n    \
    \    return List(min, index)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val minIndex = arr.indexOf(min)\n      \
    \  List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) return List()\n    \
    \    return List(min, index)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List[Long]()\n\
    \        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return\
    \ List[Long]()\n        val min = evens.min\n        val index = arr.indexOf(min)\n\
    \        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n\
    \        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) return List()\n    \
    \    else return List(min, index)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) return List()\n    \
    \    return List(min, index)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) List() else List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        // 1. Find the smallest even value in\
    \ the array\n        // 2. Find the index of the smallest even value\n       \
    \ // 3. Return the smallest even value and its index\n        // 4. If there are\
    \ no even values, return []\n        // 5. If the array is empty, return []\n\
    \        // 6. If there are multiple nodes with the same smallest even value,\
    \ return the node that has smallest index\n        // 7. If there are no even\
    \ values, return []\n        // 8. If the array is empty, return []\n        //\
    \ 9. If there are multiple nodes with the same smallest even value, return the\
    \ node that has smallest index\n        // 10. If there are no even values, return\
    \ []\n        // 11. If the array is empty, return []\n        // 12. If there\
    \ are multiple nodes with the same smallest even value, return the node that has\
    \ smallest index\n        // 13. If there are no even values, return []\n    \
    \    // 14. If the array is empty, return []\n        // 15. If there are multiple\
    \ nodes with the same smallest even value, return the node that has smallest index\n\
    \        // 16. If there are no even values, return []\n        // 17. If the\
    \ array is empty, return []\n        // 18. If there are multiple nodes with the\
    \ same smallest even value, return the node that has smallest index\n        //\
    \ 19. If there are no even values, return []\n        // 20. If the array is empty,\
    \ return []\n        // 21. If there are multiple nodes with the same smallest\
    \ even value, return the node that has smallest index\n        // 22. If there\
    \ are no even values, return []\n        // 23. If the array is empty, return\
    \ []\n        // 24. If there are multiple nodes with the same smallest even value,\
    \ return the node that has smallest index\n        // 25. If there are no even\
    \ values, return []\n        // 26. If the array is empty, return []\n       \
    \ // 27. If there are multiple nodes with the same smallest even value, return\
    \ the node that has smallest index\n        // 28. If there are no even values,\
    \ return []\n        // 29. If the array is empty, return []\n        // 30. If\
    \ there are multiple nodes with the same smallest even value, return the node\
    \ that has smallest index\n        // 31. If there are no even values, return\
    \ []\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpph8eix_d.scala:29:47\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m    \e[33mdef\e[0m \e[36mpluck\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \ ^\e[0m\n\e[31m   |\e[0m                                               Found:\
    \    Unit\n\e[31m   |\e[0m                                               Required:\
    \ List[Long]\n\e[31m30 |\e[0m        \e[34m// 1. Find the smallest even value\
    \ in the array\e[0m\n\e[31m31 |\e[0m        \e[34m// 2. Find the index of the\
    \ smallest even value\e[0m\n\e[31m32 |\e[0m        \e[34m// 3. Return the smallest\
    \ even value and its index\e[0m\n\e[31m33 |\e[0m        \e[34m// 4. If there are\
    \ no even values, return []\e[0m\n\e[31m34 |\e[0m        \e[34m// 5. If the array\
    \ is empty, return []\e[0m\n\e[31m35 |\e[0m        \e[34m// 6. If there are multiple\
    \ nodes with the same smallest even value, return the node that has smallest index\e\
    [0m\n\e[31m36 |\e[0m        \e[34m// 7. If there are no even values, return []\e\
    [0m\n\e[31m37 |\e[0m        \e[34m// 8. If the array is empty, return []\e[0m\n\
    \e[31m38 |\e[0m        \e[34m// 9. If there are multiple nodes with the same smallest\
    \ even value, return the node that has smallest index\e[0m\n\e[31m39 |\e[0m  \
    \      \e[34m// 10. If there are no even values, return []\e[0m\n\e[31m40 |\e\
    [0m        \e[34m// 11. If the array is empty, return []\e[0m\n\e[31m41 |\e[0m\
    \        \e[34m// 12. If there are multiple nodes with the same smallest even\
    \ value, return the node that has smallest index\e[0m\n\e[31m42 |\e[0m       \
    \ \e[34m// 13. If there are no even values, return []\e[0m\n\e[31m43 |\e[0m  \
    \      \e[34m// 14. If the array is empty, return []\e[0m\n\e[31m44 |\e[0m   \
    \     \e[34m// 15. If there are multiple nodes with the same smallest even value,\
    \ return the node that has smallest index\e[0m\n\e[31m45 |\e[0m        \e[34m//\
    \ 16. If there are no even values, return []\e[0m\n\e[31m46 |\e[0m        \e[34m//\
    \ 17. If the array is empty, return []\e[0m\n\e[31m47 |\e[0m        \e[34m// 18.\
    \ If there are multiple nodes with the same s"
  stdout: ''
  timestamp: 1659798559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) List() else List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var minEven = Long.MaxValue\n      \
    \  var minEvenIndex = -1\n        for (i <- 0 until arr.length) {\n          \
    \  if (arr(i) % 2 == 0 && arr(i) < minEven) {\n                minEven = arr(i)\n\
    \                minEvenIndex = i\n            }\n        }\n        if (minEvenIndex\
    \ == -1) return List()\n        return List(minEven, minEvenIndex)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                index\
    \ = i\n            }\n        }\n        if (index == -1) List() else List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) return List()\n        val minEven = evens.min\n \
    \       val index = arr.indexOf(minEven)\n        List(minEven, index)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.isEmpty) List()\n        else {\n            val min = evens.min\n\
    \            val index = arr.indexOf(min)\n            List(min, index)\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) return List()\n \
    \       return List(min, minIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n        var\
    \ minIndex = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (minIndex == -1) List() else List(min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List()\n\
    \        val min = evens.min\n        val index = arr.indexOf(min)\n        List(min,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n\
    \        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     var min = arr.min\n        if (min % 2 == 1) {\n            min = arr.filter(x\
    \ => x % 2 == 0).min\n            if (min % 2 == 1) return List()\n        }\n\
    \        List(min, arr.indexOf(min).toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.pluck(tmp68raigar.scala:33)\n\tat Problem$.main(tmp68raigar.scala:46)\n\
    \tat Problem.main(tmp68raigar.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return List()\n   \
    \     val min = arr.filter(_ % 2 == 0).min\n        val index = arr.indexOf(min)\n\
    \        return List(min, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.pluck(tmp6w3563fz.scala:31)\n\tat Problem$.main(tmp6w3563fz.scala:43)\n\
    \tat Problem.main(tmp6w3563fz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798559
