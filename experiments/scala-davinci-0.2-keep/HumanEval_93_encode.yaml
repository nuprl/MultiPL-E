name: HumanEval_93_encode
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that takes a message, and encodes in such a \n    // way\
  \ that it swaps case of all letters, replaces all vowels in \n    // the message\
  \ with the letter that appears 2 places ahead of that \n    // vowel in the english\
  \ alphabet. \n    // Assume only letters. \n    // Examples:\n    // >>> encode('test')\n\
  \    // 'TGST'\n    // >>> encode('This is a message')\n    // 'tHKS KS C MGSSCGG'\n\
  \    def encode(message : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
  )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n\
  \    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"This is\
  \ a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw\
  \ WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
completions: ["        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = 'a' to 'z'\n        val alphabetMap = alphabet.zip(alphabet.tail :+ 'a').toMap\n\
    \        val messageMap = message.map(c => if (vowels.contains(c.toLower)) alphabetMap(c.toLower)\
    \ else c)\n        messageMap.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabet2 = alphabet + alphabet\n        var result = \"\"\n   \
    \     for (i <- 0 until message.length) {\n            val c = message(i)\n  \
    \          if (vowels.contains(c.toLower)) {\n                result += alphabet2(alphabet.indexOf(c.toLower)\
    \ + 2)\n            } else {\n                result += c\n            }\n   \
    \     }\n        result", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetUpper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetUpperMap\
    \ = alphabetUpper.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val vowelsUpperMap = vowels.toUpperCase.zipWithIndex.toMap\n        val\
    \ result = new StringBuilder\n        for (c <- message) {\n            if (vowels.contains(c))\
    \ {\n                val index = vowelsMap(c)\n                val newIndex =\
    \ (index + 2) % vowels.length\n                result += vowels(newIndex)\n  \
    \          } else if (vowels.toUpperCase.contains(c)) {\n                val index\
    \ = vowelsUpperMap(c)\n                val newIndex = (index + 2) % vowels.length\n\
    \                result += vowels.toUpperCase()(newIndex)\n            } else\
    \ if (alphabet.contains(c)) {\n                val index = alphabetMap(c)\n  \
    \              val newIndex = (index + 2) % alphabet.length\n                result\
    \ += alphabet(newIndex)\n            } else if (alphabetUpper.contains(c)) {\n\
    \                val index = alphabetUpperMap(c)\n                val newIndex\
    \ = (index + 2) % alphabetUpper.length\n                result += alphabetUpper(newIndex)\n\
    \            } else {\n                result += c\n            }\n        }\n\
    \        result.toString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val map = Map[Char, Char]()\n    \
    \    for (i <- 0 until alphabet.length) {\n            val c = alphabet(i)\n \
    \           val c2 = if (i == alphabet.length - 1) alphabet(0) else alphabet(i\
    \ + 1)\n            val c3 = if (i == alphabet.length - 2) alphabet(0) else if\
    \ (i == alphabet.length - 1) alphabet(1) else alphabet(i + 2)\n            map(c)\
    \ = if (vowels.contains(c)) c3 else c2\n        }\n        message.map(c => if\
    \ (c.isUpper) map(c.toLower).toUpper else map(c)).mkString", "        val vowels\
    \ = \"aeiou\"\n        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowels.indexOf(c.toLower)\n                val\
    \ next = (index + 2) % vowels.length\n                vowels(next).toUpper\n \
    \           } else {\n                c.toUpper\n            }\n        })\n \
    \       encoded.mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = 'a' to 'z'\n        val alphabetMap = alphabet.zip(alphabet.tail\
    \ :+ 'a').toMap\n        message.map(c => if (vowels.contains(c.toLower)) alphabetMap(c.toLower)\
    \ else c)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                if (c.isUpper)\
    \ c.toLower else c.toUpper\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val encodeMap = Map('a'\
    \ -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'y')\n        message.map(c\
    \ => if (vowels.contains(c.toLower)) encodeMap(c.toLower) else c).map(c => if\
    \ (c.isLower) c.toUpper else c.toLower).mkString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val encodedMessage = message.map(x => {\n  \
    \          if (vowels.contains(x.toLower)) {\n                val index = alphabetMap(x.toLower)\n\
    \                val index2 = (index + 2) % alphabet.length\n                alphabetMap2(index2).toUpper\n\
    \            } else {\n                x.toUpper\n            }\n        })\n\
    \        encodedMessage", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encodedAlphabet = alphabet.map(c => if (vowels.contains(c)) alphabet((alphabetMap(c)\
    \ + 2) % alphabet.size) else c)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(c => if (c.isUpper) encodedAlphabetMap(c.toLower).toUpper\
    \ else encodedAlphabetMap(c)).mkString", "        val vowels = \"aeiou\"\n   \
    \     val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = new StringBuilder\n        for (c <- message) {\n     \
    \       if (c.isLetter) {\n                val letter = c.toLower\n          \
    \      if (vowels.contains(letter)) {\n                    val index = (vowelsMap(letter)\
    \ + 2) % vowels.length\n                    encoded += vowels(index).toUpper\n\
    \                } else {\n                    val index = (alphabetMap(letter)\
    \ + 2) % alphabet.length\n                    encoded += alphabet(index).toUpper\n\
    \                }\n            } else {\n                encoded += c\n     \
    \       }\n        }\n        encoded.toString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        def\
    \ encodeChar(c : Char) : Char = {\n            val index = alphabet.indexOf(c.toLower)\n\
    \            if (index == -1) c\n            else if (vowels.contains(c.toLower))\
    \ alphabet((index + 2) % alphabet.length)\n            else alphabet((index +\
    \ alphabet.length) % alphabet.length)\n        }\n        message.map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val shift = 2\n        val shiftedAlphabet = alphabet.drop(shift)\
    \ ++ alphabet.take(shift)\n        val shiftedVowels = vowels.map(v => shiftedAlphabet(alphabet.indexOf(v)))\n\
    \        val shiftedVowelsMap = vowels.zip(shiftedVowels).toMap\n        val shiftedAlphabetMap\
    \ = alphabet.zip(shiftedAlphabet).toMap\n        message.map(c => if (vowels.contains(c))\
    \ shiftedVowelsMap(c) else shiftedAlphabetMap(c)).map(c => if (c.isUpper) c.toLower\
    \ else c.toUpper).mkString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex).toUpper\n            } else {\n            \
    \    val index = alphabetMap(c.toLower)\n                val newIndex = (index\
    \ + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n       \
    \     }\n        })\n        encoded", "        val vowels = \"aeiou\"\n     \
    \   val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val alphabetMap2 =\
    \ alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val vowelsMap2 =\
    \ vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val result = new StringBuilder\n\
    \        for (c <- message) {\n            if (vowels.contains(c.toLower)) {\n\
    \                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % 5\n                result.append(vowelsMap2(newIndex).toUpper)\n\
    \            } else {\n                val index = alphabetMap(c.toLower)\n  \
    \              val newIndex = (index + 2) % 26\n                result.append(alphabetMap2(newIndex).toUpper)\n\
    \            }\n        }\n        result.toString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        def\
    \ encodeChar(c : Char) : Char = {\n            if (vowels.contains(c)) {\n   \
    \             val index = alphabet.indexOf(c)\n                val newIndex =\
    \ (index + 2) % alphabet.length\n                alphabet(newIndex)\n        \
    \    } else {\n                c\n            }\n        }\n        message.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar)", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabet2 = alphabet + alphabet\n        val alphabet3 = alphabet2 + alphabet\n\
    \        val alphabet4 = alphabet3 + alphabet\n        val alphabet5 = alphabet4\
    \ + alphabet\n        val alphabet6 = alphabet5 + alphabet\n        val alphabet7\
    \ = alphabet6 + alphabet\n        val alphabet8 = alphabet7 + alphabet\n     \
    \   val alphabet9 = alphabet8 + alphabet\n        val alphabet10 = alphabet9 +\
    \ alphabet\n        val alphabet11 = alphabet10 + alphabet\n        val alphabet12\
    \ = alphabet11 + alphabet\n        val alphabet13 = alphabet12 + alphabet\n  \
    \      val alphabet14 = alphabet13 + alphabet\n        val alphabet15 = alphabet14\
    \ + alphabet\n        val alphabet16 = alphabet15 + alphabet\n        val alphabet17\
    \ = alphabet16 + alphabet\n        val alphabet18 = alphabet17 + alphabet\n  \
    \      val alphabet19 = alphabet18 + alphabet\n        val alphabet20 = alphabet19\
    \ + alphabet\n        val alphabet21 = alphabet20 + alphabet\n        val alphabet22\
    \ = alphabet21 + alphabet\n        val alphabet23 = alphabet22 + alphabet\n  \
    \      val alphabet24 = alphabet23 + alphabet\n        val alphabet25 = alphabet24\
    \ + alphabet\n        val alphabet26 = alphabet25 + alphabet\n        val alphabet27\
    \ = alphabet26 + alphabet\n        val alphabet28 = alphabet27 + alphabet\n  \
    \      val alphabet29 = alphabet28 + alphabet\n        val alphabet30 = alphabet29\
    \ + alphabet\n        val alphabet31 = alphabet30 + alphabet\n        val alphabet32\
    \ = alphabet31 + alphabet\n        val alphabet33 = alphabet32 + alphabet\n  \
    \      val alphabet34 = alphabet33 + alphabet\n        val alphabet35 = alphabet34\
    \ + alphabet\n        val alphabet36 = alphabet35 + alphabet\n        val alphabet37\
    \ = alphabet36 + alphabet\n        val alphabet38 = alphabet37 + alphabet\n  \
    \      val alphabet39 = alphabet38 + alphabet\n        val alphabet40 = alphabet39\
    \ + alphabet\n        val alphabet41 = alphabet40 + alphabet\n        val alphabet42\
    \ = alphabet41 + alphabet\n        val alphabet43 = alphabet42 + alphabet\n  \
    \      val alphabet44 = alphabet43 + alphabet\n        val alphabet45 = alphabet44\
    \ + alphabet\n        val alphabet46 = alphabet45 + alphabet\n        val alphabet47\
    \ = alphabet46 + alphabet\n        val alphabet48 = alphabet47 + alphabet\n  \
    \      val alphabet49 = alphabet48 + alphabet\n", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to 'z'\n        val alphabetMap\
    \ = alphabet.zip(alphabet.tail ++ List('a')).toMap\n        message.map(c => if\
    \ (vowels.contains(c.toLower)) alphabetMap(c.toLower) else c).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val vowels2 = Set('c', 'f', 'j', 'n', 'r', 'v', 'z')\n  \
    \      val vowels3 = Set('b', 'd', 'g', 'h', 'k', 'l', 'm', 'p', 'q', 's', 't',\
    \ 'w', 'x', 'y')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    \
    \    val alphabet2 = \"cdefghijklmnopqrstuvwxyzab\"\n        val alphabet3 = \"\
    bcdefghijklmnopqrstuvwxyza\"\n        val alphabet4 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabet5 = \"CDEFGHIJKLMNOPQRSTUVWXYZAB\"\n        val alphabet6\
    \ = \"BCDEFGHIJKLMNOPQRSTUVWXYZAB\"\n        def encodeChar(c : Char) : Char =\
    \ {\n            if (vowels.contains(c)) alphabet2(alphabet.indexOf(c))\n    \
    \        else if (vowels2.contains(c)) alphabet3(alphabet.indexOf(c))\n      \
    \      else if (vowels3.contains(c)) alphabet(alphabet.indexOf(c))\n         \
    \   else if (vowels.contains(c.toLower)) alphabet5(alphabet4.indexOf(c))\n   \
    \         else if (vowels2.contains(c.toLower)) alphabet6(alphabet4.indexOf(c))\n\
    \            else if (vowels3.contains(c.toLower)) alphabet4(alphabet4.indexOf(c))\n\
    \            else c\n        }\n        message.map(encodeChar)", "        val\
    \ vowels = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c)) {\n                val index = vowelMap(c)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex)\n\
    \            } else if (alphabet.contains(c)) {\n                val index = alphabetMap(c)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabet(newIndex)\n            } else {\n                c\n            }\n\
    \        })\n        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                val nextIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(nextIndex)\n     \
    \       } else {\n                c\n            }\n        }\n        message.map(c\
    \ => if (c.isUpper) encodeChar(c.toLower).toUpper else encodeChar(c)).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alpha = 'a' to 'z'\n\
    \        val alphaMap = (alpha zip alpha.tail.tail).toMap\n        message.map(c\
    \ => if (vowels.contains(c.toLower)) alphaMap(c.toLower) else c).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        def encodeChar(c\
    \ : Char) : Char = {\n            if (vowels.contains(c)) {\n                val\
    \ index = alphabet.indexOf(c)\n                alphabet((index + 2) % alphabet.length)\n\
    \            } else {\n                c\n            }\n        }\n        message.map(c\
    \ => if (c.isUpper) encodeChar(c.toLower).toUpper else encodeChar(c)).mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val encoded = for (c <- message) yield {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ val newIndex = (index + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        }\n \
    \       encoded.mkString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val alphabetMap2 =\
    \ alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val vowelsMap2 =\
    \ vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val result = new StringBuilder\n\
    \        for (c <- message) {\n            if (vowels.contains(c.toLower)) {\n\
    \                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % 5\n                val newChar = vowelsMap2(newIndex)\n    \
    \            if (c.isUpper) result += newChar.toUpper\n                else result\
    \ += newChar\n            }\n            else {\n                val index = alphabetMap(c.toLower)\n\
    \                val newIndex = (index + 2) % 26\n                val newChar\
    \ = alphabetMap2(newIndex)\n                if (c.isUpper) result += newChar.toUpper\n\
    \                else result += newChar\n            }\n        }\n        result.toString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetList = alphabet.toList\n  \
    \      val vowelsList = vowels.toList\n        val messageList = message.toList\n\
    \        val encodedList = messageList.map(x => {\n            if (vowels.contains(x.toLower))\
    \ {\n                val index = vowelsMap(x.toLower)\n                val newIndex\
    \ = (index + 2) % 5\n                val newVowel = vowelsList(newIndex)\n   \
    \             if (x.isUpper) newVowel.toUpper else newVowel\n            } else\
    \ if (alphabet.contains(x.toLower)) {\n                val index = alphabetMap(x.toLower)\n\
    \                val newIndex = (index + 2) % 26\n                val newLetter\
    \ = alphabetList(newIndex)\n                if (x.isUpper) newLetter.toUpper else\
    \ newLetter\n            } else x\n        })\n        encodedList.mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        def encodeChar(c : Char) : Char = {\n            if\
    \ (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n  \
    \              alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        }\n        message.map(c => if (c.isLower)\
    \ encodeChar(c) else encodeChar(c.toLower).toUpper).mkString", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to 'z'\n        val\
    \ alphabetMap = alphabet.zip(alphabet.tail :+ 'a').toMap\n        message.map(c\
    \ => if (vowels.contains(c.toLower)) alphabetMap(c.toLower) else c).map(c => if\
    \ (c.isUpper) c.toLower else c.toUpper)", "        val vowels = \"aeiou\"\n  \
    \      val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = if (index + 2 >= vowels.length) index + 2 - vowels.length else index + 2\n\
    \                vowels(newIndex).toUpper\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = if (index + 2 >= alphabet.length) index + 2 - alphabet.length else index +\
    \ 2\n                alphabet(newIndex).toUpper\n            } else {\n      \
    \          c\n            }\n        })\n        encoded", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabet2 = alphabet + alphabet\n        val vowels2 = alphabet2.slice(alphabet.indexOf('a'),\
    \ alphabet.indexOf('a') + 5)\n        val message2 = message.toLowerCase\n   \
    \     val message3 = message2.map(c => if (vowels.contains(c)) vowels2(vowels.indexOf(c))\
    \ else c)\n        val message4 = message3.map(c => if (alphabet.contains(c))\
    \ alphabet2(alphabet.indexOf(c)) else c)\n        message4.map(c => if (c.isLower)\
    \ c.toUpper else c.toLower).mkString", "        val vowels = List('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphaMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphaMap2 = alphaMap.map(x => (x._2,\
    \ x._1))\n        val alphaMap3 = alphaMap2.map(x => (x._1 + 2, x._2))\n     \
    \   val alphaMap4 = alphaMap3.map(x => (x._1 % 26, x._2))\n        val alphaMap5\
    \ = alphaMap4.map(x => (x._1, x._2.toUpper))\n        val alphaMap6 = alphaMap2.map(x\
    \ => (x._1, x._2.toUpper))\n        val alphaMap7 = alphaMap6 ++ alphaMap5\n \
    \       val alphaMap8 = alphaMap7.map(x => (x._2.toLower, x._2))\n        val\
    \ alphaMap9 = alphaMap8 ++ alphaMap2\n        val alphaMap10 = alphaMap9.map(x\
    \ => (x._2.toUpper, x._2))\n        val alphaMap11 = alphaMap10 ++ alphaMap9\n\
    \        val alphaMap12 = alphaMap11.map(x => (x._2.toLower, x._2))\n        val\
    \ alphaMap13 = alphaMap12 ++ alphaMap11\n        val alphaMap14 = alphaMap13.map(x\
    \ => (x._2.toUpper, x._2))\n        val alphaMap15 = alphaMap14 ++ alphaMap13\n\
    \        val alphaMap16 = alphaMap15.map(x => (x._2.toLower, x._2))\n        val\
    \ alphaMap17 = alphaMap16 ++ alphaMap15\n        val alphaMap18 = alphaMap17.map(x\
    \ => (x._2.toUpper, x._2))\n        val alphaMap19 = alphaMap18 ++ alphaMap17\n\
    \        val alphaMap20 = alphaMap19.map(x => (x._2.toLower, x._2))\n        val\
    \ alphaMap21 = alphaMap20 ++ alphaMap19\n        val alphaMap22 = alphaMap21.map(x\
    \ => (x._2.toUpper, x._2", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = 'a' to 'z'\n        val alphabetMap = alphabet.zip(alphabet.drop(2)\
    \ ++ alphabet.take(2)).toMap\n        message.map(c => if (vowels.contains(c.toLower))\
    \ alphabetMap(c.toLower) else c)", "        val vowels = \"aeiou\"\n        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val alphabetIndexMap\
    \ = alphabetMap.map(_.swap)\n        val vowelsIndexMap = vowelsMap.map(_.swap)\n\
    \        val encodeMap = vowels.zip(vowels.drop(2) ++ vowels.take(2)).toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                encodeMap(c)\n            } else if (alphabet.contains(c))\
    \ {\n                alphabetIndexMap((alphabetMap(c) + 2) % 26)\n           \
    \ } else {\n                c\n            }\n        }\n        message.map(c\
    \ => if (c.isUpper) encodeChar(c.toLower).toUpper else encodeChar(c))", "    \
    \    val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val nextIndex = (index + 2) % vowels.length\n               \
    \ vowels(nextIndex).toUpper\n            } else {\n                c.toUpper\n\
    \            }\n        })\n        encoded", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x\
    \ => {\n            if (vowels.contains(x)) {\n                val index = alphabetMap(x)\n\
    \                alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                x\n            }\n        })\n        val encodedAlphabetMap\
    \ = alphabet.zip(encodedAlphabet).toMap\n        message.map(x => {\n        \
    \    if (x.isUpper) {\n                encodedAlphabetMap(x.toLower).toUpper\n\
    \            } else {\n                encodedAlphabetMap(x)\n            }\n\
    \        })", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val\
    \ alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                if (c.isUpper)\
    \ c.toLower else c.toUpper\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabet2 = alphabet + alphabet\n        val map = new HashMap[Char,\
    \ Char]\n        for (i <- 0 until alphabet.length) {\n            map(alphabet(i))\
    \ = alphabet2(i + 2)\n        }\n        val sb = new StringBuilder\n        for\
    \ (c <- message) {\n            if (vowels.contains(c.toLower)) sb.append(map(c.toLower))\n\
    \            else if (c.isUpper) sb.append(c.toLower)\n            else sb.append(c.toUpper)\n\
    \        }\n        sb.toString", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x =>\
    \ if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) % alphabet.size) else\
    \ x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n \
    \       message.map(x => if (vowels.contains(x.toLower)) encodedAlphabetMap(x.toLower)\
    \ else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "     \
    \   val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ message.map(c => if (vowels.contains(c.toLower)) alphabet((alphabetMap(c.toLower)\
    \ + 2) % 26) else c)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n  \
    \      val alphabet = ('a' to 'z').toArray\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = alphabet.indexOf(c.toLower)\n                alphabet((index + 2) % alphabet.length)\n\
    \            } else {\n                c\n            }\n        })\n        encoded.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).mkString", "        val vowels =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to 'z'\n        val\
    \ alphabetMap = alphabet.zip(alphabet.tail :+ 'a').toMap\n        val messageEncoded\
    \ = message.map(c => if (vowels.contains(c.toLower)) alphabetMap(c.toLower) else\
    \ c)\n        messageEncoded.map(c => if (c.isUpper) c.toLower else c.toUpper)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val shift = 2\n        val encodeMap = alphabet.zip(alphabet.drop(shift)\
    \ ++ alphabet.take(shift)).toMap\n        message.map(c => if (vowels.contains(c.toLower))\
    \ encodeMap(c.toLower) else c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = \"AEIOUaeiou\"\n        val alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c)) {\n                val index = vowelsMap(c)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex)\n\
    \            } else if (alphabet.contains(c)) {\n                val index = alphabetMap(c)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabet(newIndex)\n            } else {\n                c\n            }\n\
    \        })\n        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val map = alphabet.zip(alphabet.drop(2)\
    \ ++ alphabet.take(2)).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ map(x.toLower) else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabetMap2((index\
    \ + 2) % alphabet.length)\n            } else {\n                if (c.isUpper)\
    \ c.toLower else c.toUpper\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        def encodeChar(c : Char) : Char = {\n       \
    \     if (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n\
    \                alphabet((index + 2) % alphabet.length)\n            } else if\
    \ (c.isUpper) {\n                c.toLower\n            } else {\n           \
    \     c.toUpper\n            }\n        }\n        message.map(encodeChar)", " \
    \       val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a'\
    \ to 'z'\n        val alphabetMap = alphabet.zip(alphabet.tail ++ List('a')).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) alphabetMap(c.toLower)\
    \ else c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString", "     \
    \   val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toArray\n        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ val newIndex = if (index + 2 > alphabet.length - 1) index + 2 - alphabet.length\
    \ else index + 2\n                alphabet(newIndex)\n            } else {\n \
    \               c\n            }\n        })\n        encoded.mkString", "   \
    \     val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        def encodeChar(c : Char) : Char = {\n         \
    \   val c2 = if (c.isUpper) c.toLower else c\n            if (vowels.contains(c2))\
    \ {\n                val index = vowelsMap(c2)\n                val index2 = (index\
    \ + 2) % vowels.length\n                val c3 = vowelsMap2(index2)\n        \
    \        if (c.isUpper) c3.toUpper else c3\n            } else {\n           \
    \     val index = alphabetMap(c2)\n                val index2 = (index + 2) %\
    \ alphabet.length\n                val c3 = alphabetMap2(index2)\n           \
    \     if (c.isUpper) c3.toUpper else c3\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encodedAlphabet = alphabet.map(c => if (vowels.contains(c)) alphabet((alphabetMap(c)\
    \ + 2) % alphabet.size) else c)\n        val encodedAlphabetMap = encodedAlphabet.zipWithIndex.toMap\n\
    \        val encodedAlphabetUpper = encodedAlphabet.map(_.toUpper)\n        val\
    \ encodedAlphabetMapUpper = encodedAlphabetUpper.zipWithIndex.toMap\n        message.map(c\
    \ => if (c.isUpper) encodedAlphabetUpper(encodedAlphabetMapUpper(c)) else encodedAlphabet(encodedAlphabetMap(c.toLower)))",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = (alphabet.zipWithIndex.toMap)\n        val vowelsMap\
    \ = (vowels.zipWithIndex.toMap)\n        val encoded = message.map(c => {\n  \
    \          if (c.isUpper) {\n                if (vowels.contains(c.toLower)) {\n\
    \                    val index = (vowelsMap(c.toLower) + 2) % 5\n            \
    \        vowels(index).toUpper\n                } else {\n                   \
    \ alphabet((alphabetMap(c.toLower) + 2) % 26).toUpper\n                }\n   \
    \         } else {\n                if (vowels.contains(c)) {\n              \
    \      val index = (vowelsMap(c) + 2) % 5\n                    vowels(index)\n\
    \                } else {\n                    alphabet((alphabetMap(c) + 2) %\
    \ 26)\n                }\n            }\n        })\n        encoded", "     \
    \   val vowels = Set('a', 'e', 'i', 'o', 'u')\n        def shift(c : Char) : Char\
    \ = {\n            if (vowels.contains(c)) {\n                val next = c + 2\n\
    \                if (next > 'z') {\n                    ('a' + next - 'z' - 1).toChar\n\
    \                } else {\n                    next.toChar\n                }\n\
    \            } else {\n                c\n            }\n        }\n        message.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).map(shift).mkString", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        }\n        message.map(c => if (c.isUpper) encodeChar(c.toLower).toUpper\
    \ else encodeChar(c)).mkString", "        val vowels = \"aeiou\"\n        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val encoded = message.toLowerCase.map(c\
    \ => {\n            if (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n\
    \                alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        })\n        encoded.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        val vowels = List('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x\
    \ => {\n            val index = alphabetMap(x)\n            if (index + 2 > 25)\
    \ alphabet(index + 2 - 26)\n            else alphabet(index + 2)\n        })\n\
    \        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n      \
    \  val encodedMessage = message.map(x => {\n            if (vowels.contains(x.toLower))\
    \ encodedAlphabetMap(x.toLower)\n            else if (x.isUpper) x.toLower\n \
    \           else x.toUpper\n        })\n        encodedMessage.mkString", "  \
    \      val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabetMap2((index\
    \ + 2) % alphabet.length)\n            } else if (c.isUpper) {\n             \
    \   c.toLower\n            } else if (c.isLower) {\n                c.toUpper\n\
    \            } else {\n                c\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.toMap.map(x\
    \ => (x._2 + 2) % 26 -> x._1)\n        val vowelsMap2 = vowels.zipWithIndex.toMap.map(x\
    \ => (x._2 + 2) % 5 -> x._1)\n        val message2 = message.map(x => if (vowels.contains(x.toLower))\
    \ vowelsMap2(vowelsMap(x.toLower)) else alphabetMap2(alphabetMap(x.toLower)))\n\
    \        message2.map(x => if (x.isUpper) x.toLower else x.toUpper).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        def encodeChar(c : Char) : Char = {\n            if\
    \ (vowels contains c) {\n                val index = alphabet.indexOf(c)\n   \
    \             alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        }\n        message.map(c => if (c.isUpper)\
    \ encodeChar(c.toLower).toUpper else encodeChar(c)).mkString", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toArray\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        def encodeChar(c\
    \ : Char) : Char = {\n            if (vowels.contains(c)) {\n                val\
    \ index = alphabetMap(c)\n                alphabet((index + 2) % alphabet.length)\n\
    \            } else {\n                c.toUpper\n            }\n        }\n \
    \       message.map(encodeChar).mkString", "        val vowels = \"aeiou\"\n \
    \       val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = alphabet.indexOf(c.toLower)\n                val newIndex = (index + 2) %\
    \ alphabet.length\n                alphabet(newIndex).toUpper\n            } else\
    \ {\n                c.toUpper\n            }\n        })\n        encoded.mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        var encoded = \"\"\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ val newIndex = (index + 2) % 26\n                encoded += alphabet(newIndex).toUpper\n\
    \            } else {\n                encoded += c.toUpper\n            }\n \
    \       }\n        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encodedAlphabet = alphabet.map(c => if (vowels.contains(c)) alphabet((alphabetMap(c)\
    \ + 2) % alphabet.size) else c)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(c => if (c.isUpper) encodedAlphabetMap(c.toLower).toUpper\
    \ else encodedAlphabetMap(c)).mkString", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x)", "        val vowels = \"aeiou\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (c.isUpper) c.toLower\n\
    \            else if (c.isLower) c.toUpper\n            else c\n        }).map(c\
    \ => {\n            if (vowelsMap.contains(c)) {\n                val index =\
    \ vowelsMap(c)\n                val newIndex = (index + 2) % vowels.length\n \
    \               vowels(newIndex)\n            } else {\n                c\n  \
    \          }\n        })\n        encoded", "        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabet2\
    \ = alphabet + alphabet\n        val alphabet3 = alphabet2 + alphabet\n      \
    \  val alphabet4 = alphabet3 + alphabet\n        val alphabet5 = alphabet4 + alphabet\n\
    \        val alphabet6 = alphabet5 + alphabet\n        val alphabet7 = alphabet6\
    \ + alphabet\n        val alphabet8 = alphabet7 + alphabet\n        val alphabet9\
    \ = alphabet8 + alphabet\n        val alphabet10 = alphabet9 + alphabet\n    \
    \    val alphabet11 = alphabet10 + alphabet\n        val alphabet12 = alphabet11\
    \ + alphabet\n        val alphabet13 = alphabet12 + alphabet\n        val alphabet14\
    \ = alphabet13 + alphabet\n        val alphabet15 = alphabet14 + alphabet\n  \
    \      val alphabet16 = alphabet15 + alphabet\n        val alphabet17 = alphabet16\
    \ + alphabet\n        val alphabet18 = alphabet17 + alphabet\n        val alphabet19\
    \ = alphabet18 + alphabet\n        val alphabet20 = alphabet19 + alphabet\n  \
    \      val alphabet21 = alphabet20 + alphabet\n        val alphabet22 = alphabet21\
    \ + alphabet\n        val alphabet23 = alphabet22 + alphabet\n        val alphabet24\
    \ = alphabet23 + alphabet\n        val alphabet25 = alphabet24 + alphabet\n  \
    \      val alphabet26 = alphabet25 + alphabet\n        val alphabet27 = alphabet26\
    \ + alphabet\n        val alphabet28 = alphabet27 + alphabet\n        val alphabet29\
    \ = alphabet28 + alphabet\n        val alphabet30 = alphabet29 + alphabet\n  \
    \      val alphabet31 = alphabet30 + alphabet\n        val alphabet32 = alphabet31\
    \ + alphabet\n        val alphabet33 = alphabet32 + alphabet\n        val alphabet34\
    \ = alphabet33 + alphabet\n        val alphabet35 = alphabet34 + alphabet\n  \
    \      val alphabet36 = alphabet35 + alphabet\n        val alphabet37 = alphabet36\
    \ + alphabet\n        val alphabet38 = alphabet37 + alphabet\n        val alphabet39\
    \ = alphabet38 + alphabet\n        val alphabet40 = alphabet39 + alphabet\n  \
    \      val alphabet41 = alphabet40 + alphabet\n        val alphabet42 = alphabet41\
    \ + alphabet\n        val alphabet43 = alphabet42 + alphabet\n        val alphabet44\
    \ = alphabet43 + alphabet\n        val alphabet45 = alphabet44 + alphabet\n  \
    \      val alphabet46 = alphabet45 + alphabet\n        val alphabet47 = alphabet46\
    \ + alphabet\n        val alphabet48 = alphabet47 + alphabet\n        val alphabet49\
    \ = alphabet48 + alphabet\n", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoder = (c :\
    \ Char) => {\n            if (vowels.contains(c)) {\n                val index\
    \ = vowelsMap(c)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex)\n            } else {\n                val index\
    \ = alphabetMap(c)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex)\n            }\n        }\n        message.map(c\
    \ => if (c.isUpper) encoder(c.toLower).toUpper else encoder(c))", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to 'z'\n \
    \       val alphabetMap = alphabet.zip(alphabet.tail :+ 'a').toMap\n        val\
    \ encodeMap = alphabetMap ++ alphabetMap.map(x => (x._1.toUpper, x._2.toUpper))\n\
    \        val encode = (c : Char) => if (vowels.contains(c.toLower)) encodeMap(c)\
    \ else c\n        message.map(encode)", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        def encodeChar(c : Char) : Char = {\n  \
    \          if (vowels.contains(c)) alphabetMap3(alphabetMap(c))\n            else\
    \ alphabetMap2(alphabetMap(c))\n        }\n        message.map(c => if (c.isUpper)\
    \ encodeChar(c.toLower).toUpper else encodeChar(c))", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                val newIndex = if (index + 2 > alphabet.length - 1) (index +\
    \ 2) % alphabet.length else index + 2\n                alphabet(newIndex).toUpper\n\
    \            } else if (c.isLower) c.toUpper else c.toLower\n        })", "  \
    \      val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 2) % 5)).toMap\n        def encodeChar(c : Char) : Char =\
    \ {\n            if (vowels.contains(c)) {\n                vowels(vowelsMap2(c))\n\
    \            } else if (alphabet.contains(c)) {\n                alphabet((alphabetMap(c)\
    \ + alphabet.length / 2) % alphabet.length)\n            } else {\n          \
    \      c\n            }\n        }\n        message.map(encodeChar)", "      \
    \  val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val alphabetMap3\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap4\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap5\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap6\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap7\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap8\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap9\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap10\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap11\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap12\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap13\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap14\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap15\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap16\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap17\
    \ = alphabet.zipWithIndex.map", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex).toUpper\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n\
    \            } else {\n                c\n            }\n        })\n        encoded",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toArray\n        val mapping = vowels.map(v => (v, alphabet((alphabet.indexOf(v)\
    \ + 2) % alphabet.length))).toMap\n        message.map(c => if (vowels.contains(c.toLower))\
    \ mapping(c.toLower) else c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val shift = 2\n        message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val shiftedIndex\
    \ = (index + shift) % alphabet.length\n                val shiftedChar = alphabet(shiftedIndex)\n\
    \                if (c.isUpper) shiftedChar.toUpper else shiftedChar\n       \
    \     } else {\n                if (c.isUpper) c.toLower else c.toUpper\n    \
    \        }\n        })", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = 'a' to 'z'\n        val alphabetMap = alphabet.zip(alphabet.tail\
    \ :+ 'a').toMap\n        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ alphabetMap(c)\n            else if (vowels.contains(c.toLower)) alphabetMap(c.toLower).toUpper\n\
    \            else if (c.isUpper) c.toLower\n            else c.toUpper\n     \
    \   }\n        message.map(encodeChar)", "        val vowels = \"aeiou\"\n   \
    \     val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val vowelsMap2 = vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val result = new StringBuilder\n        for (c <- message) {\n       \
    \     if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % 5\n                val newChar =\
    \ vowelsMap2(newIndex)\n                if (c.isUpper) result.append(newChar.toUpper)\n\
    \                else result.append(newChar)\n            } else {\n         \
    \       val index = alphabetMap(c.toLower)\n                val newIndex = (index\
    \ + 2) % 26\n                val newChar = alphabetMap2(newIndex)\n          \
    \      if (c.isUpper) result.append(newChar.toUpper)\n                else result.append(newChar)\n\
    \            }\n        }\n        result.toString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetSize = alphabet.size\n\
    \        val encodeMap = alphabet.map(c => if (vowels.contains(c)) {\n       \
    \     val index = alphabetMap(c)\n            val newIndex = (index + 2) % alphabetSize\n\
    \            alphabet(newIndex)\n        } else c).zipWithIndex.toMap\n      \
    \  message.map(c => if (c.isUpper) encodeMap(c.toLower).toUpper else encodeMap(c))",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ val newIndex = (index + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        })\n\
    \        encoded.mkString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val alphabetMap2 =\
    \ alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val vowelsMap2 =\
    \ vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val result = new StringBuilder\n\
    \        for (c <- message) {\n            if (vowels.contains(c.toLower)) {\n\
    \                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % 5\n                val newChar = vowelsMap2(newIndex)\n    \
    \            result.append(if (c.isUpper) newChar.toUpper else newChar)\n    \
    \        } else {\n                val index = alphabetMap(c.toLower)\n      \
    \          val newIndex = (index + 2) % 26\n                val newChar = alphabetMap2(newIndex)\n\
    \                result.append(if (c.isUpper) newChar.toUpper else newChar)\n\
    \            }\n        }\n        result.toString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap4 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap5 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap6 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap7 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap8 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap9 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap10 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap11 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap12 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap13 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap14 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap15 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap16 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap17 = alphabet.zipWithIndex.map",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        val result = new StringBuilder\n        for (c\
    \ <- message) {\n            if (c.isUpper) {\n                if (vowels.contains(c.toLower))\
    \ {\n                    val index = vowelsMap(c.toLower)\n                  \
    \  val newIndex = (index + 2) % 5\n                    result.append(vowelsMap2(newIndex).toUpper)\n\
    \                } else {\n                    val index = alphabetMap(c.toLower)\n\
    \                    val newIndex = (index + 2) % 26\n                    result.append(alphabetMap2(newIndex).toUpper)\n\
    \                }\n            } else {\n                if (vowels.contains(c))\
    \ {\n                    val index = vowelsMap(c)\n                    val newIndex\
    \ = (index + 2) % 5\n                    result.append(vowelsMap2(newIndex))\n\
    \                } else {\n                    val index = alphabetMap(c)\n  \
    \                  val newIndex = (index + 2) % 26\n                    result.append(alphabetMap2(newIndex))\n\
    \                }\n            }\n        }\n        result.toString", "    \
    \    val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c)) {\n\
    \                val index = alphabetMap(c)\n                alphabet((index +\
    \ 2) % alphabet.length)\n            } else {\n                if (c.isUpper)\
    \ c.toLower else c.toUpper\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encodedAlphabet = alphabet.map(c => if (vowels.contains(c)) alphabet((alphabetMap(c)\
    \ + 2) % alphabet.length) else c)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(c => if (c.isUpper) encodedAlphabetMap(c.toLower).toUpper\
    \ else encodedAlphabetMap(c)).mkString", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(c\
    \ => if (vowels.contains(c)) alphabet((alphabetMap(c) + 2) % alphabet.length)\
    \ else c)\n        val encodedAlphabetMap = encodedAlphabet.zipWithIndex.toMap\n\
    \        val encodedMessage = message.map(c => if (alphabet.contains(c.toLower))\
    \ encodedAlphabet((encodedAlphabetMap(c.toLower) + 1) % encodedAlphabet.length)\
    \ else c)\n        encodedMessage", "        val vowels = \"aeiou\"\n        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabet2 = alphabet.drop(2)\
    \ + alphabet.take(2)\n        message.map(c => if (vowels.contains(c.toLower))\
    \ alphabet2(alphabet.indexOf(c.toLower)) else c)", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val newAlphabet = alphabet.map(x\
    \ => if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) % 26) else x)\n   \
    \     val newAlphabetMap = newAlphabet.zipWithIndex.toMap\n        message.map(x\
    \ => if (x.isUpper) newAlphabet(newAlphabetMap(x.toLower)).toUpper else newAlphabet(newAlphabetMap(x)))",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       def encodeChar(c : Char) : Char = {\n            if (c.isUpper) {\n  \
    \              val index = alphabetMap(c.toLower)\n                alphabetMap2(index).toUpper\n\
    \            } else if (vowels.contains(c)) {\n                val index = alphabetMap(c)\n\
    \                alphabetMap2((index + 2) % alphabet.length)\n            } else\
    \ {\n                c\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alpha = ('a' to\
    \ 'z').toList\n        val alphaMap = alpha.zipWithIndex.toMap\n        val alphaMap2\
    \ = alpha.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val alphaMap3 = alpha.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphaMap4 = alpha.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphaMap5 = alpha.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphaMap6 = alpha.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphaMap7 = alpha.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphaMap8 = alpha.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphaMap9 = alpha.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphaMap10 = alpha.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphaMap11 = alpha.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphaMap12 = alpha.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphaMap13 = alpha.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphaMap14 = alpha.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphaMap15 = alpha.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphaMap16 = alpha.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphaMap17 = alpha.zipWithIndex.map",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ alphabet((index + 2) % alphabet.length)\n            } else if (c.isUpper) {\n\
    \                c.toLower\n            } else {\n                c.toUpper\n\
    \            }\n        })", "        val vowels = List('a', 'e', 'i', 'o', 'u')\n\
    \        val alpha = ('a' to 'z').toList\n        val alphaMap = alpha.zipWithIndex.toMap\n\
    \        val alphaMap2 = alpha.zipWithIndex.map(x => (x._2, x._1)).toMap\n   \
    \     val alphaMap3 = alpha.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n  \
    \      val alphaMap4 = alpha.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n \
    \       val alphaMap5 = alpha.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphaMap6 = alpha.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphaMap7 = alpha.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphaMap8 = alpha.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphaMap9 = alpha.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphaMap10 = alpha.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphaMap11 = alpha.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphaMap12 = alpha.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphaMap13 = alpha.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphaMap14 = alpha.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphaMap15 = alpha.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphaMap16 = alpha.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphaMap17 = alpha.zipWithIndex.map", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetSize = alphabet.size\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                val newIndex\
    \ = (index + 2) % alphabetSize\n                alphabet(newIndex)\n         \
    \   } else {\n                c\n            }\n        }\n        message.map(c\
    \ => if (c.isUpper) encodeChar(c.toLower).toUpper else encodeChar(c)).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        def encodeChar(c : Char) : Char = {\n            if\
    \ (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n  \
    \              alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        }\n        message.map(c => if (c.isUpper)\
    \ encodeChar(c.toLower).toUpper else encodeChar(c)).mkString", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val vowelsMap2 = vowels.zipWithIndex.map(x => (x._1, (x._2 + 2) % 5)).toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._1, (x._2 + 2) %\
    \ 26)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._1,\
    \ (x._2 + 24) % 26)).toMap\n        val vowelsMap3 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 5)).toMap\n        val vowelsMap4 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 3) % 5)).toMap\n        val vowelsMap5 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 4) % 5)).toMap\n        val vowelsMap6 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 1) % 5)).toMap\n        val vowelsMap7 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 3) % 5)).toMap\n        val vowelsMap8 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 4) % 5)).toMap\n        val vowelsMap9 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 1) % 5)).toMap\n        val vowelsMap10 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 3) % 5)).toMap\n        val vowelsMap11 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 4) % 5)).toMap\n        val vowelsMap12 = vowels.zipWithIndex.map(x\
    \ => (x._", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMapReverse = alphabetMap.map(_.swap)\n\
    \        val vowelsMapReverse = vowelsMap.map(_.swap)\n        val messageArray\
    \ = message.toLowerCase.toCharArray\n        for (i <- 0 until messageArray.length)\
    \ {\n            if (vowels.contains(messageArray(i))) {\n                messageArray(i)\
    \ = alphabetMapReverse(vowelsMap(messageArray(i)) + 2)\n            }\n      \
    \      else {\n                messageArray(i) = alphabetMapReverse(alphabetMap(messageArray(i))\
    \ + 2)\n            }\n        }\n        messageArray.mkString", "        var\
    \ result = \"\"\n        for (c <- message) {\n            if (c.isUpper) result\
    \ += c.toLower\n            else if (c.isLower) result += c.toUpper\n        \
    \    else result += c\n        }\n        result", "        val vowels = \"aeiou\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val map = Map[Char,\
    \ Char]()\n        for (i <- 0 until alphabet.length) {\n            map += (alphabet(i)\
    \ -> alphabet((i + 2) % alphabet.length))\n        }\n        var result = \"\"\
    \n        for (i <- 0 until message.length) {\n            if (vowels.contains(message(i)))\
    \ {\n                result += map(message(i))\n            } else {\n       \
    \         result += message(i)\n            }\n        }\n        result", " \
    \       val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toArray\n        val alphabetMap = alphabet.zipWithIndex.toMap\n   \
    \     def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                alphabet((alphabetMap(c) + 2) % alphabet.length)\n      \
    \      } else {\n                c\n            }\n        }\n        message.map(c\
    \ => if (c.isUpper) encodeChar(c.toLower).toUpper else encodeChar(c)).mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        val index = alphabetMap(c.toLower)\n            if (vowels.contains(c.toLower))\
    \ {\n                val newIndex = (index + 2) % 26\n                vowels(vowelsMap.find(_._2\
    \ == newIndex).get._1)\n            } else {\n                alphabet((index\
    \ + 26 - 2) % 26)\n            }\n        })\n        encoded.mkString", "   \
    \     val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val encodedAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x)\
    \ + 2) % alphabet.length) else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper\
    \ else encodedAlphabetMap(x)).mkString", "        val vowels = \"aeiou\"\n   \
    \     val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val nextIndex\
    \ = (index + 2) % vowels.length\n                vowels(nextIndex).toUpper\n \
    \           } else {\n                val index = alphabetMap(c.toLower)\n   \
    \             val nextIndex = (index + 2) % alphabet.length\n                alphabet(nextIndex).toUpper\n\
    \            }\n        })\n        encoded", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x)", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val alphabetMap3\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap4\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap5\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap6\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap7\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap8\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap9\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap10\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap11\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap12\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap13\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap14\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap15\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap16\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap17\
    \ =", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        message.map(c\
    \ => if (vowels.contains(c.toLower)) ((c + 2 - 'a') % 26 + 'a').toChar else c)\n\
    \            .map(c => if (c.isUpper) c.toLower else c.toUpper)", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val nextIndex = (index + 2) % alphabet.length\n\
    \                alphabet(nextIndex).toUpper\n            } else {\n         \
    \       c.toUpper\n            }\n        })", "        val vowels = \"aeiou\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            val lower = c.toLower\n\
    \            if (vowels.contains(lower)) {\n                val index = (vowelsMap(lower)\
    \ + 2) % vowels.length\n                vowels(index).toUpper\n            } else\
    \ if (alphabet.contains(lower)) {\n                val index = (alphabetMap(lower)\
    \ + 2) % alphabet.length\n                alphabet(index).toUpper\n          \
    \  } else {\n                c\n            }\n        })\n        encoded", " \
    \       val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encodeMap = vowels.map(v => (v, alphabet(alphabetMap(v) + 2))).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) encodeMap(c.toLower)\
    \ else c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString", "     \
    \   val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "     \
    \   val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alpha = ('a' to 'z').toList\n\
    \        val alphaMap = alpha.zipWithIndex.toMap\n        val alphaMap2 = alpha.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphaMap3 = alpha.zipWithIndex.map(x =>\
    \ (x._2 + 2, x._1)).toMap\n        val alphaMap4 = alpha.zipWithIndex.map(x =>\
    \ (x._2 + 2, x._1)).toMap\n        val alphaMap5 = alpha.zipWithIndex.map(x =>\
    \ (x._2 + 2, x._1)).toMap\n        val alphaMap6 = alpha.zipWithIndex.map(x =>\
    \ (x._2 + 2, x._1)).toMap\n        val alphaMap7 = alpha.zipWithIndex.map(x =>\
    \ (x._2 + 2, x._1)).toMap\n        val alphaMap8 = alpha.zipWithIndex.map(x =>\
    \ (x._2 + 2, x._1)).toMap\n        val alphaMap9 = alpha.zipWithIndex.map(x =>\
    \ (x._2 + 2, x._1)).toMap\n        val alphaMap10 = alpha.zipWithIndex.map(x =>\
    \ (x._2 + 2, x._1)).toMap\n        val alphaMap11 = alpha.zipWithIndex.map(x =>\
    \ (x._2 + 2, x._1)).toMap\n        val alphaMap12 = alpha.zipWithIndex.map(x =>\
    \ (x._2 + 2, x._1)).toMap\n        val alphaMap13 = alpha.zipWithIndex.map(x =>\
    \ (x._2 + 2, x._1)).toMap\n        val alphaMap14 = alpha.zipWithIndex.map(x =>\
    \ (x._2 + 2, x._1)).toMap\n        val alphaMap15 = alpha.zipWithIndex.map(x =>\
    \ (x._2 + 2, x._1)).toMap\n        val alphaMap16 = alpha.zipWithIndex.map(x =>\
    \ (x._2 + 2, x._1)).toMap\n        val alphaMap17 = alpha.zipWithIndex.map", " \
    \       val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 2) % 5)).toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 2) % 26)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap4 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap5 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap6 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap7 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap8 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap9 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap10 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap11 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap12 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap13 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap14", "        //\
    \ Write your code here\n        return \"\"", "        val vowels = Set('a', 'e',\
    \ 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(c\
    \ => if (vowels.contains(c)) alphabet((alphabetMap(c) + 2) % alphabet.length)\
    \ else c)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(c => if (c.isUpper) encodedAlphabetMap(c.toLower).toUpper\
    \ else encodedAlphabetMap(c))", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap4 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap5 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap6 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap7 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap8 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap9 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap10 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap11 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap12 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap13 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap14 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap15 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap16 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap17 = alphabet.zipWithIndex.map",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        })\n\
    \        encoded", "        val vowels = List('a', 'e', 'i', 'o', 'u')\n     \
    \   val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 ->\
    \ x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x)", "        var result = \"\"\n        for (c <- message) {\n       \
    \     if (c.isUpper) result += c.toLower\n            else if (c.isLower) result\
    \ += c.toUpper\n            else result += c\n        }\n        result", "  \
    \      val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to\
    \ 'z'\n        val alphabetMap = alphabet.zip(alphabet.tail :+ 'a').toMap\n  \
    \      message.map(c => if (vowels.contains(c.toLower)) alphabetMap(c.toLower)\
    \ else c).map(c => if (c.isUpper) c.toLower else c.toUpper)", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n  \
    \          } else {\n                c.toUpper\n            }\n        })\n  \
    \      encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val\
    \ alphabet = 'a' to 'z'\n        val alphabetMap = alphabet.zip(alphabet.tail\
    \ :+ 'a').toMap\n        message.map(x => if (vowels.contains(x.toLower)) alphabetMap(x.toLower)\
    \ else x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabet2 = alphabet.tail + alphabet.head\n        val alphabet3\
    \ = alphabet2.tail + alphabet2.head\n        val alphabet4 = alphabet3.tail +\
    \ alphabet3.head\n        val alphabet5 = alphabet4.tail + alphabet4.head\n  \
    \      val alphabet6 = alphabet5.tail + alphabet5.head\n        val alphabet7\
    \ = alphabet6.tail + alphabet6.head\n        val alphabet8 = alphabet7.tail +\
    \ alphabet7.head\n        val alphabet9 = alphabet8.tail + alphabet8.head\n  \
    \      val alphabet10 = alphabet9.tail + alphabet9.head\n        val alphabet11\
    \ = alphabet10.tail + alphabet10.head\n        val alphabet12 = alphabet11.tail\
    \ + alphabet11.head\n        val alphabet13 = alphabet12.tail + alphabet12.head\n\
    \        val alphabet14 = alphabet13.tail + alphabet13.head\n        val alphabet15\
    \ = alphabet14.tail + alphabet14.head\n        val alphabet16 = alphabet15.tail\
    \ + alphabet15.head\n        val alphabet17 = alphabet16.tail + alphabet16.head\n\
    \        val alphabet18 = alphabet17.tail + alphabet17.head\n        val alphabet19\
    \ = alphabet18.tail + alphabet18.head\n        val alphabet20 = alphabet19.tail\
    \ + alphabet19.head\n        val alphabet21 = alphabet20.tail + alphabet20.head\n\
    \        val alphabet22 = alphabet21.tail + alphabet21.head\n        val alphabet23\
    \ = alphabet22.tail + alphabet22.head\n        val alphabet24 = alphabet23.tail\
    \ + alphabet23.head\n        val alphabet25 = alphabet24.tail + alphabet24.head\n\
    \        val alphabet26 = alphabet25.tail + alphabet25.head\n        val alphabet27\
    \ = alphabet26.tail + alphabet26.head\n        val alphabet28 = alphabet27.tail\
    \ + alphabet27.head\n        val alphabet29 = alphabet28.tail + alphabet28.head\n\
    \        val alphabet30 = alphabet29.tail + alphabet29.head\n        val alphabet31\
    \ = alphabet30.tail + alphabet30.head\n        val alphabet32 = alphabet31.tail\
    \ + alphabet31.head\n        val alphabet33 = alphabet32.tail + alphabet32.head\n\
    \       ", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetArray = alphabet.toArray\n\
    \        val vowelsArray = vowels.toArray\n        val messageArray = message.toArray\n\
    \        for (i <- 0 until messageArray.length) {\n            if (vowels.contains(messageArray(i)))\
    \ {\n                messageArray(i) = vowelsArray((vowelsMap(messageArray(i))\
    \ + 2) % vowelsArray.length)\n            }\n            else if (alphabet.contains(messageArray(i)))\
    \ {\n                messageArray(i) = alphabetArray((alphabetMap(messageArray(i))\
    \ + 2) % alphabetArray.length)\n            }\n        }\n        return messageArray.mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encodedAlphabet = alphabet.map(x => {\n            if (vowels.contains(x))\
    \ {\n                val index = alphabetMap(x)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex)\n      \
    \      } else x\n        })\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => {\n            if (x.isUpper) {\n                encodedAlphabetMap(x.toLower).toUpper\n\
    \            } else encodedAlphabetMap(x)\n        })", "        val vowels =\
    \ \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val\
    \ alphabet2 = alphabet + alphabet\n        val vowels2 = alphabet2.substring(alphabet.indexOf(\"\
    c\"), alphabet.indexOf(\"c\") + 5)\n        val map = Map[Char, Char]() ++ vowels.zip(vowels2)\n\
    \        message.map(c => if (vowels.contains(c.toLower)) map(c.toLower) else\
    \ c)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        message.map(x => if (vowels.contains(x.toLower)) alphabet((alphabet.indexOf(x.toLower)\
    \ + 2) % 26) else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encodedAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x)\
    \ + 2) % alphabet.length) else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper\
    \ else encodedAlphabetMap(x))", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = 'a' to 'z'\n        val alphabetMap = alphabet.zip(alphabet.tail\
    \ :+ 'a').toMap\n        message.map(c => if (vowels.contains(c.toLower)) alphabetMap(c.toLower)\
    \ else c)", "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        val vowelsMap = Map(\n            'a' -> 'c',\n\
    \            'e' -> 'g',\n            'i' -> 'k',\n            'o' -> 'q',\n \
    \           'u' -> 's'\n        )\n        val letterMap = Map(\n            'a'\
    \ -> 'A',\n            'b' -> 'B',\n            'c' -> 'C',\n            'd' ->\
    \ 'D',\n            'e' -> 'E',\n            'f' -> 'F',\n            'g' -> 'G',\n\
    \            'h' -> 'H',\n            'i' -> 'I',\n            'j' -> 'J',\n \
    \           'k' -> 'K',\n            'l' -> 'L',\n            'm' -> 'M',\n  \
    \          'n' -> 'N',\n            'o' -> 'O',\n            'p' -> 'P',\n   \
    \         'q' -> 'Q',\n            'r' -> 'R',\n            's' -> 'S',\n    \
    \        't' -> 'T',\n            'u' -> 'U',\n            'v' -> 'V',\n     \
    \       'w' -> 'W',\n            'x' -> 'X',\n            'y' -> 'Y',\n      \
    \      'z' -> 'Z'\n        )\n        val letterMap2 = Map(\n            'A' ->\
    \ 'a',\n            'B' -> 'b',\n            'C' -> 'c',\n            'D' -> 'd',\n\
    \            'E' -> 'e',\n            'F' -> 'f',\n            'G' -> 'g',\n \
    \           'H' -> 'h',\n            'I' -> 'i',\n            'J' -> 'j',\n  \
    \          'K' -> 'k',\n            'L' -> 'l',\n            'M' -> 'm',\n   \
    \         'N' -> 'n',\n            'O' -> 'o',\n            'P' -> 'p',\n    \
    \        'Q' -> 'q',\n            'R' -> 'r',\n            '", "        val vowels\
    \ = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to 'z'\n       \
    \ val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val encoded = message.map(x => {\n         \
    \   if (vowels.contains(x.toLower)) {\n                val index = alphabetMap(x.toLower)\n\
    \                val index2 = (index + 2) % 26\n                alphabetMap2(index2).toString.toUpperCase\n\
    \            } else {\n                x.toString.toUpperCase\n            }\n\
    \        })\n        encoded.mkString", "        val vowels = List('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encodedMessage = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val nextIndex\
    \ = (index + 2) % vowels.length\n                val nextVowel = vowels(nextIndex)\n\
    \                if (c.isUpper) nextVowel.toUpper else nextVowel\n           \
    \ } else {\n                val index = alphabetMap(c.toLower)\n             \
    \   val nextIndex = (index + 2) % alphabet.length\n                val nextLetter\
    \ = alphabet(nextIndex)\n                if (c.isUpper) nextLetter.toUpper else\
    \ nextLetter\n            }\n        })\n        encodedMessage.mkString", " \
    \       val vowels = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetList = alphabet.toList\n  \
    \      val vowelsList = vowels.toList\n        val alphabetMap2 = alphabet.zipWithIndex.toMap.map(x\
    \ => (x._1, (x._2 + 2) % alphabet.length))\n        val vowelsMap2 = vowels.zipWithIndex.toMap.map(x\
    \ => (x._1, (x._2 + 2) % vowels.length))\n        message.map(x => if (vowels.contains(x))\
    \ vowelsList(vowelsMap2(x)) else alphabetList(alphabetMap2(x)))", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x\
    \ => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower)) else\
    \ x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "        val\
    \ vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        })\n\
    \        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n      \
    \  val alphabet = 'a' to 'z'\n        val alphabetMap = alphabet.zip(alphabet.drop(2)\
    \ ++ alphabet.take(2)).toMap\n        message.map(c => if (vowels.contains(c.toLower))\
    \ alphabetMap(c.toLower) else c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val shift = 2\n        val encodeMap = alphabet.map(x => (x, alphabet((alphabetMap(x)\
    \ + shift) % alphabet.size))).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ encodeMap(x.toLower) else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetSize = alphabet.size\n        message.map(c => {\n          \
    \  if (vowels.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                val newIndex = (index + 2) % alphabetSize\n                val\
    \ newChar = alphabet(newIndex)\n                if (c.isUpper) newChar.toUpper\
    \ else newChar\n            } else {\n                if (c.isUpper) c.toLower\
    \ else c.toUpper\n            }\n        })", "        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val vowelsMap2 = vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val result = new StringBuilder\n        for (c <- message) {\n       \
    \     if (c.isUpper) {\n                if (vowels.contains(c.toLower)) {\n  \
    \                  val index = vowelsMap(c.toLower)\n                    val newIndex\
    \ = (index + 2) % 5\n                    result += vowelsMap2(newIndex).toUpper\n\
    \                } else {\n                    val index = alphabetMap(c.toLower)\n\
    \                    val newIndex = (index + 2) % 26\n                    result\
    \ += alphabetMap2(newIndex).toUpper\n                }\n            } else {\n\
    \                if (vowels.contains(c)) {\n                    val index = vowelsMap(c)\n\
    \                    val newIndex = (index + 2) % 5\n                    result\
    \ += vowelsMap2(newIndex)\n                } else {\n                    val index\
    \ = alphabetMap(c)\n                    val newIndex = (index + 2) % 26\n    \
    \                result += alphabetMap2(newIndex)\n                }\n       \
    \     }\n        }\n        result.toString", "        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val encoded =\
    \ new StringBuilder\n        for (c <- message) {\n            if (c.isLetter)\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ if (vowels.contains(c.toLower)) {\n                    val newIndex = (index\
    \ + 2) % 26\n                    encoded += alphabet(newIndex).toUpper\n     \
    \           } else {\n                    encoded += alphabet(index).toUpper\n\
    \                }\n            } else {\n                encoded += c\n     \
    \       }\n        }\n        encoded.toString", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        def encodeChar(c : Char) : Char = {\n      \
    \      if (vowels.contains(c)) {\n                val index = alphabetMap(c)\n\
    \                alphabetMap2((index + 2) % 26)\n            } else {\n      \
    \          if (c.isUpper) c.toLower else c.toUpper\n            }\n        }\n\
    \        message.map(encodeChar)", "        val vowels = List('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val vowelMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                val newVowel = vowels(newIndex)\n\
    \                if (c.isUpper) newVowel.toUpper else newVowel\n            }\
    \ else if (c.isUpper) {\n                val index = alphabetMap(c.toLower)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabet(newIndex).toUpper\n            } else {\n                val index\
    \ = alphabetMap(c)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex)\n            }\n        })\n        encoded.mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = (vowelsMap(c.toLower)\
    \ + 2) % vowels.length\n                vowels(index).toUpper\n            } else\
    \ {\n                if (c.isUpper) alphabet(alphabetMap(c.toLower)).toUpper else\
    \ alphabet(alphabetMap(c))\n            }\n        })\n        encoded", "   \
    \     val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c)) {\n\
    \                val index = alphabetMap(c)\n                val nextIndex = (index\
    \ + 2) % alphabet.length\n                alphabet(nextIndex)\n            } else\
    \ {\n                c\n            }\n        }\n        message.map(c => if\
    \ (c.isUpper) encodeChar(c.toLower).toUpper else encodeChar(c)).mkString", " \
    \       var result = \"\"\n        for (c <- message) {\n            if (c.isUpper)\
    \ result += c.toLower\n            else if (c.isLower) result += c.toUpper\n \
    \           else result += c\n        }\n        result = result.replaceAll(\"\
    a\", \"c\")\n        result = result.replaceAll(\"e\", \"g\")\n        result\
    \ = result.replaceAll(\"i\", \"k\")\n        result = result.replaceAll(\"o\"\
    , \"q\")\n        result = result.replaceAll(\"u\", \"w\")\n        result", " \
    \       val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val vowelsMap = vowels.zipWithIndex.toMap\n        val encodedVowels = vowels.map(v\
    \ => {\n            val index = vowelsMap(v)\n            val newIndex = (index\
    \ + 2) % vowels.length\n            vowels(newIndex)\n        })\n        val\
    \ encodedVowelsMap = vowels.zip(encodedVowels).toMap\n        val encodedAlphabet\
    \ = alphabet.map(c => {\n            if (vowels.contains(c)) encodedVowelsMap(c)\n\
    \            else if (c.isUpper) c.toLower\n            else c.toUpper\n     \
    \   })\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(c => encodedAlphabetMap(c))", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ map = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'y')\n    \
    \    message.map(x => if (vowels.contains(x)) map(x) else x).map(x => if (x.isUpper)\
    \ x.toLower else x.toUpper).mkString", "        var result = \"\"\n        for\
    \ (c <- message) {\n            if (c.isUpper) {\n                result += c.toLower\n\
    \            } else if (c.isLower) {\n                result += c.toUpper\n  \
    \          } else {\n                result += c\n            }\n        }\n \
    \       result", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val\
    \ alphabet = 'a' to 'z'\n        val map = alphabet.zip(alphabet.drop(2) ++ alphabet.take(2)).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) map(c.toLower) else\
    \ c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString", "        val\
    \ vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        var encoded = \"\"\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowels.indexOf(c.toLower)\n                val\
    \ newIndex = (index + 2) % vowels.length\n                encoded += vowels(newIndex).toUpper\n\
    \            } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabet.indexOf(c.toLower)\n                val newIndex = (index + 2) %\
    \ alphabet.length\n                encoded += alphabet(newIndex).toUpper\n   \
    \         } else {\n                encoded += c\n            }\n        }\n \
    \       encoded", "        val vowels = List('a', 'e', 'i', 'o', 'u')\n      \
    \  val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageList = message.toLowerCase.toList\n        val messageList2\
    \ = messageList.map(x => if (vowels.contains(x)) alphabetMap2((alphabetMap(x)\
    \ + 2) % 26) else x)\n        messageList2.map(x => if (x.isUpper) x.toLower else\
    \ x.toUpper).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n \
    \       val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 ->\
    \ x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetList = alphabet.toList\n  \
    \      val vowelsList = vowels.toList\n        val messageList = message.toList\n\
    \        val encodedList = messageList.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowelsList.length\n                val newVowel = vowelsList(newIndex)\n\
    \                if (c.isUpper) newVowel.toUpper else newVowel\n            }\
    \ else if (alphabet.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                val newIndex = (index + 2) % alphabetList.length\n          \
    \      val newLetter = alphabetList(newIndex)\n                if (c.isUpper)\
    \ newLetter.toUpper else newLetter\n            } else c\n        })\n       \
    \ encodedList.mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map", "        val vowels =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n \
    \       def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        }\n        message.map(c => if (c.isUpper) encodeChar(c.toLower).toUpper\
    \ else encodeChar(c)).mkString", "        val vowels = \"aeiou\"\n        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabet2 = alphabet\
    \ + alphabet\n        val vowels2 = alphabet2.substring(alphabet.indexOf(\"c\"\
    ), alphabet.indexOf(\"c\") + 5)\n        val message2 = message.toLowerCase\n\
    \        val message3 = message2.map(x => if (vowels.contains(x)) vowels2(vowels.indexOf(x))\
    \ else x)\n        val message4 = message3.map(x => if (alphabet.contains(x))\
    \ alphabet2(alphabet.indexOf(x)) else x)\n        message4.toUpperCase", "   \
    \     val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val map = Map[Char, Char]()\n        for (i <- 0 until alphabet.length)\
    \ {\n            val next = (i + 2) % alphabet.length\n            map += (alphabet(i)\
    \ -> alphabet(next))\n        }\n        message.map(c => if (vowels.contains(c.toLower))\
    \ map(c.toLower) else c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        var encoded = \"\"\n        for (c <- message) {\n            if (c.isUpper)\
    \ {\n                encoded += c.toLower\n            } else if (c.isLower) {\n\
    \                encoded += c.toUpper\n            } else {\n                encoded\
    \ += c\n            }\n        }\n        encoded", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ encoding = alphabet.zip(alphabet.drop(2) ::: alphabet.take(2)).toMap\n     \
    \   message.map(c => if (vowels.contains(c.toLower)) encoding(c.toLower) else\
    \ c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ alphabet((index + 2) % alphabet.length)\n            } else {\n            \
    \    c\n            }\n        })\n        encoded.map(c => if (c.isUpper) c.toLower\
    \ else c.toUpper).mkString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex).toUpper\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n\
    \            } else {\n                c\n            }\n        })\n        encoded",
  "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val encoded = message.toLowerCase.map(c => {\n     \
    \       if (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n\
    \                alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        })\n        encoded.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val map = alphabet.zip(alphabet.drop(2)\
    \ ++ alphabet.take(2)).toMap\n        message.map(c => if (vowels.contains(c.toLower))\
    \ map(c.toLower) else c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map", "        val vowels =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n \
    \       def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        }\n        message.map(c => if (c.isUpper) encodeChar(c.toLower).toUpper\
    \ else encodeChar(c)).mkString", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val mapping = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q',\
    \ 'u' -> 's')\n        message.map(c => if (vowels.contains(c)) mapping(c) else\
    \ c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString", "        val\
    \ vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val nextIndex = (index + 2) % vowels.length\n               \
    \ val nextVowel = vowels(nextIndex)\n                if (c.isUpper) nextVowel.toUpper\
    \ else nextVowel\n            } else if (c.isUpper) c.toLower else c.toUpper\n\
    \        })\n        encoded", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val alphabetMap2 =\
    \ alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val vowelsMap2 =\
    \ vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n        message.map(x => {\n\
    \            if (x.isUpper) {\n                alphabetMap2(alphabetMap(x.toLower.toString)\
    \ + 2).toUpper\n            } else if (vowelsMap.contains(x.toLower.toString))\
    \ {\n                vowelsMap2(vowelsMap(x.toLower.toString) + 2)\n         \
    \   } else {\n                x\n            }\n        })", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        def encodeChar(c\
    \ : Char) : Char = {\n            val upper = c.isUpper\n            val lower\
    \ = c.toLower\n            if (vowels.contains(lower)) {\n                val\
    \ index = alphabetMap(lower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                val newChar = alphabet(newIndex)\n                if (upper)\
    \ newChar.toUpper else newChar\n            } else {\n                if (upper)\
    \ lower.toUpper else lower\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val shift = 2\n    \
    \    message.map(c => if (vowels.contains(c.toLower)) (c + shift).toChar else\
    \ c)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = for (c <- message) yield\
    \ {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val nextIndex = (index + 2) % vowels.length\n\
    \                val nextVowel = vowels(nextIndex)\n                if (c.isUpper)\
    \ nextVowel.toUpper else nextVowel\n            } else {\n                val\
    \ index = alphabetMap(c.toLower)\n                val nextIndex = (index + 2)\
    \ % alphabet.length\n                val nextLetter = alphabet(nextIndex)\n  \
    \              if (c.isUpper) nextLetter.toUpper else nextLetter\n           \
    \ }\n        }\n        encoded.mkString", "        val vowels = \"aeiou\"\n \
    \       val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = new StringBuilder\n        for (c <- message) {\n     \
    \       if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val nextIndex = (index + 2) % vowels.length\n               \
    \ encoded += vowels(nextIndex).toUpper\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val nextIndex\
    \ = (index + 2) % alphabet.length\n                encoded += alphabet(nextIndex).toUpper\n\
    \            } else {\n                encoded += c\n            }\n        }\n\
    \        encoded.toString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabet2 = \"cdefghijklmnopqrstuvwxyzab\"\
    \n        val vowels2 = \"cgjkqsxyz\"\n        val map = Map[Char, Char]()\n \
    \       for (i <- 0 until alphabet.length) {\n            map += (alphabet(i)\
    \ -> alphabet2(i))\n        }\n        for (i <- 0 until vowels.length) {\n  \
    \          map += (vowels(i) -> vowels2(i))\n        }\n        var result = \"\
    \"\n        for (c <- message) {\n            result += map(c)\n        }\n  \
    \      result", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val next = (index + 2) % vowels.length\n                vowels(next).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        })\n\
    \        encoded", "        val vowels = \"aeiou\"\n        val alphabet = \"\
    abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = (alphabet zip alphabet.tail).toMap\n\
    \        val alphabetMap2 = (alphabet zip alphabet.tail.tail).toMap\n        val\
    \ alphabetMap3 = (alphabet zip alphabet.tail.tail.tail).toMap\n        val alphabetMap4\
    \ = (alphabet zip alphabet.tail.tail.tail.tail).toMap\n        val alphabetMap5\
    \ = (alphabet zip alphabet.tail.tail.tail.tail.tail).toMap\n        val alphabetMap6\
    \ = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail).toMap\n        val alphabetMap7\
    \ = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail).toMap\n       \
    \ val alphabetMap8 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap9 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap10 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap11 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap12 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap13 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap14 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap15 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap16 = (alphabet zip alphabet.tail.tail", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetSize\
    \ = alphabet.size\n        message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabetSize\n                val newChar = alphabet(newIndex)\n\
    \                if (c.isUpper) newChar.toUpper else newChar\n            } else\
    \ if (c.isUpper) c.toLower else c.toUpper\n        })", "        val vowels =\
    \ \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n  \
    \          } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex).toUpper\n            } else {\n          \
    \      c\n            }\n        })\n        encoded", "        val vowels = \"\
    aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val vowelsMap2 = vowels.zipWithIndex.map(x => (x._1, (x._2 + 2) % 5)).toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._1, (x._2 + 2) %\
    \ 26)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._1,\
    \ (x._2 + 24) % 26)).toMap\n        val alphabetMap4 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap5 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap6 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap7 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap8 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap9 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap10 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap11 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap12 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap13 = alphabet.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 26)).toMap\n        val alphabetMap14", "        val\
    \ vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet\
    \ = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) %\
    \ 26) else x)\n        val alphabetMapEncoded = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (alphabet.contains(x)) alphabetMapEncoded(x) else\
    \ x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        def encodeChar(c\
    \ : Char) : Char = {\n            if (vowels.contains(c)) {\n                val\
    \ index = alphabetMap(c)\n                alphabetMap2((index + 2) % alphabet.length)\n\
    \            } else if (c.isUpper) {\n                c.toLower\n            }\
    \ else {\n                c.toUpper\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetList = alphabet.toList\n  \
    \      val vowelsList = vowels.toList\n        val messageList = message.toList\n\
    \        val encodedList = messageList.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowelsList.length\n                vowelsList(newIndex).toUpper\n\
    \            } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabetList.length\n\
    \                alphabetList(newIndex).toUpper\n            } else {\n      \
    \          c\n            }\n        })\n        encodedList.mkString", "    \
    \    val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val shift = 2\n        val shiftedAlphabet = alphabet.drop(shift) ++ alphabet.take(shift)\n\
    \        val shiftedAlphabetMap = shiftedAlphabet.zipWithIndex.toMap\n       \
    \ val shiftedAlphabetSet = shiftedAlphabet.toSet\n        val shiftedVowels =\
    \ vowels.map(v => shiftedAlphabet(alphabetMap(v)))\n        val shiftedVowelsSet\
    \ = shiftedVowels.toSet\n        val shiftedVowelsMap = shiftedVowels.zipWithIndex.toMap\n\
    \        val shiftedVowelsMapReverse = shiftedVowelsMap.map(_.swap)\n        val\
    \ shiftedVowelsMapReverse2 = shiftedVowelsMapReverse.map(p => (p._1 + shift) ->\
    \ p._2)\n        val shiftedVowelsMapReverse3 = shiftedVowelsMapReverse2.map(p\
    \ => (p._1 % 26) -> p._2)\n        val shiftedVowelsMapReverse4 = shiftedVowelsMapReverse3.map(p\
    \ => alphabet(p._1) -> p._2)\n        val shiftedVowelsMapReverse5 = shiftedVowelsMapReverse4.map(p\
    \ => p._1.toUpper -> p._2)\n        val shiftedVowelsMapReverse6 = shiftedVowelsMapReverse5.map(p\
    \ => p._1.toLower -> p._2)\n        val shiftedVowelsMapReverse7 = shiftedVowelsMapReverse6.map(p\
    \ => p._1.toUpper -> p._2)\n        val shiftedVowelsMapReverse8 = shiftedVowelsMapReverse7.map(p\
    \ => p._1.toLower -> p._2)\n        val shiftedVowelsMapReverse9 = shiftedVowelsMapReverse8.map(p\
    \ => p._1.toUpper -> p._2)\n        val shiftedVowelsMapReverse", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetSize\
    \ = alphabet.size\n        val encoded = message.map(c => {\n            if (c.isUpper)\
    \ c.toLower else c\n        }).map(c => {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                val newIndex\
    \ = (index + 2) % alphabetSize\n                alphabet(newIndex)\n         \
    \   } else c\n        }).map(c => {\n            if (c.isLower) c.toUpper else\
    \ c\n        })\n        encoded.mkString", "        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabet2\
    \ = alphabet + alphabet\n        val alphabet3 = alphabet2 + alphabet\n      \
    \  val alphabet4 = alphabet3 + alphabet\n        val alphabet5 = alphabet4 + alphabet\n\
    \        val alphabet6 = alphabet5 + alphabet\n        val alphabet7 = alphabet6\
    \ + alphabet\n        val alphabet8 = alphabet7 + alphabet\n        val alphabet9\
    \ = alphabet8 + alphabet\n        val alphabet10 = alphabet9 + alphabet\n    \
    \    val alphabet11 = alphabet10 + alphabet\n        val alphabet12 = alphabet11\
    \ + alphabet\n        val alphabet13 = alphabet12 + alphabet\n        val alphabet14\
    \ = alphabet13 + alphabet\n        val alphabet15 = alphabet14 + alphabet\n  \
    \      val alphabet16 = alphabet15 + alphabet\n        val alphabet17 = alphabet16\
    \ + alphabet\n        val alphabet18 = alphabet17 + alphabet\n        val alphabet19\
    \ = alphabet18 + alphabet\n        val alphabet20 = alphabet19 + alphabet\n  \
    \      val alphabet21 = alphabet20 + alphabet\n        val alphabet22 = alphabet21\
    \ + alphabet\n        val alphabet23 = alphabet22 + alphabet\n        val alphabet24\
    \ = alphabet23 + alphabet\n        val alphabet25 = alphabet24 + alphabet\n  \
    \      val alphabet26 = alphabet25 + alphabet\n        val alphabet27 = alphabet26\
    \ + alphabet\n        val alphabet28 = alphabet27 + alphabet\n        val alphabet29\
    \ = alphabet28 + alphabet\n        val alphabet30 = alphabet29 + alphabet\n  \
    \      val alphabet31 = alphabet30 + alphabet\n        val alphabet32 = alphabet31\
    \ + alphabet\n        val alphabet33 = alphabet32 + alphabet\n        val alphabet34\
    \ = alphabet33 + alphabet\n        val alphabet35 = alphabet34 + alphabet\n  \
    \      val alphabet36 = alphabet35 + alphabet\n        val alphabet37 = alphabet36\
    \ + alphabet\n        val alphabet38 = alphabet37 + alphabet\n        val alphabet39\
    \ = alphabet38 + alphabet\n        val alphabet40 = alphabet39 + alphabet\n  \
    \      val alphabet41 = alphabet40 + alphabet\n        val alphabet42 = alphabet41\
    \ + alphabet\n        val alphabet43 = alphabet42 + alphabet\n        val alphabet44\
    \ = alphabet43 + alphabet\n        val alphabet45 = alphabet44 + alphabet\n  \
    \      val alphabet46 = alphabet45 + alphabet\n        val alphabet47 = alphabet46\
    \ + alphabet\n        val alphabet48 = alphabet47 + alphabet\n        val alphabet49\
    \ = alphabet48 + alphabet\n", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val encoded = for (c <- message)\
    \ yield {\n            if (vowels.contains(c.toLower)) {\n                val\
    \ index = alphabet.indexOf(c.toLower)\n                alphabet((index + 2) %\
    \ alphabet.length)\n            } else {\n                c\n            }\n \
    \       }\n        encoded.mkString", "        val vowels = List('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        val messageList = message.toLowerCase.toList\n\
    \        val encodedList = messageList.map(x => if (vowels.contains(x)) alphabetMap2(alphabetMap(x))\
    \ else x)\n        encodedList.map(x => if (x.isUpper) x.toLower else x.toUpper).mkString",
  "        var result = \"\"\n        for (c <- message) {\n            if (c.isUpper)\
    \ result += c.toLower\n            else if (c.isLower) result += c.toUpper\n \
    \           else result += c\n        }\n        result", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val vowelsMap2 = vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val encoded = message.map(x => {\n            if (vowels.contains(x.toLower))\
    \ {\n                val index = vowelsMap(x.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowelsMap2(newIndex)\n      \
    \      } else if (alphabet.contains(x.toLower)) {\n                val index =\
    \ alphabetMap(x.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabetMap2(newIndex)\n            } else {\n              \
    \  x\n            }\n        })\n        encoded.map(x => if (x.isUpper) x.toLower\
    \ else x.toUpper).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        def shift(c : Char) : Char = {\n            if (vowels.contains(c)) {\n\
    \                val index = (c - 'a' + 2) % 26\n                ('a' + index).toChar\n\
    \            } else {\n                c\n            }\n        }\n        message.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).map(shift)", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encodeMap\
    \ = alphabet.zip(alphabet.drop(2) ++ alphabet.take(2)).toMap\n        message.map(c\
    \ => if (vowels.contains(c.toLower)) encodeMap(c.toLower) else c)", "        val\
    \ vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex).toUpper\n            } else {\n          \
    \      c\n            }\n        })\n        encoded", "        val vowels = \"\
    aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelMap(c.toLower)\n                val nextIndex\
    \ = (index + 2) % vowels.length\n                val nextVowel = vowels(nextIndex)\n\
    \                if (c.isUpper) nextVowel.toUpper else nextVowel\n           \
    \ } else {\n                val index = alphabetMap(c.toLower)\n             \
    \   val nextIndex = (index + 2) % alphabet.length\n                val nextLetter\
    \ = alphabet(nextIndex)\n                if (c.isUpper) nextLetter.toUpper else\
    \ nextLetter\n            }\n        })\n        encoded", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val alphabetMap3\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap4\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap5\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap6\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap7\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap8\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap9\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap10\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap11\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap12\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap13\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap14\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap15\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap16\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap17\
    \ = alphabet.zipWithIndex.map", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val nextIndex = (index + 2) % vowels.length\n\
    \                vowels(nextIndex).toUpper\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val nextIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(nextIndex).toUpper\n\
    \            } else {\n                c\n            }\n        })\n        encoded",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to\
    \ 'z'\n        val alphabetMap = alphabet.zip(alphabet.tail ++ alphabet.take(1)).toMap\n\
    \        val encodeMap = alphabetMap ++ alphabetMap.map(_.swap)\n        message.map(c\
    \ => if (vowels.contains(c.toLower)) alphabetMap(c.toLower) else c)", "      \
    \  val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val alphabetMap3\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        def encodeChar(c\
    \ : Char) : Char = {\n            if (vowels.contains(c)) alphabetMap3(alphabetMap(c))\n\
    \            else if (c.isUpper) alphabetMap2(alphabetMap(c.toLower)).toUpper\n\
    \            else alphabetMap2(alphabetMap(c))\n        }\n        message.map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val letters = ('a' to\
    \ 'z').toList\n        val lettersMap = letters.zipWithIndex.toMap\n        val\
    \ lettersMap2 = letters.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) lettersMap2(lettersMap(x.toLower))\
    \ else x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabet2 = alphabet + alphabet\n        val alphabet3 = alphabet2\
    \ + alphabet\n        val alphabet4 = alphabet3 + alphabet\n        val alphabet5\
    \ = alphabet4 + alphabet\n        val alphabet6 = alphabet5 + alphabet\n     \
    \   val alphabet7 = alphabet6 + alphabet\n        val alphabet8 = alphabet7 +\
    \ alphabet\n        val alphabet9 = alphabet8 + alphabet\n        val alphabet10\
    \ = alphabet9 + alphabet\n        val alphabet11 = alphabet10 + alphabet\n   \
    \     val alphabet12 = alphabet11 + alphabet\n        val alphabet13 = alphabet12\
    \ + alphabet\n        val alphabet14 = alphabet13 + alphabet\n        val alphabet15\
    \ = alphabet14 + alphabet\n        val alphabet16 = alphabet15 + alphabet\n  \
    \      val alphabet17 = alphabet16 + alphabet\n        val alphabet18 = alphabet17\
    \ + alphabet\n        val alphabet19 = alphabet18 + alphabet\n        val alphabet20\
    \ = alphabet19 + alphabet\n        val alphabet21 = alphabet20 + alphabet\n  \
    \      val alphabet22 = alphabet21 + alphabet\n        val alphabet23 = alphabet22\
    \ + alphabet\n        val alphabet24 = alphabet23 + alphabet\n        val alphabet25\
    \ = alphabet24 + alphabet\n        val alphabet26 = alphabet25 + alphabet\n  \
    \      val alphabet27 = alphabet26 + alphabet\n        val alphabet28 = alphabet27\
    \ + alphabet\n        val alphabet29 = alphabet28 + alphabet\n        val alphabet30\
    \ = alphabet29 + alphabet\n        val alphabet31 = alphabet30 + alphabet\n  \
    \      val alphabet32 = alphabet31 + alphabet\n        val alphabet33 = alphabet32\
    \ + alphabet\n        val alphabet34 = alphabet33 + alphabet\n        val alphabet35\
    \ = alphabet34 + alphabet\n        val alphabet36 = alphabet35 + alphabet\n  \
    \      val alphabet37 = alphabet36 + alphabet\n        val alphabet38 = alphabet37\
    \ + alphabet\n        val alphabet39 = alphabet38 + alphabet\n        val alphabet40\
    \ = alphabet39 + alphabet\n        val alphabet41 = alphabet40 + alphabet\n  \
    \      val alphabet42 = alphabet41 + alphabet\n        val alphabet43 = alphabet42\
    \ + alphabet\n        val alphabet44 = alphabet43 + alphabet\n        val alphabet45\
    \ = alphabet44 + alphabet\n        val alphabet46 = alphabet45 + alphabet\n  \
    \      val alphabet47 = alphabet46 + alphabet\n        val alphabet48 = alphabet47\
    \ + alphabet\n        val alphabet49 = alphabet48 + alphabet\n", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        message.map(c\
    \ => if (vowels.contains(c.toLower)) alphabet((alphabetMap(c.toLower) + 2) % 26)\
    \ else c)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c.toUpper\n \
    \           }\n        }\n        message.map(encodeChar).mkString", "       \
    \ val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val encodeMap\
    \ = alphabet.zipWithIndex.map(x => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n\
    \        val encodeMap2 = alphabet.zipWithIndex.map(x => (x._1, alphabetMap2((x._2\
    \ + 24) % 26))).toMap\n        val encodeMap3 = alphabet.zipWithIndex.map(x =>\
    \ (x._1, alphabetMap2((x._2 + 13) % 26))).toMap\n        val encodeMap4 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 23) % 26))).toMap\n        message.map(x => if\
    \ (vowels.contains(x)) encodeMap(x) else if (vowels.contains(x.toLower)) encodeMap2(x.toLower)\
    \ else if (vowels.contains(x.toUpper)) encodeMap3(x.toUpper) else encodeMap4(x.toUpper)).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map", "        val vowels =\
    \ \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetArray = alphabet.toArray\n        val vowelsArray = vowels.toArray\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = vowelsMap(c)\n                val nextIndex =\
    \ (index + 2) % vowelsArray.length\n                vowelsArray(nextIndex)\n \
    \           } else {\n                val index = alphabetMap(c)\n           \
    \     val nextIndex = (index + 2) % alphabetArray.length\n                alphabetArray(nextIndex)\n\
    \            }\n        }\n        message.map(c => if (c.isUpper) encodeChar(c.toLower).toUpper\
    \ else encodeChar(c)).mkString"]
stop_tokens:
- "\n    }\n"
