language: swift
name: HumanEval_93_encode
results:
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    // your code here\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmpruygbteh/tmpruygbteh.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49e2d32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b49e2a29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b49e2a29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49e2a287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpruygbteh                        0x0000561ca06d3307 <unavailable> + 4871

    5    libc.so.6                          0x00002b49e2f1e460 __libc_start_main +
    245

    6    tmpruygbteh                        0x0000561ca06d2f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824557
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    let vowels: Set<Character> = [\"a\"\
    , \"e\", \"i\", \"o\", \"u\"]\n    var encoded = String()\n    for char in message\
    \ {\n        if let ascii = char.asciiValue {\n            if ascii >= 97 && ascii\
    \ <= 122 {\n                if vowels.contains(char) {\n                    let\
    \ newAscii = ascii + 2\n                    if newAscii > 122 {\n            \
    \            let diff = newAscii - 122\n                        let newChar =\
    \ Character(UnicodeScalar(97 + diff - 1)!)\n                        encoded.append(newChar)\n\
    \                    } else {\n                        let newChar = Character(UnicodeScalar(newAscii)!)\n\
    \                        encoded.append(newChar)\n                    }\n    \
    \            } else {\n                    let newChar = Character(UnicodeScalar(ascii\
    \ - 32)!)\n                    encoded.append(newChar)\n                }\n  \
    \          } else if ascii >= 65 && ascii <= 90 {\n                if vowels.contains(char)\
    \ {\n                    let newAscii = ascii + 2\n                    if newAscii\
    \ > 90 {\n                        let diff = newAscii - 90\n                 \
    \       let newChar = Character(UnicodeScalar(65 + diff - 1)!)\n             \
    \           encoded.append(newChar)\n                    } else {\n          \
    \              let newChar = Character(UnicodeScalar(newAscii)!)\n           \
    \             encoded.append(newChar)\n                    }\n               \
    \ } else {\n                    let newChar = Character(UnicodeScalar(ascii +\
    \ 32)!)\n                    encoded.append(newChar)\n                }\n    \
    \        }\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpng9xcwzm.swift:22:77: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                        let newChar\
    \ = Character(UnicodeScalar(97 + diff - 1)!)\n                               \
    \                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n                            \
    \                                                \n/tmp/tmpng9xcwzm.swift:25:72:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                        let newChar = Character(UnicodeScalar(newAscii)!)\n \
    \                                               ~~~~~~~~~~~~~~~~~~~~~~~^\n   \
    \                                                                    \n/tmp/tmpng9xcwzm.swift:29:70:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                    let newChar = Character(UnicodeScalar(ascii - 32)!)\n   \
    \                                         ~~~~~~~~~~~~~~~~~~~~~~~~~^\n       \
    \                                                              \n/tmp/tmpng9xcwzm.swift:37:77:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                        let newChar = Character(UnicodeScalar(65 + diff - 1)!)\n\
    \                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \n\
    /tmp/tmpng9xcwzm.swift:40:72: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                        let newChar\
    \ = Character(UnicodeScalar(newAscii)!)\n                                    \
    \            ~~~~~~~~~~~~~~~~~~~~~~~^\n                                      \
    \                                 \n/tmp/tmpng9xcwzm.swift:44:70: error: cannot\
    \ force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                    let newChar = Character(UnicodeScalar(ascii + 32)!)\n   \
    \                                         ~~~~~~~~~~~~~~~~~~~~~~~~~^\n       \
    \                                         "
  stdout: ''
  timestamp: 1659824557
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    let letters = \"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ\"\
    \n    let vowels = \"aAeEiIoOuU\"\n    var newMessage = \"\"\n    for char in\
    \ message.characters {\n        if (letters.containsString(String(char))) {\n\
    \            if (vowels.containsString(String(char))) {\n                if (char\
    \ == \"u\") {\n                    newMessage += \"a\"\n                } else\
    \ if (char == \"U\") {\n                    newMessage += \"A\"\n            \
    \    } else {\n                    newMessage += String(characters[2])\n     \
    \           }\n            } else {\n                if (char == \"z\") {\n  \
    \                  newMessage += \"a\"\n                } else if (char == \"\
    Z\") {\n                    newMessage += \"A\"\n                } else {\n  \
    \                  newMessage += String(characters[2])\n                }\n  \
    \          }\n        } else {\n            newMessage += String(char)\n     \
    \   }\n    }\n    return newMessage\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpbxytj4_5.swift:16:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in message.characters {\n                \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpbxytj4_5.swift:17:21:\
    \ error: value of type 'String' has no member 'containsString'\n        if (letters.containsString(String(char)))\
    \ {\n            ~~~~~~~ ^~~~~~~~~~~~~~\n/tmp/tmpbxytj4_5.swift:18:24: error:\
    \ value of type 'String' has no member 'containsString'\n            if (vowels.containsString(String(char)))\
    \ {\n                ~~~~~~ ^~~~~~~~~~~~~~\n/tmp/tmpbxytj4_5.swift:24:42: error:\
    \ cannot find 'characters' in scope\n                    newMessage += String(characters[2])\n\
    \                                         ^~~~~~~~~~\n/tmp/tmpbxytj4_5.swift:32:42:\
    \ error: cannot find 'characters' in scope\n                    newMessage +=\
    \ String(characters[2])\n                                         ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824557
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    return message.split(separator: \"\
    \ \").map { $0.map {\n        switch $0 {\n        case \"a\", \"e\", \"i\", \"\
    o\", \"u\":\n            return characterAfterN(letters: \"abcdefghijklmnopqrstuvwxyz\"\
    , character: $0, n: 2)\n        default:\n            return $0.isLowercase ?\
    \ $0.uppercased() : $0.lowercased()\n        }\n    }}.joined(separator: \" \"\
    )\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpt9qepcr9.swift:16:20: error: cannot find 'characterAfterN' in scope\n\
    \            return characterAfterN(letters: \"abcdefghijklmnopqrstuvwxyz\", character:\
    \ $0, n: 2)\n                   ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824557
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmpuxy54hfc/tmpuxy54hfc.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38da61cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38da313b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38da313988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38da3127b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuxy54hfc                        0x000055bc3bde7307 <unavailable> + 4871

    5    libc.so.6                          0x00002b38da808460 __libc_start_main +
    245

    6    tmpuxy54hfc                        0x000055bc3bde6f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824430
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    let lowerCase = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    let upperCase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    let vowels = \"aeiou\"\
    \n    var encodedMessage = \"\"\n    for letter in message {\n        if lowerCase.contains(letter)\
    \ {\n            let index = lowerCase.index(of: letter)!\n            if vowels.contains(letter)\
    \ {\n                let encodedIndex = (index.encodedOffset + 2) % lowerCase.count\n\
    \                encodedMessage.append(lowerCase[lowerCase.index(lowerCase.startIndex,\
    \ offsetBy: encodedIndex)])\n            } else {\n                encodedMessage.append(lowerCase[lowerCase.index(lowerCase.startIndex,\
    \ offsetBy: index.encodedOffset)])\n            }\n        } else if upperCase.contains(letter)\
    \ {\n            let index = upperCase.index(of: letter)!\n            if vowels.contains(letter.lowercased())\
    \ {\n                let encodedIndex = (index.encodedOffset + 2) % upperCase.count\n\
    \                encodedMessage.append(upperCase[upperCase.index(upperCase.startIndex,\
    \ offsetBy: encodedIndex)])\n            } else {\n                encodedMessage.append(upperCase[upperCase.index(upperCase.startIndex,\
    \ offsetBy: index.encodedOffset)])\n            }\n        } else {\n        \
    \    encodedMessage.append(letter)\n        }\n    }\n    return encodedMessage\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmpda99tx94/tmpda99tx94.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aecfbe57c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aecfbb4eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aecfbb4e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aecfbb4d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpda99tx94                        0x000056059f6d1927 <unavailable> + 6439

    5    libc.so.6                          0x00002aecfc043460 __libc_start_main +
    245

    6    tmpda99tx94                        0x000056059f6d1569 <unavailable> + 5481

    '
  stdout: ''
  timestamp: 1659824557
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n  let vowelShift = 2\n  let vowels = \"\
    aeiouAEIOU\"\n  let alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  let encodedAlphabet = alphabet.substring(vowelShift) + alphabet.substring(0,\
    \ end: vowelShift - 1)\n  var result = \"\"\n  for character in message.characters\
    \ {\n    if vowels.contains(character) {\n      let index = alphabet.indexOf(character)\n\
    \      result += encodedAlphabet[index]\n    } else {\n      result += character\n\
    \    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp5311c3jo.swift:16:34: error: value of type 'String' has no member\
    \ 'substring'\n  let encodedAlphabet = alphabet.substring(vowelShift) + alphabet.substring(0,\
    \ end: vowelShift - 1)\n                        ~~~~~~~~ ^~~~~~~~~\n/tmp/tmp5311c3jo.swift:16:67:\
    \ error: value of type 'String' has no member 'substring'\n  let encodedAlphabet\
    \ = alphabet.substring(vowelShift) + alphabet.substring(0, end: vowelShift - 1)\n\
    \                                                         ~~~~~~~~ ^~~~~~~~~\n\
    /tmp/tmp5311c3jo.swift:18:28: error: 'characters' is unavailable: Please use String\
    \ directly\n  for character in message.characters {\n                        \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp5311c3jo.swift:20:28:\
    \ error: value of type 'String' has no member 'indexOf'\n      let index = alphabet.indexOf(character)\n\
    \                  ~~~~~~~~ ^~~~~~~\n/tmp/tmp5311c3jo.swift:23:17: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \ result += character\n                ^\n"
  stdout: ''
  timestamp: 1659824557
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\",\
    \ \"o\", \"u\"]\n    let shiftedMessage = message.map { (char) -> String in\n\
    \        if let index = vowels.firstIndex(of: String(char)) {\n            let\
    \ shiftedIndex = (index + 2) % vowels.count\n            return vowels[shiftedIndex]\n\
    \        } else {\n            return String(char)\n        }\n    }.map { $0.lowercased()\
    \ == $0 ? $0.uppercased() : $0.lowercased() }.joined()\n    return shiftedMessage\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmp35gu8wir/tmp35gu8wir.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8b4aff7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8b4aceeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8b4acee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8b4aced7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp35gu8wir                        0x0000557b88a298c7 <unavailable> + 6343

    5    libc.so.6                          0x00002b8b4b1e3460 __libc_start_main +
    245

    6    tmp35gu8wir                        0x0000557b88a29509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824557
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    let lowercase = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    let uppercase = [\"A\", \"E\", \"I\", \"O\", \"U\"]\n   \
    \ var encoded = \"\"\n    for letter in message.characters {\n        if lowercase.contains(String(letter))\
    \ {\n            let index = lowercase.index(of: String(letter))!\n          \
    \  encoded += lowercase[(index + 2) % 5]\n        } else if uppercase.contains(String(letter))\
    \ {\n            let index = uppercase.index(of: String(letter))!\n          \
    \  encoded += uppercase[(index + 2) % 5]\n        } else {\n            encoded\
    \ += String(letter)\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp0oesdujz.swift:16:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in message.characters {\n              \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp0oesdujz.swift:18:35: warning: 'index(of:)' is deprecated: renamed to\
    \ 'firstIndex(of:)'\n            let index = lowercase.index(of: String(letter))!\n\
    \                                  ^\n/tmp/tmp0oesdujz.swift:18:35: note: use\
    \ 'firstIndex(of:)' instead\n            let index = lowercase.index(of: String(letter))!\n\
    \                                  ^~~~~\n                                  firstIndex\n\
    /tmp/tmp0oesdujz.swift:21:35: warning: 'index(of:)' is deprecated: renamed to\
    \ 'firstIndex(of:)'\n            let index = uppercase.index(of: String(letter))!\n\
    \                                  ^\n/tmp/tmp0oesdujz.swift:21:35: note: use\
    \ 'firstIndex(of:)' instead\n            let index = uppercase.index(of: String(letter))!\n\
    \                                  ^~~~~\n                                  firstIndex\n"
  stdout: ''
  timestamp: 1659824557
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var encoded = \"\"\n    let vowels\
    \ = \"aeiou\"\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    for character\
    \ in message.lowercased() {\n        var character_index = alphabet.index(of:\
    \ character)\n        if let index = character_index {\n            if vowels.contains(character)\
    \ {\n                character_index = alphabet.index(index, offsetBy: 2)\n  \
    \          }\n            let encoded_char = alphabet[character_index!]\n    \
    \        encoded.append(encoded_char.uppercased())\n        } else {\n       \
    \     encoded.append(character)\n        }\n    }\n    return encoded\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmp4b1kxlhb/tmp4b1kxlhb.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0acbbc3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0acb8bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0acb8ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0acb8b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4b1kxlhb                        0x000055fcb40c9827 <unavailable> + 6183

    5    libc.so.6                          0x00002b0acbdaf460 __libc_start_main +
    245

    6    tmp4b1kxlhb                        0x000055fcb40c9469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659824557
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var output = \"\"\n    for char in\
    \ message.characters {\n        output += encodeChar(char)\n    }\n    return\
    \ output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpio_wsi7s.swift:14:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in message.characters {\n                \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpio_wsi7s.swift:15:19:\
    \ error: cannot find 'encodeChar' in scope\n        output += encodeChar(char)\n\
    \                  ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824557
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var vowels = Set<Character>()\n   \
    \ vowels.insert(\"a\")\n    vowels.insert(\"e\")\n    vowels.insert(\"i\")\n \
    \   vowels.insert(\"o\")\n    vowels.insert(\"u\")\n    vowels.insert(\"A\")\n\
    \    vowels.insert(\"E\")\n    vowels.insert(\"I\")\n    vowels.insert(\"O\")\n\
    \    vowels.insert(\"U\")\n    \n    var newString = String()\n    for char in\
    \ message.characters {\n        var newChar = char\n        if vowels.contains(char)\
    \ {\n            newChar = getCharacter(char: char, isAhead: true)\n        }\n\
    \        newChar = swapCase(char: newChar)\n        newString.append(newChar)\n\
    \    }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpt8ywnnyu.swift:26:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in message.characters {\n                \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpt8ywnnyu.swift:29:23:\
    \ error: cannot find 'getCharacter' in scope\n            newChar = getCharacter(char:\
    \ char, isAhead: true)\n                      ^~~~~~~~~~~~\n/tmp/tmpt8ywnnyu.swift:31:19:\
    \ error: cannot find 'swapCase' in scope\n        newChar = swapCase(char: newChar)\n\
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824557
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmpuxy54hfc/tmpuxy54hfc.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38da61cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38da313b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38da313988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38da3127b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuxy54hfc                        0x000055bc3bde7307 <unavailable> + 4871

    5    libc.so.6                          0x00002b38da808460 __libc_start_main +
    245

    6    tmpuxy54hfc                        0x000055bc3bde6f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824430
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n\tvar encodedMessage = \"\"\n\tlet alphabet\
    \ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"]\n\tlet vowels = [\"a\", \"e\", \"i\", \"o\",\
    \ \"u\"]\n\tfor letter in message.characters {\n\t\tlet a = String(letter).lowercased()\n\
    \t\tif alphabet.contains(a) {\n\t\t\tif vowels.contains(a) {\n\t\t\t\tencodedMessage.append(alphabet[(alphabet.index(of:\
    \ a)! + 2) % alphabet.count])\n\t\t\t} else {\n\t\t\t\tencodedMessage.append(String(letter).uppercased())\n\
    \t\t\t}\n\t\t} else {\n\t\t\tencodedMessage.append(String(letter))\n\t\t}\n\t\
    }\n\treturn encodedMessage\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp326rvkh7.swift:16:24: error: 'characters' is unavailable: Please\
    \ use String directly\n        for letter in message.characters {\n          \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp326rvkh7.swift:20:46: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n                                encodedMessage.append(alphabet[(alphabet.index(of:\
    \ a)! + 2) % alphabet.count])\n                                              \
    \                           ^\n/tmp/tmp326rvkh7.swift:20:46: note: use 'firstIndex(of:)'\
    \ instead\n                                encodedMessage.append(alphabet[(alphabet.index(of:\
    \ a)! + 2) % alphabet.count])\n                                              \
    \                           ^~~~~\n                                          \
    \                               firstIndex\n"
  stdout: ''
  timestamp: 1659824557
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    let letters = Array(message)\n    var\
    \ encoded = \"\"\n    for char in letters {\n        if char == char.lowercaseString\
    \ {\n            encoded.append(char.uppercaseString)\n        } else {\n    \
    \        encoded.append(char.lowercaseString)\n        }\n    }\n    encoded =\
    \ encoded.stringByReplacingOccurrencesOfString(\"a\", withString: \"c\")\n   \
    \ encoded = encoded.stringByReplacingOccurrencesOfString(\"e\", withString: \"\
    g\")\n    encoded = encoded.stringByReplacingOccurrencesOfString(\"i\", withString:\
    \ \"k\")\n    encoded = encoded.stringByReplacingOccurrencesOfString(\"o\", withString:\
    \ \"q\")\n    encoded = encoded.stringByReplacingOccurrencesOfString(\"u\", withString:\
    \ \"w\")\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmplj0gu2x0.swift:16:25: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'lowercaseString'\n        if char == char.lowercaseString\
    \ {\n                   ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmplj0gu2x0.swift:17:33: error:\
    \ value of type 'String.Element' (aka 'Character') has no member 'uppercaseString'\n\
    \            encoded.append(char.uppercaseString)\n                          \
    \ ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmplj0gu2x0.swift:19:33: error: value of type 'String.Element'\
    \ (aka 'Character') has no member 'lowercaseString'\n            encoded.append(char.lowercaseString)\n\
    \                           ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmplj0gu2x0.swift:22:23:\
    \ error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    encoded = encoded.stringByReplacingOccurrencesOfString(\"a\", withString:\
    \ \"c\")\n              ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplj0gu2x0.swift:23:23:\
    \ error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    encoded = encoded.stringByReplacingOccurrencesOfString(\"e\", withString:\
    \ \"g\")\n              ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplj0gu2x0.swift:24:23:\
    \ error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    encoded = encoded.stringByReplacingOccurrencesOfString(\"i\", withString:\
    \ \"k\")\n              ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplj0gu2x0.swift:25:23:\
    \ error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    encoded = encoded.stringByReplacingOccurrencesOfString(\"o\", withString:\
    \ \"q\")\n              ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplj0gu2x0.swift:26:23:\
    \ error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    encoded = encoded.stringByReplacingOccurrencesOfString(\"u\", withString:\
    \ \"w\")\n              ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824557
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    return message.map {\n        let uni\
    \ = $0.unicodeScalars\n        if uni.first!.isLetter {\n            let isUpper\
    \ = uni.first!.isUpperCase\n            let ascii = uni.first!.value - (isUpper\
    \ ? 65 : 97)\n            let res = (ascii + 2) % 26\n            return UnicodeScalar(res\
    \ + (isUpper ? 65 : 97))!\n        } else {\n            return $0\n        }\n\
    \    }.map {\n        let uni = $0.unicodeScalars\n        if uni.first!.isLetter\
    \ {\n            let isUpper = uni.first!.isUpperCase\n            let ascii =\
    \ uni.first!.value - (isUpper ? 65 : 97)\n            let res = (ascii + 2) %\
    \ 26\n            return UnicodeScalar(res + (isUpper ? 65 : 97))!\n        }\
    \ else {\n            return $0\n        }\n    }.map {\n        let uni = $0.unicodeScalars\n\
    \        let ascii = uni.first!.value\n        return UnicodeScalar(ascii + (uni.first!.isUpperCase\
    \ ? 32 : -32))!\n    }.reduce(\"\") { String($0) + String($1) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpgn2nmkq3.swift:13:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return message.map {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824665
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var encoded = \"\"\n    let vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let shift = 2\n    let alphabet =\
    \ \"abcdefghijklmnopqrstuvwxyz\"\n    let encoding = \"cdefghijklmnopqrstuvwxyzab\"\
    \n    let dictionary = zip(Array(alphabet), Array(encoding))\n    let letterDictionary\
    \ = dictionary.reduce([String: String]()) { (var dictionary, tuple) in\n     \
    \   dictionary[tuple.0] = tuple.1\n        return dictionary\n    }\n    for letter\
    \ in message.lowercaseString {\n        if vowels.contains(String(letter)) {\n\
    \            encoded += letterDictionary[String(letter)]!\n        } else {\n\
    \            encoded += letterDictionary[String(letter)]!\n        }\n    }\n\
    \    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp702uj3xz.swift:19:69: error: closure cannot have keyword arguments\n\
    \    let letterDictionary = dictionary.reduce([String: String]()) { (var dictionary,\
    \ tuple) in\n                                                                \
    \    ^~~~\n                                                                  \
    \  \n/tmp/tmp702uj3xz.swift:20:26: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'Dictionary<String, String>.Index'\n\
    \        dictionary[tuple.0] = tuple.1\n                         ^\n/tmp/tmp702uj3xz.swift:20:37:\
    \ error: cannot assign value of type 'String.Element' (aka 'Character') to subscript\
    \ of type '(key: String, value: String)'\n        dictionary[tuple.0] = tuple.1\n\
    \                              ~~~~~~^\n/tmp/tmp702uj3xz.swift:23:27: error: value\
    \ of type 'String' has no member 'lowercaseString'\n    for letter in message.lowercaseString\
    \ {\n                  ~~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824557
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n  var encodedMessage = \"\"\n  for letter\
    \ in message.characters {\n    let uppercaseLetter = String(letter).uppercaseString\n\
    \    let lowercaseLetter = String(letter).lowercaseString\n    if uppercaseLetter\
    \ == lowercaseLetter {\n      encodedMessage.append(letter)\n    } else if uppercaseLetter\
    \ == \"A\" {\n      encodedMessage.append(\"C\")\n    } else if uppercaseLetter\
    \ == \"E\" {\n      encodedMessage.append(\"G\")\n    } else if uppercaseLetter\
    \ == \"I\" {\n      encodedMessage.append(\"K\")\n    } else if uppercaseLetter\
    \ == \"O\" {\n      encodedMessage.append(\"Q\")\n    } else if uppercaseLetter\
    \ == \"U\" {\n      encodedMessage.append(\"Y\")\n    } else if uppercaseLetter\
    \ == \"Y\" {\n      encodedMessage.append(\"A\")\n    } else if uppercaseLetter\
    \ == \"B\" {\n      encodedMessage.append(\"D\")\n    } else if uppercaseLetter\
    \ == \"C\" {\n      encodedMessage.append(\"E\")\n    } else if uppercaseLetter\
    \ == \"D\" {\n      encodedMessage.append(\"F\")\n    } else if uppercaseLetter\
    \ == \"F\" {\n      encodedMessage.append(\"H\")\n    } else if uppercaseLetter\
    \ == \"G\" {\n      encodedMessage.append(\"I\")\n    } else if uppercaseLetter\
    \ == \"H\" {\n      encodedMessage.append(\"J\")\n    } else if uppercaseLetter\
    \ == \"J\" {\n      encodedMessage.append(\"L\")\n    } else if uppercaseLetter\
    \ == \"K\" {\n      encodedMessage.append(\"M\")\n    } else if uppercaseLetter\
    \ == \"L\" {\n      encodedMessage.append(\"N\")\n    } else if uppercaseLetter\
    \ == \"M\" {\n      encodedMessage.append(\"O\")\n    } else if uppercaseLetter\
    \ == \"N\" {\n      encodedMessage.append(\"P\")\n    } else if uppercaseLetter\
    \ == \"P\" {\n      encodedMessage.append(\"R\")\n    } else if uppercaseLetter\
    \ == \"Q\" {\n      encodedMessage.append(\"S\")\n    } else if upperc\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpbmns9cqb.swift:57:21: error: expected '{' after 'if' condition\n\
    \    } else if upperc\n                    ^\n/tmp/tmpbmns9cqb.swift:77:84: error:\
    \ expected '}' at end of brace statement\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                       \
    \                                                            ^\n/tmp/tmpbmns9cqb.swift:12:40:\
    \ note: to match this opening '{'\nfunc encode(message: String) -> String {\n\
    \                                       ^\n/tmp/tmpbmns9cqb.swift:14:25: error:\
    \ 'characters' is unavailable: Please use String directly\n  for letter in message.characters\
    \ {\n                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpbmns9cqb.swift:15:42: error: value of type 'String'\
    \ has no member 'uppercaseString'\n    let uppercaseLetter = String(letter).uppercaseString\n\
    \                          ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpbmns9cqb.swift:16:42:\
    \ error: value of type 'String' has no member 'lowercaseString'\n    let lowercaseLetter\
    \ = String(letter).lowercaseString\n                          ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpbmns9cqb.swift:57:15: error: cannot find 'upperc' in scope\n    } else\
    \ if upperc\n              ^~~~~~\n/tmp/tmpbmns9cqb.swift:61:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824557
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n\treturn \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmpk8t4y4tx/tmpk8t4y4tx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6fd4bbec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6fd48b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6fd48b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6fd48b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk8t4y4tx                        0x000055c7bca27307 <unavailable> + 4871

    5    libc.so.6                          0x00002b6fd4daa460 __libc_start_main +
    245

    6    tmpk8t4y4tx                        0x000055c7bca26f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824557
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    let vowels = \"aeiouAEIOU\"\n    let\
    \ encoded = message.characters.map {\n        if vowels.characters.contains($0)\
    \ {\n            return $0.value\n        } else {\n            return $0\n  \
    \      }\n    }.map {\n        return $0\n    }\n    return String(encoded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_a5yo7m0.swift:20:11: error: unable to infer type of a closure\
    \ parameter '$0' in the current context\n    }.map {\n          ^\n/tmp/tmp_a5yo7m0.swift:16:23:\
    \ error: value of type 'String.Element' (aka 'Character') has no member 'value'\n\
    \            return $0.value\n                   ~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659824557
