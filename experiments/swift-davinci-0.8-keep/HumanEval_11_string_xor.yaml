name: HumanEval_11_string_xor
language: swift
prompt: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
  \ '110')\n/// '100'\nfunc string_xor(a: String, b: String) -> String {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\"\
  ) == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
  \ \"0101\", b: \"0000\") == \"0101\")"
completions: ["\tvar output = \"\"\n\tfor i in 0 ..< a.characters.count {\n\t\tif\
    \ a[i] == b[i] {\n\t\t\toutput += \"0\"\n\t\t} else {\n\t\t\toutput += \"1\"\n\
    \t\t}\n\t}\n\treturn output", "    let zipped = zip(a, b)\n    let result = zipped.map\
    \ { (l, r) -> String in\n        return String(Int(String(l))! ^ Int(String(r))!)\n\
    \    }\n    return result.joined()", "    var str = \"\"\n    if a.count != b.count\
    \ {\n        return str\n    }\n    for i in 0..<a.count {\n        let aChar\
    \ = a[a.index(a.startIndex, offsetBy: i)]\n        let bChar = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if aChar == bChar {\n            str.append(\"0\")\n\
    \        } else {\n            str.append(\"1\")\n        }\n    }\n    return\
    \ str", "    var res = \"\"\n    for i in 0..<a.count {\n        res += String(Int(String(a[i]))!\
    \ ^ Int(String(b[i]))!)\n    }\n    return res", '    return String(zip(a, b).map{
    $0 != $1 ? "1" : "0" })', "  var result = \"\"\n  for idx in 0..<a.characters.count\
    \ {\n    let ia = a.index(a.startIndex, offsetBy: idx)\n    let ib = b.index(b.startIndex,\
    \ offsetBy: idx)\n    let ca = a[ia]\n    let cb = b[ib]\n    if (ca == cb) {\n\
    \      result += \"0\"\n    } else {\n      result += \"1\"\n    }\n  }\n  return\
    \ result", "    let n = a.count\n    var ret = \"\"\n    for i in 0..<n {\n  \
    \      let ai = a[i]\n        let bi = b[i]\n        if ai == bi {\n         \
    \   ret += \"0\"\n        } else {\n            ret += \"1\"\n        }\n    }\n\
    \    return ret", "    let a = Int(a, radix: 2)!\n    let b = Int(b, radix: 2)!\n\
    \    let result = a ^ b\n    return String(result, radix: 2)", "    // your code\
    \ here\n    return \"\"", "  assert(a.characters.count == b.characters.count)\n\
    \  var result = \"\"\n  for (charA, charB) in zip(a.characters, b.characters)\
    \ {\n    if charA == charB {\n      result.append(\"0\")\n    } else {\n     \
    \ result.append(\"1\")\n    }\n  }\n  return result", "    if a.count != b.count\
    \ {\n        return \"\"\n    }\n    var result = \"\"\n    for i in 0 ..< a.count\
    \ {\n        let x = a[i]\n        let y = b[i]\n        result += x ^ y ? \"\
    1\" : \"0\"\n    }\n    return result", "    let aBytes = Array(a.utf8)\n    let\
    \ bBytes = Array(b.utf8)\n    var result = [UInt8]()\n    for i in 0..<aBytes.count\
    \ {\n        result.append(aBytes[i] ^ bBytes[i])\n    }\n    return String(bytes:\
    \ result, encoding: .utf8)!", '    return String(Int(a)! ^ Int(b)!, radix: 2)',
  "    var c = \"\"\n    for i in 0..<a.characters.count {\n        c += String(Int(String(a[a.index(a.startIndex,\
    \ offsetBy: i)]))! ^ Int(String(b[b.index(b.startIndex, offsetBy: i)]))!)\n  \
    \  }\n    return c", "  return String(a.utf8.enumerated().map({\n    String(UnicodeScalar(UInt8($0.element\
    \ ^ b[b.index(b.startIndex, offsetBy: $0.offset)]) & 0x7f))\n  }))", "    let\
    \ count = a.count\n    var aChars = Array(a.utf8)\n    var bChars = Array(b.utf8)\n\
    \    var result = [UInt8]()\n    for i in 0..<count {\n        let a = Int(aChars[i])\n\
    \        let b = Int(bChars[i])\n        result.append(UInt8(a ^ b))\n    }\n\
    \    return String(bytes: result, encoding: .utf8)!", "    let xor = zip(a, b).map\
    \ { x, y in\n        switch (x, y) {\n        case (\"0\", \"0\"): return \"0\"\
    \n        case (\"1\", \"1\"): return \"0\"\n        default: return \"1\"\n \
    \       }\n    }\n    return String(xor)", "    var c = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        c += xor(a: a[i], b: b[i])\n    }\n    return c", "    // Read all\
    \ characters into an array\n    let ca = Array(a.characters)\n    let cb = Array(b.characters)\n\
    \    // Make sure both strings are of the same length\n    guard ca.count == cb.count\
    \ else {\n        fatalError(\"\\(a) and \\(b) must be of the same length\")\n\
    \    }\n    // XOR the two strings\n    let c = zip(ca, cb).map { $0 != $1 ? \"\
    1\" : \"0\" }\n    // Return result\n    return String(c)", "    var a = a\n \
    \   var b = b\n    let n = a.characters.count\n    let m = b.characters.count\n\
    \    if n > m {\n        for _ in 0..<n-m {\n            b = \"0\" + b\n     \
    \   }\n    } else if m > n {\n        for _ in 0..<m-n {\n            a = \"0\"\
    \ + a\n        }\n    }\n    var result = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        if a[i] == b[i] {\n            result += \"0\"\n        } else {\n\
    \            result += \"1\"\n        }\n    }\n    return result"]
stop_tokens:
- "\n}"
