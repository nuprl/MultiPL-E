name: HumanEval_83_starts_one_ends
language: swift
prompt: "\n/// Given a positive integer n, return the count of the numbers of n-digit\n\
  /// positive integers that start or end with 1.\nfunc starts_one_ends(n: Int) ->\
  \ Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(starts_one_ends(n: 1) == 1)\nassert(starts_one_ends(n:\
  \ 2) == 18)\nassert(starts_one_ends(n: 3) == 180)\nassert(starts_one_ends(n: 4)\
  \ == 1800)\nassert(starts_one_ends(n: 5) == 18000)"
completions: ["    if n == 1 {\n        return 2\n    } else if n == 2 {\n       \
    \ return 3\n    } else {\n        return 3*start_ends(n: n-1)\n    }", "    var\
    \ dp: [[Int]] = Array(repeating: Array(repeating: 0, count: 10), count: n + 1)\n\
    \    for i in 1...9 {\n        dp[1][i] = 1\n    }\n    for i in 2...n {\n   \
    \     for j in 0...9 {\n            for k in 0...9 {\n                if k ==\
    \ 1 || j == 1 {\n                    dp[i][j] += dp[i - 1][k]\n              \
    \  }\n            }\n        }\n    }\n    return dp[n].reduce(0, +)", "  var\
    \ count = 0\n  for i in 1...9 {\n    count += starts_one_ends(n: n, curr: i)\n\
    \  }\n  return count", "    if n <= 0 {\n        return 0\n    }\n    let n =\
    \ n - 1\n    return n * 9 + 1", "    let n_range = 1..<n + 1\n    let results\
    \ = n_range.map { _ in\n        Array(repeating: 0, count: 10)\n    }\n    for\
    \ idx in 1..<n {\n        for jdx in 0..<10 {\n            if jdx == 0 {\n   \
    \             results[idx][jdx] = results[idx - 1][1]\n            } else if jdx\
    \ == 9 {\n                results[idx][jdx] = results[idx - 1][8]\n          \
    \  } else {\n                results[idx][jdx] = results[idx - 1][jdx - 1] + results[idx\
    \ - 1][jdx + 1]\n            }\n        }\n    }\n    return 2 * results[n - 1].reduce(0,\
    \ +)", "    if n == 1 {\n        return 2\n    } else if n == 2 {\n        return\
    \ 10\n    }\n    let a = starts_one_ends(n - 1)\n    let b = starts_one_ends(n\
    \ - 2)\n    return a + 9 * b", "    var number_array = Array(repeating: 1, count:\
    \ n)\n    var count = 1 // There is at least one number that starts with one\n\
    \    var dg_index = 1\n    var carry = 0\n    var last_digit = 1\n    let last_index\
    \ = n - 1\n    var digit = 0\n    var i = 0\n    while dg_index < n {\n      \
    \  count += last_digit\n        for _ in 1...last_digit {\n            i = last_index\
    \ - dg_index\n            digit = number_array[i] + 1 + carry\n            if\
    \ digit > 9 {\n                number_array[i] = digit % 10\n                carry\
    \ = 1\n            } else {\n                number_array[i] = digit\n       \
    \         carry = 0\n            }\n            dg_index += 1\n        }\n   \
    \     last_digit = dg_index\n    }\n    count += last_digit\n    return count",
  '    return n == 1 ? 2 : starts_one_ends(n - 1) + count_by_last_digit(n - 1)', " \
    \   var val = 1\n    var max = 1\n    var i = 1\n    while i < n {\n        val\
    \ *= 10\n        max += val\n        i += 1\n    }\n    return max", '    return
    1', "  var memo: [[Int]] = [[]]\n  memo[0] = [1, 1]\n\n  (1...n).forEach { i in\n\
    \    var temp = [Int](count: i + 1, repeatedValue: 0)\n    temp[0] = 1\n    (1...i).forEach\
    \ { j in\n      temp[j] = memo[i - 1][j - 1] + memo[i - 1][j]\n    }\n    memo.append(temp)\n\
    \  }\n\n  return memo[n - 1].reduce(0, combine: +)", "    assert(n > 0)\n    var\
    \ next = [[Int]](repeating: [Int](repeating: 0, count: 2), count: n)\n    next[0][0]\
    \ = 1\n    for _ in 1..<n {\n        next[0][1] = next[0][0]\n        next[0][0]\
    \ = 0\n        for i in 1..<(n - 1) {\n            next[i][1] = next[i][0] + next[i\
    \ - 1][1]\n            next[i][0] = next[i - 1][0]\n        }\n        next[n\
    \ - 1][1] = next[n - 1][0] + next[n - 2][1]\n        next[n - 1][0] = next[n -\
    \ 2][0]\n    }\n    return next[n - 1][0] + next[n - 1][1]", "    if n == 1 {\n\
    \        return 2\n    } else if n == 2 {\n        return 9\n    } else {\n  \
    \      return (starts_one_ends(n - 1) * 10 - 9) + starts_one_ends(n - 2)\n   \
    \ }", '    return count_num_digits(n: n) - count_no_one_digits(n: n)', "    precondition(n\
    \ > 0)\n    return 10 * starts_one_ends(n - 1) + Int(Int32.pow(10, n - 1))", " \
    \   let result = a(n - 1) + b(n - 1) - a(n - 2)\n    return result", "    let\
    \ x = floor(Double(n - 1) / 2)\n    return Int(pow(10, x))", "    var count =\
    \ 0\n    var work = n\n    if n < 2 {\n        return 1\n    }\n    while work\
    \ > 1 {\n        count += pow(10, Double(work - 1))\n        work -= 1\n    }\n\
    \    return count * 2", "    var nums = 0\n    for d in 1..<n {\n        var exp\
    \ = 1\n        for _ in 0..<d {\n            exp *= 10\n        }\n        nums\
    \ += 9 * exp\n    }\n    return nums + 1", "  assert(n > 0)\n  return 1 + (n -\
    \ 1) * 9"]
stop_tokens:
- "\n}"
