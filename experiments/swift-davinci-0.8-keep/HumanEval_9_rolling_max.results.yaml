language: swift
name: HumanEval_9_rolling_max
results:
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    if numbers.count == 0 {\n        return []\n    }\n\n    var\
    \ result = [Int]()\n    var current_max = numbers[0]\n    result.append(current_max)\n\
    \n    for n in numbers[1..<numbers.count] {\n        current_max = max(current_max,\
    \ n)\n        result.append(current_max)\n    }\n\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var maximums = [Int]()\n    var max = numbers[0]\n    maximums.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        maximums.append(max)\n    }\n    return\
    \ maximums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a56c83c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a5697a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a5697a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a5697a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a56979bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a56779e83 <unavailable> + 188035

    6    tmp5a28dvvq                        0x000055ea748a3ae8 <unavailable> + 6888

    7    tmp5a28dvvq                        0x000055ea748a35ad <unavailable> + 5549

    8    libc.so.6                          0x00002b8a56e6f460 __libc_start_main +
    245

    9    tmp5a28dvvq                        0x000055ea748a32b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var current_max = numbers[0]\n    var result = [current_max]\n\
    \    for number in numbers[1..<numbers.count] {\n        current_max = max(current_max,\
    \ number)\n        result.append(current_max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5edb16c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5ed80d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab5ed80d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab5ed80d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab5ed80cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab5ed60ce83 <unavailable> + 188035

    6    tmpeaw9q7x6                        0x000056448d583c38 <unavailable> + 7224

    7    tmpeaw9q7x6                        0x000056448d58370d <unavailable> + 5901

    8    libc.so.6                          0x00002ab5edd02460 __libc_start_main +
    245

    9    tmpeaw9q7x6                        0x000056448d583419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659824826
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var answer = [Int]()\n    var current_max = Int.min\n    for\
    \ number in numbers {\n        current_max = max(current_max, number)\n      \
    \  answer.append(current_max)\n    }\n    return answer\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824826
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var rolling_max: [Int] = []\n    for n in numbers {\n      \
    \  let last_rolling_max = rolling_max.last ?? Int.min\n        rolling_max.append(max(last_rolling_max,\
    \ n))\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    return [Int](\n        repeating: 0,\n        count: numbers.count\n\
    \    ).enumerated().map { index, element in\n        let previous = index - 1\n\
    \        let previous_max = previous >= 0 ? numbers[previous] : 0\n        return\
    \ max(previous_max, numbers[index])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmp06zbzugj/tmp06zbzugj.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b233e76fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b233e466b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b233e466988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b233e4657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp06zbzugj                        0x0000562a99f77916 <unavailable> + 6422

    5    libc.so.6                          0x00002b233e95b460 __libc_start_main +
    245

    6    tmp06zbzugj                        0x0000562a99f772e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824826
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    if numbers.count == 0 {\n        return []\n    }\n\n    if\
    \ numbers.count == 1 {\n        return [numbers[0]]\n    }\n\n    var result =\
    \ [Int]()\n    var max = numbers[0]\n    result.append(max)\n\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n\
    \        result.append(max)\n    }\n\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824826
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max: Int = 0\n    var max_list: [Int] = []\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        max_list.append(max)\n    }\n    return max_list\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824826
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_element = Int.min\n    for\
    \ number in numbers {\n        if number > max_element {\n            max_element\
    \ = number\n        }\n        result.append(max_element)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824826
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var maxes = [Int]()\n    var currMax = Int.min\n    for number\
    \ in numbers {\n        if number > currMax {\n            currMax = number\n\
    \        }\n        maxes.append(currMax)\n    }\n    return maxes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if max < numbers[i] {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002abe8ef56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abe8ec4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002abe8ec4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002abe8ec4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002abe8ec4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002abe8ea4ce83 <unavailable> + 188035

    6    tmpbf0qgav1                        0x0000560bfa1d1ae8 <unavailable> + 6888

    7    tmpbf0qgav1                        0x0000560bfa1d15ad <unavailable> + 5549

    8    libc.so.6                          0x00002abe8f142460 __libc_start_main +
    245

    9    tmpbf0qgav1                        0x0000560bfa1d12b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824826
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_seen = [Int]()\n    var local_max = 0\n    for num in\
    \ numbers {\n        if num > local_max {\n            local_max = num\n     \
    \   }\n        max_seen.append(local_max)\n    }\n    return max_seen\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824826
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    let size = numbers.count\n    var numbers = numbers\n    var\
    \ max_indices = [Int](count: size, repeatedValue: 0)\n    for i in 1..<size {\n\
    \        if numbers[i] > numbers[max_indices[i - 1]] {\n            max_indices[i]\
    \ = i\n        } else {\n            max_indices[i] = max_indices[i - 1]\n   \
    \     }\n    }\n    return max_indices.map { numbers[$0] }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpezluh1d9.swift:9:23: error: no exact matches in call to initializer\
    \ \n    var max_indices = [Int](count: size, repeatedValue: 0)\n             \
    \         ^\n/tmp/tmpezluh1d9.swift:9:23: note: candidate has partially matching\
    \ parameter list (repeating: Int, count: Int)\n    var max_indices = [Int](count:\
    \ size, repeatedValue: 0)\n                      ^\n/tmp/tmpezluh1d9.swift:9:23:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    var max_indices = [Int](count: size, repeatedValue: 0)\n         \
    \             ^\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    return [Int](0...numbers.count - 1).map { numbers[0...$0].max()!\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(rolling_max(numbers: [] as [Int])\
    \ == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\n\
    assert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b13e3692c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13e3389561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13e3389286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13e338913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13e3388bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpdzy44jni                        0x0000555b426c2db3 <unavailable> + 7603

    6    tmpdzy44jni                        0x0000555b426c27bd <unavailable> + 6077

    7    libc.so.6                          0x00002b13e387e460 __libc_start_main +
    245

    8    tmpdzy44jni                        0x0000555b426c24c9 <unavailable> + 5321

    '
  stdout: ''
  timestamp: 1659824826
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    if numbers.count == 0 {\n        return []\n    }\n    var results\
    \ = [Int]()\n    results.append(numbers[0])\n    for i in 1..<numbers.count {\n\
    \        results.append(max(results[i - 1], numbers[i]))\n    }\n    return results\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824826
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    return numbers.reduce([Int]()) { (result, next) in\n       \
    \ return result + [result.last.map { max($0, next) } ?? next]\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_at_current_index = numbers\n    for (i, _) in numbers.enumerated()\
    \ {\n        max_at_current_index[i] = numbers[0..<i].max() ?? 0\n    }\n    return\
    \ max_at_current_index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpak1jb0v5/tmpak1jb0v5.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad621b57c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad62184eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad62184e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad62184d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpak1jb0v5                        0x0000556586cbd93d <unavailable> + 6461

    5    libc.so.6                          0x00002ad621d43460 __libc_start_main +
    245

    6    tmpak1jb0v5                        0x0000556586cbd459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1659824826
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    result.reserveCapacity(numbers.count)\n\
    \    var current_max = Int.min\n    for i in numbers {\n        if i > current_max\
    \ {\n            current_max = i\n        }\n        result.append(current_max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824826
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    for index in 0..<numbers.count {\n\
    \        let slice = numbers[0...index]\n        result.append(slice.max()!)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n  var result = [Int]()\n  var max = numbers[0]\n  result.append(max)\n\
    \  for i in 1..<numbers.count {\n    if numbers[i] > max {\n      max = numbers[i]\n\
    \    }\n    result.append(max)\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af5542bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af553fb6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af553fb6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af553fb613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af553fb5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af553db5e83 <unavailable> + 188035

    6    tmp7bessoln                        0x0000561349d45ae8 <unavailable> + 6888

    7    tmp7bessoln                        0x0000561349d455ad <unavailable> + 5549

    8    libc.so.6                          0x00002af5544ab460 __libc_start_main +
    245

    9    tmp7bessoln                        0x0000561349d452b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824826
