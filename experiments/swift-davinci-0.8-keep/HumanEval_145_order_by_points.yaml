name: HumanEval_145_order_by_points
language: swift
prompt: "\n/// Write a function which sorts the given list of integers\n/// in ascending\
  \ order according to the sum of their digits.\n/// Note: if there are several items\
  \ with similar sum of their digits,\n/// order them based on their index in original\
  \ list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11, -12]) == [-1,\
  \ -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfunc order_by_points(nums:\
  \ [Int]) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12])\
  \ == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145,\
  \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
  \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
  \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3])\
  \ == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3,\
  \ 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
  \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
completions: ["    return nums.sorted(by: { (first, second) -> Bool in\n        let\
    \ firstSum = first > 0 ? first : -first\n        let secondSum = second > 0 ?\
    \ second : -second\n        return getSumOfDigits(n: firstSum) < getSumOfDigits(n:\
    \ secondSum)\n    })", "    var result: [Int] = []\n    var array: [(Int, Int)]\
    \ = []\n    for (index, num) in nums.enumerated() {\n        var sum = 0\n   \
    \     for i in String(num) {\n            sum += Int(String(i))!\n        }\n\
    \        array.append((index, sum))\n    }\n    array.sort { $0.1 < $1.1 }\n \
    \   for (index, _) in array {\n        result.append(nums[index])\n    }\n   \
    \ return result", "    var sumArray = [Int]()\n    for i in nums {\n        var\
    \ sum = 0\n        var num = i\n        while num != 0 {\n            sum += num\
    \ % 10\n            num /= 10\n        }\n        sumArray.append(sum)\n    }\n\
    \    return insertionsort(nums, sumArray)", "    var result: [Int] = []\n    var\
    \ sorted: [(Int, Int)] = []\n    for (index, value) in nums.enumerated() {\n \
    \       let value: Int = abs(value)\n        var sum: Int = 0\n        for char\
    \ in String(value) {\n            sum += Int(String(char))!\n        }\n     \
    \   sorted.append((sum, index))\n    }\n    sorted.sort(by: {$0.0 < $1.0})\n \
    \   for item in sorted {\n        result.append(nums[item.1])\n    }\n    return\
    \ result", "    var result: [Int] = []\n    var points: [Int] = []\n    var ids:\
    \ [Int] = []\n    for i in 0..<nums.count {\n        var sum = 0\n        for\
    \ j in String(nums[i]).characters {\n            sum += Int(String(j))!\n    \
    \    }\n        points.append(sum)\n        ids.append(i)\n    }\n    for i in\
    \ 0..<nums.count {\n        var min = points[i]\n        var min_id = i\n    \
    \    for j in i+1..<nums.count {\n            if points[j] < min {\n         \
    \       min = points[j]\n                min_id = j\n            }\n        }\n\
    \        points[min_id] = points[i]\n        points[i] = min\n        let temp\
    \ = ids[i]\n        ids[i] = ids[min_id]\n        ids[min_id] = temp\n    }\n\
    \    for i in 0..<nums.count {\n        result.append(nums[ids[i]])\n    }\n \
    \   return result", "  return nums.sorted { (a, b) -> Bool in\n    let sumA =\
    \ sum_of_digits(a)\n    let sumB = sum_of_digits(b)\n    if sumA != sumB {\n \
    \     return sumA < sumB\n    }\n    return nums.index(of: a)! < nums.index(of:\
    \ b)!\n  }", "    return nums.sorted { (a, b) -> Bool in\n        a.digitsSum\
    \ == b.digitsSum ? a < b : a.digitsSum < b.digitsSum\n    }", "    var result\
    \ = [Int]()\n    var dict = [Int: Int]()\n    for number in nums {\n        var\
    \ sum = 0\n        let stringNum = String(number)\n        for ch in stringNum\
    \ {\n            sum += Int(String(ch))!\n        }\n        dict[number] = sum\n\
    \    }\n    let arr = dict.sorted { (t1, t2) -> Bool in\n        if t1.value <\
    \ t2.value {\n            return true\n        } else if t1.value == t2.value\
    \ {\n            return t1.key < t2.key\n        } else {\n            return\
    \ false\n        }\n    }\n    for element in arr {\n        result.append(element.key)\n\
    \    }\n    return result", "    return nums.sorted(by: {\n        return $0.sumDigits()\
    \ < $1.sumDigits()\n    })", "    // your code here!\n    return []", "    var\
    \ arr = nums\n    arr.sort { (a, b) -> Bool in\n        let aString = String(a)\n\
    \        let bString = String(b)\n        let aSum = aString.reduce(0) { (res,\
    \ char) -> Int in\n            let val = Int(String(char)) ?? 0\n            return\
    \ res + val\n        }\n        let bSum = bString.reduce(0) { (res, char) ->\
    \ Int in\n            let val = Int(String(char)) ?? 0\n            return res\
    \ + val\n        }\n        if aSum == bSum {\n            return nums.firstIndex(of:\
    \ a)! < nums.firstIndex(of: b)!\n        }\n        return aSum < bSum\n    }\n\
    \    return arr", "    return nums.sorted { (left, right) -> Bool in\n       \
    \ let leftSum = left.digits.reduce(0, +)\n        let rightSum = right.digits.reduce(0,\
    \ +)\n        return leftSum == rightSum ? left < right : leftSum < rightSum\n\
    \    }", "    var nums = nums\n    func sum(_ num: Int) -> Int {\n        return\
    \ String(num).reduce(0) { $0 + $1.wholeNumberValue! }\n    }\n    nums.sort {\
    \ sum($0) == sum($1) ? $0 < $1 : sum($0) < sum($1) }\n    return nums", "    return\
    \ nums.sorted { (left, right) -> Bool in\n        let left_sum = left.digits.reduce(0,\
    \ +)\n        let right_sum = right.digits.reduce(0, +)\n        return left_sum\
    \ < right_sum\n    }", "    return nums.sorted(by: {\n        sumOfDigits(num:\
    \ $0) < sumOfDigits(num: $1)\n    })", '    return nums.sorted { return get_sum(num:
    $0) < get_sum(num: $1) }', "    return nums.sorted(by: {\n        var a = abs($0)\n\
    \        var b = abs($1)\n        var acum = 0\n        var bcum = 0\n       \
    \ while a > 0 {\n            acum += a % 10\n            a /= 10\n        }\n\
    \        while b > 0 {\n            bcum += b % 10\n            b /= 10\n    \
    \    }\n        return acum < bcum\n    })", "    let sumOfDigits = nums.map {\
    \ $0.sumOfDigits() }\n    let points = Array(zip(sumOfDigits, nums))\n    let\
    \ sorted = points.sorted { (tuple1, tuple2) -> Bool in\n        if tuple1.0 ==\
    \ tuple2.0 {\n            return tuple1.1 < tuple2.1\n        }\n        return\
    \ tuple1.0 < tuple2.0\n    }\n    return sorted.map { $0.1 }", "    guard nums.count\
    \ > 0 else { return [] }\n    return nums.sorted(by: {\n        guard let aSum\
    \ = sumOfDigits(nums: $0), let bSum = sumOfDigits(nums: $1) else { return false\
    \ }\n        if aSum == bSum {\n            return nums.firstIndex(of: $0)! <\
    \ nums.firstIndex(of: $1)!\n        }\n        return aSum < bSum\n    })", " \
    \   if nums.isEmpty {\n        return []\n    }\n    return nums.sorted(by: {(item1:\
    \ Int, item2: Int) -> Bool in\n        var item1Sum = 0\n        var item2Sum\
    \ = 0\n        var item1 = item1\n        var item2 = item2\n        while item1\
    \ != 0 {\n            item1Sum += item1 % 10\n            item1 /= 10\n      \
    \  }\n        while item2 != 0 {\n            item2Sum += item2 % 10\n       \
    \     item2 /= 10\n        }\n        return item1Sum < item2Sum\n    })"]
stop_tokens:
- "\n}"
