name: HumanEval_49_modp
language: swift
prompt: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n///\
  \ 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
  \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101,\
  \ p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
  assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
  \ 31, p: 5) == 3)"
completions: ["    var (current, result) = (1, 1)\n    while current <= n {\n    \
    \    result = result * current % p\n        current = current + 1\n    }\n   \
    \ return result", "    var p = p\n    if p <= 0 {\n        return -1\n    }\n\
    \    var n = n\n    if n <= 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let temp = modp(n: n / 2, p: p)\n        return (temp * temp) % p\n \
    \   } else {\n        let temp = modp(n: n - 1, p: p)\n        return (n * temp)\
    \ % p\n    }", "    if n == 0 {\n        return 1\n    } else if n % 2 == 0 {\n\
    \        return (modp(n / 2, p: p) * modp(n / 2, p: p)) % p\n    } else {\n  \
    \      return (2 * modp(n / 2, p: p) * modp(n / 2, p: p)) % p\n    }", "    if\
    \ n < 0 {\n        return p - modp(-n, p: p)\n    }\n    if n == 0 {\n       \
    \ return 1\n    }\n    if n % 2 == 0 {\n        return (modp(n / 2, p: p) * modp(n\
    \ / 2, p: p)) % p\n    }\n    return (modp(n / 2, p: p) * modp(n / 2, p: p) *\
    \ 2) % p", "    var res = 1\n    var a = 2\n    var b = n\n    while b > 0 {\n\
    \        if b % 2 == 1 {\n            res = (res * a) % p\n        }\n       \
    \ a = (a * a) % p\n        b /= 2\n    }\n    return res", "    var res = 1\n\
    \    for _ in 1...n {\n        res = (res * 2) % p\n    }\n    return res", " \
    \ var n = n\n  var p = p\n  var counter = 0\n  var result = 1\n  while n != 0\
    \ {\n    if n % 2 == 1 {\n      result = (result * counter) % p\n    }\n    counter\
    \ = (counter * counter) % p\n    n /= 2\n  }\n  return result", "    if n == 0\
    \ {\n        return 1\n    }\n    if n % 2 == 0 {\n        return modp(n: n /\
    \ 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return 2 * modp(n: n - 1, p:\
    \ p) % p", "    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n  \
    \      return modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    else\
    \ {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p) % p\n    }", "   \
    \ assert(p > 0)\n    if n == 0 {\n        return 1\n    } else if n % 2 == 0 {\n\
    \        let b = modp(n / 2, p: p)\n        return modp(b, p: p) * modp(b, p:\
    \ p) % p\n    } else {\n        return n * modp(n - 1, p: p) % p\n    }", "  \
    \  var result = 1\n    var a = n\n    var b = p\n    while (a != 0) {\n      \
    \  if (a % 2 == 1) {\n            result = (result * a) % b\n        }\n     \
    \   a = a >> 1\n        b = (b * b) % p\n    }\n    return result", "    if p\
    \ <= n {\n        return modp(n, p: p * 2) % p\n    } else if n == 0 {\n     \
    \   return 1\n    } else {\n        return modp(n - 1, p: p) * 2 % p\n    }",
  '    return Int(gmpz_ui_pow_ui(UInt(n), UInt(p)))', "    var d = 1\n    var k =\
    \ 0\n    while (1 << k) <= n {\n        k += 1\n    }\n    while k > 0 {\n   \
    \     k -= 1\n        d = (d * d) % p\n        if (n & (1 << k)) != 0 {\n    \
    \        d = (d * 2) % p\n        }\n    }\n    return d", "  if n == 0 {\n  \
    \  return 1\n  }\n  if n % 2 == 0 {\n    return modp(n: n / 2, p: p) * modp(n:\
    \ n / 2, p: p) % p\n  }\n  return modp(n: n - 1, p: p) * modp(n: 1, p: p) % p",
  "  if n == 0 {\n    return 1\n  }\n  if n % 2 == 0 {\n    let r = modp(n/2, p: p)\n\
    \    return (r * r) % p\n  }\n  return (n * modp(n-1, p: p)) % p", "  var result\
    \ = 1\n  var n = n\n  while n > 0 {\n    if n & 1 == 1 {\n      result = (result\
    \ * n) % p\n    }\n    n >>= 1\n  }\n  return result", "    // TODO: error handling\n\
    \    // if p == 0 { return }\n    if p == 1 { return 0 }\n    var r = 1\n    var\
    \ k = n\n    while k > 0 {\n        if k & 1 == 1 {\n            r = r * n % p\n\
    \        }\n        k = k >> 1\n        n = n * n % p\n    }\n    return r", " \
    \   assert(n >= 0 && p > 0)\n    if n == 0 {\n        return 1\n    }\n    if\
    \ n % 2 == 0 {\n        let sq = modp(n: n / 2, p: p)\n        return sq * sq\
    \ % p\n    }\n    return modp(n: n - 1, p: p) * n % p", "    if p == 1 {\n   \
    \     return 0\n    }\n    var r = 1\n    var n = n\n    while n > 0 {\n     \
    \   if n & 1 == 1 {\n            r = (r * n) % p\n        }\n        n >>= 1\n\
    \    }\n    return r"]
stop_tokens:
- "\n}"
