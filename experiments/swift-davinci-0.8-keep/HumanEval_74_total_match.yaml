name: HumanEval_74_total_match
language: swift
prompt: "\n/// Write a function that accepts two lists of strings and returns the\
  \ list that has \n/// total number of chars in the all strings of the list less\
  \ than the other list.\n/// if the two lists have the same number of chars, return\
  \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
  \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
  \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
  \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
  \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfunc total_match(lst1: [String], lst2:\
  \ [String]) -> [String] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(total_match(lst1: [] as [String], lst2:\
  \ [] as [String]) == [] as [String])\nassert(total_match(lst1: [\"hi\", \"admin\"\
  ], lst2: [\"hi\", \"hi\"]) == [\"hi\", \"hi\"])\nassert(total_match(lst1: [\"hi\"\
  , \"admin\"], lst2: [\"hi\", \"hi\", \"admin\", \"project\"]) == [\"hi\", \"admin\"\
  ])\nassert(total_match(lst1: [\"4\"], lst2: [\"1\", \"2\", \"3\", \"4\", \"5\"])\
  \ == [\"4\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"Hi\"\
  ]) == [\"hI\", \"Hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"\
  hI\", \"hi\", \"hi\"]) == [\"hI\", \"hi\", \"hi\"])\nassert(total_match(lst1: [\"\
  hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hii\"]) == [\"hi\", \"admin\"])\nassert(total_match(lst1:\
  \ [] as [String], lst2: [\"this\"]) == [] as [String])\nassert(total_match(lst1:\
  \ [\"this\"], lst2: [] as [String]) == [] as [String])"
completions: ["    let s1 = lst1.reduce(0) { x, y in x + y.count }\n    let s2 = lst2.reduce(0)\
    \ { x, y in x + y.count }\n    return s1 <= s2 ? lst1 : lst2", "    let total1\
    \ = lst1.map { $0.count }.reduce(0, +)\n    let total2 = lst2.map { $0.count }.reduce(0,\
    \ +)\n    return total1 < total2 ? lst1 : lst2", "  var lst1Total = 0\n  var lst2Total\
    \ = 0\n  for word in lst1 {\n    lst1Total += word.count\n  }\n  for word in lst2\
    \ {\n    lst2Total += word.count\n  }\n  if lst1Total > lst2Total {\n    return\
    \ lst2\n  } else {\n    return lst1\n  }", '    return lst1.joined().count < lst2.joined().count
    ? lst1 : lst2', "    var a = lst1.map({ $0.count }).reduce(0, +)\n    var b =\
    \ lst2.map({ $0.count }).reduce(0, +)\n    return a < b ? lst1 : lst2", "    let\
    \ count1 = lst1.reduce(0) { $0 + $1.count }\n    let count2 = lst2.reduce(0) {\
    \ $0 + $1.count }\n    return count1 < count2 ? lst1 : lst2", "    let total1\
    \ = lst1.reduce(0) { $0 + $1.count }\n    let total2 = lst2.reduce(0) { $0 + $1.count\
    \ }\n    return total1 > total2 ? lst2 : lst1", "    let sumCharsOfLst1 = lst1.reduce(0)\
    \ { result, string in\n        result + string.count\n    }\n    let sumCharsOfLst2\
    \ = lst2.reduce(0) { result, string in\n        result + string.count\n    }\n\
    \    return sumCharsOfLst1 <= sumCharsOfLst2 ? lst1 : lst2", "\tlet total1 = lst1.reduce(0)\
    \ { $0 + $1.count }\n\tlet total2 = lst2.reduce(0) { $0 + $1.count }\n\treturn\
    \ total1 < total2 ? lst1 : lst2", "    var num1 = 0\n    var num2 = 0\n    for\
    \ str in lst1 {\n        num1 += str.count\n    }\n    for str in lst2 {\n   \
    \     num2 += str.count\n    }\n    if num1 < num2 {\n        return lst1\n  \
    \  } else {\n        return lst2\n    }", "    var count1 = 0\n    var count2\
    \ = 0\n    for i in lst1 {\n        count1 += i.count\n    }\n    for i in lst2\
    \ {\n        count2 += i.count\n    }\n    if count1 < count2 {\n        return\
    \ lst1\n    } else {\n        return lst2\n    }", "    //lst1.\n    var chars1\
    \ = 0\n    var chars2 = 0\n    for str in lst1 {\n        chars1 += str.count\n\
    \    }\n    for str in lst2 {\n        chars2 += str.count\n    }\n    if chars1\
    \ < chars2 {\n        return lst1\n    } else if chars2 < chars1 {\n        return\
    \ lst2\n    } else {\n        return lst1\n    }", "    var totalChar1 = 0\n \
    \   var totalChar2 = 0\n    for i in lst1 {\n        totalChar1 += i.count\n \
    \   }\n    for i in lst2 {\n        totalChar2 += i.count\n    }\n    if totalChar1\
    \ < totalChar2 {\n        return lst1\n    }\n    return lst2", "    var result\
    \ = lst1\n    if lst1.reduce(0, {$0 + $1.count}) > lst2.reduce(0, {$0 + $1.count})\
    \ {\n        result = lst2\n    }\n    return result", '    return lst1.reduce(0,
    {$0 + $1.count}) < lst2.reduce(0, {$0 + $1.count}) ? lst1 : lst2', "    var total1\
    \ = 0\n    var total2 = 0\n    for str in lst1 {\n        total1 += str.count\n\
    \    }\n    for str in lst2 {\n        total2 += str.count\n    }\n    if total1\
    \ == total2 {\n        return lst1\n    } else if total1 < total2 {\n        return\
    \ lst1\n    } else {\n        return lst2\n    }", "    var matchCount = 0\n \
    \   var matchArr = [String]()\n    for a in lst1 {\n        for b in lst2 {\n\
    \            if b.count == a.count {\n                matchCount += 1\n      \
    \          matchArr.append(b)\n            }\n        }\n    }\n    if matchCount\
    \ == lst1.count {\n        return matchArr\n    } else {\n        return lst1\n\
    \    }", '    return lst1.count < lst2.count ? lst1 : lst2', "\tvar lst1Sum =\
    \ 0\n\tvar lst2Sum = 0\n\t\n\tfor item in lst1 {\n\t\tlst1Sum += item.count\n\t\
    }\n\t\n\tfor item in lst2 {\n\t\tlst2Sum += item.count\n\t}\n\t\n\treturn lst1Sum\
    \ < lst2Sum ? lst1 : lst2", "\tvar sum1 = 0\n\tvar sum2 = 0\n\tfor s in lst1 {\n\
    \t\tsum1 += s.count\n\t}\n\tfor s in lst2 {\n\t\tsum2 += s.count\n\t}\n\tif sum1\
    \ == sum2 {\n\t\treturn lst1\n\t} else if sum1 < sum2 {\n\t\treturn lst1\n\t}\
    \ else {\n\t\treturn lst2\n\t}"]
stop_tokens:
- "\n}"
