name: HumanEval_70_strange_sort_list
language: swift
prompt: "\n/// Given list of integers, return list in strange order.\n/// Strange\
  \ sorting, is when you start with the minimum value,\n/// then maximum of the remaining\
  \ integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1, 2,\
  \ 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n\
  /// strange_sort_list([]) == []\nfunc strange_sort_list(lst: [Int]) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) ==\
  \ [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8,\
  \ 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
  \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
  \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as\
  \ [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7,\
  \ 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5,\
  \ 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
completions: ["    let sorted = lst.sorted()\n    return zip(sorted, sorted.reversed()).flatMap\
    \ { $0 }", "    var lst = lst\n    var result = [Int]()\n    while !lst.isEmpty\
    \ {\n        var ind_min = 0\n        var ind_max = 0\n        for i in 0..<lst.count\
    \ {\n            if lst[i] < lst[ind_min] {\n                ind_min = i\n   \
    \         }\n            if lst[i] > lst[ind_max] {\n                ind_max =\
    \ i\n            }\n        }\n        result.append(lst[ind_min])\n        lst.remove(at:\
    \ ind_min)\n        if !lst.isEmpty {\n            result.append(lst[ind_max])\n\
    \            lst.remove(at: ind_max)\n        }\n    }\n    return result", " \
    \   var lst = lst\n    var sorted: [Int] = []\n    while !lst.isEmpty {\n    \
    \    sorted.append(lst.remove(at: lst.index(of: lst.min()!)!))\n        sorted.append(lst.remove(at:\
    \ lst.index(of: lst.max()!)!))\n    }\n    return sorted", "    var result = [Int]()\n\
    \    let sorted = lst.sorted()\n    var i = 0\n    while result.count < lst.count\
    \ {\n        result.append(sorted[i])\n        if (i < lst.count - 1) {\n    \
    \        result.append(sorted[lst.count - 1 - i])\n        }\n        i += 1\n\
    \    }\n    return result", "    if lst.count == 0 {\n        return []\n    }\n\
    \    var lst = lst\n    var result = [Int]()\n    while !lst.isEmpty {\n     \
    \   result.append(lst.min()!)\n        if lst.count > 1 {\n            result.append(lst.max()!)\n\
    \        }\n        lst.remove(result.last!)\n        lst.remove(result.last!)\n\
    \    }\n    return result", "    var result: [Int] = []\n    let sortedList =\
    \ lst.sorted(by: <)\n    var minIndex = 0\n    var maxIndex = sortedList.count\
    \ - 1\n    for i in 0..<sortedList.count {\n        if i % 2 == 0 {\n        \
    \    result.append(sortedList[minIndex])\n            minIndex += 1\n        }\
    \ else {\n            result.append(sortedList[maxIndex])\n            maxIndex\
    \ -= 1\n        }\n    }\n    return result", "    // Write your code here\n \
    \   var lst = lst\n    var result: [Int] = []\n    lst.sort()\n    var lst1 =\
    \ lst\n    var lst2 = lst.reversed()\n    for i in 0..<lst.count {\n        if\
    \ i % 2 == 0 {\n            result.append(lst1.removeFirst())\n        } else\
    \ {\n            result.append(lst2.removeFirst())\n        }\n    }\n    return\
    \ result", "\t\n\tguard lst.count > 1 else {\n\t\treturn lst\n\t}\n\t\n\tvar arr\
    \ = lst\n\t\n\tfor i in 0 ..< arr.count / 2 {\n\t\tarr.insert(arr.remove(at: arr.index(of:\
    \ arr.min()!)!), at: arr.index(of: arr.max()!)!)\n\t}\n\t\n\treturn arr", "  \
    \  var result = [Int]()\n    var lst = lst\n    while lst.count > 0 {\n      \
    \  result.append(lst.min()!)\n        lst.remove(at: lst.index(of: lst.min()!)!)\n\
    \        if lst.count == 0 {\n            break\n        }\n        result.append(lst.max()!)\n\
    \        lst.remove(at: lst.index(of: lst.max()!)!)\n    }\n    return result",
  "    let lst = lst.sort()\n    var output = [Int]()\n    var i = 0\n    var j =\
    \ lst.count - 1\n    while i <= j {\n        output.append(lst[i])\n        if\
    \ i != j {\n            output.append(lst[j])\n        }\n        i += 1\n   \
    \     j -= 1\n    }\n    return output", "\tvar lst = lst\n\tvar res = [Int]()\n\
    \twhile !lst.isEmpty {\n\t\tres.append(lst.min()!)\n\t\tres.append(lst.max()!)\n\
    \t\tlst.remove(at: lst.index(of: lst.min()!)!)\n\t\tlst.remove(at: lst.index(of:\
    \ lst.max()!)!)\n\t}\n\treturn res", "    var newLst = lst\n    var listLength\
    \ = newLst.count\n    var minIndex = 0\n    var maxIndex = 0\n    var minValue\
    \ = 0\n    var maxValue = 0\n    var result: [Int] = []\n    \n    while listLength\
    \ > 0 {\n        minValue = newLst[0]\n        maxValue = newLst[0]\n        for\
    \ i in 0..<listLength {\n            if newLst[i] < minValue {\n             \
    \   minValue = newLst[i]\n                minIndex = i\n            }\n      \
    \      if newLst[i] > maxValue {\n                maxValue = newLst[i]\n     \
    \           maxIndex = i\n            }\n        }\n        result.append(minValue)\n\
    \        newLst.remove(at: minIndex)\n        listLength -= 1\n        if listLength\
    \ == 0 {\n            break\n        }\n        result.append(maxValue)\n    \
    \    newLst.remove(at: maxIndex)\n        listLength -= 1\n    }\n    return result",
  "    var res: [Int] = []\n    guard lst.count > 0 else {\n        return res\n \
    \   }\n    let min = lst.min()!\n    var lstCopy = lst\n    lstCopy.remove(at:\
    \ lstCopy.index(of: min)!)\n    res.append(min)\n    while lstCopy.count > 0 {\n\
    \        let max = lstCopy.max()!\n        lstCopy.remove(at: lstCopy.index(of:\
    \ max)!)\n        res.append(max)\n        if lstCopy.count > 0 {\n          \
    \  let min = lstCopy.min()!\n            lstCopy.remove(at: lstCopy.index(of:\
    \ min)!)\n            res.append(min)\n        }\n    }\n    return res", "  \
    \  guard !lst.isEmpty else { return [] }\n    return Array(lst.min()!...lst.max()!).map\
    \ {\n        lst.filter { $0 != $0.signum() * $0.signum() * $0 }.min()!\n    }",
  "    let sorted = lst.sorted()\n    var result = [Int]()\n    var i = 0\n    while\
    \ i < sorted.count {\n        result.append(sorted[i])\n        if i + 1 < sorted.count\
    \ {\n            result.append(sorted[sorted.count - i - 1])\n        }\n    \
    \    i += 1\n    }\n    return result", "    var sorted = lst.sorted()\n    var\
    \ result = [Int]()\n    var isOdd = true\n    while !sorted.isEmpty {\n      \
    \  if isOdd {\n            result.append(sorted.removeFirst())\n        } else\
    \ {\n            result.append(sorted.removeLast())\n        }\n        isOdd\
    \ = !isOdd\n    }\n    return result", "    var copy = lst\n    var sorted = [Int]()\n\
    \    while !copy.isEmpty {\n        sorted.append(copy.min()!)\n        copy.remove(at:\
    \ copy.index(of: copy.min()!)!)\n        if !copy.isEmpty {\n            sorted.append(copy.max()!)\n\
    \            copy.remove(at: copy.index(of: copy.max()!)!)\n        }\n    }\n\
    \    return sorted", "    guard lst.count > 0 else { return [] }\n    var result\
    \ = lst\n    var start = 0\n    var end = lst.count - 1\n    var isAscending =\
    \ true\n    while start < end {\n        if isAscending {\n            result.swapAt(start,\
    \ start + 1)\n            start += 1\n        } else {\n            result.swapAt(end,\
    \ end - 1)\n            end -= 1\n        }\n        isAscending = !isAscending\n\
    \    }\n    return result", "  var arr = lst.sort()\n  var res = [Int]()\n  let\
    \ len = arr.count\n  var counter = 0\n  while counter < len {\n    var c = 1\n\
    \    while c <= 2 {\n      if counter < len {\n        let start = arr.startIndex\n\
    \        let end = arr.endIndex\n        let mid = start + (end - start) / 2\n\
    \        if c == 1 {\n          res.append(arr[start])\n          arr.removeAtIndex(start)\n\
    \        } else {\n          res.append(arr[mid])\n          arr.removeAtIndex(mid)\n\
    \        }\n        counter += 1\n      }\n      c += 1\n    }\n  }\n  return\
    \ res", "    var lst = lst\n    var res = [Int]()\n    while !lst.isEmpty {\n\
    \        if lst.count == 1 {\n            res.append(lst[0])\n            lst.removeAll()\n\
    \        } else {\n            res.append(lst.min()!)\n            lst.remove(at:\
    \ lst.index(of: lst.min()!)!)\n            res.append(lst.max()!)\n          \
    \  lst.remove(at: lst.index(of: lst.max()!)!)\n        }\n    }\n    return res"]
stop_tokens:
- "\n}"
