name: HumanEval_6_parse_nested_parens
language: swift
prompt: "\n/// Input to this function is a string represented multiple groups for\
  \ nested parentheses separated by spaces.\n/// For each of the group, output the\
  \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
  \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
  \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
  \ -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()())\
  \ ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
  \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
  \ \"(()(())((())))\") == [4])"
completions: ["    var max_nesting_per_group = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var stack = Stack<Character>()\n\
    \        var max_nesting = 0\n        var nesting = 0\n        for char in group\
    \ {\n            if char == \"(\" {\n                nesting += 1\n          \
    \      if nesting > max_nesting {\n                    max_nesting = nesting\n\
    \                }\n                stack.push(element: char)\n            } else\
    \ if char == \")\" {\n                nesting -= 1\n                if !stack.is_empty()\
    \ {\n                    stack.pop()\n                }\n            }\n     \
    \   }\n        max_nesting_per_group.append(max_nesting)\n    }\n    return max_nesting_per_group",
  "    var result: [Int] = []\n    let paren_groups = paren_string.split(separator:\
    \ \" \")\n    for group in paren_groups {\n        result.append(parse_single_parens(paren_string:\
    \ String(group)))\n    }\n    return result", "    var results: [Int] = []\n \
    \   var paren_string = paren_string\n    while !paren_string.isEmpty {\n     \
    \   let end_idx = paren_string.firstIndex(of: \" \") ?? paren_string.endIndex\n\
    \        let paren_group = String(paren_string[..<end_idx])\n        let max_nesting\
    \ = compute_nesting(paren_group: paren_group)\n        results.append(max_nesting)\n\
    \        if end_idx != paren_string.endIndex {\n            paren_string = String(paren_string[end_idx...])\n\
    \        } else {\n            paren_string = \"\"\n        }\n    }\n    return\
    \ results", "    let paren_groups = paren_string.split(separator: \" \")\n   \
    \ var results = [Int]()\n    var index = 0\n    while index < paren_groups.count\
    \ {\n        let paren_group = paren_groups[index]\n        var start_index =\
    \ paren_group.startIndex\n        var end_index = paren_group.endIndex\n     \
    \   var open_brackets = 0\n        var nested_depth = 0\n        var max_nested_depth\
    \ = 0\n        for paren in paren_group {\n            if paren == \"(\" {\n \
    \               open_brackets += 1\n                if open_brackets > max_nested_depth\
    \ {\n                    max_nested_depth = open_brackets\n                }\n\
    \            } else if paren == \")\" {\n                open_brackets -= 1\n\
    \            }\n        }\n        results.append(max_nested_depth)\n        index\
    \ += 1\n    }\n    return results", "    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nested_parens = [Int]()\n    for group in groups {\n   \
    \     var current_group_max = 0\n        var current_paren_level = 0\n       \
    \ for character in group.characters {\n            if character == \"(\" {\n \
    \               current_paren_level += 1\n                if current_paren_level\
    \ > current_group_max {\n                    current_group_max = current_paren_level\n\
    \                }\n            } else if character == \")\" {\n             \
    \   current_paren_level -= 1\n            }\n        }\n        max_nested_parens.append(current_group_max)\n\
    \    }\n    return max_nested_parens", "    // TODO: Write the function here!\n\
    \    return []", "    var output: [Int] = []\n    let groups = paren_string.split(separator:\
    \ \" \")\n    for group in groups {\n        var stack: [Character] = []\n   \
    \     var count = 0\n        for char in group {\n            if char == \"(\"\
    \ {\n                stack.append(char)\n                count += 1\n        \
    \    } else if char == \")\" {\n                stack.popLast()\n            \
    \    count -= 1\n            }\n        }\n        output.append(count)\n    }\n\
    \    return output", '    return paren_string.components(separatedBy: " ").compactMap
    { $0.filter { $0 == "(" }.count }', "    var levels = [Int]()\n    var prev_parens\
    \ = 0\n    var current_level = 0\n    for c in paren_string {\n        switch\
    \ c {\n        case \"(\":\n            current_level += 1\n        case \")\"\
    :\n            if current_level == prev_parens {\n                levels.append(current_level)\n\
    \                prev_parens = current_level\n                current_level =\
    \ 0\n            } else {\n                current_level -= 1\n            }\n\
    \        default:\n            continue\n        }\n    }\n    return levels",
  "    var max_nested_depth = [Int]()\n    var current_depth = 0\n    var max_depth\
    \ = 0\n    var paren_stack = [String]()\n    for character in paren_string {\n\
    \        if character == \"(\" {\n            current_depth += 1\n           \
    \ max_depth = max(max_depth, current_depth)\n            paren_stack.append(String(character))\n\
    \        } else if character == \")\" {\n            current_depth -= 1\n    \
    \        paren_stack.append(String(character))\n        } else if character ==\
    \ \" \" {\n            max_nested_depth.append(max_depth)\n            max_depth\
    \ = 0\n            paren_stack.removeAll()\n            current_depth = 0\n  \
    \      }\n    }\n    return max_nested_depth", "    var paren_stack = Stack<String>()\n\
    \    var counts = [Int]()\n    var max_depth = 0\n    let chars = paren_string.characters\n\
    \    for char in chars {\n        switch char {\n        case \"(\":\n       \
    \     paren_stack.push(String(char))\n            if paren_stack.size() > max_depth\
    \ {\n                max_depth = paren_stack.size()\n            }\n        case\
    \ \")\":\n            paren_stack.pop()\n        case \" \":\n            if !paren_stack.isEmpty()\
    \ {\n                return []\n            }\n            counts.append(max_depth)\n\
    \            max_depth = 0\n        default:\n            return []\n        }\n\
    \    }\n    if !paren_stack.isEmpty() {\n        return []\n    }\n    counts.append(max_depth)\n\
    \    return counts", "    var result = [Int]()\n    var level = 0\n    var max_level\
    \ = 0\n    var bracket_stack = [Character]()\n    for bracket in paren_string\
    \ {\n        if bracket == \"(\" {\n            bracket_stack.append(bracket)\n\
    \            level += 1\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        } else if bracket == \")\" {\n            bracket_stack.popLast()\n\
    \            level -= 1\n        } else if bracket == \" \" {\n            result.append(max_level)\n\
    \            max_level = 0\n            level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result", "    let split_parens = paren_string.components(separatedBy:\
    \ \" \")\n    var paren_nests = [Int]()\n    for paren in split_parens {\n   \
    \     let paren_chars = paren.characters\n        var paren_nest = 0\n       \
    \ var max_nest = 0\n        for char in paren_chars {\n            if char ==\
    \ \"(\" {\n                paren_nest += 1\n            } else if char == \")\"\
    \ {\n                paren_nest -= 1\n            }\n            if paren_nest\
    \ > max_nest {\n                max_nest = paren_nest\n            }\n       \
    \ }\n        paren_nests.append(max_nest)\n    }\n    return paren_nests", " \
    \   return paren_string.components(separatedBy: \" \").map {\n        var left_count\
    \ = 0\n        var max_count = 0\n        for char in $0 {\n            if char\
    \ == \"(\" {\n                left_count += 1\n                max_count = max(max_count,\
    \ left_count)\n            } else {\n                left_count -= 1\n       \
    \     }\n        }\n        return max_count\n    }", "    var max_levels: [Int]\
    \ = []\n    var paren_groups = paren_string.components(separatedBy: \" \")\n \
    \   for paren_group in paren_groups {\n        var level = 0\n        var max_level\
    \ = 0\n        for char in paren_group.characters {\n            if char == \"\
    (\" {\n                level += 1\n            } else if char == \")\" {\n   \
    \             level -= 1\n            }\n            if level > max_level {\n\
    \                max_level = level\n            }\n        }\n        max_levels.append(max_level)\n\
    \    }\n    return max_levels", "    // Keep track of the current level of nesting\n\
    \    var current_level = 0\n    // Maintain a maximum level of nesting\n    var\
    \ max_level = 0\n    // Keep track of the maximum level of all subgroups\n   \
    \ var max_level_list = [Int]()\n    // Iterate through the characters of the input\
    \ string\n    for paren in paren_string {\n        // Increment the level if you\
    \ see an open parens\n        if paren == \"(\" {\n            current_level +=\
    \ 1\n        }\n        // Decrement the level if you see a close parens\n   \
    \     if paren == \")\" {\n            current_level -= 1\n        }\n       \
    \ // If we reached the deepest level of nesting, record it\n        if current_level\
    \ > max_level {\n            max_level = current_level\n        }\n        //\
    \ If the number of closing parens is equal to the number of opening parens, we\
    \ have reached the end of a subgroup\n        if current_level == 0 {\n      \
    \      // Record the maximum level of the current subgroup\n            max_level_list.append(max_level)\n\
    \            // Reset the maximum level for the next subgroup\n            max_level\
    \ = 0\n        }\n    }\n    return max_level_list", "    // TODO: Implement this\
    \ function\n    var depth: Int = 0\n    var maxDepth: Int = 0\n    var result:\
    \ [Int] = []\n    var c: Character\n    for c in paren_string.characters {\n \
    \       if c == \"(\" {\n            depth += 1\n            if depth > maxDepth\
    \ {\n                maxDepth = depth\n            }\n        } else if c == \"\
    )\" {\n            depth -= 1\n        } else if c == \" \" {\n            result.append(maxDepth)\n\
    \            maxDepth = 0\n            depth = 0\n        }\n    }\n    result.append(maxDepth)\n\
    \    return result", "    /// Returns the number of parenthesis pairs representing\
    \ the maximum nesting in a list of parentheses.\n    /// >>> parse_nested_parens_helper('(()())')\n\
    \    /// 2\n    /// >>> parse_nested_parens_helper('(())((()))')\n    /// 2\n\
    \    /// >>> parse_nested_parens_helper('((()))')\n    /// 3\n    /// >>> parse_nested_parens_helper('((())()())')\n\
    \    /// 3\n    func parse_nested_parens_helper(paren_string: String) -> Int {\n\
    \        var max_paren_count = 0\n        var current_paren_count = 0\n      \
    \  for ch in paren_string {\n            if ch == \"(\" {\n                current_paren_count\
    \ += 1\n            } else if ch == \")\" {\n                current_paren_count\
    \ -= 1\n            }\n            max_paren_count = max(max_paren_count, current_paren_count)\n\
    \        }\n        return max_paren_count\n    }\n    /// Separate the string\
    \ into groups using whitespace as delimiter.\n    return paren_string.components(separatedBy:\
    \ \" \").map({parse_nested_parens_helper(paren_string: $0)})", '    return paren_string.components(separatedBy:
    " ").map(nested_parens)', "    var max_depth = 0\n    var paren_stack = Stack<Character>()\n\
    \    var result = [Int]()\n    var in_group = false\n    for ch in paren_string\
    \ {\n        if ch == \"(\" {\n            if !in_group {\n                in_group\
    \ = true\n                max_depth = 0\n            }\n            paren_stack.push(ch)\n\
    \            max_depth = max(max_depth, paren_stack.size)\n        } else if ch\
    \ == \")\" {\n            paren_stack.pop()\n            if paren_stack.size ==\
    \ 0 {\n                in_group = false\n                result.append(max_depth)\n\
    \            }\n        }\n    }\n    return result"]
stop_tokens:
- "\n}"
