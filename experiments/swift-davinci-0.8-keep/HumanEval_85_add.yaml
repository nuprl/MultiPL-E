name: HumanEval_85_add
language: swift
prompt: "\n/// Given a non-empty list of integers lst. add the even elements that\
  \ are at odd indices..\n/// Examples:\n/// add([4, 2, 6, 7]) ==> 2\nfunc add(lst:\
  \ [Int]) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(add(lst: [4, 88]) == 88)\nassert(add(lst:\
  \ [4, 5, 6, 7, 2, 122]) == 122)\nassert(add(lst: [4, 0, 6, 7]) == 0)\nassert(add(lst:\
  \ [4, 4, 6, 8]) == 12)"
completions: ['    return lst.enumerated().filter { $0.offset % 2 != 0 && $0.element
    % 2 == 0 }.reduce(0) { $0 + $1.element }', "    //let ans = lst.enumerated().filter\
    \ {$0.0 % 2 != 0}.map {$0.1}\n    let ans = lst.enumerated().filter {$0.0 % 2\
    \ != 0}.map {$0.1}.reduce(0, +)\n    return ans", '    return lst.filter({$0 %
    2 == 0}).reduce(0, +)', "    var total = 0\n    for (index, number) in lst.enumerated()\
    \ {\n        if index % 2 != 0 && number % 2 == 0 {\n            total += number\n\
    \        }\n    }\n    return total", "    \n    var addSum = 0\n    \n    for\
    \ index in lst.indices where index % 2 != 0 {\n        addSum += (lst[index] %\
    \ 2 == 0) ? lst[index] : 0\n    }\n    \n    return addSum", "    var sum = 0\n\
    \    var counter = 0\n    for i in lst {\n        if counter % 2 != 0 && i % 2\
    \ == 0 {\n            sum += i\n        }\n        counter += 1\n    }\n    return\
    \ sum", "    var sum = 0\n    for (index, num) in lst.enumerated() {\n       \
    \ if (index % 2 == 1) && (num % 2 == 0) {\n            sum += num\n        }\n\
    \    }\n    return sum", '    return lst.enumerated().filter({ $0.offset % 2 !=
    0 && $0.element % 2 == 0 }).map({ $0.element }).reduce(0, +)', "    // This can\
    \ be done with a lot of map and filter but since the order of execution of map\
    \ and filter is not specified,\n    // I find using a loop cleaner\n    var sum\
    \ = 0\n    for (index, value) in lst.enumerated() {\n        if index % 2 == 1\
    \ && value % 2 == 0 {\n            sum += value\n        }\n    }\n    return\
    \ sum", "    var sum = 0\n    for (index, element) in lst.enumerated() {\n   \
    \     if index % 2 != 0 && element % 2 == 0 {\n            sum += element\n  \
    \      }\n    }\n    return sum", "    var sum = 0\n    for (index, item) in lst.enumerated()\
    \ {\n        if index % 2 != 0 && item % 2 == 0 {\n            sum += item\n \
    \       }\n    }\n    return sum", "  var sum = 0\n  for (index, num) in lst.enumerated()\
    \ {\n    if index % 2 != 0 && num % 2 == 0 {\n      sum += num\n    }\n  }\n \
    \ return sum", '    return lst.filter{$0 % 2 == 0}.filter{lst.index(of: $0)! %
    2 != 0}.reduce(0, +)', "    var sum = 0\n    for i in 1..<lst.count {\n      \
    \  if lst[i] % 2 == 0 {\n            sum += lst[i]\n        }\n    }\n    return\
    \ sum", "    return lst.enumerated().reduce(0) {\n        (result, tuple) in\n\
    \        let (index, element) = tuple\n        return index % 2 == 1 && element\
    \ % 2 == 0 ? result + element : result\n    }", "    var num = 0\n    for (index,\
    \ value) in lst.enumerated() {\n        if index % 2 != 0 {\n            num +=\
    \ value\n        }\n    }\n    return num", '    return lst.enumerated().filter({$0.offset
    % 2 != 0}).filter({$0.element % 2 == 0}).reduce(0, {$0 + $1.element})', "    var\
    \ result = 0\n    for (i, val) in lst.enumerated() {\n        if i % 2 != 0 &&\
    \ val % 2 == 0 {\n            result += val\n        }\n    }\n    return result",
  '    return lst.enumerated().reduce(0) { $1.offset % 2 == 1 && $1.element % 2 ==
    0 ? $0 + $1.element : $0 }', "    let result = lst.enumerated().filter { $0.0\
    \ % 2 != 0 }.filter { $0.1 % 2 == 0 }.map { $0.1 }.reduce(0, +)\n    return result"]
stop_tokens:
- "\n}"
