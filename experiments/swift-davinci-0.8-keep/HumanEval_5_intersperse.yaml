name: HumanEval_5_intersperse
language: swift
prompt: "\n/// Insert a number 'delimeter' between every two consecutive elements\
  \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
  \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int)\
  \ -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter:\
  \ 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
  \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) ==\
  \ [2, 2, 2, 2, 2])"
completions: ["    if numbers.isEmpty {\n        return []\n    }\n    return numbers.reduce([Int]())\
    \ { acc, num in\n        if acc.isEmpty {\n            return [num]\n        }\n\
    \        return acc + [delimeter] + [num]\n    }", "    if numbers.isEmpty {\n\
    \        return []\n    }\n    if numbers.count == 1 {\n        return numbers\n\
    \    }\n    var result = [Int]()\n    for i in 0..<numbers.count - 1 {\n     \
    \   result.append(numbers[i])\n        result.append(delimeter)\n    }\n    result.append(numbers[numbers.count\
    \ - 1])\n    return result", "  // base case:\n  if numbers.count == 0 {\n   \
    \ return []\n  } else if numbers.count == 1 {\n    return numbers\n  } else {\n\
    \    // recursive case:\n    var result = [Int]()\n    result.append(numbers[0])\n\
    \    result.append(delimeter)\n    result.append(contentsOf: intersperse(numbers:\
    \ Array(numbers[1..<numbers.count]), delimeter: delimeter))\n    return result\n\
    \  }", "    if numbers.isEmpty {\n        return []\n    }\n    if numbers.count\
    \ == 1 {\n        return numbers\n    }\n    return numbers.dropLast().reduce([numbers.last!])\
    \ { result, number in\n        return result + [delimeter] + [number]\n    }",
  "    if numbers.isEmpty {\n        return []\n    } else {\n        return Array(interpose(numbers,\
    \ delimeter: delimeter))\n    }", '    return intersperse(numbers, delimeter:
    delimeter, result: [])', "    if let first = numbers.first {\n        return [first]\
    \ + [delimeter] + intersperse(Array(numbers[1..<numbers.count]), delimeter: delimeter)\n\
    \    } else {\n        return []\n    }", "\tif numbers.isEmpty {\n\t\treturn\
    \ []\n\t} else {\n\t\treturn [numbers[0]] + [delimeter] + intersperse(Array(numbers[1..<numbers.count]),\
    \ delimeter: delimeter)\n\t}", "    // EXERCISE: your code here!\n    return []",
  "    guard let n = numbers.first else {\n        return []\n    }\n    guard numbers.count\
    \ > 1 else {\n        return [n]\n    }\n    return [n] + [delimeter] + intersperse(Array(numbers[1..<numbers.count]),\
    \ delimeter: delimeter)", "    if numbers.isEmpty {\n        return []\n    }\
    \ else {\n        let head = numbers[0]\n        let tail = numbers[1..<numbers.count]\n\
    \        return [head] + intersperse(Array(tail), delimeter: delimeter).map {\
    \ $0 + delimeter }\n    }", "\tif numbers.isEmpty {\n\t\treturn []\n\t}\n\t\n\t\
    var result = [Int]()\n\t\n\tfor i in 0..<numbers.count {\n\t\tresult.append(numbers[i])\n\
    \t\tif i < numbers.count - 1 {\n\t\t\tresult.append(delimeter)\n\t\t}\n\t}\n\t\
    \n\treturn result", "    if numbers.isEmpty {\n        return []\n    }\n    else\
    \ {\n        var result = [Int]()\n        result.append(numbers[0])\n       \
    \ for i in 1..<numbers.count {\n            result.append(delimeter)\n       \
    \     result.append(numbers[i])\n        }\n        return result\n    }", " \
    \   if numbers.isEmpty {\n        return []\n    }\n    var l = [Int]()\n    l.append(numbers[0])\n\
    \    for i in 1..<numbers.count {\n        l.append(delimeter)\n        l.append(numbers[i])\n\
    \    }\n    return l", "    var output: [Int] = []\n    for i in 0..<numbers.count\
    \ {\n        output.append(numbers[i])\n        if i != numbers.count - 1 {\n\
    \            output.append(delimeter)\n        }\n    }\n    return output", " \
    \   var result: [Int] = []\n    for i in 0..<numbers.count {\n        result.append(numbers[i])\n\
    \        if i != numbers.count - 1 {\n            result.append(delimeter)\n \
    \       }\n    }\n    return result", "    if numbers.isEmpty {\n        return\
    \ []\n    }\n    var numbers = numbers\n    let head = numbers.removeFirst()\n\
    \    return [head] + numbers.flatMap { [delimeter, $0] }", "    func go(numbers:\
    \ [Int], delimeter: Int, acc: [Int]) -> [Int] {\n        if numbers.isEmpty {\n\
    \            return acc\n        } else if let (x, xs) = numbers.decompose {\n\
    \            return go(xs, delimeter: delimeter, acc: acc + [x, delimeter])\n\
    \        } else {\n            fatalError(\"impossible\")\n        }\n    }\n\
    \    return go(numbers, delimeter: delimeter, acc: [])", "  guard let first =\
    \ numbers.first else { return [] }\n  guard numbers.count > 1 else { return [first]\
    \ }\n  return [first] + [delimeter] + intersperse(Array(numbers[1..<numbers.count]),\
    \ delimeter: delimeter)", "    if numbers.isEmpty {\n        return []\n    }\
    \ else {\n        return insert(numbers[0], numbers.dropFirst().map { insert(delimeter,\
    \ [$0]) }.reduce([], +))\n    }"]
stop_tokens:
- "\n}"
