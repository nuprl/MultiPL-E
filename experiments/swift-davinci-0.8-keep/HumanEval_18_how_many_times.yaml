name: HumanEval_18_how_many_times
language: swift
prompt: "\n/// Find how many times a given substring can be found in the original\
  \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n/// >>>\
  \ how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n/// 3\n\
  func how_many_times(string: String, substring: String) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(how_many_times(string: \"\", substring:\
  \ \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") ==\
  \ 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
  \ \"john doe\", substring: \"john\") == 1)"
completions: ["    var how_many = 0\n    var string = string\n    while string.contains(substring)\
    \ {\n        let range = string.range(of: substring)!\n        string.removeSubrange(range)\n\
    \        how_many += 1\n    }\n    return how_many", "    var result = 0\n   \
    \ var start = string.startIndex\n    var end = string.index(start, offsetBy: substring.count\
    \ - 1)\n    while end < string.endIndex {\n        let mySubstring = string[start...end]\n\
    \        if mySubstring == substring {\n            result += 1\n        }\n \
    \       start = string.index(after: start)\n        end = string.index(after:\
    \ end)\n    }\n    return result", "    let characterSet = CharacterSet(charactersIn:\
    \ string)\n    let sub = CharacterSet(charactersIn: substring)\n    let characterIntersection\
    \ = characterSet.intersection(sub)\n    let characters = CharacterSet(charactersIn:\
    \ String(characterIntersection))\n    return string.components(separatedBy: characters).count",
  "    let parentString = string\n    let substring = substring\n    let searchString\
    \ = substring\n    let searchLength = searchString.count\n    let parentLength\
    \ = parentString.count\n    var count = 0\n    var searchRange = parentString.startIndex..<parentString.endIndex\n\
    \    while let range = parentString.range(of: searchString, options: [], range:\
    \ searchRange) {\n        searchRange = range.upperBound..<parentString.endIndex\n\
    \        count += 1\n    }\n    return count", "    var result = 0\n    var last_found\
    \ = -1\n    while last_found != nil {\n        if let range = string.rangeOfString(substring,\
    \ options: NSStringCompareOptions.LiteralSearch, range: (last_found + 1)..<string.endIndex)\
    \ {\n            last_found = distance(string.startIndex, range.startIndex)\n\
    \            result += 1\n        } else {\n            last_found = nil\n   \
    \     }\n    }\n    return result", "    var count = 0\n    var last_index = string.startIndex\n\
    \    while let range = string.range(of: substring, options: .literal, range: last_index..<string.endIndex,\
    \ locale: nil) {\n        count += 1\n        last_index = range.upperBound\n\
    \    }\n    return count", "  var count = 0\n  var left = 0\n  let right = string.count\
    \ - substring.count\n  for _ in left...right {\n    if substring == string[left..<left+substring.count]\
    \ {\n      count += 1\n    }\n    left += 1\n  }\n  return count", "    var count\
    \ = 0\n    var index = string.startIndex\n    for _ in 1...string.count {\n  \
    \      let range = index..<string.index(index, offsetBy: substring.count)\n  \
    \      if string[range] == substring {\n            count += 1\n        }\n  \
    \      index = string.index(after: index)\n    }\n    return count", "    var\
    \ counter = 0\n    var target = string\n    let lenght = substring.characters.count\n\
    \    var startIndex = string.startIndex\n    while let index = target.rangeOfString(substring)?.startIndex\
    \ {\n        counter += 1\n        startIndex = startIndex.advancedBy(index +\
    \ lenght)\n        target = target.substringFromIndex(startIndex)\n    }\n   \
    \ return counter", "    var count = 0\n    for i in 0 ..< string.count - substring.count\
    \ + 1 {\n        let range = string.index(string.startIndex, offsetBy: i) ..<\
    \ string.index(string.startIndex, offsetBy: i + substring.count)\n        if string[range]\
    \ == substring {\n            count += 1\n        }\n    }\n    return count",
  "  // TODO\n  return 0", '    return 0', "  precondition(string.characters.count\
    \ >= substring.characters.count)\n  if string.characters.count == 0 {\n    return\
    \ 0\n  }\n  var times = 0\n  var offset = 0\n  while let range = string.rangeOfString(substring,\
    \ options: [], range: offset..<string.endIndex, locale: nil) {\n    offset = range.endIndex\n\
    \    times += 1\n  }\n  return times", "    var count = 0\n    for (i, _) in string.characters.enumerated()\
    \ {\n        if string.substring(with: string.characters.index(string.startIndex,\
    \ offsetBy: i)..<string.characters.index(string.startIndex, offsetBy: i + substring.characters.count))\
    \ == substring {\n            count += 1\n        }\n    }\n    return count",
  "    guard !string.isEmpty else { return 0 }\n    guard !substring.isEmpty else\
    \ { return 0 }\n    guard substring.count <= string.count else { return 0 }\n\
    \    \n    var count = 0\n    for index in 0..<string.count where string.startIndex.distance(to:\
    \ string.index(string.startIndex, offsetBy: index)) < (string.count - substring.count\
    \ + 1) {\n        let subString = string[string.index(string.startIndex, offsetBy:\
    \ index)..<string.index(string.startIndex, offsetBy: index + substring.count)]\n\
    \        if subString == substring {\n            count += 1\n        }\n    }\n\
    \    return count", "    var count = 0\n    let range = Range(start: string.startIndex,\
    \ end: string.endIndex)\n    string.enumerateSubstringsInRange(range, options:\
    \ NSStringEnumerationOptions.ByComposedCharacterSequences) { (substring, substringRange,\
    \ enclosingRange, stop) -> () in\n        if let substring = substring {\n   \
    \         if substring == substring {\n                count += 1\n          \
    \  }\n        }\n    }\n    return count", "    var howManyTimes = 0\n    var\
    \ startIndex = string.startIndex\n    while startIndex < string.endIndex {\n \
    \       let endIndex = string.index(startIndex, offsetBy: substring.count, limitedBy:\
    \ string.endIndex)\n        if let endIndex = endIndex, string[startIndex..<endIndex]\
    \ == substring {\n            howManyTimes += 1\n            startIndex = endIndex\n\
    \        } else {\n            break\n        }\n    }\n    return howManyTimes",
  "    let len = string.characters.count\n    let s_len = substring.characters.count\n\
    \    var i = 0\n    var count = 0\n    while(i < len - s_len + 1) {\n        if\
    \ string[string.index(string.startIndex, offsetBy: i)..<string.index(string.startIndex,\
    \ offsetBy: i + s_len)] == substring {\n            count += 1\n            i\
    \ += s_len\n        } else {\n            i += 1\n        }\n    }\n    return\
    \ count", "    if string.isEmpty || substring.isEmpty {\n        return 0\n  \
    \  }\n    let chars: [Character] = Array(string)\n    let subchars: [Character]\
    \ = Array(substring)\n    var count = 0\n    var subindex = 0\n    for char in\
    \ chars {\n        if char == subchars[subindex] {\n            subindex += 1\n\
    \            if subindex == subchars.count {\n                count += 1\n   \
    \             subindex = 0\n            }\n        } else {\n            subindex\
    \ = 0\n        }\n    }\n    return count", "    var count = 0\n    for c in string.characters\
    \ {\n        if String(c) == substring {\n            count += 1\n        }\n\
    \    }\n    return count"]
stop_tokens:
- "\n}"
