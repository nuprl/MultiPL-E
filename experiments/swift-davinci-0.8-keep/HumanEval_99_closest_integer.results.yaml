language: swift
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let smallestInteger = Int(doubleValue!)\n\
    \    let largestInteger = smallestInteger + 1\n    let differenceSmallest = abs(smallestInteger\
    \ - doubleValue!)\n    let differenceLargest = abs(largestInteger - doubleValue!)\n\
    \    if differenceSmallest > differenceLargest {\n        return largestInteger\n\
    \    } else {\n        return smallestInteger\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpwp7tjhlb.swift:19:50: error: binary operator '-' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n    let differenceSmallest = abs(smallestInteger\
    \ - doubleValue!)\n                                 ~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~\n\
    /tmp/tmpwp7tjhlb.swift:19:50: note: overloads for '-' exist with these partially\
    \ matching parameter lists: (Double, Double), (Int, Int)\n    let differenceSmallest\
    \ = abs(smallestInteger - doubleValue!)\n                                    \
    \             ^\n/tmp/tmpwp7tjhlb.swift:20:48: error: binary operator '-' cannot\
    \ be applied to operands of type 'Int' and 'Double'\n    let differenceLargest\
    \ = abs(largestInteger - doubleValue!)\n                                ~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~\n/tmp/tmpwp7tjhlb.swift:20:48: note: overloads for '-' exist\
    \ with these partially matching parameter lists: (Double, Double), (Int, Int)\n\
    \    let differenceLargest = abs(largestInteger - doubleValue!)\n            \
    \                                   ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let floatValue = Float(value)\n    let doubleValue = Double(value)\n    if\
    \ floatValue == nil && doubleValue == nil {\n        return -1\n    }\n    let\
    \ intValue = Int(value)\n    var decimalPart = floatValue != nil ? fmodf(floatValue!,\
    \ 1) : fmod(doubleValue!, 1)\n    if decimalPart == 0 {\n        return intValue\n\
    \    }\n    decimalPart = decimalPart < 0 ? decimalPart * -1 : decimalPart\n \
    \   let decimalPoint = decimalPart * 10\n    if decimalPoint == 5.0 {\n      \
    \  return intValue + (intValue < 0 ? -1 : 1)\n    }\n    let roundedDecimalPoint\
    \ = Int(round(decimalPoint))\n    return intValue + (roundedDecimalPoint > 5 ?\
    \ 1 : 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpf4tbl7n4.swift:22:43: error: cannot find 'fmodf' in scope\n   \
    \ var decimalPart = floatValue != nil ? fmodf(floatValue!, 1) : fmod(doubleValue!,\
    \ 1)\n                                          ^~~~~\n/tmp/tmpf4tbl7n4.swift:22:67:\
    \ error: cannot find 'fmod' in scope\n    var decimalPart = floatValue != nil\
    \ ? fmodf(floatValue!, 1) : fmod(doubleValue!, 1)\n                          \
    \                                        ^~~~\n/tmp/tmpf4tbl7n4.swift:24:16: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \       return intValue\n               ^\n/tmp/tmpf4tbl7n4.swift:24:16: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        return intValue\n               ^\n                        ?? <#default\
    \ value#>\n/tmp/tmpf4tbl7n4.swift:24:16: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        return intValue\n  \
    \             ^\n                       !\n/tmp/tmpf4tbl7n4.swift:29:16: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \       return intValue + (intValue < 0 ? -1 : 1)\n               ^\n/tmp/tmpf4tbl7n4.swift:29:16:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return intValue + (intValue < 0 ? -1 : 1)\n               ^\n\
    \               (        ?? <#default value#>)\n/tmp/tmpf4tbl7n4.swift:29:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return intValue + (intValue < 0 ? -1 : 1)\n               ^\n\
    \                       !\n/tmp/tmpf4tbl7n4.swift:29:28: error: value of optional\
    \ type 'Int?' must be unwrapped to a value of type 'Int'\n        return intValue\
    \ + (intValue < 0 ? -1 : 1)\n                           ^\n/tmp/tmpf4tbl7n4.swift:29:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return intValue + (intValue < 0 ? -1 : 1)\n                 \
    \          ^\n                                    ?? <#default value#>\n/tmp/tmpf4tbl7n4.swift:29:28:\
    \ note"
  stdout: ''
  timestamp: 1660014263
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp9_bc1c8x/tmp9_bc1c8x.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af55f599c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af55f290b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af55f290988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af55f28f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9_bc1c8x                        0x0000564d1fa40264 <unavailable> + 4708

    5    libc.so.6                          0x00002af55f785460 __libc_start_main +
    245

    6    tmp9_bc1c8x                        0x0000564d1fa3fee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014263
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  // ...\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpq4u3z0a8/tmpq4u3z0a8.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5df7855c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5df754cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5df754c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5df754b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq4u3z0a8                        0x000055b8d0260264 <unavailable> + 4708

    5    libc.so.6                          0x00002b5df7a41460 __libc_start_main +
    245

    6    tmpq4u3z0a8                        0x000055b8d025fee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014263
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpo_8igpza/tmpo_8igpza.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002aef1d24dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef1cf44561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aef1cf44286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aef1cf4413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aef1cf43bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpo_8igpza                        0x00005623a981375a <unavailable> + 5978

    6    tmpo_8igpza                        0x00005623a98133dd <unavailable> + 5085

    7    libc.so.6                          0x00002aef1d439460 __libc_start_main +
    245

    8    tmpo_8igpza                        0x00005623a9813039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  let\
    \ number = Double(value)!\n  let rounded = number.rounded()\n  if rounded > number\
    \ {\n    return Int(rounded - 1)\n  }\n  return Int(rounded)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.cZkNs8/tmpiyeqd4pa-1.o:tmpiyeqd4pa-1.o:function $s11tmpiyeqd4pa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.cZkNs8/tmpiyeqd4pa-1.o:tmpiyeqd4pa-1.o:function $s11tmpiyeqd4pa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.cZkNs8/tmpiyeqd4pa-1.o:tmpiyeqd4pa-1.o:function $s11tmpiyeqd4pa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.cZkNs8/tmpiyeqd4pa-1.o:tmpiyeqd4pa-1.o:function $s11tmpiyeqd4pa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.cZkNs8/tmpiyeqd4pa-1.o:tmpiyeqd4pa-1.o:function $s11tmpiyeqd4pa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.cZkNs8/tmpiyeqd4pa-1.o:tmpiyeqd4pa-1.o:function $s11tmpiyeqd4pa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.cZkNs8/tmpiyeqd4pa-1.o:tmpiyeqd4pa-1.o:function $s11tmpiyeqd4pa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  // Convert value to Double\n    let doubleValue = (value as NSString).doubleValue\n\
    \    // Get the absolute value\n    let absValue = abs(doubleValue)\n    // Get\
    \ the Int value from the double\n    let floorValue = floor(absValue)\n    //\
    \ Check if the double value is already an Int\n    if absValue == floorValue {\n\
    \        // Return the Int\n        return Int(doubleValue)\n    }\n    // Get\
    \ the fractional value\n    let fraction = absValue - floorValue\n    // If the\
    \ fractional value is greater than or equal to 0.5, then increment the Int value\n\
    \    if fraction >= 0.5 {\n        return Int(doubleValue) + 1\n    }\n    //\
    \ Otherwise just return the Int value\n    return Int(doubleValue)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp162qeof9.swift:17:33: error: cannot find type 'NSString' in scope\n\
    \    let doubleValue = (value as NSString).doubleValue\n                     \
    \           ^~~~~~~~\n/tmp/tmp162qeof9.swift:17:43: error: value of type 'String'\
    \ has no member 'doubleValue'\n    let doubleValue = (value as NSString).doubleValue\n\
    \                      ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmp162qeof9.swift:21:22:\
    \ error: cannot find 'floor' in scope\n    let floorValue = floor(absValue)\n\
    \                     ^~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var closest: Int = 0\n    let value_double: Double = Double(value)!\n    if\
    \ value_double > 0 {\n        closest = Int(value_double.rounded(.up))\n    }\
    \ else {\n        closest = Int(value_double.rounded(.down))\n    }\n    return\
    \ closest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.x1EYY7/tmp_zfbns5u-1.o:tmp_zfbns5u-1.o:function $s11tmp_zfbns5u15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.x1EYY7/tmp_zfbns5u-1.o:tmp_zfbns5u-1.o:function $s11tmp_zfbns5u15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.x1EYY7/tmp_zfbns5u-1.o:tmp_zfbns5u-1.o:function $s11tmp_zfbns5u15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.x1EYY7/tmp_zfbns5u-1.o:tmp_zfbns5u-1.o:function $s11tmp_zfbns5u15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.x1EYY7/tmp_zfbns5u-1.o:tmp_zfbns5u-1.o:function $s11tmp_zfbns5u15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.x1EYY7/tmp_zfbns5u-1.o:tmp_zfbns5u-1.o:function $s11tmp_zfbns5u15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.x1EYY7/tmp_zfbns5u-1.o:tmp_zfbns5u-1.o:function $s11tmp_zfbns5u15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.x1EYY7/tmp_zfbns5u-1.o:tmp_zfbns5u-1.o:function $s11tmp_zfbns5u15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.x1EYY7/tmp_zfbns5u-1.o:tmp_zfbns5u-1.o:function $s11tmp_zfbns5u15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.x1EYY7/tmp_zfbns5u-1.o:tmp_zfbns5u-1.o:function $s11tmp_zfbns5u15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.x1EYY7/tmp_zfbns5u-1.o:tmp_zfbns5u-1.o:function $s11tmp_zfbns5u15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.x1EYY7/tmp_zfbns5u-1.o:tmp_zfbns5u-1.o:function $s11tmp_zfbns5u15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.x1EYY7/tmp_zfbns5u-1.o:tmp_zfbns5u-1.o:function $s11tmp_zfbns5u15closest_i'
  stdout: ''
  timestamp: 1660014263
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let val = Double(value)!\n    let integer = Int(val)\n    if val - Double(integer)\
    \ >= 0.5 {\n        return integer + 1\n    } else {\n        return integer\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpcnf8l5ms/tmpcnf8l5ms.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b02e18e2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b02e15d9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b02e15d9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b02e15d87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcnf8l5ms                        0x0000562d675a7512 <unavailable> + 5394

    5    libc.so.6                          0x00002b02e1ace460 __libc_start_main +
    245

    6    tmpcnf8l5ms                        0x0000562d675a7049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let valueDouble = Double(value)\n    let lowerBound = floor(valueDouble!)\n\
    \    let upperBound = ceil(valueDouble!)\n    let half = lowerBound + ((upperBound\
    \ - lowerBound) / 2)\n    return half >= valueDouble! ? Int(lowerBound) : Int(upperBound)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp2mgx_221.swift:17:22: error: cannot find 'floor' in scope\n   \
    \ let lowerBound = floor(valueDouble!)\n                     ^~~~~\n/tmp/tmp2mgx_221.swift:18:22:\
    \ error: cannot find 'ceil' in scope\n    let upperBound = ceil(valueDouble!)\n\
    \                     ^~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  if let number = Double(value) {\n        let number = round(number)\n     \
    \   return Int(number)\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpvzp05une.swift:17:22: error: cannot find 'round' in scope\n   \
    \     let number = round(number)\n                     ^~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  guard let double = Double(value) else {\n        return 0\n    }\n    return\
    \ Int(double.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.r8zDB9/tmpqcp1kp2q-1.o:tmpqcp1kp2q-1.o:function $s11tmpqcp1kp2q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.r8zDB9/tmpqcp1kp2q-1.o:tmpqcp1kp2q-1.o:function $s11tmpqcp1kp2q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.r8zDB9/tmpqcp1kp2q-1.o:tmpqcp1kp2q-1.o:function $s11tmpqcp1kp2q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.r8zDB9/tmpqcp1kp2q-1.o:tmpqcp1kp2q-1.o:function $s11tmpqcp1kp2q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.r8zDB9/tmpqcp1kp2q-1.o:tmpqcp1kp2q-1.o:function $s11tmpqcp1kp2q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.r8zDB9/tmpqcp1kp2q-1.o:tmpqcp1kp2q-1.o:function $s11tmpqcp1kp2q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.r8zDB9/tmpqcp1kp2q-1.o:tmpqcp1kp2q-1.o:function $s11tmpqcp1kp2q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  if let inputDouble = Double(value) {\n        return Int(round(inputDouble))\n\
    \    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp5y77hycj.swift:17:20: error: cannot find 'round' in scope\n   \
    \     return Int(round(inputDouble))\n                   ^~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value.floatValue.rounded())\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpvky9j2al.swift:16:22: error: value of type 'String' has no member\
    \ 'floatValue'\n    return Int(value.floatValue.rounded())\n               ~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n\t\
    if let number = Double(value) {\n\t\treturn Int(number.rounded(.awayFromZero))\n\
    \t}\n\treturn 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.EeKS77/tmp_4_r2st0-1.o:tmp_4_r2st0-1.o:function $s11tmp_4_r2st015closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.EeKS77/tmp_4_r2st0-1.o:tmp_4_r2st0-1.o:function $s11tmp_4_r2st015closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.EeKS77/tmp_4_r2st0-1.o:tmp_4_r2st0-1.o:function $s11tmp_4_r2st015closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.EeKS77/tmp_4_r2st0-1.o:tmp_4_r2st0-1.o:function $s11tmp_4_r2st015closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.EeKS77/tmp_4_r2st0-1.o:tmp_4_r2st0-1.o:function $s11tmp_4_r2st015closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.EeKS77/tmp_4_r2st0-1.o:tmp_4_r2st0-1.o:function $s11tmp_4_r2st015closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.EeKS77/tmp_4_r2st0-1.o:tmp_4_r2st0-1.o:function $s11tmp_4_r2st015closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  guard !value.isEmpty else { return 0 }\n    guard let number = Double(value)\
    \ else { return 0 }\n    let left = Int(floor(number))\n    let right = Int(ceil(number))\n\
    \    let distanceLeft = abs(number - Double(left))\n    let distanceRight = abs(number\
    \ - Double(right))\n    return distanceLeft > distanceRight ? right : left\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp572nobbp.swift:18:20: error: cannot find 'floor' in scope\n   \
    \ let left = Int(floor(number))\n                   ^~~~~\n/tmp/tmp572nobbp.swift:19:21:\
    \ error: cannot find 'ceil' in scope\n    let right = Int(ceil(number))\n    \
    \                ^~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let decimal = Double(value)!\n    let rounded = round(decimal)\n    return\
    \ Int(rounded)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp8n8zy3pk.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(decimal)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    return Int(num.rounded(.toNearestOrAwayFromZero))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.uKPhv8/tmppol57_jj-1.o:tmppol57_jj-1.o:function $s11tmppol57_jj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.uKPhv8/tmppol57_jj-1.o:tmppol57_jj-1.o:function $s11tmppol57_jj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.uKPhv8/tmppol57_jj-1.o:tmppol57_jj-1.o:function $s11tmppol57_jj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.uKPhv8/tmppol57_jj-1.o:tmppol57_jj-1.o:function $s11tmppol57_jj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.uKPhv8/tmppol57_jj-1.o:tmppol57_jj-1.o:function $s11tmppol57_jj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uKPhv8/tmppol57_jj-1.o:tmppol57_jj-1.o:function $s11tmppol57_jj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uKPhv8/tmppol57_jj-1.o:tmppol57_jj-1.o:function $s11tmppol57_jj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014263
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var closest = Int(value) ?? 0\n    if value.contains(\".\") {\n        let\
    \ values = value.split(separator: \".\")\n        let value1 = Double(values[0])\
    \ ?? 0\n        let value2 = Double(values[1]) ?? 0\n        if value2 > 0 {\n\
    \            closest = Int(value1 + 1)\n        }\n    }\n    return closest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpd1zj51sr/tmpd1zj51sr.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5389199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5388e90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5388e90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5388e8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd1zj51sr                        0x0000563025849872 <unavailable> + 6258

    5    libc.so.6                          0x00002b5389385460 __libc_start_main +
    245

    6    tmpd1zj51sr                        0x00005630258493a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1660014263
