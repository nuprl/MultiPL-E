language: swift
name: HumanEval_159_eat
results:
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    var result = 0\n    if remaining >= need {\n\
    \        result = number + need\n    } else {\n        result = number + remaining\n\
    \    }\n    return [result, remaining - need]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp9evvwcmt/tmp9evvwcmt.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac32865fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac328356b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac328356988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3283557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9evvwcmt                        0x000055d40de43658 <unavailable> + 5720

    5    libc.so.6                          0x00002ac32884b460 __libc_start_main +
    245

    6    tmp9evvwcmt                        0x000055d40de42fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014069
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    return [min(number + remaining, need), max(0,\
    \ number + remaining - need)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpq1z84g3r/tmpq1z84g3r.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b70f6847c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b70f653eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b70f653e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b70f653d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq1z84g3r                        0x00005570d7d6f474 <unavailable> + 5236

    5    libc.so.6                          0x00002b70f6a33460 __libc_start_main +
    245

    6    tmpq1z84g3r                        0x00005570d7d6f0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013875
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    var totalEaten = number\n    var remainingCarrots\
    \ = remaining\n    var result: [Int] = []\n    \n    if need <= remaining {\n\
    \        remainingCarrots = remaining - need\n        totalEaten += need\n   \
    \ } else {\n        totalEaten += remaining\n        remainingCarrots = 0\n  \
    \  }\n    \n    result.append(totalEaten)\n    result.append(remainingCarrots)\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014069
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n  if remaining == 0 {\n    return [number, 0]\n\
    \  }\n  if remaining < need - number {\n    return [number + remaining, 0]\n \
    \ }\n  return [number + need, remaining - need + number]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp_j0z6xp_/tmp_j0z6xp_.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9b5f3e0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9b5f0d7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9b5f0d7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9b5f0d67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_j0z6xp_                        0x00005558e57df384 <unavailable> + 4996

    5    libc.so.6                          0x00002b9b5f5cc460 __libc_start_main +
    245

    6    tmp_j0z6xp_                        0x00005558e57defc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014069
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    return [number + min(need, remaining), max(0,\
    \ remaining - need)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013875
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    return [number + min(need, remaining), max(0,\
    \ remaining - need)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013875
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    // Write your code here...\n    return [0, 0]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpcodiikc9/tmpcodiikc9.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d451dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d44ed3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d44ed3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d44ed27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcodiikc9                        0x000055d26de45384 <unavailable> + 4996

    5    libc.so.6                          0x00002b8d453c8460 __libc_start_main +
    245

    6    tmpcodiikc9                        0x000055d26de44fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014069
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    var res = [number, remaining]\n    if res[1]\
    \ >= res[0] + need {\n        res[1] -= res[0] + need\n        res[0] += need\n\
    \    } else {\n        res[0] += res[1]\n        res[1] = 0\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6,\
    \ remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) ==\
    \ [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp3bt3xpub/tmp3bt3xpub.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b461959ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4619295b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4619295988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46192947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3bt3xpub                        0x000055760c6a1434 <unavailable> + 5172

    5    libc.so.6                          0x00002b461978a460 __libc_start_main +
    245

    6    tmp3bt3xpub                        0x000055760c6a1079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660014069
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    var total = number + remaining\n    var remain\
    \ = 0\n    if (total >= need) {\n        total = need\n        remain = total\
    \ - need\n    }\n    return [total, remain]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp9sf9yqdo/tmp9sf9yqdo.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d32a0bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d32702b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d32702988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d327017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9sf9yqdo                        0x0000562498107384 <unavailable> + 4996

    5    libc.so.6                          0x00002b5d32bf7460 __libc_start_main +
    245

    6    tmp9sf9yqdo                        0x0000562498106fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014069
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    var eaten: Int = number + need\n    let remainingCarrots:\
    \ Int = eaten > remaining ? 0 : remaining - eaten\n    return [eaten, remainingCarrots]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpn1fbdnnj/tmpn1fbdnnj.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0aa96efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0aa93e6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0aa93e6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0aa93e57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn1fbdnnj                        0x000055631bde6384 <unavailable> + 4996

    5    libc.so.6                          0x00002b0aa98db460 __libc_start_main +
    245

    6    tmpn1fbdnnj                        0x000055631bde5fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014069
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    if remaining < need {\n        return [number\
    \ + remaining, 0]\n    }\n    return [number + need, remaining - need]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014069
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    let result = [number + (need < remaining ? need\
    \ : remaining), (need > remaining ? need - remaining : 0)]\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpho32b145/tmpho32b145.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba23d0f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba23cde8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba23cde8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba23cde77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpho32b145                        0x000055d7f0808384 <unavailable> + 4996

    5    libc.so.6                          0x00002ba23d2dd460 __libc_start_main +
    245

    6    tmpho32b145                        0x000055d7f0807fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014069
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    let count = number + min(need, remaining)\n\
    \    let last = max(0, remaining - need)\n    return [count, last]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014069
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    var array = [Int]()\n    var a = number\n  \
    \  var b = need\n    var c = remaining\n    if c >= b {\n        a += b\n    \
    \    c -= b\n        b = 0\n    } else {\n        a += c\n        b -= c\n   \
    \     c = 0\n    }\n    array.append(a)\n    array.append(c)\n    return array\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014069
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    var message = \"\"\n    if number <= 0 || number\
    \ > 1000 {\n        message = \"number should be number between 0 and 1000\"\n\
    \    }\n    if need <= 0 || need > 1000 {\n        message = \"need should be\
    \ number between 0 and 1000\"\n    }\n    if remaining <= 0 || remaining > 1000\
    \ {\n        message = \"remaining should be number between 0 and 1000\"\n   \
    \ }\n    guard message.isEmpty else {\n        print(message)\n        return\
    \ []\n    }\n    let eatenCarrots = number + need\n    var remainingCarrots =\
    \ remaining - need\n    if remainingCarrots < 0 {\n        remainingCarrots =\
    \ 0\n    }\n    return [eatenCarrots, remainingCarrots]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp04quxzn3/tmp04quxzn3.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b51ddc43c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b51dd93ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b51dd93a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51dd9397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp04quxzn3                        0x000055f12d9f7898 <unavailable> + 6296

    5    libc.so.6                          0x00002b51dde2f460 __libc_start_main +
    245

    6    tmp04quxzn3                        0x000055f12d9f7209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660014069
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    let result = number + need\n    return [result,\
    \ max(0, remaining - need)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpw4g73tu2/tmpw4g73tu2.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7c7b135c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7c7ae2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7c7ae2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7c7ae2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw4g73tu2                        0x000055cb5071a6f8 <unavailable> + 5880

    5    libc.so.6                          0x00002b7c7b321460 __libc_start_main +
    245

    6    tmpw4g73tu2                        0x000055cb5071a069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660014069
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    return [number + min(need, remaining), max(0,\
    \ remaining - need)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013875
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    let eaten = number + need > remaining ? remaining\
    \ : number + need\n    return [eaten, remaining - eaten]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpkzu66kwr/tmpkzu66kwr.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b02cfaacc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b02cf7a3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b02cf7a3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b02cf7a27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkzu66kwr                        0x000055ce577ea384 <unavailable> + 4996

    5    libc.so.6                          0x00002b02cfc98460 __libc_start_main +
    245

    6    tmpkzu66kwr                        0x000055ce577e9fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014069
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    return [number + min(need, remaining), max(0,\
    \ remaining - need)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013875
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfunc eat(number: Int, need: Int,\
    \ remaining: Int) -> [Int] {\n    let total: Int = number + remaining\n    if\
    \ (total >= need) {\n        return [need, total - need]\n    } else {\n     \
    \   return [total, 0]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpav34xvfc/tmpav34xvfc.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d5eac0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d5e7b7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d5e7b7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d5e7b67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpav34xvfc                        0x000055978279f384 <unavailable> + 4996

    5    libc.so.6                          0x00002b8d5ecac460 __libc_start_main +
    245

    6    tmpav34xvfc                        0x000055978279efc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014069
