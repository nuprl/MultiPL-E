language: swift
name: HumanEval_49_modp
results:
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var (current, result) = (1, 1)\n    while current <= n {\n        result\
    \ = result * current % p\n        current = current + 1\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmppat914ws/tmppat914ws.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ccb8abc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ccb5a2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ccb5a2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ccb5a17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppat914ws                        0x000056374cace24d <unavailable> + 4685

    5    libc.so.6                          0x00002b8ccba97460 __libc_start_main +
    245

    6    tmppat914ws                        0x000056374cacdef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014461
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var p = p\n    if p <= 0 {\n        return -1\n    }\n    var n = n\n\
    \    if n <= 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let temp\
    \ = modp(n: n / 2, p: p)\n        return (temp * temp) % p\n    } else {\n   \
    \     let temp = modp(n: n - 1, p: p)\n        return (n * temp) % p\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpbe9g3swx/tmpbe9g3swx.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e7feedc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e7fbe4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e7fbe4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e7fbe37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbe9g3swx                        0x00005575515232cd <unavailable> + 4813

    5    libc.so.6                          0x00002b6e800d9460 __libc_start_main +
    245

    6    tmpbe9g3swx                        0x0000557551522ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014461
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    } else if n % 2 == 0 {\n        return\
    \ (modp(n / 2, p: p) * modp(n / 2, p: p)) % p\n    } else {\n        return (2\
    \ * modp(n / 2, p: p) * modp(n / 2, p: p)) % p\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp81j_06e2.swift:17:21: error: missing argument label 'n:' in call\n\
    \        return (modp(n / 2, p: p) * modp(n / 2, p: p)) % p\n                \
    \    ^\n                     n: \n/tmp/tmp81j_06e2.swift:17:41: error: missing\
    \ argument label 'n:' in call\n        return (modp(n / 2, p: p) * modp(n / 2,\
    \ p: p)) % p\n                                        ^\n                    \
    \                     n: \n/tmp/tmp81j_06e2.swift:19:25: error: missing argument\
    \ label 'n:' in call\n        return (2 * modp(n / 2, p: p) * modp(n / 2, p: p))\
    \ % p\n                        ^\n                         n: \n/tmp/tmp81j_06e2.swift:19:45:\
    \ error: missing argument label 'n:' in call\n        return (2 * modp(n / 2,\
    \ p: p) * modp(n / 2, p: p)) % p\n                                           \
    \ ^\n                                             n: \n"
  stdout: ''
  timestamp: 1660014461
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return p - modp(-n, p: p)\n    }\n    if n == 0 {\n\
    \        return 1\n    }\n    if n % 2 == 0 {\n        return (modp(n / 2, p:\
    \ p) * modp(n / 2, p: p)) % p\n    }\n    return (modp(n / 2, p: p) * modp(n /\
    \ 2, p: p) * 2) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7ls7ui1q.swift:15:24: error: missing argument label 'n:' in call\n\
    \        return p - modp(-n, p: p)\n                       ^\n               \
    \         n: \n/tmp/tmp7ls7ui1q.swift:21:21: error: missing argument label 'n:'\
    \ in call\n        return (modp(n / 2, p: p) * modp(n / 2, p: p)) % p\n      \
    \              ^\n                     n: \n/tmp/tmp7ls7ui1q.swift:21:41: error:\
    \ missing argument label 'n:' in call\n        return (modp(n / 2, p: p) * modp(n\
    \ / 2, p: p)) % p\n                                        ^\n               \
    \                          n: \n/tmp/tmp7ls7ui1q.swift:23:17: error: missing argument\
    \ label 'n:' in call\n    return (modp(n / 2, p: p) * modp(n / 2, p: p) * 2) %\
    \ p\n                ^\n                 n: \n/tmp/tmp7ls7ui1q.swift:23:37: error:\
    \ missing argument label 'n:' in call\n    return (modp(n / 2, p: p) * modp(n\
    \ / 2, p: p) * 2) % p\n                                    ^\n               \
    \                      n: \n"
  stdout: ''
  timestamp: 1660014461
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var res = 1\n    var a = 2\n    var b = n\n    while b > 0 {\n      \
    \  if b % 2 == 1 {\n            res = (res * a) % p\n        }\n        a = (a\
    \ * a) % p\n        b /= 2\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014461
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var res = 1\n    for _ in 1...n {\n        res = (res * 2) % p\n    }\n\
    \    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ac88fdc1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac88fab8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac88fab8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac88fab813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac88fab7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpk874cpsy                        0x000055c4c772675d <unavailable> + 5981

    6    tmpk874cpsy                        0x000055c4c77263cf <unavailable> + 5071

    7    libc.so.6                          0x00002ac88ffad460 __libc_start_main +
    245

    8    tmpk874cpsy                        0x000055c4c7725fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014461
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n  var n = n\n  var p = p\n  var counter = 0\n  var result = 1\n  while n\
    \ != 0 {\n    if n % 2 == 1 {\n      result = (result * counter) % p\n    }\n\
    \    counter = (counter * counter) % p\n    n /= 2\n  }\n  return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmplpxe2zsr/tmplpxe2zsr.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2816d8ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2816a85b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2816a85988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2816a847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplpxe2zsr                        0x0000558d5d12924d <unavailable> + 4685

    5    libc.so.6                          0x00002b2816f7a460 __libc_start_main +
    245

    6    tmplpxe2zsr                        0x0000558d5d128ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014461
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return 2 * modp(n:\
    \ n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014461
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    else {\n       \
    \ return modp(n: n - 1, p: p) * modp(n: n, p: p) % p\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014467
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    assert(p > 0)\n    if n == 0 {\n        return 1\n    } else if n % 2\
    \ == 0 {\n        let b = modp(n / 2, p: p)\n        return modp(b, p: p) * modp(b,\
    \ p: p) % p\n    } else {\n        return n * modp(n - 1, p: p) % p\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsp9z2yi_.swift:18:21: error: missing argument label 'n:' in call\n\
    \        let b = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmpsp9z2yi_.swift:19:20: error: missing argument label 'n:' in call\n\
    \        return modp(b, p: p) * modp(b, p: p) % p\n                   ^\n    \
    \                n: \n/tmp/tmpsp9z2yi_.swift:19:36: error: missing argument label\
    \ 'n:' in call\n        return modp(b, p: p) * modp(b, p: p) % p\n           \
    \                        ^\n                                    n: \n/tmp/tmpsp9z2yi_.swift:21:24:\
    \ error: missing argument label 'n:' in call\n        return n * modp(n - 1, p:\
    \ p) % p\n                       ^\n                        n: \n"
  stdout: ''
  timestamp: 1660014461
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    var a = n\n    var b = p\n    while (a != 0) {\n\
    \        if (a % 2 == 1) {\n            result = (result * a) % b\n        }\n\
    \        a = a >> 1\n        b = (b * b) % p\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b75951a4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7594e9b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7594e9b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7594e9b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7594e9abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpcxyvpyis                        0x0000564692570737 <unavailable> + 5943

    6    tmpcxyvpyis                        0x00005646925701e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b7595390460 __libc_start_main +
    245

    8    tmpcxyvpyis                        0x000056469256fef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014461
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if p <= n {\n        return modp(n, p: p * 2) % p\n    } else if n ==\
    \ 0 {\n        return 1\n    } else {\n        return modp(n - 1, p: p) * 2 %\
    \ p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxuw3j6mb.swift:15:20: error: missing argument label 'n:' in call\n\
    \        return modp(n, p: p * 2) % p\n                   ^\n                \
    \    n: \n/tmp/tmpxuw3j6mb.swift:19:20: error: missing argument label 'n:' in\
    \ call\n        return modp(n - 1, p: p) * 2 % p\n                   ^\n     \
    \               n: \n"
  stdout: ''
  timestamp: 1660014461
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    return Int(gmpz_ui_pow_ui(UInt(n), UInt(p)))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmuks_lg3.swift:14:16: error: cannot find 'gmpz_ui_pow_ui' in scope\n\
    \    return Int(gmpz_ui_pow_ui(UInt(n), UInt(p)))\n               ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014461
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var d = 1\n    var k = 0\n    while (1 << k) <= n {\n        k += 1\n\
    \    }\n    while k > 0 {\n        k -= 1\n        d = (d * d) % p\n        if\
    \ (n & (1 << k)) != 0 {\n            d = (d * 2) % p\n        }\n    }\n    return\
    \ d\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014461
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n  if n == 0 {\n    return 1\n  }\n  if n % 2 == 0 {\n    return modp(n: n\
    \ / 2, p: p) * modp(n: n / 2, p: p) % p\n  }\n  return modp(n: n - 1, p: p) *\
    \ modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014467
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n  if n == 0 {\n    return 1\n  }\n  if n % 2 == 0 {\n    let r = modp(n/2,\
    \ p: p)\n    return (r * r) % p\n  }\n  return (n * modp(n-1, p: p)) % p\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmm8gofye.swift:18:17: error: missing argument label 'n:' in call\n\
    \    let r = modp(n/2, p: p)\n                ^\n                 n: \n/tmp/tmpmm8gofye.swift:19:15:\
    \ error: cannot convert value of type 'Duration' to expected argument type 'Int'\n\
    \    return (r * r) % p\n              ^\n/tmp/tmpmm8gofye.swift:21:19: error:\
    \ missing argument label 'n:' in call\n  return (n * modp(n-1, p: p)) % p\n  \
    \                ^\n                   n: \n"
  stdout: ''
  timestamp: 1660014461
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n  var result = 1\n  var n = n\n  while n > 0 {\n    if n & 1 == 1 {\n   \
    \   result = (result * n) % p\n    }\n    n >>= 1\n  }\n  return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpggcreo6j/tmpggcreo6j.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1dde44c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1ddb3bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1ddb3b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1ddb3a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpggcreo6j                        0x0000562fac2c62cd <unavailable> + 4813

    5    libc.so.6                          0x00002ad1de030460 __libc_start_main +
    245

    6    tmpggcreo6j                        0x0000562fac2c5ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014461
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    // TODO: error handling\n    // if p == 0 { return }\n    if p == 1 {\
    \ return 0 }\n    var r = 1\n    var k = n\n    while k > 0 {\n        if k &\
    \ 1 == 1 {\n            r = r * n % p\n        }\n        k = k >> 1\n       \
    \ n = n * n % p\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpq1_xzkn2.swift:24:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = n * n % p\n        ^\n"
  stdout: ''
  timestamp: 1660014461
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    assert(n >= 0 && p > 0)\n    if n == 0 {\n        return 1\n    }\n \
    \   if n % 2 == 0 {\n        let sq = modp(n: n / 2, p: p)\n        return sq\
    \ * sq % p\n    }\n    return modp(n: n - 1, p: p) * n % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpndxsarqa/tmpndxsarqa.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b43ccc2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b43cc925b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b43cc925988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b43cc9247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpndxsarqa                        0x000055d4d7cc42cd <unavailable> + 4813

    5    libc.so.6                          0x00002b43cce1a460 __libc_start_main +
    245

    6    tmpndxsarqa                        0x000055d4d7cc3ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014461
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if p == 1 {\n        return 0\n    }\n    var r = 1\n    var n = n\n\
    \    while n > 0 {\n        if n & 1 == 1 {\n            r = (r * n) % p\n   \
    \     }\n        n >>= 1\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpzy5065z3/tmpzy5065z3.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af14f298c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af14ef8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af14ef8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af14ef8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzy5065z3                        0x00005583412582cd <unavailable> + 4813

    5    libc.so.6                          0x00002af14f484460 __libc_start_main +
    245

    6    tmpzy5065z3                        0x0000558341257ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014461
