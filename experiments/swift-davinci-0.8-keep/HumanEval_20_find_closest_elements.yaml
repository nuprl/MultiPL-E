name: HumanEval_20_find_closest_elements
language: swift
prompt: "\n/// From a supplied list of numbers (of length at least two) select and\
  \ return two that are the closest to each\n/// other and return them in order (smaller\
  \ number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double,\
  \ Double) {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0,\
  \ 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
  \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
  \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
  \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
completions: ["    // 1. find absolute difference between each 2\n    // 2. find smallest\
    \ 2\n    // 3. return\n    var abs_diff_dict = [Double: [Double]]()\n    var abs_diff\
    \ = [Double]()\n    var pair_list = [(Double, Double)]()\n    var sorted_abs_diff\
    \ = [Double]()\n    for i in 0..<numbers.count-1 {\n        for j in i+1..<numbers.count\
    \ {\n            abs_diff.append(abs(numbers[i] - numbers[j]))\n            pair_list.append((numbers[i],\
    \ numbers[j]))\n        }\n    }\n    //print(abs_diff)\n    for i in 0..<abs_diff.count\
    \ {\n        abs_diff_dict[abs_diff[i]] = [pair_list[i].0, pair_list[i].1]\n \
    \   }\n    sorted_abs_diff = abs_diff.sorted()\n    //print(abs_diff_dict)\n \
    \   //print(sorted_abs_diff)\n    return (abs_diff_dict[sorted_abs_diff[0]]![0],\
    \ abs_diff_dict[sorted_abs_diff[0]]![1])", "    if numbers.count < 2 {\n     \
    \   return (0, 0)\n    }\n    var closest = (numbers[0], numbers[1])\n    var\
    \ difference = abs(closest.0 - closest.1)\n    for i in 0..<numbers.count {\n\
    \        for j in (i + 1)..<numbers.count {\n            if abs(numbers[i] - numbers[j])\
    \ < difference {\n                closest = (numbers[i], numbers[j])\n       \
    \         difference = abs(numbers[i] - numbers[j])\n            }\n        }\n\
    \    }\n    return closest", "    \n    var newNumbers: [Double] = numbers.sort()\n\
    \    var currentClosest: Double = Double.infinity\n    var closestElements: (Double,\
    \ Double) = (0, 0)\n    \n    for number in newNumbers {\n        let closest\
    \ = abs(number - newNumbers[newNumbers.indexOf(number)!+1])\n        if closest\
    \ < currentClosest {\n            currentClosest = closest\n            closestElements\
    \ = (number, newNumbers[newNumbers.indexOf(number)!+1])\n        }\n    }\n  \
    \  \n    return closestElements", "    if numbers.count < 2 {\n        return\
    \ (0, 0)\n    }\n    var (first, second) = (numbers[0], numbers[1])\n    if abs(first\
    \ - second) > abs(numbers[numbers.count - 1] - numbers[numbers.count - 2]) {\n\
    \        (first, second) = (numbers[numbers.count - 1], numbers[numbers.count\
    \ - 2])\n    }\n    for i in 0..<numbers.count - 1 {\n        if abs(numbers[i]\
    \ - numbers[i + 1]) < abs(first - second) {\n            (first, second) = (numbers[i],\
    \ numbers[i + 1])\n        }\n    }\n    return (first, second)", "    // TODO:\
    \ implement function\n    return (0.0, 0.0)", "    assert(numbers.count >= 2)\n\
    \    var closest: (Double, Double) = (numbers[0], numbers[1])\n    var closest_difference\
    \ = closest.1 - closest.0\n    for i in 0..<numbers.count {\n        for j in\
    \ i..<numbers.count {\n            if i != j {\n                let difference\
    \ = numbers[j] - numbers[i]\n                if difference < closest_difference\
    \ {\n                    closest = (numbers[i], numbers[j])\n                \
    \    closest_difference = difference\n                }\n            }\n     \
    \   }\n    }\n    return closest", "    var minDiff = numbers[1] - numbers[0]\n\
    \    var minPair = (numbers[0], numbers[1])\n    for i in 0..<numbers.count -\
    \ 1 {\n        for j in (i + 1)..<numbers.count {\n            let diff = numbers[j]\
    \ - numbers[i]\n            if diff < minDiff {\n                minDiff = diff\n\
    \                minPair = (numbers[i], numbers[j])\n            }\n        }\n\
    \    }\n    return minPair", "    // Determine the smallest number\n    let sorted\
    \ = numbers.sorted()\n    var closest_one = sorted[0]\n    var closest_two = sorted[1]\n\
    \    var difference = closest_two - closest_one\n    var index = 1\n    while\
    \ index < sorted.count - 1 {\n        if sorted[index+1] - sorted[index] < difference\
    \ {\n            closest_one = sorted[index]\n            closest_two = sorted[index+1]\n\
    \            difference = closest_two - closest_one\n        }\n        index\
    \ += 1\n    }\n    return (closest_one, closest_two)", "    var closest_elements\
    \ = (numbers[0], numbers[1])\n    var closest_difference = abs(numbers[0] - numbers[1])\n\
    \    for i in 0..<numbers.count - 1 {\n        for j in (i + 1)..<numbers.count\
    \ {\n            let difference = abs(numbers[i] - numbers[j])\n            if\
    \ difference < closest_difference {\n                closest_difference = difference\n\
    \                closest_elements = (numbers[i], numbers[j])\n            }\n\
    \        }\n    }\n    return closest_elements", "    precondition(numbers.count\
    \ >= 2)\n    if (numbers.count == 2) {\n        return (numbers[0], numbers[1])\n\
    \    }\n    var min = numbers[0] - numbers[1]\n    var max = numbers[0] - numbers[1]\n\
    \    for x in 0...numbers.count - 2 {\n        for y in x+1...numbers.count -\
    \ 1 {\n            if (min > numbers[x] - numbers[y]) {\n                min =\
    \ numbers[x] - numbers[y]\n            }\n            if (max < numbers[x] - numbers[y])\
    \ {\n                max = numbers[x] - numbers[y]\n            }\n        }\n\
    \    }\n    return (min, max)", "    guard numbers.count >= 2 else {\n       \
    \ fatalError(\"find_closest_elements: not enough numbers to compare\")\n    }\n\
    \    var closest1 = numbers[0]\n    var closest2 = numbers[1]\n    var lowestDiff\
    \ = closest2 - closest1\n    for index in 0..<numbers.count {\n        guard index\
    \ < numbers.count - 1 else {\n            break\n        }\n        let diff =\
    \ numbers[index + 1] - numbers[index]\n        if diff < lowestDiff {\n      \
    \      closest1 = numbers[index]\n            closest2 = numbers[index + 1]\n\
    \            lowestDiff = diff\n        }\n    }\n    return (closest1, closest2)",
  "    var closest = (numbers[0], numbers[1])\n    var diff = fabs(closest.0 - closest.1)\n\
    \    for i in 0..<numbers.count {\n        for j in 0..<numbers.count {\n    \
    \        if i != j {\n                let newDiff = fabs(numbers[i] - numbers[j])\n\
    \                if newDiff < diff {\n                    closest = (numbers[i],\
    \ numbers[j])\n                    diff = newDiff\n                }\n       \
    \     }\n        }\n    }\n    return closest", "    var diff = 1E300\n    var\
    \ closest1 = 0.0\n    var closest2 = 0.0\n    var start = 0\n    var end = 1\n\
    \    while end < numbers.count {\n        let diff1 = numbers[end] - numbers[start]\n\
    \        if diff1 < diff {\n            diff = diff1\n            closest1 = numbers[start]\n\
    \            closest2 = numbers[end]\n        }\n        start += 1\n        end\
    \ += 1\n    }\n    return (closest1, closest2)", "    var tup = (Double.infinity,\
    \ Double.infinity)\n    for i in 0..<numbers.count {\n        for j in i+1..<numbers.count\
    \ {\n            if abs(numbers[i] - numbers[j]) < abs(tup.0 - tup.1) {\n    \
    \            tup = (numbers[i], numbers[j])\n            }\n        }\n    }\n\
    \    return tup", "    var minDist = abs(numbers[0] - numbers[1])\n    var minIndex\
    \ = 0\n    for i in 0...numbers.count - 2 {\n        if abs(numbers[i] - numbers[i\
    \ + 1]) < minDist {\n            minDist = abs(numbers[i] - numbers[i + 1])\n\
    \            minIndex = i\n        }\n    }\n    return (numbers[minIndex], numbers[minIndex\
    \ + 1])", "    var diff : Double = abs(numbers[0] - numbers[1])\n    var min1\
    \ : Double = numbers[0]\n    var min2 : Double = numbers[1]\n    for var i=0;\
    \ i<numbers.count-1; i++ {\n        for var j=i+1; j<numbers.count; j++ {\n  \
    \          if abs(numbers[i] - numbers[j]) < diff {\n                diff = abs(numbers[i]\
    \ - numbers[j])\n                min1 = numbers[i]\n                min2 = numbers[j]\n\
    \            }\n        }\n    }\n    return (min1, min2)", "    var min_difference\
    \ = Double.infinity\n    var min_elements = (0.0, 0.0)\n    for var i = 0; i <\
    \ numbers.count; i++ {\n        for var j = i + 1; j < numbers.count; j++ {\n\
    \            let difference = abs(numbers[i] - numbers[j])\n            if difference\
    \ < min_difference {\n                min_difference = difference\n          \
    \      min_elements = (numbers[i], numbers[j])\n            }\n        }\n   \
    \ }\n    return min_elements", "    var closest: (Double, Double) = (numbers[0],\
    \ numbers[1])\n    for i in 0..<numbers.count {\n        for j in 0..<numbers.count\
    \ {\n            if abs(numbers[i] - numbers[j]) < abs(closest.0 - closest.1)\
    \ {\n                closest = (numbers[i], numbers[j])\n            }\n     \
    \   }\n    }\n    return closest", "    assert(numbers.count >= 2)\n    var c1\
    \ = numbers[0]\n    var c2 = numbers[1]\n    var d = c2 - c1\n    var d_min =\
    \ d\n    for i in 1 ..< numbers.count - 1 {\n        c1 = numbers[i]\n       \
    \ c2 = numbers[i + 1]\n        d = c2 - c1\n        if d < d_min {\n         \
    \   d_min = d\n        }\n    }\n    return (d_min, d_min)", "    var min_difference:\
    \ Double = DBL_MAX\n    var min_difference_pair: (Double, Double) = (DBL_MAX,\
    \ DBL_MAX)\n    for index in 0..<numbers.count {\n        for second_index in\
    \ 0..<numbers.count {\n            if index != second_index {\n              \
    \  let difference = abs(numbers[index] - numbers[second_index])\n            \
    \    if difference < min_difference {\n                    min_difference = difference\n\
    \                    min_difference_pair = (numbers[index], numbers[second_index])\n\
    \                }\n            }\n        }\n    }\n    return min_difference_pair"]
stop_tokens:
- "\n}"
