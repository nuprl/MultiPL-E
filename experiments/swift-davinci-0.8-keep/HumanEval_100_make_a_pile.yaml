name: HumanEval_100_make_a_pile
language: swift
prompt: "\n/// Given a positive integer n, you have to make a pile of n levels of\
  \ stones.\n/// The first level has n stones.\n/// The number of stones in the next\
  \ level is:\n/// - the next odd number if n is odd.\n/// - the next even number\
  \ if n is even.\n/// Return the number of stones in each level in a list, where\
  \ element at index\n/// i represents the number of stones in the level (i+1).\n\
  /// Examples:\n/// >>> make_a_pile(3)\n/// [3, 5, 7]\nfunc make_a_pile(n: Int) ->\
  \ [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(make_a_pile(n: 3) == [3, 5, 7])\nassert(make_a_pile(n:\
  \ 4) == [4, 6, 8, 10])\nassert(make_a_pile(n: 5) == [5, 7, 9, 11, 13])\nassert(make_a_pile(n:\
  \ 6) == [6, 8, 10, 12, 14, 16])\nassert(make_a_pile(n: 8) == [8, 10, 12, 14, 16,\
  \ 18, 20, 22])"
completions: ["    var ans = [n]\n    var next = n%2 == 0 ? n+2 : n+1\n    while next\
    \ < n*2 {\n        ans.append(next)\n        next += next%2 == 0 ? 2 : 1\n   \
    \ }\n    return ans", "    var result = [Int]()\n    var last = n\n    while last\
    \ > 0 {\n        result.append(last)\n        last = last % 2 == 0 ? last - 1\
    \ : last + 1\n    }\n    return result", "    var l = [Int]()\n    l.append(n)\n\
    \    for i in 1...n {\n        if l[i-1] % 2 == 0 {\n            l.append(l[i-1]\
    \ + 2)\n        } else {\n            l.append(l[i-1] + 1)\n        }\n    }\n\
    \    return l", '    return [Int]((n...3*n).step(n%2==0 ? 2 : 1).filter{ $0 %
    2 != 0 })', "    var pile = [n]\n    var i = n\n    while i > 1 {\n        i =\
    \ (i % 2 == 0) ? i - 1 : i - 2\n        pile.append(i)\n    }\n    return pile",
  "    var result = [Int]()\n    var layer = n\n    while layer != 0 {\n        result.append(layer)\n\
    \        if layer % 2 == 0 {\n            layer -= 1\n        } else {\n     \
    \       layer -= 2\n        }\n    }\n    return result", "    var result = [n]\n\
    \    var i = n\n    while i > 0 {\n        if i % 2 == 0 {\n            i = i\
    \ + 1\n        } else {\n            i = i + 2\n        }\n        result.append(i)\n\
    \    }\n    return result", '  return (0..<n).map { max(n, $0.isEven ? n + 1 :
    n - 1) }', "  var list = [n]\n  while n != 1 {\n    n = n % 2 == 0 ? n / 2 : n\
    \ * 3 + 1\n    list.append(n)\n  }\n  return list", "    return Array(1...n).map\
    \ { n in\n        if n % 2 == 0 {\n            return n + 1\n        } else {\n\
    \            return n + 2\n        }\n    }", '    return []', "  assert(n > 0)\n\
    \  var res = [Int]()\n  var x = n\n  while x > 0 {\n    res.append(x)\n    if\
    \ x.isMultiple(of: 2) {\n      x += 1\n    } else {\n      x += 2\n    }\n  }\n\
    \  return res", "    let max_level = n + (n-1) / 2\n    var levels = [Int](repeating:\
    \ 0, count: max_level)\n    var i = 0\n    var j = 0\n    while i < n {\n    \
    \    levels[j] = j*2 + 1\n        j += 1\n        i += 1\n    }\n    i = n\n \
    \   while i < max_level {\n        levels[i] = levels[i-1] + 2\n        i += 1\n\
    \    }\n    return levels", "    var stones = [Int]()\n    stones.append(n)\n\
    \    var next_stone = 0\n    while next_stone <= n {\n        if n % 2 == 0 {\n\
    \            next_stone = n + 2\n        } else {\n            next_stone = n\
    \ + 1\n        }\n        n = next_stone\n        stones.append(n)\n    }\n  \
    \  return stones", "    guard n > 0 else {\n        return []\n    }\n    return\
    \ (1...n).map { x in\n        if x % 2 == 0 {\n            return 2 * x\n    \
    \    } else {\n            return 2 * x - 1\n        }\n    }", "  var level =\
    \ n\n  var result = [n]\n  while true {\n    level = (level.isEven ? level + 1\
    \ : level + 2)\n    result.append(level)\n    if level >= n * 2 {\n      break\n\
    \    }\n  }\n  return result", "  let base: (Int) -> Int = { n in n * 2 + 1 }\n\
    \  return Array(1...n).map { base($0) }", "    var pile = [n]\n    var current_level\
    \ = n\n    while current_level > 1 {\n        if current_level % 2 == 0 {\n  \
    \          current_level -= 1\n        } else {\n            current_level -=\
    \ 2\n        }\n        pile.append(current_level)\n    }\n    return pile", " \
    \   let result = [n]\n    return result", '    return (0..<n).map { $0 + n }']
stop_tokens:
- "\n}"
