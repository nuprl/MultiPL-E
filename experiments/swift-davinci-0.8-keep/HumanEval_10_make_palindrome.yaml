name: HumanEval_10_make_palindrome
language: swift
prompt: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
  /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
  \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
  \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
  /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
  /// 'catac'\nfunc make_palindrome(string: String) -> String {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\n\
  assert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
  \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
  assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
completions: ["    let reverse = string.characters.reverse()\n    let rev_string =\
    \ String(reverse)\n    let max_palindrome_prefix = rev_string.suffix_prefix_match(string)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(max_palindrome_prefix))\n\
    \    let rev_prefix = String(prefix.characters.reverse())\n    return string +\
    \ rev_prefix", "    var characters = Array(string.characters)\n    let count =\
    \ characters.count\n    let half = count / 2\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    var index = 0\n    while index\
    \ < half {\n        let to_check = String(characters[index..<count])\n       \
    \ let palindrome_length = to_check.count - longest_common_prefix_length(first:\
    \ to_check, second: String(to_check.characters.reverse()))\n        if palindrome_length\
    \ > longest_palindrome_length {\n            longest_palindrome_length = palindrome_length\n\
    \            longest_palindrome_index = index\n        }\n        index += 1\n\
    \    }\n    if longest_palindrome_length == 0 {\n        return string\n    }\n\
    \    let to_append = String(characters[0..<longest_palindrome_index].reverse())\n\
    \    return string + to_append", "    var longest_palindrome_string = find_longest_palindrome(string:\
    \ string)\n    return string + String(longest_palindrome_string.characters.reversed())",
  "    let string_length = string.characters.count\n    var string_characters = Array(string.characters)\n\
    \    var suffix_start_index = 0\n    var suffix_end_index = 0\n    var reverse_suffix_start_index\
    \ = 0\n    var reverse_suffix_end_index = 0\n    var palindrome_length = 0\n \
    \   var palindrome_center = 0\n    // The main idea behind this palindrome finding\
    \ algorithm is that we will find the longest palindrome\n    // centered around\
    \ each character and pick the longest one out of these palindromes.\n    for i\
    \ in 0..<string_length {\n        // Even length palindrome.\n        if i > 0\
    \ && string_characters[i] == string_characters[i - 1] {\n            suffix_start_index\
    \ = i - 1\n            suffix_end_index = i\n            reverse_suffix_start_index\
    \ = string_length - suffix_end_index - 1\n            reverse_suffix_end_index\
    \ = string_length - suffix_start_index - 1\n            while (suffix_start_index\
    \ >= 0 && reverse_suffix_start_index < string_length) &&\n                   \
    \ string_characters[suffix_start_index] == string_characters[reverse_suffix_start_index]\
    \ {\n                suffix_start_index -= 1\n                reverse_suffix_start_index\
    \ += 1\n            }\n            suffix_start_index += 1\n            reverse_suffix_start_index\
    \ -= 1\n            let current_palindrome_length = (suffix_end_index - suffix_start_index)\
    \ + 1\n            if current_palindrome_length > palindrome_length {\n      \
    \          palindrome_length = current_palindrome_length\n                palindrome_center\
    \ = i\n            }\n        }\n        // Odd length palindrome.\n        if\
    \ i > 0 && string_characters[i] == string_characters[i - 1] {\n            suffix_start_index\
    \ = i - 1\n            suffix_end_index = i + 1\n            reverse_suffix_start_index\
    \ = string_length - suffix_end_index - 1\n            reverse_suffix_end_index\
    \ =", "  let string = Array(string)\n  let length = string.count\n  let max_length\
    \ = 2 * length - 1\n  let T = Array(repeating: (0, String.Index.init(encodedOffset:\
    \ 0)), count: max_length)\n  var center = 0\n  var right = 0\n  let l = string.endIndex\n\
    \  var c: Int\n  var r: Int\n  var i: Int\n  var i_mirror: Int\n  var expand:\
    \ Int = -1\n  var diff: Int = -1\n  var i2: Int\n  var i2_mirror: Int\n  for i\
    \ in 0..<max_length {\n    expand = 1\n    if i < right {\n      i_mirror = 2\
    \ * center - i\n      diff = right - i\n      if diff > 0 {\n        if T[i_mirror].0\
    \ < diff {\n          T[i] = T[i_mirror]\n          continue\n        } else if\
    \ T[i_mirror].0 == diff && i == max_length - 1 {\n          T[i] = T[i_mirror]\n\
    \          continue\n        }\n      }\n      expand = diff + 1\n    }\n    i2\
    \ = i + expand\n    i2_mirror = i - expand\n    while i2 < max_length && i2_mirror\
    \ >= 0 &&\n      ((i2 % 2 == 0) || (string[i2 / 2] == string[i2_mirror / 2]))\
    \ {\n      expand += 1\n      i2 += 1\n      i2_mirror -= 1\n    }\n    T[i] =\
    \ (expand, string.startIndex.advanced(by: (i - expand) / 2))\n    if i + expand\
    \ > right {\n      center = i\n      right = i + expand\n    }\n  }\n  c = 0\n\
    \  for r in 1..<max_length {\n    if T[r].0 > T[c].0 {\n      c = r\n    }\n \
    \ }\n  var result = string\n  result.append(contentsOf: string[T[c].1..<l].reversed())\n\
    \  return String(result)", "    let length = string.count\n    if length == 0\
    \ {\n        return \"\"\n    }\n    // Find the longest suffix that is also a\
    \ prefix.\n    // We actually search for the longest prefix that is also a suffix.\n\
    \    let reversed = string.reversed()\n    var suffix = \"\"\n    for i in 0..<length\
    \ {\n        let prefix = String(string[..<i])\n        if reversed.hasPrefix(prefix)\
    \ {\n            suffix = prefix\n        }\n    }\n    let prefixIndex = string.index(string.startIndex,\
    \ offsetBy: length - suffix.count)\n    let prefix = String(string[..<prefixIndex])\n\
    \    return string + String(prefix.reversed())", "    var prefix = string\n  \
    \  let suffix = String(string.characters.reverse())\n    var pivot = suffix.endIndex\n\
    \    while (pivot != suffix.startIndex) {\n        if (prefix.hasSuffix(suffix[suffix.startIndex..<pivot]))\
    \ {\n            return prefix + suffix[pivot..<suffix.endIndex]\n        }\n\
    \        pivot = pivot.predecessor()\n    }\n    return string + suffix", "  \
    \  guard !string.isEmpty else {\n        return string\n    }\n    var v = Array(string)\n\
    \    var i = v.count - 1\n    while i >= 0 {\n        var j = 0\n        var k\
    \ = i\n        while k < v.count {\n            if v[j] != v[k] {\n          \
    \      break\n            }\n            j += 1\n            k += 1\n        }\n\
    \        if k == v.count {\n            break\n        }\n        i -= 1\n   \
    \ }\n    let non_palindrome_suffix = v[(i + 1) ..< v.count]\n    var reverse_prefix\
    \ = non_palindrome_suffix.reverse()\n    v.appendContentsOf(reverse_prefix)\n\
    \    return String(v)", "    if string.count == 0 {\n        return string\n \
    \   }\n    var str = string\n    while !str.is_palindrome() {\n        str.remove(at:\
    \ str.startIndex)\n    }\n    return string + str.reversed()", "  if string.characters.count\
    \ <= 1 {\n    return string\n  }\n  var m: Int = 0\n  let u: Int = string.characters.count\
    \ - 1\n  var r: [Character] = []\n  var l: [Character] = []\n  for var i: Int\
    \ = 0; i < string.characters.count; i++ {\n    let index: String.Index = string.startIndex.advancedBy(i)\n\
    \    let char: Character = string[index]\n    r.append(char)\n    l.append(char)\n\
    \  }\n  r.reverse()\n  for var i: Int = 0; i < string.characters.count; i++ {\n\
    \    if r[i] == l[0] {\n      var j: Int = 0\n      while j < u - i + 1 {\n  \
    \      if r[i + j] != l[j] {\n          break\n        }\n        j += 1\n   \
    \   }\n      if j > m {\n        m = j\n      }\n    }\n  }\n  var result: String\
    \ = string\n  for var i: Int = m; i < string.characters.count; i++ {\n    let\
    \ index: String.Index = string.startIndex.advancedBy(i)\n    let char: Character\
    \ = string[index]\n    result += String(char)\n  }\n  return result", "    let\
    \ b = string.unicodeScalars.map { $0.value }\n    let a = b + [0] + b.reverse().map\
    \ { -$0 }\n    let n = a.count\n    var z = [Int](count: n, repeatedValue: 0)\n\
    \    var l = 0\n    var r = 0\n    for i in 1..<n {\n        z[i] = (r > i) ?\
    \ min(r - i, z[i - l]) : 0\n        while i + z[i] < n && a[i + z[i]] == a[i -\
    \ z[i]] {\n            z[i]++\n        }\n        if i + z[i] > r {\n        \
    \    l = i\n            r = i + z[i]\n        }\n    }\n    var result = string\n\
    \    for i in 0..<n/2 {\n        result.append(UnicodeScalar(abs(a[i + n/2 + 1])))\n\
    \    }\n    return result", "    var s = string\n    let reversed = String(s.characters.reverse())\n\
    \    var lcs = lcs_length(s, reversed)\n    let prefix = String(s.characters.prefix(s.characters.count\
    \ - lcs))\n    let reversed_prefix = String(prefix.characters.reverse())\n   \
    \ s += reversed_prefix\n    return s", "    let stringLength = string.characters.count\n\
    \    if stringLength == 0 {\n        return \"\"\n    }\n    var i = stringLength\n\
    \    var suffixString = string\n    while !suffixString.is_palindrome() {\n  \
    \      suffixString = String(suffixString.characters.dropFirst())\n        i -=\
    \ 1\n    }\n    let prefixString = String(string.characters.prefix(stringLength\
    \ - i))\n    return string + prefixString.reverse()", "    let suffix = suffix_palindrome(string)\n\
    \    let prefix = String(string.dropLast(suffix.count))\n    return prefix + String(suffix.reversed())\
    \ + suffix", "    var s = [Character](string)\n    let f = failure_array(string:\
    \ string)\n    let n = string.count\n    let m = f[n - 1]\n    if m == n {\n \
    \       return string\n    }\n    else {\n        for i in (0..<n - m - 1).reversed()\
    \ {\n            s.append(s[i])\n        }\n        return String(s)\n    }",
  "    let reversed = String(string.characters.reverse())\n    let length = string.characters.count\n\
    \    if length < 2 {\n        return string\n    }\n\n    // Add start of the\
    \ string at the end of the string\n    let prefix = String(string.characters.dropLast(length\
    \ - 1))\n    var candidate = string + reversed\n    let palindrome = candidate.characters\n\
    \    var offset = 1\n    for i in 1..<length - 1 {\n        var prefix_front =\
    \ String(prefix.characters.dropLast(i))\n        var prefix_back = String(prefix.characters.dropFirst(i))\n\
    \        if prefix_front == prefix_back {\n            candidate = prefix_front\
    \ + string + reversed\n            if is_palindrome(candidate) {\n           \
    \     return candidate\n            }\n        }\n    }\n    return candidate",
  "    let (prefix, postfix) = split_palindrome(string)\n    return string + String(prefix.characters.reverse())",
  "    if string.count == 0 {\n        return string\n    }\n    var tmp = string\n\
    \    while !is_palindrome(string: tmp) {\n        tmp = tmp.prefix(tmp.count -\
    \ 1)\n    }\n    return string + String(tmp.reversed())", "    let length = string.characters.count\n\
    \    if length <= 1 {\n        return string\n    }\n    // Determines whether\
    \ a postfix is a palindrome.\n    let is_palindrome = { (prefix: String, suffix:\
    \ String) -> Bool in\n        if prefix.characters.count != suffix.characters.count\
    \ {\n            return false\n        }\n        var (prefix_chars, suffix_chars)\
    \ = (prefix.characters, suffix.characters)\n        for _ in 0..<prefix.characters.count\
    \ {\n            if prefix_chars.popFirst() != suffix_chars.popLast() {\n    \
    \            return false\n            }\n        }\n        return true\n   \
    \ }\n    // Find the longest palindromic postfix.\n    var (max_postfix, postfix)\
    \ = (\"\", string)\n    while !is_palindrome(string, postfix) {\n        max_postfix\
    \ = postfix\n        postfix = String(postfix.characters.dropFirst())\n    }\n\
    \    // Prepend the reverse of the prefix.\n    return string + String(max_postfix.characters.reverse())",
  "    let prefix = palindrome_postfix(string)\n    let prefix_reversed = String(prefix.characters.reverse())\n\
    \    return prefix_reversed + string"]
stop_tokens:
- "\n}"
