name: HumanEval_162_string_to_md5
language: swift
prompt: "\n/// Given a string 'text', return its md5 hash equivalent string.\n///\
  \ If 'text' is an empty string, return None.\n/// >>> string_to_md5('Hello world')\
  \ == '3e25960a79dbc69b674cd4ec67a72c62'\nfunc string_to_md5(text: String) -> String?\
  \ {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(string_to_md5(text: \"Hello world\") ==\
  \ \"3e25960a79dbc69b674cd4ec67a72c62\")\nassert(string_to_md5(text: \"\") == nil)\n\
  assert(string_to_md5(text: \"A B C\") == \"0ef78513b0cb8cef12743f5aeb35f888\")\n\
  assert(string_to_md5(text: \"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\"\
  )"
completions: ["    if text.isEmpty {\n        return nil\n    }\n\n    let textAsData\
    \ = text.data(using: .utf8)!\n    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    let newData = NSData.init(data: textAsData)\n    CC_MD5(newData.bytes, CC_LONG(textAsData.count),\
    \ &digest)\n    let output = NSMutableString(capacity: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    for byte in digest {\n        output.appendFormat(\"%02x\", byte)\n    }\n\
    \    return output as String", '    return nil', "    guard !text.isEmpty else\
    \ {\n        return nil\n    }\n    guard let data = text.data(using: .utf8) else\
    \ {\n        return nil\n    }\n    let hash = (data as NSData).md5().hexEncodedString()\n\
    \    return hash", "    let data = text.data(using: .utf8)\n    guard let digest\
    \ = data?.withUnsafeBytes({ (bytes: UnsafePointer<CChar>) -> [UInt8] in\n    \
    \    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n  \
    \      CC_MD5(bytes, CC_LONG(data!.count), &digest)\n        return digest\n \
    \   }) else {\n        return nil\n    }\n    return digest.map { String(format:\
    \ \"%02x\", $0) }.joined()", "    if text.isEmpty {\n        return nil\n    }\n\
    \    let data = text.data(using: .utf8)!\n    var hash = [UInt8](repeating: 0,\
    \ count: Int(CC_MD5_DIGEST_LENGTH))\n    data.withUnsafeBytes {\n        _ = CC_MD5($0.baseAddress,\
    \ CC_LONG(data.count), &hash)\n    }\n    return Data(hash).map { String(format:\
    \ \"%02hhx\", $0) }.joined()", "    guard text.characters.count > 0 else {\n \
    \       return nil\n    }\n    let raw_hash = md5(text)\n    return hex_string_from_data(raw_hash)",
  "    if text.isEmpty {\n        return nil\n    }\n    let context = UnsafeMutablePointer<CC_MD5_CTX>.alloc(1)\n\
    \    var digest = [UInt8](count: Int(CC_MD5_DIGEST_LENGTH), repeatedValue: 0)\n\
    \    CC_MD5_Init(context)\n    CC_MD5_Update(context, text, CC_LONG(text.lengthOfBytesUsingEncoding(NSUTF8StringEncoding)))\n\
    \    CC_MD5_Final(&digest, context)\n    context.dealloc(1)\n    var hexString\
    \ = \"\"\n    for byte in digest {\n        hexString += String(format:\"%02x\"\
    , byte)\n    }\n    return hexString", "    if text.isEmpty {\n        return\
    \ nil\n    }\n    return text.md5()", "    if text.characters.count < 1 {\n  \
    \      return nil\n    }\n    if let data = text.data(using: String.Encoding.utf8)\
    \ {\n        let hash = data.withUnsafeBytes { (bytes: UnsafePointer<Data>) ->\
    \ [UInt8] in\n            var hash: [UInt8] = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \            CC_MD5(bytes, CC_LONG(data.count), &hash)\n            return hash\n\
    \        }\n        let result = hash.map { String(format: \"%02x\", $0) }.joined()\n\
    \        return result\n    }\n    return nil", "    if text.isEmpty {\n     \
    \   return nil\n    }\n\n    let messageData = text.data(using:.utf8)!\n    var\
    \ digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    if text.isEmpty {\n        return nil\n    }\n    return text.md5()", "   \
    \ if text.isEmpty {\n        return nil\n    }\n    let md5 = MD5(text)\n    return\
    \ md5.hexValue", "    if !text.isEmpty {\n        let textBytes = Array(text.utf8)\n\
    \        let hash = MD5(textBytes).calculate()\n        let md5 = NSMutableString()\n\
    \        for byte in hash {\n            md5.appendFormat(\"%02x\", byte)\n  \
    \      }\n        return md5 as String\n    }\n    return nil", "    if text.isEmpty\
    \ {\n        return nil\n    }\n    if let data = text.data(using: .utf8) {\n\
    \        return data_to_md5(data: data)\n    }\n    return nil", "    guard text.count\
    \ > 0 else {\n        return nil\n    }\n    var output = Array<UInt8>(repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    CC_MD5(text, CC_LONG(text.count),\
    \ &output)\n    return output.toHexString()", "    if text.isEmpty {\n       \
    \ return nil\n    }\n    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    if let data = text.data(using: String.Encoding.utf8) {\n        data.withUnsafeBytes\
    \ {\n            _ = CC_MD5($0, CC_LONG(data.count), &digest)\n        }\n   \
    \ }\n    var digestHex = \"\"\n    for index in 0..<Int(CC_MD5_DIGEST_LENGTH)\
    \ {\n        digestHex += String(format: \"%02x\", digest[index])\n    }\n   \
    \ return digestHex", "    if text.isEmpty {\n        return nil\n    }\n\n   \
    \ let cString = text.cString(using: String.Encoding.utf8)\n    let length = CUnsignedInt(text.lengthOfBytes(using:\
    \ String.Encoding.utf8))\n    let result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity:\
    \ Int(CC_MD5_DIGEST_LENGTH))\n    CC_MD5(cString!, length, result)\n    return\
    \ string_from_md5(result: result)", "    if text.isEmpty {\n        return nil\n\
    \    }\n\n    let c_data = text.data(using: String.Encoding.utf8, allowLossyConversion:\
    \ false)\n    let digest_length = Int(CC_MD5_DIGEST_LENGTH)\n    let result =\
    \ UnsafeMutablePointer<CUnsignedChar>.allocate(capacity: digest_length)\n\n  \
    \  let c_data_ptr = (c_data! as NSData).bytes\n    CC_MD5(c_data_ptr, CC_LONG(c_data!.count),\
    \ result)\n\n    let hash = NSMutableString()\n    for i in 0..<digest_length\
    \ {\n        hash.appendFormat(\"%02x\", result[i])\n    }\n\n    result.deallocate()\n\
    \n    return String(hash)", "    if text.isEmpty {\n        return nil\n    }\n\
    \    let text_to_hash = text.data(using: .utf8)!\n    let md5_hash = MD5(text_to_hash)\n\
    \    return md5_hash.map { String(format: \"%02hhx\", $0) }.joined()", "    if\
    \ (text.isEmpty) {\n        return nil\n    }\n    let messageData = text.data(using:.utf8)!\n\
    \    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()"]
stop_tokens:
- "\n}"
