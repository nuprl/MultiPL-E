language: swift
name: HumanEval_87_get_row
results:
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var result:\
    \ [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n        for (j, e)\
    \ in row.enumerated() {\n            if e == x {\n                result.append((i,\
    \ j))\n            }\n        }\n    }\n    return result.sorted(by: {$0.0 < $1.0})\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp5cfxdeu1/tmp5cfxdeu1.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b423e324c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b423e01bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b423e01b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b423e01a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5cfxdeu1                        0x00005613e463277f <unavailable> + 6015

    5    libc.so.6                          0x00002b423e510460 __libc_start_main +
    245

    6    tmp5cfxdeu1                        0x00005613e4632249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var result:\
    \ [(Int, Int)] = []\n    for (indexRow, row) in lst.enumerated() {\n        for\
    \ (indexColumn, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((indexRow, indexColumn))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpka9cs_vw/tmpka9cs_vw.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3c07b3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3c04aab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3c04aa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3c04a97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpka9cs_vw                        0x000055ffec98877f <unavailable> + 6015

    5    libc.so.6                          0x00002ab3c099f460 __libc_start_main +
    245

    6    tmpka9cs_vw                        0x000055ffec988249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    let x\
    \ = x\n    let z = zip(lst, 0...lst.count - 1)\n    let y = z.map { (r, i) ->\
    \ [(Int, Int)] in\n        return r.enumerated().filter { $0.element == x }.map\
    \ { (j, _) in (i, j) }\n    }\n    let a = y.flatMap { $0 }\n    return a.sorted\
    \ { (e1, e2) -> Bool in\n        return e1.0 < e2.0 || (e1.0 == e2.0 && e1.1 >\
    \ e2.1)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b414b9f3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b414b6ea561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b414b6ea286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b414b6ea13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b414b6e9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmppww0x7lt                        0x000056472838a858 <unavailable> + 10328

    6    tmppww0x7lt                        0x000056472838a1da <unavailable> + 8666

    7    libc.so.6                          0x00002b414bbdf460 __libc_start_main +
    245

    8    tmppww0x7lt                        0x0000564728389489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var r\
    \ = [(Int, Int)]()\n    var i = 0\n    for row in lst {\n        if let j = row.index(of:\
    \ x) {\n            r.append((i, j))\n        }\n        i += 1\n    }\n    return\
    \ r.sorted{$0.0 < $1.0}.sorted{$0.1 > $1.1}\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp3qfvnyp2/tmp3qfvnyp2.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab38577ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab385475b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab385475988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3854747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3qfvnyp2                        0x00005636e470678f <unavailable> + 6031

    5    libc.so.6                          0x00002ab38596a460 __libc_start_main +
    245

    6    tmp3qfvnyp2                        0x00005636e4706259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    let coordinates\
    \ = lst.enumerated().flatMap { (y, row) -> [(Int, Int)] in\n        row.enumerated().filter\
    \ { $0.element == x }.map { (y, $0.offset) }\n    }\n    return coordinates.sorted\
    \ { $0.0 != $1.0 ? $0.0 < $1.0 : $0.1 > $1.1 }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var res:\
    \ [(Int, Int)] = []\n    for (r, row) in lst.enumerated() {\n        for (c, col)\
    \ in row.enumerated() {\n            if col == x {\n                res.append((r,\
    \ c))\n            }\n        }\n    }\n    let ordered_res = res.sorted { (t1,\
    \ t2) -> Bool in\n        if t1.0 == t2.0 {\n            return t1.1 > t2.1\n\
    \        }\n        return t1.0 < t2.0\n    }\n    return ordered_res\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var result:\
    \ [(Int, Int)] = []\n    for (row, value) in lst.enumerated() {\n        if let\
    \ index = value.firstIndex(of: x) {\n            result.append((row, index))\n\
    \        }\n    }\n    return result.sorted(by: { (lhs, rhs) -> Bool in\n    \
    \    if lhs.0 == rhs.0 {\n            return lhs.1 > rhs.1\n        }\n      \
    \  return lhs.0 < rhs.0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpj7_n5iu_/tmpj7_n5iu_.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06b3b69c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06b3860b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06b3860988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06b385f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj7_n5iu_                        0x000055738302182f <unavailable> + 6191

    5    libc.so.6                          0x00002b06b3d55460 __libc_start_main +
    245

    6    tmpj7_n5iu_                        0x00005573830212f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var result:\
    \ [(Int, Int)] = []\n    for (y, xs) in lst.enumerated() {\n        for (x2, x)\
    \ in xs.enumerated() {\n            if x == x {\n                result.append((y,\
    \ x2))\n            }\n        }\n    }\n    return result.sorted(by: { $0.0 <\
    \ $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpxa004b1u/tmpxa004b1u.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba9e0c70c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba9e0967b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba9e0967988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba9e09667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxa004b1u                        0x000055f1ead7e77f <unavailable> + 6015

    5    libc.so.6                          0x00002ba9e0e5c460 __libc_start_main +
    245

    6    tmpxa004b1u                        0x000055f1ead7e249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var ret:\
    \ [(Int, Int)] = []\n    for (y, row) in lst.enumerated() {\n        for (x, col)\
    \ in row.enumerated() {\n            if col == x {\n                ret.append((y,\
    \ x))\n            }\n        }\n    }\n    ret.sort(by: { $0.0 < $1.0 || ($0.0\
    \ == $1.0 && $0.1 > $1.1) })\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpds2u9m4b/tmpds2u9m4b.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31f92f3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31f8feab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31f8fea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31f8fe97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpds2u9m4b                        0x00005625291137ff <unavailable> + 6143

    5    libc.so.6                          0x00002b31f94df460 __libc_start_main +
    245

    6    tmpds2u9m4b                        0x00005625291132c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\tvar result:\
    \ [(Int, Int)] = []\n\tvar rows = 0\n\tvar columns = 0\n\tfor row in lst {\n\t\
    \tfor column in row {\n\t\t\tif column == x {\n\t\t\t\tresult.append((rows, columns))\n\
    \t\t\t}\n\t\t\tcolumns += 1\n\t\t}\n\t\trows += 1\n\t\tcolumns = 0\n\t}\n\tresult.sort(by:\
    \ { (a, b) -> Bool in\n\t\tif a.0 == b.0 {\n\t\t\treturn a.1 > b.1\n\t\t}\n\t\t\
    return a.0 < b.0\n\t})\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var result:\
    \ [(Int, Int)] = []\n    for (row, arr) in lst.enumerated() {\n        for (col,\
    \ val) in arr.enumerated() {\n            if val == x {\n                result.append((row,\
    \ col))\n            }\n        }\n    }\n    return result.sorted(by: { (a, b)\
    \ -> Bool in\n        return a.0 < b.0\n    }).sorted(by: { (a, b) -> Bool in\n\
    \        return a.1 > b.1\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp74lf5j37/tmp74lf5j37.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7ad7fd7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7ad7cceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7ad7cce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7ad7ccd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp74lf5j37                        0x0000557653c6777f <unavailable> + 6015

    5    libc.so.6                          0x00002b7ad81c3460 __libc_start_main +
    245

    6    tmp74lf5j37                        0x0000557653c67249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var result:\
    \ [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for j in 0..<lst[i].count\
    \ {\n            if lst[i][j] == x {\n                result.append((i, j))\n\
    \            }\n        }\n    }\n    let sorted = result.sorted { $0.0 < $1.0\
    \ }\n    return sorted.sorted { $0.1 > $1.1 }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp37fwjwh4/tmp37fwjwh4.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b823adefc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b823aae6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b823aae6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b823aae57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp37fwjwh4                        0x000056364f29d7ef <unavailable> + 6127

    5    libc.so.6                          0x00002b823afdb460 __libc_start_main +
    245

    6    tmp37fwjwh4                        0x000056364f29d2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var result\
    \ = [(Int, Int)]()\n    for (row, list) in lst.enumerated() {\n        for (column,\
    \ element) in list.enumerated() {\n            if element == x {\n           \
    \     result.append((row, column))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (left, right) -> Bool in\n        left.0 < right.0\n   \
    \ }).sorted(by: { (left, right) -> Bool in\n        left.1 > right.1\n    })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpxolpl3jn/tmpxolpl3jn.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abacfafac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abacf7f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abacf7f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abacf7f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxolpl3jn                        0x000055ba333397cf <unavailable> + 6095

    5    libc.so.6                          0x00002abacfce6460 __libc_start_main +
    245

    6    tmpxolpl3jn                        0x000055ba33339299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpio5z1o3j/tmpio5z1o3j.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae89e748c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae89e43fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae89e43f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae89e43e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpio5z1o3j                        0x000056141a7e049f <unavailable> + 5279

    5    libc.so.6                          0x00002ae89e934460 __libc_start_main +
    245

    6    tmpio5z1o3j                        0x000056141a7dff69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var result\
    \ = [(Int, Int)]()\n    for (row, col) in lst.enumerated() {\n        for (col,\
    \ num) in col.enumerated() {\n            if num == x {\n                result.append((row,\
    \ col))\n            }\n        }\n    }\n    return result.sorted(by: { $0.0\
    \ < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp81fuwxv3/tmp81fuwxv3.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92196b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92193a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92193a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92193a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp81fuwxv3                        0x000055e0ea5017cf <unavailable> + 6095

    5    libc.so.6                          0x00002b921989c460 __libc_start_main +
    245

    6    tmp81fuwxv3                        0x000055e0ea501299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var res:\
    \ [(Int, Int)] = []\n    for (y, row) in lst.enumerated() {\n        for (z, item)\
    \ in row.enumerated() {\n            if item == x {\n                res.append((y,\
    \ z))\n            }\n        }\n    }\n    return res.sorted(by: { $0.0 < $1.0\
    \ || ($0.0 == $1.0 && $0.1 > $1.1) })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\tvar res\
    \ = [(Int, Int)]()\n\tif lst.count == 0 {\n\t\treturn res\n\t}\n\tfor (i, row)\
    \ in lst.enumerated() {\n\t\tvar inds = [Int]()\n\t\tfor (j, value) in row.enumerated()\
    \ {\n\t\t\tif value == x {\n\t\t\t\tinds.append(j)\n\t\t\t}\n\t\t}\n\t\tfor ind\
    \ in inds.sorted(by: >) {\n\t\t\tres.append((i, ind))\n\t\t}\n\t}\n\treturn res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var result\
    \ = [(Int, Int)]()\n    for (index, sublst) in lst.enumerated() {\n        for\
    \ (subindex, element) in sublst.enumerated() {\n            if element == x {\n\
    \                result.append((index, subindex))\n            }\n        }\n\
    \    }\n    return result.sorted{ $0.0 == $1.0 ? $0.1 > $1.1 : $0.0 < $1.0 }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    let count\
    \ = lst.reduce(0) { (sum, row) -> Int in\n        return sum + row.filter { $0\
    \ == x }.count\n    }\n    var tuple = [(Int, Int)]()\n    tuple.reserveCapacity(count)\n\
    \    for (y, row) in lst.enumerated() {\n        for (x, n) in row.enumerated()\
    \ {\n            if n == x {\n                tuple.append((y, x))\n         \
    \   }\n        }\n    }\n    return tuple.sorted { $0.0 < $1.0 }.sorted { $0.1\
    \ > $1.1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpvg3v0db4/tmpvg3v0db4.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1859e0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1859b03b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1859b03988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1859b027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvg3v0db4                        0x000055da2dde79bf <unavailable> + 6591

    5    libc.so.6                          0x00002b1859ff8460 __libc_start_main +
    245

    6    tmpvg3v0db4                        0x000055da2dde7489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var result:\
    \ [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for j in 0..<lst[i].count\
    \ {\n            if lst[i][j] == x {\n                result.append((i, j))\n\
    \            }\n        }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by:\
    \ { $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp6wuacbou/tmp6wuacbou.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c7fad8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c7f7cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c7f7cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c7f7ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6wuacbou                        0x0000560ac36767ef <unavailable> + 6127

    5    libc.so.6                          0x00002b6c7fcc4460 __libc_start_main +
    245

    6    tmp6wuacbou                        0x0000560ac36762b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660014426
