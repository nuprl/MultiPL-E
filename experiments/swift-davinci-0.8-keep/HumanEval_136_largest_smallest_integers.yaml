name: HumanEval_136_largest_smallest_integers
language: swift
prompt: "\n/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
  \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
  \ in a list.\n/// If there is no negative or positive integers, return them as None.\n\
  /// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n\
  /// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
  \ == (None, None)\nfunc largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(largest_smallest_integers(lst: [2, 4, 1,\
  \ 3, 5, 7]) == (nil, 1))\nassert(largest_smallest_integers(lst: [2, 4, 1, 3, 5,\
  \ 7, 0]) == (nil, 1))\nassert(largest_smallest_integers(lst: [1, 3, 2, 4, 5, 6,\
  \ -2]) == (-2, 1))\nassert(largest_smallest_integers(lst: [4, 5, 3, 6, 2, 7, -7])\
  \ == (-7, 2))\nassert(largest_smallest_integers(lst: [7, 3, 8, 4, 9, 2, 5, -9])\
  \ == (-9, 2))\nassert(largest_smallest_integers(lst: [] as [Int]) == (nil, nil))\n\
  assert(largest_smallest_integers(lst: [0]) == (nil, nil))\nassert(largest_smallest_integers(lst:\
  \ [-1, -3, -5, -6]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-1, -3,\
  \ -5, -6, 0]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-6, -4, -4,\
  \ -3, 1]) == (-3, 1))\nassert(largest_smallest_integers(lst: [-6, -4, -4, -3, -100,\
  \ 1]) == (-3, 1))"
completions: ["    let negative_integers = lst.filter({ $0 < 0 })\n    let positive_integers\
    \ = lst.filter({ $0 > 0 })\n    let largest_negative_integer = negative_integers.isEmpty\
    \ ? nil : negative_integers.max()\n    let smallest_positive_integer = positive_integers.isEmpty\
    \ ? nil : positive_integers.min()\n    return (largest_negative_integer, smallest_positive_integer)",
  "    var min = Optional<Int>.None\n    var max = Optional<Int>.None\n    for item\
    \ in lst {\n        if item > 0 {\n            if let n = min {\n            \
    \    if item < n {\n                    min = item\n                }\n      \
    \      } else {\n                min = item\n            }\n        } else if\
    \ item < 0 {\n            if let n = max {\n                if item > n {\n  \
    \                  max = item\n                }\n            } else {\n     \
    \           max = item\n            }\n        }\n    }\n    return (max, min)",
  "    guard !lst.isEmpty else { return (nil, nil) }\n    var smallest: Int? = nil\n\
    \    var largest: Int? = nil\n    for element in lst {\n        if element > 0\
    \ {\n            if smallest == nil {\n                smallest = element\n  \
    \          } else if element < smallest! {\n                smallest = element\n\
    \            }\n        } else if element < 0 {\n            if largest == nil\
    \ {\n                largest = element\n            } else if element > largest!\
    \ {\n                largest = element\n            }\n        }\n    }\n    return\
    \ (largest, smallest)", '    return (largest_integer(lst), smallest_integer(lst))',
  "    var min: Int? = nil\n    var max: Int? = nil\n    for num in lst {\n      \
    \  if num < 0 {\n            max = num > max ? num : max\n        } else {\n \
    \           min = num < min ? num : min\n        }\n    }\n    return (max, min)",
  "    let positive = lst.filter { $0 > 0 }.min()\n    let negative = lst.filter {\
    \ $0 < 0 }.max()\n    return (negative, positive)", "    let positive_numbers\
    \ = lst.filter({$0 > 0})\n    let negative_numbers = lst.filter({$0 < 0})\n  \
    \  return (negative_numbers.max(), positive_numbers.min())", '    return (lst.filter
    {$0 < 0}.max(), lst.filter {$0 > 0}.min())', '    return (lst.min(), lst.max())',
  "    let negative = lst.filter {$0 < 0}.max()\n    let positive = lst.filter {$0\
    \ > 0}.min()\n    return (negative, positive)", "  var (min, max) = (Int.max,\
    \ Int.min)\n  for item in lst {\n    if item < 0 {\n      if item > max {\n  \
    \      max = item\n      }\n    } else if item > 0 {\n      if item < min {\n\
    \        min = item\n      }\n    }\n  }\n  return (min == Int.max ? nil : min,\
    \ max == Int.min ? nil : max)", "    let neg = lst.filter {\n        $0 < 0\n\
    \    }.max()\n    let pos = lst.filter {\n        $0 > 0\n    }.min()\n    return\
    \ (neg, pos)", "    var max: Int? = nil\n    var min: Int? = nil\n    for i in\
    \ lst {\n        if i > 0 {\n            if min == nil || i < min! {\n       \
    \         min = i\n            }\n        } else if i < 0 {\n            if max\
    \ == nil || i > max! {\n                max = i\n            }\n        }\n  \
    \  }\n    return (max, min)", '    return (lst.minElement() { $0 < $1 }, lst.maxElement()
    { $0 < $1 })', "    let negatives = lst.filter { $0 < 0 }\n    let positives =\
    \ lst.filter { $0 > 0 }\n    return (negatives.isEmpty ? nil : negatives.max(),\
    \ positives.isEmpty ? nil : positives.min())", "    //\u2193\u2193\u2193\u2193\
    \ Your code goes below \u2193\u2193\u2193\u2193\n    return (nil, nil)\n    //\u2191\
    \u2191\u2191\u2191 Your code goes above \u2191\u2191\u2191\u2191", "    let negative_lst\
    \ = lst.filter({ $0 < 0 })\n    let positive_lst = lst.filter({ $0 > 0 })\n  \
    \  return (negative_lst.max(), positive_lst.min())", "    var negativeList = [Int]()\n\
    \    var positiveList = [Int]()\n    for item in lst {\n        if item < 0 {\n\
    \            negativeList.append(item)\n        } else if item > 0 {\n       \
    \     positiveList.append(item)\n        }\n    }\n    return (negativeList.count\
    \ > 0 ? negativeList.maxElement() : nil, positiveList.count > 0 ? positiveList.minElement()\
    \ : nil)", "  var min = Int.max\n  var max = Int.min\n  var minSet = false\n \
    \ var maxSet = false\n  for x in lst {\n    if x > 0 {\n      if x < min {\n \
    \       min = x\n        minSet = true\n      }\n    } else if x < 0 {\n     \
    \ if x > max {\n        max = x\n        maxSet = true\n      }\n    }\n  }\n\
    \  return (maxSet ? max : nil, minSet ? min : nil)", "    var negative = Int.min\n\
    \    var positive = Int.max\n    for item in lst {\n        if item < 0 {\n  \
    \          negative = max(negative, item)\n        } else if item > 0 {\n    \
    \        positive = min(positive, item)\n        }\n    }\n    if positive ==\
    \ Int.max {\n        positive = nil\n    }\n    if negative == Int.min {\n   \
    \     negative = nil\n    }\n    return (negative, positive)"]
stop_tokens:
- "\n}"
