language: swift
name: HumanEval_21_rescale_to_unit
results:
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = numbers[0]\n    var max = numbers[0]\n    for number in numbers\
    \ {\n        if number < min {\n            min = number\n        }\n        if\
    \ number > max {\n            max = number\n        }\n    }\n    let range =\
    \ max - min\n    let rescaled = numbers.map { (number) -> Double in\n        (number\
    \ - min) / range\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013724
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    precondition(numbers.count >= 2)\n    let minimum = numbers.minElement()!\n\
    \    let maximum = numbers.maxElement()!\n    return numbers.map { $0 - minimum\
    \ }.map { $0 / (maximum - minimum) }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpoehdktvq.swift:8:27: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let minimum = numbers.minElement()!\n                  ~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpoehdktvq.swift:9:27: error: value of type '[Double]' has\
    \ no member 'maxElement'\n    let maximum = numbers.maxElement()!\n          \
    \        ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013724
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_max = get_min_max(numbers)\n    return numbers.map { ($0 - min_max.min)\
    \ / (min_max.max - min_max.min) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpsf352mxx.swift:7:19: error: cannot find 'get_min_max' in scope\n\
    \    let min_max = get_min_max(numbers)\n                  ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013725
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var numbers = numbers\n    let min = numbers.minElement()!\n    let max\
    \ = numbers.maxElement()!\n    for i in 0..<numbers.count {\n        numbers[i]\
    \ = (numbers[i] - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnba77l8l.swift:8:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpnba77l8l.swift:9:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpnba77l8l.swift:11:41:\
    \ error: binary operator '/' cannot be applied to two 'Duration' operands\n  \
    \      numbers[i] = (numbers[i] - min) / (max - min)\n                     ~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~\n/tmp/tmpnba77l8l.swift:11:41: note: overloads for '/' exist with\
    \ these partially matching parameter lists: (Double, Double), (Duration, Duration)\n\
    \        numbers[i] = (numbers[i] - min) / (max - min)\n                     \
    \                   ^\n/tmp/tmpnba77l8l.swift:11:34: error: binary operator '-'\
    \ cannot be applied to operands of type 'Double' and 'Duration'\n        numbers[i]\
    \ = (numbers[i] - min) / (max - min)\n                      ~~~~~~~~~~ ^ ~~~\n\
    /tmp/tmpnba77l8l.swift:11:34: note: overloads for '-' exist with these partially\
    \ matching parameter lists: (ContinuousClock.Instant, ContinuousClock.Instant),\
    \ (Double, Double), (Duration, Duration), (SuspendingClock.Instant, SuspendingClock.Instant)\n\
    \        numbers[i] = (numbers[i] - min) / (max - min)\n                     \
    \            ^\n"
  stdout: ''
  timestamp: 1660013724
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var numbers = numbers\n    let max_num = numbers.maxElement()!\n    let\
    \ min_num = numbers.minElement()!\n    numbers = numbers.map { (number) -> Double\
    \ in\n        (number - min_num) / (max_num - min_num)\n    }\n    return numbers\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp2muoaze7.swift:8:27: error: value of type '[Double]' has no member\
    \ 'maxElement'\n    let max_num = numbers.maxElement()!\n                  ~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp2muoaze7.swift:9:27: error: value of type '[Double]' has\
    \ no member 'minElement'\n    let min_num = numbers.minElement()!\n          \
    \        ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013723
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let minimum = numbers.minElement()\n    let maximum = numbers.maxElement()\n\
    \    return numbers.map {($0 - minimum!) / (maximum! - minimum!)}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxop6teco.swift:7:27: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let minimum = numbers.minElement()\n                  ~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpxop6teco.swift:8:27: error: value of type '[Double]' has\
    \ no member 'maxElement'\n    let maximum = numbers.maxElement()\n           \
    \       ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013723
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let current_min = numbers.minElement()!\n    let current_max = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - current_min) / (current_max - current_min) }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpw087kt0c.swift:7:31: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let current_min = numbers.minElement()!\n                \
    \      ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpw087kt0c.swift:8:31: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let current_max = numbers.maxElement()!\n  \
    \                    ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013723
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    precondition(numbers.count >= 2)\n    let min = numbers.minElement()!\n\
    \    let max = numbers.maxElement()!\n    let span = max - min\n    if span >\
    \ 0 {\n        return numbers.map { (n: Double) -> Double in\n            return\
    \ (n - min) / span\n        }\n    } else {\n        return numbers.map { (n:\
    \ Double) -> Double in\n            return 0.0\n        }\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpmkde168e.swift:8:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpmkde168e.swift:9:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013723
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    var min = numbers[0]\n    var max = numbers[0]\n\
    \    for n in numbers {\n        if n < min {\n            min = n\n        }\n\
    \        if n > max {\n            max = n\n        }\n    }\n    let dist = max\
    \ - min\n    for n in numbers {\n        result.append((n - min) / dist)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013724
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    assert(numbers.count >= 2)\n    var output = [Double]()\n    let min\
    \ = numbers.minElement()!\n    let max = numbers.maxElement()!\n    let range\
    \ = max - min\n    if range == 0 {\n        output = numbers.map { _ in return\
    \ 0.5 }\n    } else {\n        output = numbers.map { x in return (x - min) /\
    \ range }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpoyr8ixxf.swift:9:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpoyr8ixxf.swift:10:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013723
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    return numbers.map { min($1, $0) }.map { max($1, $0) }.map { ($0 - min_value)\
    \ / (max_value - min_value) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpqgl0hb4m.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpqgl0hb4m.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpqgl0hb4m.swift:9:44: error: contextual\
    \ closure type '(Double) throws -> Duration' expects 1 argument, but 2 were used\
    \ in closure body\n    return numbers.map { min($1, $0) }.map { max($1, $0) }.map\
    \ { ($0 - min_value) / (max_value - min_value) }\n                           \
    \                ^\n/tmp/tmpqgl0hb4m.swift:9:24: error: contextual closure type\
    \ '(Double) throws -> (Duration, Duration)' expects 1 argument, but 2 were used\
    \ in closure body\n    return numbers.map { min($1, $0) }.map { max($1, $0) }.map\
    \ { ($0 - min_value) / (max_value - min_value) }\n                       ^\n"
  stdout: ''
  timestamp: 1660013724
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var new_numbers = numbers.map({ $0 })\n    let min = new_numbers.minElement()!\n\
    \    let max = new_numbers.maxElement()!\n    new_numbers = new_numbers.map({\n\
    \        ($0 - min) / (max - min)\n    })\n    return new_numbers\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnucz3k8f.swift:8:27: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = new_numbers.minElement()!\n              ~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpnucz3k8f.swift:9:27: error: value of type '[Double]' has\
    \ no member 'maxElement'\n    let max = new_numbers.maxElement()!\n          \
    \    ~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013723
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_max = (min: numbers.minElement()!, max: numbers.maxElement()!)\n\
    \    return numbers.map { (el) -> Double in\n        if el == min_max.max {\n\
    \            return 1.0\n        } else if el == min_max.min {\n            return\
    \ 0.0\n        } else {\n            return (el - min_max.min) / (min_max.max\
    \ - min_max.min)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_pz_n0vr.swift:7:33: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_max = (min: numbers.minElement()!, max: numbers.maxElement()!)\n\
    \                        ~~~~~~~ ^~~~~~~~~~\n/tmp/tmp_pz_n0vr.swift:7:61: error:\
    \ value of type '[Double]' has no member 'maxElement'\n    let min_max = (min:\
    \ numbers.minElement()!, max: numbers.maxElement()!)\n                       \
    \                             ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013724
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let numbers_range = max_number - min_number\n    let transformed_numbers\
    \ = numbers.map { number in\n        (number - min_number) / numbers_range\n \
    \   }\n    return transformed_numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbdpo06aw.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpbdpo06aw.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013723
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    assert(numbers.count >= 2)\n    let min_max_pair = min_max(numbers)\n\
    \    let minimum = min_max_pair.0\n    let maximum = min_max_pair.1\n    return\
    \ numbers.map { rescale_to_unit($0, minimum: minimum, maximum: maximum) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpq9hwf5c5.swift:8:24: error: cannot find 'min_max' in scope\n  \
    \  let min_max_pair = min_max(numbers)\n                       ^~~~~~~\n/tmp/tmpq9hwf5c5.swift:11:41:\
    \ error: extra arguments at positions #2, #3 in call\n    return numbers.map {\
    \ rescale_to_unit($0, minimum: minimum, maximum: maximum) }\n                \
    \                        ^\n/tmp/tmpq9hwf5c5.swift:6:6: note: 'rescale_to_unit(numbers:)'\
    \ declared here\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n     ^\n\
    /tmp/tmpq9hwf5c5.swift:11:42: error: cannot convert value of type 'Double' to\
    \ expected argument type '[Double]'\n    return numbers.map { rescale_to_unit($0,\
    \ minimum: minimum, maximum: maximum) }\n                                    \
    \     ^\n/tmp/tmpq9hwf5c5.swift:11:26: error: cannot convert value of type '[Double]'\
    \ to closure result type 'Double'\n    return numbers.map { rescale_to_unit($0,\
    \ minimum: minimum, maximum: maximum) }\n                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013723
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    guard numbers.count > 1 else {\n        return numbers\n    }\n    let\
    \ min = numbers.min()!\n    let max = numbers.max()!\n    let range = max - min\n\
    \    return numbers.map { $0 / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpy1zdaw31/tmpy1zdaw31.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b506965dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5069354b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5069354988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b50693537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy1zdaw31                        0x00005647473776d3 <unavailable> + 5843

    5    libc.so.6                          0x00002b5069849460 __libc_start_main +
    245

    6    tmpy1zdaw31                        0x00005647473772d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660013724
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let scale = 1.0 / numbers.max()!\n    return numbers.map({ (v: Double)\
    \ -> Double in\n        return v * scale\n    })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpjjub8kc0/tmpjjub8kc0.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad25baa9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad25b7a0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad25b7a0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad25b79f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjjub8kc0                        0x0000559351ae5613 <unavailable> + 5651

    5    libc.so.6                          0x00002ad25bc95460 __libc_start_main +
    245

    6    tmpjjub8kc0                        0x0000559351ae5219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1660013724
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n\n      \
    \  }\n        if n > max_value {\n            max_value = n\n        }\n    }\n\
    \    let diff = max_value - min_value\n    return numbers.map { (n) -> Double\
    \ in\n        return (n - min_value) / diff\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013724
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_max = find_min_max(numbers)\n    return numbers.map { (x: Double)\
    \ -> Double in\n        // FIXME: Should check for division by zero\n        (x\
    \ - min_max.min) / (min_max.max - min_max.min)\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpo1cdwdfb.swift:7:19: error: cannot find 'find_min_max' in scope\n\
    \    let min_max = find_min_max(numbers)\n                  ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013724
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_val = numbers.minElement()\n    let max_val = numbers.maxElement()\n\
    \    if (min_val == nil || max_val == nil) {\n        return numbers\n    }\n\
    \    let dist = max_val! - min_val!\n    if (dist == 0) {\n        return numbers\n\
    \    }\n    return numbers.map { (v: Double) -> Double in\n        (v - min_val!)\
    \ / dist\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpedzzzfn7.swift:7:27: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_val = numbers.minElement()\n                  ~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpedzzzfn7.swift:8:27: error: value of type '[Double]' has\
    \ no member 'maxElement'\n    let max_val = numbers.maxElement()\n           \
    \       ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013724
