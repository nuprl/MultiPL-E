name: HumanEval_9_rolling_max
language: swift
prompt: "\n/// From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n/// in the sequence.\n/// >>> rolling_max([1, 2, 3,\
  \ 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int]) -> [Int]\
  \ {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == []\
  \ as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
  \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
  \ == [3, 3, 3, 100, 100])"
completions: ["    if numbers.count == 0 {\n        return []\n    }\n\n    var result\
    \ = [Int]()\n    var current_max = numbers[0]\n    result.append(current_max)\n\
    \n    for n in numbers[1..<numbers.count] {\n        current_max = max(current_max,\
    \ n)\n        result.append(current_max)\n    }\n\n    return result", "    var\
    \ maximums = [Int]()\n    var max = numbers[0]\n    maximums.append(max)\n   \
    \ for i in 1..<numbers.count {\n        if numbers[i] > max {\n            max\
    \ = numbers[i]\n        }\n        maximums.append(max)\n    }\n    return maximums",
  "    var current_max = numbers[0]\n    var result = [current_max]\n    for number\
    \ in numbers[1..<numbers.count] {\n        current_max = max(current_max, number)\n\
    \        result.append(current_max)\n    }\n    return result", "    var answer\
    \ = [Int]()\n    var current_max = Int.min\n    for number in numbers {\n    \
    \    current_max = max(current_max, number)\n        answer.append(current_max)\n\
    \    }\n    return answer", "    var rolling_max: [Int] = []\n    for n in numbers\
    \ {\n        let last_rolling_max = rolling_max.last ?? Int.min\n        rolling_max.append(max(last_rolling_max,\
    \ n))\n    }\n    return rolling_max", "    return [Int](\n        repeating:\
    \ 0,\n        count: numbers.count\n    ).enumerated().map { index, element in\n\
    \        let previous = index - 1\n        let previous_max = previous >= 0 ?\
    \ numbers[previous] : 0\n        return max(previous_max, numbers[index])\n  \
    \  }", "    if numbers.count == 0 {\n        return []\n    }\n\n    if numbers.count\
    \ == 1 {\n        return [numbers[0]]\n    }\n\n    var result = [Int]()\n   \
    \ var max = numbers[0]\n    result.append(max)\n\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n\
    \        result.append(max)\n    }\n\n    return result", "    var max: Int =\
    \ 0\n    var max_list: [Int] = []\n    for number in numbers {\n        if number\
    \ > max {\n            max = number\n        }\n        max_list.append(max)\n\
    \    }\n    return max_list", "    var result = [Int]()\n    var max_element =\
    \ Int.min\n    for number in numbers {\n        if number > max_element {\n  \
    \          max_element = number\n        }\n        result.append(max_element)\n\
    \    }\n    return result", "    var maxes = [Int]()\n    var currMax = Int.min\n\
    \    for number in numbers {\n        if number > currMax {\n            currMax\
    \ = number\n        }\n        maxes.append(currMax)\n    }\n    return maxes",
  "    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n  \
    \  for i in 1..<numbers.count {\n        if max < numbers[i] {\n            max\
    \ = numbers[i]\n        }\n        result.append(max)\n    }\n    return result",
  "    var max_seen = [Int]()\n    var local_max = 0\n    for num in numbers {\n \
    \       if num > local_max {\n            local_max = num\n        }\n       \
    \ max_seen.append(local_max)\n    }\n    return max_seen", "    let size = numbers.count\n\
    \    var numbers = numbers\n    var max_indices = [Int](count: size, repeatedValue:\
    \ 0)\n    for i in 1..<size {\n        if numbers[i] > numbers[max_indices[i -\
    \ 1]] {\n            max_indices[i] = i\n        } else {\n            max_indices[i]\
    \ = max_indices[i - 1]\n        }\n    }\n    return max_indices.map { numbers[$0]\
    \ }", '    return [Int](0...numbers.count - 1).map { numbers[0...$0].max()! }',
  "    if numbers.count == 0 {\n        return []\n    }\n    var results = [Int]()\n\
    \    results.append(numbers[0])\n    for i in 1..<numbers.count {\n        results.append(max(results[i\
    \ - 1], numbers[i]))\n    }\n    return results", "    return numbers.reduce([Int]())\
    \ { (result, next) in\n        return result + [result.last.map { max($0, next)\
    \ } ?? next]\n    }", "    var max_at_current_index = numbers\n    for (i, _)\
    \ in numbers.enumerated() {\n        max_at_current_index[i] = numbers[0..<i].max()\
    \ ?? 0\n    }\n    return max_at_current_index", "    var result = [Int]()\n \
    \   result.reserveCapacity(numbers.count)\n    var current_max = Int.min\n   \
    \ for i in numbers {\n        if i > current_max {\n            current_max =\
    \ i\n        }\n        result.append(current_max)\n    }\n    return result",
  "    var result = [Int]()\n    for index in 0..<numbers.count {\n        let slice\
    \ = numbers[0...index]\n        result.append(slice.max()!)\n    }\n    return\
    \ result", "  var result = [Int]()\n  var max = numbers[0]\n  result.append(max)\n\
    \  for i in 1..<numbers.count {\n    if numbers[i] > max {\n      max = numbers[i]\n\
    \    }\n    result.append(max)\n  }\n  return result"]
stop_tokens:
- "\n}"
