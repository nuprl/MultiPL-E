name: HumanEval_115_max_fill
language: swift
prompt: "\n/// You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n/// and\
  \ all buckets have the same capacity.\n/// Your task is to use the buckets to empty\
  \ the wells.\n/// Output the number of times you need to lower the buckets.\n///\
  \ Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n/// bucket_capacity\
  \ : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid : [[0,0,1,1], [0,0,0,0],\
  \ [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output: 5\n/// Example 3:\n\
  /// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity : 5\n/// Output:\
  \ 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <= grid.length\
  \ <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// *\
  \ 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
  \ 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid:\
  \ [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
  \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], capacity: 9) == 2)"
completions: ['    return -1', '  return 0', "    let row = grid.count\n    let col\
    \ = grid[0].count\n    var cur = 0\n    for i in 0..<row {\n        for j in 0..<col\
    \ {\n            if grid[i][j] > 0 {\n                cur = max(cur, grid[i][j])\n\
    \            }\n        }\n    }\n    print(cur)\n    var left = 0\n    var right\
    \ = cur\n    while left < right {\n        let mid = left + (right - left + 1)\
    \ / 2\n        if max_fill_helper(grid: grid, capacity: capacity, height: mid)\
    \ {\n            left = mid\n        } else {\n            right = mid - 1\n \
    \       }\n    }\n    return right", "    var sum = 0\n    var height = -1\n \
    \   for wells in grid {\n        if let max = wells.max() {\n            sum +=\
    \ max\n            height = max(height, max)\n        }\n    }\n    if capacity\
    \ >= height {\n        return sum\n    }\n    return capacity * grid.count + max_fill(grid:\
    \ grid, capacity: capacity + 1)", "    var fill = 0\n    var rows = [Int](repeating:\
    \ 0, count: grid.count)\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                rows[i] += 1\n        \
    \    }\n        }\n    }\n    for row in rows {\n        if row > capacity {\n\
    \            fill += row / capacity\n            if row % capacity > 0 {\n   \
    \             fill += 1\n            }\n        } else {\n            fill +=\
    \ 1\n        }\n    }\n    return fill", "    var steps = 0\n    let m = grid.count\n\
    \    let n = grid[0].count\n    var total = 0\n    var fill = 0\n    // loop through\
    \ the rows\n    for row in 0..<m {\n        total = 0\n        fill = 0\n    \
    \    // loop through the columns\n        for col in 0..<n {\n            total\
    \ += grid[row][col]\n            fill += min(grid[row][col], capacity)\n     \
    \   }\n        // if any bucket has not been filled, fill it\n        if total\
    \ > fill {\n            steps += total - fill\n        }\n    }\n    return steps",
  "    // assert(grid.length > 0 && grid[0].length > 0)\n    var filled_wells = grid\n\
    \    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n       \
    \     if (grid[i][j] > 0) {\n                filled_wells[i][j] = capacity\n \
    \           }\n        }\n    }\n    var num_rows = grid.count\n    var num_cols\
    \ = grid[0].count\n    var min_height = min(\n        Array(repeating: 0, count:\
    \ num_cols),\n        filled_wells.reduce(Array(repeating: 0, count: num_cols),\
    \ +)\n    )\n    var water_level = 0\n    while (water_level < capacity) {\n \
    \       water_level += 1\n        var change = false\n        for i in 0..<num_rows\
    \ {\n            for j in 0..<num_cols {\n                if (filled_wells[i][j]\
    \ >= water_level) {\n                    change = true\n                    if\
    \ (i > 0 && filled_wells[i - 1][j] < water_level) {\n                        filled_wells[i\
    \ - 1][j] = water_level\n                    }\n                    if (i < num_rows\
    \ - 1 && filled_wells[i + 1][j] < water_level) {\n                        filled_wells[i\
    \ + 1][j] = water_level\n                    }\n                    if (j > 0\
    \ && filled_wells[i][j - 1] < water_level) {\n                        filled_wells[i][j\
    \ - 1] = water_level\n                    }\n                    if (j < num_cols\
    \ - 1 && filled_wells[i][j + 1] < water_level) {\n                        filled_wells[i][j\
    \ + 1] = water_level\n                    }\n                }\n            }\n\
    \        }\n        if (!change) {\n            break\n        }\n    }\n    var\
    \ max_height = max(\n        Array(repeating: 0, count: num_cols),\n        filled_wells.reduce(Array(repeating:\
    \ 0, count: num_cols), +", "    var result = 0\n    var max_fill = 0\n    for\
    \ i in 0..<grid.count {\n        max_fill = 0\n        for j in 0..<grid[i].count\
    \ {\n            max_fill = max(max_fill, grid[i][j])\n        }\n        if max_fill\
    \ != 0 {\n            result += (max_fill - 1) / capacity + 1\n        }\n   \
    \ }\n    return result", "    var result = 0\n    for row in grid {\n        var\
    \ c = capacity\n        for x in row {\n            c = c - x\n            if\
    \ c < 0 {\n                c = capacity\n                result += 1\n       \
    \     }\n        }\n        result += 1\n    }\n    return result", "    // TODO:\
    \ implement\n    return 0", "    var grid = grid\n    var count = 0\n    for row\
    \ in 0..<grid.count {\n        for col in 0..<grid[row].count {\n            let\
    \ well = grid[row][col]\n            if well == 0 {\n                continue\n\
    \            }\n            let fill = min(well, capacity)\n            count\
    \ += fill\n            grid[row][col] -= fill\n            var r = row\n     \
    \       while r > 0 && fill > 0 {\n                if grid[r-1][col] == 0 {\n\
    \                    break\n                }\n                let take = min(fill,\
    \ grid[r-1][col])\n                grid[r-1][col] -= take\n                fill\
    \ -= take\n                r -= 1\n            }\n        }\n    }\n    return\
    \ count", "    let rowCount = grid.count\n    let colCount = grid[0].count\n \
    \   var sum: Int = 0\n    for row in 0..<rowCount {\n        let rowSum = grid[row].reduce(0,\
    \ +)\n        if (rowSum > 0) {\n            sum += colCount - rowSum\n      \
    \  }\n    }\n    let count = max(1, sum / capacity)\n    return count", "    if\
    \ (grid.count == 0) {\n        return 0\n    }\n    let n = grid.count, m = grid[0].count\n\
    \    let row_maxes = grid.map { row in\n        row.reduce(0) { $0 > $1 ? $0 :\
    \ $1 }\n    }\n    var cur_max = 0\n    var res = 0\n    while true {\n      \
    \  var all_zero = true\n        for i in 0..<n {\n            if row_maxes[i]\
    \ == 0 {\n                continue\n            }\n            all_zero = false\n\
    \            for j in 0..<m {\n                if grid[i][j] > 0 {\n         \
    \           cur_max = max(cur_max, j)\n                }\n            }\n    \
    \    }\n        if all_zero {\n            break\n        }\n        for i in\
    \ 0..<n {\n            for j in 0..<cur_max+1 {\n                if grid[i][j]\
    \ > 0 {\n                    grid[i][j] -= capacity\n                    if grid[i][j]\
    \ < 0 {\n                        grid[i][j] = 0\n                    }\n     \
    \           }\n            }\n        }\n        res += 1\n    }\n    return res",
  "    var num_operations = 0\n    var capacity = capacity\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if capacity <= 0 {\n  \
    \              return num_operations\n            }\n            if grid[i][j]\
    \ == 1 {\n                capacity -= 1\n                num_operations += 1\n\
    \            }\n        }\n    }\n    return num_operations", "    var sum = 0\n\
    \    for row in grid {\n        var fill = 0\n        for column in row {\n  \
    \          if column == 1 {\n                fill += 1\n            } else {\n\
    \                if fill > 0 {\n                    let drop = min(fill, capacity)\n\
    \                    sum += drop\n                    fill -= drop\n         \
    \       }\n            }\n        }\n        if fill > 0 {\n            sum +=\
    \ fill\n        }\n    }\n    return sum", "    // handle null and empty case\n\
    \    guard grid.count > 0 && grid[0].count > 0 else {\n        return 0\n    }\n\
    \    // create a mutable copy of the grid\n    var grid = grid\n    // handle\
    \ special case of empty rows\n    while grid.count > 0 && grid[0].reduce(0, +)\
    \ == 0 {\n        grid.removeFirst()\n    }\n    // handle special case of empty\
    \ columns\n    for row in 0..<grid.count {\n        for column in (0..<grid[row].count).reversed()\
    \ {\n            if grid[row][column] == 0 {\n                grid[row].removeLast()\n\
    \            } else {\n                break\n            }\n        }\n    }\n\
    \    // handle special case of empty grid\n    guard grid.count > 0 && grid[0].count\
    \ > 0 else {\n        return 0\n    }\n    // find min height of grid (will use\
    \ it to check if we've found the maximum)\n    let min_height = grid.map { $0.min()!\
    \ }.min()!\n    // the current maximum size\n    var max_size = 0\n    // function\
    \ to compute the current size of the grid\n    func size(_ grid: [[Int]]) -> Int\
    \ {\n        return grid.reduce(0) { $0 + $1.reduce(0, +) }\n    }\n    // starting\
    \ at min_height...\n    for current_height in min_height...capacity {\n      \
    \  // create a temporary grid (we'll work on this one)\n        var tmp_grid =\
    \ grid\n        // assume we start at the upper-left corner\n        var x = 0\n\
    \        var y = 0\n        // check all the cells in the grid\n        while\
    \ y < tmp_grid.count {\n            while x < tmp_grid[y].count {\n          \
    \      // if we have a block, check if the current height is lower than the bucket\
    \ capacity\n                if tmp_grid[y][x] > 0 {\n                    // if\
    \ we need more water to reach the current height, add it\n                   \
    \ if tmp_grid[y][x] < current_height {\n                        tmp_grid[y][x]\
    \ = current_height\n                    }\n                    // if we have a\
    \ block,", "    var bucket_count = 0\n    var bucket_capacity = capacity\n   \
    \ for row in grid {\n        for cell in row {\n            if cell == 1 {\n \
    \               bucket_count += 1\n                bucket_capacity -= 1\n    \
    \        }\n            if bucket_capacity == 0 {\n                bucket_count\
    \ += 1\n                bucket_capacity = capacity\n            }\n        }\n\
    \        if bucket_capacity != capacity {\n            bucket_count += 1\n   \
    \         bucket_capacity = capacity\n        }\n    }\n    return bucket_count",
  "    let n = grid.count\n    let m = grid[0].count\n    var buckets = Array(repeating:\
    \ capacity, count: m)\n    var steps = 0\n    for row in grid {\n        var found\
    \ = false\n        for i in 0..<row.count {\n            if row[i] == 1 {\n  \
    \              found = true\n                break\n            }\n        }\n\
    \        if !found {\n            continue\n        }\n        // this row has\
    \ 1's\n        for i in 0..<row.count {\n            if row[i] == 1 {\n      \
    \          buckets[i] -= 1\n            }\n        }\n        steps += 1\n   \
    \     if buckets.allSatisfy({$0 == 0}) {\n            return steps\n        }\n\
    \    }\n    return steps", "  var fill = Array(repeating: Array(repeating: 0,\
    \ count: grid[0].count), count: grid.count)\n  var max_filled = 0\n  for i in\
    \ 0..<grid.count {\n    for j in 0..<grid[0].count {\n      if grid[i][j] == 1\
    \ {\n        fill[i][j] = capacity\n        max_filled += capacity\n      }\n\
    \    }\n  }\n  var flows = 0\n  while true {\n    flows += 1\n    var buckets\
    \ = Set<Int>()\n    var bucket_col = 0\n    var bucket_row = 0\n    for i in 0..<grid.count\
    \ {\n      for j in 0..<grid[0].count {\n        if grid[i][j] == 1 {\n      \
    \    if fill[i][j] > 0 {\n            buckets.insert(j)\n            if fill[i][j]\
    \ > fill[bucket_row][bucket_col] {\n              bucket_row = i\n           \
    \   bucket_col = j\n            }\n          }\n        }\n      }\n    }\n  \
    \  if buckets.count == 0 {\n      break\n    }\n    // print(\"flow \\(flows)\
    \ -> \\(fill)\")\n    var pour = fill[bucket_row][bucket_col]\n    // print(\"\
    pour \\(pour)\")\n    fill[bucket_row][bucket_col] = 0\n    var j = bucket_col\
    \ + 1\n    while pour > 0 && j < grid[0].count {\n      if buckets.contains(j)\
    \ {\n        let p = pour\n        pour -= fill[bucket_row][j]\n        if pour\
    \ > 0 {\n          fill[bucket_row][j] = 0\n        } else {\n          fill[bucket_row][j]\
    \ = -pour\n        }\n        pour = max(0, pour)\n      }\n      j += 1\n   \
    \ }\n    j = bucket_col - 1\n    while pour > 0 && j >= 0 {\n      if buckets.contains(j)\
    \ {\n        let p = pour\n        pour -= fill[bucket_row][j]\n        if pour\
    \ > 0 {\n          fill[bucket_row][j", "    var ans = 0\n    for j in 0..<grid[0].count\
    \ {\n        var sum = 0\n        for i in 0..<grid.count {\n            sum +=\
    \ grid[i][j]\n        }\n        ans += max(0, sum - capacity)\n    }\n    return\
    \ ans"]
stop_tokens:
- "\n}"
