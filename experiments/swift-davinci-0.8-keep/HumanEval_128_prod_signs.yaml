name: HumanEval_128_prod_signs
language: swift
prompt: "\n/// You are given an array arr of integers and you need to return\n///\
  \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
  \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
  \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
  \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
  \ {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\n\
  assert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1,\
  \ 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
  \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
  assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
  \ 0]) == 0)"
completions: ["    guard !arr.isEmpty else { return nil }\n    let signs = arr.map\
    \ { Int(abs($0) / $0) }\n    return arr.map { abs($0) }.reduce(1, *) * signs.reduce(1,\
    \ *)", "    if (arr.count == 0) {\n        return nil\n    }\n    var total =\
    \ 0\n    for num in arr {\n        if (num > 0) {\n            total += 1\n  \
    \      } else if (num < 0) {\n            total -= 1\n        }\n    }\n    return\
    \ abs(total)", '  return arr.isEmpty ? nil : arr.map { abs($0) }.reduce(1, *)
    * arr.reduce(1, *)', "    if arr.isEmpty {\n        return nil\n    }\n    let\
    \ signs = arr.map { (i: Int) -> Int in\n        if i > 0 {\n            return\
    \ 1\n        } else if i < 0 {\n            return -1\n        } else {\n    \
    \        return 0\n        }\n    }\n    let sumOfMagnitudes = arr.reduce(0) {\
    \ (acc, i) -> Int in\n        if i < 0 {\n            return acc + (-i)\n    \
    \    } else {\n            return acc + i\n        }\n    }\n    return sumOfMagnitudes\
    \ * signs.reduce(1, *)", "    var sum = 0\n    var prod = 1\n    if arr.count\
    \ == 0 {\n        return nil\n    }\n    for i in arr {\n        sum += abs(i)\n\
    \        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod", " \
    \   if arr.isEmpty {\n        return nil\n    }\n    var positive = true\n   \
    \ var product = 1\n    for number in arr {\n        if number == 0 {\n       \
    \     return 0\n        }\n        if number < 0 {\n            positive = !positive\n\
    \        }\n        product *= number\n    }\n    if positive {\n        return\
    \ product\n    }\n    return -product", "    if arr.isEmpty {\n        return\
    \ nil\n    }\n    var result = 0\n    for a in arr {\n        result += a.signum()\
    \ * a.magnitude\n    }\n    return result", "    if arr.isEmpty {\n        return\
    \ nil\n    }\n    let signs: [Int] = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n\
    \    let res = signs.reduce(1, *)\n    return res * arr.reduce(0, { $0 + abs($1)\
    \ })", "    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0.signum() }\n    return signs.reduce(1, { $0 * $1 }) * arr.reduce(0, { $0\
    \ + abs($1) })", "    var mag_sum = 0\n    var sign_prod = 1\n    for item in\
    \ arr {\n        if item != 0 {\n            let mag = abs(item)\n           \
    \ mag_sum += mag\n            sign_prod *= item < 0 ? -1 : 1\n        }\n    }\n\
    \    return mag_sum * sign_prod", "  // TODO: Implement prod_signs\n  return nil",
  "    var res = 1\n    if arr.count > 0 {\n        for i in arr {\n            if\
    \ i == 0 {\n                res = 0\n            } else {\n                res\
    \ *= i/abs(i)\n            }\n        }\n        return res * arr.map{abs($0)}.reduce(0,\
    \ combine: +)\n    } else {\n        return nil\n    }", '    return nil', " \
    \ let sign_arr = arr.map { n in n > 0 ? 1 : n < 0 ? -1 : 0 }\n  let magn_arr =\
    \ arr.map { n in abs(n) }\n  return arr.isEmpty ? nil : magn_arr.reduce(1, *)\
    \ * sign_arr.reduce(1, *)", '    return nil', "    guard !arr.isEmpty else { return\
    \ nil }\n    return arr.map { $0 >= 0 ? 1 : -1 }.reduce(1, *) * arr.map { abs($0)\
    \ }.reduce(0, +)", "\treturn nil", "    if arr.isEmpty {\n        return nil\n\
    \    }\n    let result = arr.reduce(1) { (acc, val) -> Int in\n        return\
    \ acc * product(of: val)\n    }\n    return result", "\tguard !arr.isEmpty else\
    \ { return nil }\n\t\n\tvar sumOfMagnitudes = 0\n\tvar productOfSigns = 1\n\t\n\
    \tfor number in arr {\n\t\tif number != 0 {\n\t\t\tsumOfMagnitudes += abs(number)\n\
    \t\t\tproductOfSigns *= number / abs(number)\n\t\t}\n\t}\n\t\n\treturn sumOfMagnitudes\
    \ * productOfSigns", "  let sign = arr.reduce(1) { $0 * $1.signum() }\n  let mags\
    \ = arr.map{ abs($0) }\n  let sum = mags.reduce(0, +)\n  return sign * sum"]
stop_tokens:
- "\n}"
