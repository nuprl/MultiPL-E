name: HumanEval_58_common
language: swift
prompt: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
  \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2:\
  \ [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2:\
  \ [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
  assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
completions: ["  let set1 = Set(l1)\n  let set2 = Set(l2)\n  let common = set1.intersection(set2)\n\
    \  return Array(common).sorted()", '    return l1.intersection(l2).sorted()',
  "    let l1 = l1.sort()\n    let l2 = l2.sort()\n    var result = [Int]()\n    var\
    \ i = 0\n    var j = 0\n    while i < l1.count && j < l2.count {\n        if l1[i]\
    \ < l2[j] {\n            i += 1\n        } else if l1[i] > l2[j] {\n         \
    \   j += 1\n        } else {\n            result.append(l1[i])\n            i\
    \ += 1\n            j += 1\n        }\n    }\n    return result", "\t// write\
    \ your code here\n\tvar unique_l1 = [Int]()\n\tvar unique_l2 = [Int]()\n\tvar\
    \ common_elements = [Int]()\n\t\n\t// Find unique elements in l1, l2\n\tfor i\
    \ in l1 {\n\t\tif !unique_l1.contains(i) {\n\t\t\tunique_l1.append(i)\n\t\t}\n\
    \t}\n\tfor i in l2 {\n\t\tif !unique_l2.contains(i) {\n\t\t\tunique_l2.append(i)\n\
    \t\t}\n\t}\n\t// Find common elements\n\tfor i in unique_l1 {\n\t\tif unique_l2.contains(i)\
    \ {\n\t\t\tcommon_elements.append(i)\n\t\t}\n\t}\n\t// Sort the common_elements\n\
    \tcommon_elements.sort()\n\treturn common_elements", '    return unique(l1.filter
    { l2.contains($0) })', "    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()", "    var result = [Int]()\n    let\
    \ s1 = Set(l1)\n    let s2 = Set(l2)\n    for i in s1 {\n        if s2.contains(i)\
    \ {\n            result.append(i)\n        }\n    }\n    return result.sorted()",
  '    return []', "    let s1 = Set(l1), s2 = Set(l2)\n    let common = Array(s1.intersection(s2))\n\
    \    return common.sorted()", '    return l1.filter({ x in l2.contains(x) }).sorted()',
  '  return l1.filter({ l2.contains($0) }).unique()', '    return l1.filter{ l2.contains($0)
    }.sorted()', "    let c1 = l1.unique().sorted()\n    let c2 = l2.unique().sorted()\n\
    \    let common = c1.filter { c2.contains($0) }\n    return common", '    return
    l1.filter { l2.contains($0) }.sorted()', "    // TODO: Implement common\n    return\
    \ []", "    var d = [Int: Bool]()\n    for n in l1 {\n        d[n] = true\n  \
    \  }\n    var result = [Int]()\n    for n in l2 {\n        if d[n] == true {\n\
    \            result.append(n)\n        }\n    }\n    return result", '    return
    Array(Set(l1).intersect(Set(l2)))', '    return Array(Set(l1).intersect(Set(l2))).sorted()',
  '    return Set(l1).intersection(Set(l2)).sorted()', "    let set1 = Set(l1)\n \
    \   let set2 = Set(l2)\n    let commonSet = set1.intersection(set2)\n    let commonArray\
    \ = Array(commonSet)\n    return commonArray.sorted()"]
stop_tokens:
- "\n}"
