language: swift
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n  var groups: [String] = []\n  var currentGroup: String\
    \ = \"\"\n  var openGroups: Int = 0\n  for c in paren_string {\n    if c == \"\
    (\" {\n      openGroups += 1\n      currentGroup += String(c)\n    } else if c\
    \ == \")\" {\n      openGroups -= 1\n      currentGroup += String(c)\n      if\
    \ openGroups == 0 {\n        groups.append(currentGroup)\n        currentGroup\
    \ = \"\"\n      }\n    }\n  }\n  return groups\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824831
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var paren_arr = paren_string.components(separatedBy:\
    \ \" \")\n    var result = [String]()\n    var ix = 0\n    while ix < paren_arr.count\
    \ {\n        if paren_arr[ix] == \"(\" {\n            var sub_ix = ix + 1\n  \
    \          var open_count = 1\n            while open_count > 0 {\n          \
    \      if paren_arr[sub_ix] == \"(\" {\n                    open_count += 1\n\
    \                } else if paren_arr[sub_ix] == \")\" {\n                    open_count\
    \ -= 1\n                }\n                sub_ix += 1\n            }\n      \
    \      result.append(paren_arr[ix..<sub_ix].joined())\n            ix = sub_ix\n\
    \        } else {\n            ix += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0as94o2o.swift:9:34: error: value of type 'String' has no member\
    \ 'components'\n    var paren_arr = paren_string.components(separatedBy: \" \"\
    )\n                    ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824831
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let characters = paren_string.characters\n    var\
    \ result = [String]()\n    var buffer = [Character]()\n    var depth = 0\n   \
    \ for character in characters {\n        if character == \"(\" {\n           \
    \ depth += 1\n        } else if character == \")\" {\n            depth -= 1\n\
    \        }\n        if character != \" \" {\n            buffer.append(character)\n\
    \        }\n        if depth == 0 {\n            result.append(String(buffer))\n\
    \            buffer.removeAll()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpg29cr1r2.swift:9:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    let characters = paren_string.characters\n        \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1659824831
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var groups: [String] = []\n    var group: String\
    \ = \"\"\n    var count: Int = 0\n    for paren in paren_string {\n        if\
    \ paren == \"(\" {\n            count += 1\n        } else if paren == \")\" {\n\
    \            count -= 1\n        }\n        if count == 0 {\n            groups.append(group)\n\
    \            group = \"\"\n        } else {\n            group.append(paren)\n\
    \        }\n    }\n    return groups\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpf4l_538n/tmpf4l_538n.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b22db8fec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b22db5f5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b22db5f5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b22db5f47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf4l_538n                        0x00005597e159f787 <unavailable> + 6023

    5    libc.so.6                          0x00002b22dbaea460 __libc_start_main +
    245

    6    tmpf4l_538n                        0x00005597e159f319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659824831
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var groups = [String]()\n    var depth = 0\n    var\
    \ current_group = \"\"\n    for c in paren_string {\n        switch c {\n    \
    \    case \"(\":\n            depth += 1\n            current_group += String(c)\n\
    \        case \")\":\n            depth -= 1\n            current_group += String(c)\n\
    \            if depth == 0 {\n                groups.append(current_group)\n \
    \               current_group = \"\"\n            }\n        default:\n      \
    \      continue\n        }\n    }\n    return groups\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824831
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var parens = [String]()\n    var numberOfLeftParens\
    \ = 0\n    var numberOfRightParens = 0\n    var buffer = String()\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            numberOfLeftParens\
    \ += 1\n        } else if char == \")\" {\n            numberOfRightParens +=\
    \ 1\n        }\n        if numberOfLeftParens == numberOfRightParens {\n     \
    \       parens.append(buffer)\n            buffer = String()\n            numberOfLeftParens\
    \ = 0\n            numberOfRightParens = 0\n        } else {\n            buffer.append(char)\n\
    \        }\n    }\n    return parens\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpe3uzhzew/tmpe3uzhzew.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbbd48fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbbd186b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbbd186988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbbd1857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe3uzhzew                        0x000055bbd1230837 <unavailable> + 6199

    5    libc.so.6                          0x00002adbbd67b460 __libc_start_main +
    245

    6    tmpe3uzhzew                        0x000055bbd12303c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659824831
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return paren_string.split(separator: \" \").filter\
    \ { $0 != \"\" }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd62r2_o4.swift:9:47: error: cannot convert return expression of\
    \ type '[String.SubSequence]' (aka 'Array<Substring>') to return type '[String]'\n\
    \    return paren_string.split(separator: \" \").filter { $0 != \"\" }\n     \
    \                                         ^\n/tmp/tmpd62r2_o4.swift:9:47: note:\
    \ arguments to generic parameter 'Element' ('String.SubSequence' (aka 'Substring')\
    \ and 'String') are expected to be equal\n    return paren_string.split(separator:\
    \ \" \").filter { $0 != \"\" }\n                                             \
    \ ^\n"
  stdout: ''
  timestamp: 1659824831
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var paren_groups: [String] = []\n    var group: String\
    \ = \"\"\n    var left_count: Int = 0\n    var right_count: Int = 0\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            left_count += 1\n\
    \        } else if char == \")\" {\n            right_count += 1\n        }\n\
    \        if left_count == right_count {\n            paren_groups.append(group)\n\
    \            group = \"\"\n            left_count = 0\n            right_count\
    \ = 0\n        } else {\n            group += String(char)\n        }\n    }\n\
    \    return paren_groups\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp9dot5hze/tmp9dot5hze.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0bdfc17c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0bdf90eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0bdf90e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0bdf90d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9dot5hze                        0x000055bd878da7e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b0bdfe03460 __libc_start_main +
    245

    6    tmp9dot5hze                        0x000055bd878da379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824831
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var level = 0\n    var\
    \ buffer = \"\"\n    for c in paren_string {\n        if c == \" \" {\n      \
    \      continue\n        }\n        if c == \"(\" {\n            level += 1\n\
    \        }\n        buffer.append(c)\n        if c == \")\" {\n            level\
    \ -= 1\n            if level == 0 {\n                result.append(buffer)\n \
    \               buffer = \"\"\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824831
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var new_string = String()\n    var paren_groups =\
    \ [String]()\n    for char in paren_string {\n        if char != \" \" {\n   \
    \         new_string.append(char)\n        }\n    }\n    var number_of_open_parens\
    \ = 0\n    var number_of_closed_parens = 0\n    var current_group = String()\n\
    \    for char in new_string {\n        if char == \"(\" {\n            number_of_open_parens\
    \ += 1\n            current_group.append(char)\n        } else if char == \")\"\
    \ {\n            number_of_closed_parens += 1\n            current_group.append(char)\n\
    \        }\n        if number_of_open_parens == number_of_closed_parens {\n  \
    \          paren_groups.append(current_group)\n            current_group = String()\n\
    \            number_of_open_parens = 0\n            number_of_closed_parens =\
    \ 0\n        }\n    }\n    return paren_groups\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824831
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var current = [Character]()\n\
    \    var balance = 0\n    for ch in paren_string {\n        if ch == \" \" {\n\
    \            continue\n        }\n        if ch == \"(\" {\n            balance\
    \ += 1\n        } else if ch == \")\" {\n            balance -= 1\n        }\n\
    \        current.append(ch)\n        if balance == 0 {\n            result.append(String(current))\n\
    \            current = [Character]()\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824831
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    //TODO: Implement\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp8ui8dtfr/tmp8ui8dtfr.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b00e12c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b00b09b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2b00b09988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2b00b087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8ui8dtfr                        0x0000564ffd5bb537 <unavailable> + 5431

    5    libc.so.6                          0x00002b2b00ffe460 __libc_start_main +
    245

    6    tmp8ui8dtfr                        0x0000564ffd5bb0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659824831
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var stack = [Character]()\n\
    \    var string_accumulator = \"\"\n    for char in paren_string {\n        if\
    \ char == \"(\" {\n            stack.append(char)\n        } else if char == \"\
    )\" {\n            stack.removeLast()\n            if stack.isEmpty {\n      \
    \          result.append(string_accumulator)\n                string_accumulator\
    \ = \"\"\n            }\n        } else if !stack.isEmpty {\n            string_accumulator.append(char)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpuxdvn53h/tmpuxdvn53h.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac4ac5c9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac4ac2c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac4ac2c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac4ac2bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuxdvn53h                        0x000055b491ef4a07 <unavailable> + 6663

    5    libc.so.6                          0x00002ac4ac7b5460 __libc_start_main +
    245

    6    tmpuxdvn53h                        0x000055b491ef4599 <unavailable> + 5529

    '
  stdout: ''
  timestamp: 1659824831
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    var result:[String] = []\n    var inner:String\
    \ = \"\"\n    var current_count:Int = 0\n    for char in paren_string {\n    \
    \    if (char == \"(\" || char == \")\") {\n            inner.append(char)\n \
    \           if (char == \"(\") {\n                current_count += 1\n       \
    \     } else {\n                current_count -= 1\n            }\n        }\n\
    \        if (current_count == 0) {\n            if (inner != \"\") {\n       \
    \         result.append(inner)\n                inner = \"\"\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824831
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var group = String()\n\
    \    var parenCount = 0\n    var seenOpenParen = false\n    var isFirstParen =\
    \ true\n    var seenCloseParen = false\n    for char in paren_string {\n     \
    \   if char == \"(\" {\n            parenCount += 1\n            seenOpenParen\
    \ = true\n            isFirstParen = false\n        } else if char == \")\" {\n\
    \            parenCount -= 1\n            seenCloseParen = true\n        }\n \
    \       if parenCount == 0 && seenOpenParen && seenCloseParen {\n            result.append(group)\n\
    \            group = String()\n            seenOpenParen = false\n           \
    \ seenCloseParen = false\n        } else if isFirstParen {\n            continue\n\
    \        } else {\n            group.append(char)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp5kb98jsw/tmp5kb98jsw.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b69bfb9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b69bf893b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b69bf893988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b69bf8927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5kb98jsw                        0x000055be7dd28837 <unavailable> + 6199

    5    libc.so.6                          0x00002b69bfd88460 __libc_start_main +
    245

    6    tmp5kb98jsw                        0x000055be7dd283c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659824831
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // I'm using a stack to keep track of where my parens\
    \ are.\n    var paren_stack = [Character]()\n    var paren_string_array = [Character](paren_string.characters)\n\
    \    var group_start = 0\n    var group_end = 0\n    var groups = [String]()\n\
    \    // This loop does two things. Firstly, it checks to see if the parentheses\
    \ are properly closed.\n    // Secondly, it keeps track of the endpoints of each\
    \ group.\n    for i in 0..<paren_string_array.count {\n        if paren_string_array[i]\
    \ == \"(\" {\n            paren_stack.append(paren_string_array[i])\n        }\
    \ else if paren_string_array[i] == \")\" {\n            if paren_stack.count ==\
    \ 0 {\n                print(\"This isn't balanced\")\n                return\
    \ groups\n            } else {\n                paren_stack.removeLast()\n   \
    \             if paren_stack.count == 0 {\n                    group_end = i +\
    \ 1\n                    groups.append(String(paren_string_array[group_start..<group_end]))\n\
    \                    group_start = i + 1\n                }\n            }\n \
    \       }\n    }\n    if paren_stack.count > 0 {\n        print(\"This isn't balanced\"\
    )\n        return groups\n    }\n    return groups\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz8ukizlp.swift:11:55: error: 'characters' is unavailable: Please\
    \ use String directly\n    var paren_string_array = [Character](paren_string.characters)\n\
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpz8ukizlp.swift:11:9: warning: variable\
    \ 'paren_string_array' was never mutated; consider changing to 'let' constant\n\
    \    var paren_string_array = [Character](paren_string.characters)\n    ~~~ ^\n\
    \    let\n"
  stdout: ''
  timestamp: 1659824831
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var results = [String]()\n    var temp = [Character]()\n\
    \    var count = 0\n    for char in paren_string {\n        if char == \" \" {\n\
    \            continue\n        }\n        if char == \"(\" {\n            count\
    \ += 1\n        }\n        if char == \")\" {\n            count -= 1\n      \
    \  }\n        temp.append(char)\n        if count == 0 {\n            results.append(String(temp))\n\
    \            temp = [Character]()\n        }\n    }\n    return results\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824831
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var parens: [String] = []\n    var current_group\
    \ = \"\"\n    var group_level = 0\n    for paren in paren_string {\n        if\
    \ paren == \"(\" {\n            group_level += 1\n            current_group +=\
    \ String(paren)\n        } else if paren == \")\" {\n            group_level -=\
    \ 1\n            current_group += String(paren)\n            if group_level ==\
    \ 0 {\n                parens.append(current_group)\n                current_group\
    \ = \"\"\n            }\n        }\n    }\n    return parens\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824831
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var groups = [String]()\n    var inGroup = false\n\
    \    var group = \"\"\n    for c in paren_string {\n        if inGroup {\n   \
    \         if c == \")\" {\n                inGroup = false\n                groups.append(group)\n\
    \                group = \"\"\n            } else {\n                group.append(c)\n\
    \            }\n        } else {\n            if c == \"(\" {\n              \
    \  inGroup = true\n            }\n        }\n    }\n    return groups\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmprc7cntfs/tmprc7cntfs.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b411a2afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4119fa6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4119fa6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4119fa57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprc7cntfs                        0x00005602bd4397e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b411a49b460 __libc_start_main +
    245

    6    tmprc7cntfs                        0x00005602bd439379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824831
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the list of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n/// ['()', '(())', '(()())']\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    /// Variables to track current open parentheses and\
    \ current accumulator\n    var open_parens = 0\n    var curr_accum = \"\"\n  \
    \  /// An array to hold the results\n    var result = [String]()\n    /// Used\
    \ to keep track of whether we're in a group or not\n    var in_paren_group = false\n\
    \    /// For each character in the string\n    for char in paren_string {\n  \
    \      /// If it's a space, skip it\n        if char == \" \" {\n            continue\n\
    \        }\n        /// If it's an open parentheses, increase our open_parens\
    \ counter by 1\n        if char == \"(\" {\n            open_parens += 1\n   \
    \         /// If we're not in a paren group, we need to start one\n          \
    \  if !in_paren_group {\n                in_paren_group = true\n            }\n\
    \        }\n        /// If it's a close parentheses, decrease our open_parens\
    \ counter by 1\n        if char == \")\" {\n            open_parens -= 1\n   \
    \     }\n        /// Add the current character to the accumulator\n        curr_accum.append(char)\n\
    \        /// If our open_parens are 0, we've exhausted our current group, so add\
    \ it to the results array\n        if open_parens == 0 {\n            in_paren_group\
    \ = false\n            result.append(curr_accum)\n            curr_accum = \"\"\
    \n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824831
