name: HumanEval_93_encode
language: swift
prompt: "\n/// Write a function that takes a message, and encodes in such a \n///\
  \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
  \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
  \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
  /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc encode(message:\
  \ String) -> String {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\n\
  assert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\"\
  ) == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\"\
  )\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
  \ wRkTg\")"
completions: ["    // your code here\n    return \"\"", "    let vowels: Set<Character>\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var encoded = String()\n    for char\
    \ in message {\n        if let ascii = char.asciiValue {\n            if ascii\
    \ >= 97 && ascii <= 122 {\n                if vowels.contains(char) {\n      \
    \              let newAscii = ascii + 2\n                    if newAscii > 122\
    \ {\n                        let diff = newAscii - 122\n                     \
    \   let newChar = Character(UnicodeScalar(97 + diff - 1)!)\n                 \
    \       encoded.append(newChar)\n                    } else {\n              \
    \          let newChar = Character(UnicodeScalar(newAscii)!)\n               \
    \         encoded.append(newChar)\n                    }\n                } else\
    \ {\n                    let newChar = Character(UnicodeScalar(ascii - 32)!)\n\
    \                    encoded.append(newChar)\n                }\n            }\
    \ else if ascii >= 65 && ascii <= 90 {\n                if vowels.contains(char)\
    \ {\n                    let newAscii = ascii + 2\n                    if newAscii\
    \ > 90 {\n                        let diff = newAscii - 90\n                 \
    \       let newChar = Character(UnicodeScalar(65 + diff - 1)!)\n             \
    \           encoded.append(newChar)\n                    } else {\n          \
    \              let newChar = Character(UnicodeScalar(newAscii)!)\n           \
    \             encoded.append(newChar)\n                    }\n               \
    \ } else {\n                    let newChar = Character(UnicodeScalar(ascii +\
    \ 32)!)\n                    encoded.append(newChar)\n                }\n    \
    \        }\n        }\n    }\n    return encoded", "    let letters = \"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ\"\
    \n    let vowels = \"aAeEiIoOuU\"\n    var newMessage = \"\"\n    for char in\
    \ message.characters {\n        if (letters.containsString(String(char))) {\n\
    \            if (vowels.containsString(String(char))) {\n                if (char\
    \ == \"u\") {\n                    newMessage += \"a\"\n                } else\
    \ if (char == \"U\") {\n                    newMessage += \"A\"\n            \
    \    } else {\n                    newMessage += String(characters[2])\n     \
    \           }\n            } else {\n                if (char == \"z\") {\n  \
    \                  newMessage += \"a\"\n                } else if (char == \"\
    Z\") {\n                    newMessage += \"A\"\n                } else {\n  \
    \                  newMessage += String(characters[2])\n                }\n  \
    \          }\n        } else {\n            newMessage += String(char)\n     \
    \   }\n    }\n    return newMessage", "    return message.split(separator: \"\
    \ \").map { $0.map {\n        switch $0 {\n        case \"a\", \"e\", \"i\", \"\
    o\", \"u\":\n            return characterAfterN(letters: \"abcdefghijklmnopqrstuvwxyz\"\
    , character: $0, n: 2)\n        default:\n            return $0.isLowercase ?\
    \ $0.uppercased() : $0.lowercased()\n        }\n    }}.joined(separator: \" \"\
    )", '    return ""', "    let lowerCase = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ let upperCase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    let vowels = \"aeiou\"\n\
    \    var encodedMessage = \"\"\n    for letter in message {\n        if lowerCase.contains(letter)\
    \ {\n            let index = lowerCase.index(of: letter)!\n            if vowels.contains(letter)\
    \ {\n                let encodedIndex = (index.encodedOffset + 2) % lowerCase.count\n\
    \                encodedMessage.append(lowerCase[lowerCase.index(lowerCase.startIndex,\
    \ offsetBy: encodedIndex)])\n            } else {\n                encodedMessage.append(lowerCase[lowerCase.index(lowerCase.startIndex,\
    \ offsetBy: index.encodedOffset)])\n            }\n        } else if upperCase.contains(letter)\
    \ {\n            let index = upperCase.index(of: letter)!\n            if vowels.contains(letter.lowercased())\
    \ {\n                let encodedIndex = (index.encodedOffset + 2) % upperCase.count\n\
    \                encodedMessage.append(upperCase[upperCase.index(upperCase.startIndex,\
    \ offsetBy: encodedIndex)])\n            } else {\n                encodedMessage.append(upperCase[upperCase.index(upperCase.startIndex,\
    \ offsetBy: index.encodedOffset)])\n            }\n        } else {\n        \
    \    encodedMessage.append(letter)\n        }\n    }\n    return encodedMessage",
  "  let vowelShift = 2\n  let vowels = \"aeiouAEIOU\"\n  let alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  let encodedAlphabet = alphabet.substring(vowelShift) + alphabet.substring(0,\
    \ end: vowelShift - 1)\n  var result = \"\"\n  for character in message.characters\
    \ {\n    if vowels.contains(character) {\n      let index = alphabet.indexOf(character)\n\
    \      result += encodedAlphabet[index]\n    } else {\n      result += character\n\
    \    }\n  }\n  return result", "    let vowels = [\"a\", \"e\", \"i\", \"o\",\
    \ \"u\"]\n    let shiftedMessage = message.map { (char) -> String in\n       \
    \ if let index = vowels.firstIndex(of: String(char)) {\n            let shiftedIndex\
    \ = (index + 2) % vowels.count\n            return vowels[shiftedIndex]\n    \
    \    } else {\n            return String(char)\n        }\n    }.map { $0.lowercased()\
    \ == $0 ? $0.uppercased() : $0.lowercased() }.joined()\n    return shiftedMessage",
  "    let lowercase = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let uppercase = [\"\
    A\", \"E\", \"I\", \"O\", \"U\"]\n    var encoded = \"\"\n    for letter in message.characters\
    \ {\n        if lowercase.contains(String(letter)) {\n            let index =\
    \ lowercase.index(of: String(letter))!\n            encoded += lowercase[(index\
    \ + 2) % 5]\n        } else if uppercase.contains(String(letter)) {\n        \
    \    let index = uppercase.index(of: String(letter))!\n            encoded +=\
    \ uppercase[(index + 2) % 5]\n        } else {\n            encoded += String(letter)\n\
    \        }\n    }\n    return encoded", "    var encoded = \"\"\n    let vowels\
    \ = \"aeiou\"\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    for character\
    \ in message.lowercased() {\n        var character_index = alphabet.index(of:\
    \ character)\n        if let index = character_index {\n            if vowels.contains(character)\
    \ {\n                character_index = alphabet.index(index, offsetBy: 2)\n  \
    \          }\n            let encoded_char = alphabet[character_index!]\n    \
    \        encoded.append(encoded_char.uppercased())\n        } else {\n       \
    \     encoded.append(character)\n        }\n    }\n    return encoded", "    var\
    \ output = \"\"\n    for char in message.characters {\n        output += encodeChar(char)\n\
    \    }\n    return output", "    var vowels = Set<Character>()\n    vowels.insert(\"\
    a\")\n    vowels.insert(\"e\")\n    vowels.insert(\"i\")\n    vowels.insert(\"\
    o\")\n    vowels.insert(\"u\")\n    vowels.insert(\"A\")\n    vowels.insert(\"\
    E\")\n    vowels.insert(\"I\")\n    vowels.insert(\"O\")\n    vowels.insert(\"\
    U\")\n    \n    var newString = String()\n    for char in message.characters {\n\
    \        var newChar = char\n        if vowels.contains(char) {\n            newChar\
    \ = getCharacter(char: char, isAhead: true)\n        }\n        newChar = swapCase(char:\
    \ newChar)\n        newString.append(newChar)\n    }\n    return newString", '    return
    ""', "\tvar encodedMessage = \"\"\n\tlet alphabet = [\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ]\n\tlet vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tfor letter in message.characters\
    \ {\n\t\tlet a = String(letter).lowercased()\n\t\tif alphabet.contains(a) {\n\t\
    \t\tif vowels.contains(a) {\n\t\t\t\tencodedMessage.append(alphabet[(alphabet.index(of:\
    \ a)! + 2) % alphabet.count])\n\t\t\t} else {\n\t\t\t\tencodedMessage.append(String(letter).uppercased())\n\
    \t\t\t}\n\t\t} else {\n\t\t\tencodedMessage.append(String(letter))\n\t\t}\n\t\
    }\n\treturn encodedMessage", "    let letters = Array(message)\n    var encoded\
    \ = \"\"\n    for char in letters {\n        if char == char.lowercaseString {\n\
    \            encoded.append(char.uppercaseString)\n        } else {\n        \
    \    encoded.append(char.lowercaseString)\n        }\n    }\n    encoded = encoded.stringByReplacingOccurrencesOfString(\"\
    a\", withString: \"c\")\n    encoded = encoded.stringByReplacingOccurrencesOfString(\"\
    e\", withString: \"g\")\n    encoded = encoded.stringByReplacingOccurrencesOfString(\"\
    i\", withString: \"k\")\n    encoded = encoded.stringByReplacingOccurrencesOfString(\"\
    o\", withString: \"q\")\n    encoded = encoded.stringByReplacingOccurrencesOfString(\"\
    u\", withString: \"w\")\n    return encoded", "    return message.map {\n    \
    \    let uni = $0.unicodeScalars\n        if uni.first!.isLetter {\n         \
    \   let isUpper = uni.first!.isUpperCase\n            let ascii = uni.first!.value\
    \ - (isUpper ? 65 : 97)\n            let res = (ascii + 2) % 26\n            return\
    \ UnicodeScalar(res + (isUpper ? 65 : 97))!\n        } else {\n            return\
    \ $0\n        }\n    }.map {\n        let uni = $0.unicodeScalars\n        if\
    \ uni.first!.isLetter {\n            let isUpper = uni.first!.isUpperCase\n  \
    \          let ascii = uni.first!.value - (isUpper ? 65 : 97)\n            let\
    \ res = (ascii + 2) % 26\n            return UnicodeScalar(res + (isUpper ? 65\
    \ : 97))!\n        } else {\n            return $0\n        }\n    }.map {\n \
    \       let uni = $0.unicodeScalars\n        let ascii = uni.first!.value\n  \
    \      return UnicodeScalar(ascii + (uni.first!.isUpperCase ? 32 : -32))!\n  \
    \  }.reduce(\"\") { String($0) + String($1) }", "    var encoded = \"\"\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let shift = 2\n    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    let encoding = \"cdefghijklmnopqrstuvwxyzab\"\
    \n    let dictionary = zip(Array(alphabet), Array(encoding))\n    let letterDictionary\
    \ = dictionary.reduce([String: String]()) { (var dictionary, tuple) in\n     \
    \   dictionary[tuple.0] = tuple.1\n        return dictionary\n    }\n    for letter\
    \ in message.lowercaseString {\n        if vowels.contains(String(letter)) {\n\
    \            encoded += letterDictionary[String(letter)]!\n        } else {\n\
    \            encoded += letterDictionary[String(letter)]!\n        }\n    }\n\
    \    return encoded", "  var encodedMessage = \"\"\n  for letter in message.characters\
    \ {\n    let uppercaseLetter = String(letter).uppercaseString\n    let lowercaseLetter\
    \ = String(letter).lowercaseString\n    if uppercaseLetter == lowercaseLetter\
    \ {\n      encodedMessage.append(letter)\n    } else if uppercaseLetter == \"\
    A\" {\n      encodedMessage.append(\"C\")\n    } else if uppercaseLetter == \"\
    E\" {\n      encodedMessage.append(\"G\")\n    } else if uppercaseLetter == \"\
    I\" {\n      encodedMessage.append(\"K\")\n    } else if uppercaseLetter == \"\
    O\" {\n      encodedMessage.append(\"Q\")\n    } else if uppercaseLetter == \"\
    U\" {\n      encodedMessage.append(\"Y\")\n    } else if uppercaseLetter == \"\
    Y\" {\n      encodedMessage.append(\"A\")\n    } else if uppercaseLetter == \"\
    B\" {\n      encodedMessage.append(\"D\")\n    } else if uppercaseLetter == \"\
    C\" {\n      encodedMessage.append(\"E\")\n    } else if uppercaseLetter == \"\
    D\" {\n      encodedMessage.append(\"F\")\n    } else if uppercaseLetter == \"\
    F\" {\n      encodedMessage.append(\"H\")\n    } else if uppercaseLetter == \"\
    G\" {\n      encodedMessage.append(\"I\")\n    } else if uppercaseLetter == \"\
    H\" {\n      encodedMessage.append(\"J\")\n    } else if uppercaseLetter == \"\
    J\" {\n      encodedMessage.append(\"L\")\n    } else if uppercaseLetter == \"\
    K\" {\n      encodedMessage.append(\"M\")\n    } else if uppercaseLetter == \"\
    L\" {\n      encodedMessage.append(\"N\")\n    } else if uppercaseLetter == \"\
    M\" {\n      encodedMessage.append(\"O\")\n    } else if uppercaseLetter == \"\
    N\" {\n      encodedMessage.append(\"P\")\n    } else if uppercaseLetter == \"\
    P\" {\n      encodedMessage.append(\"R\")\n    } else if uppercaseLetter == \"\
    Q\" {\n      encodedMessage.append(\"S\")\n    } else if upperc", "\treturn \"\
    \"", "    let vowels = \"aeiouAEIOU\"\n    let encoded = message.characters.map\
    \ {\n        if vowels.characters.contains($0) {\n            return $0.value\n\
    \        } else {\n            return $0\n        }\n    }.map {\n        return\
    \ $0\n    }\n    return String(encoded)"]
stop_tokens:
- "\n}"
