name: HumanEval_141_file_name_check
language: swift
prompt: "\n/// Create a function which takes a string representing a file's name,\
  \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
  /// A file's name is considered to be valid if and only if all the following conditions\
  \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
  \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// - The\
  \ substring before the dot should not be empty, and it starts with a letter from\
  \ \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after the\
  \ dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
  example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
  \ name should start with a latin alphapet letter)\nfunc file_name_check(file_name:\
  \ String) -> String {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(file_name_check(file_name: \"example.txt\"\
  ) == \"Yes\")\nassert(file_name_check(file_name: \"1example.dll\") == \"No\")\n\
  assert(file_name_check(file_name: \"s1sdf3.asd\") == \"No\")\nassert(file_name_check(file_name:\
  \ \"K.dll\") == \"Yes\")\nassert(file_name_check(file_name: \"MY16FILE3.exe\") ==\
  \ \"Yes\")\nassert(file_name_check(file_name: \"His12FILE94.exe\") == \"No\")\n\
  assert(file_name_check(file_name: \"_Y.txt\") == \"No\")\nassert(file_name_check(file_name:\
  \ \"?aREYA.exe\") == \"No\")\nassert(file_name_check(file_name: \"/this_is_valid.dll\"\
  ) == \"No\")\nassert(file_name_check(file_name: \"this_is_valid.wow\") == \"No\"\
  )\nassert(file_name_check(file_name: \"this_is_valid.txt\") == \"Yes\")\nassert(file_name_check(file_name:\
  \ \"this_is_valid.txtexe\") == \"No\")\nassert(file_name_check(file_name: \"#this2_i4s_5valid.ten\"\
  ) == \"No\")\nassert(file_name_check(file_name: \"@this1_is6_valid.exe\") == \"\
  No\")\nassert(file_name_check(file_name: \"this_is_12valid.6exe4.txt\") == \"No\"\
  )\nassert(file_name_check(file_name: \"all.exe.txt\") == \"No\")\nassert(file_name_check(file_name:\
  \ \"I563_No.exe\") == \"Yes\")\nassert(file_name_check(file_name: \"Is3youfault.txt\"\
  ) == \"Yes\")\nassert(file_name_check(file_name: \"no_one#knows.dll\") == \"Yes\"\
  )\nassert(file_name_check(file_name: \"1I563_Yes3.exe\") == \"No\")\nassert(file_name_check(file_name:\
  \ \"I563_Yes3.txtt\") == \"No\")\nassert(file_name_check(file_name: \"final..txt\"\
  ) == \"No\")\nassert(file_name_check(file_name: \"final132\") == \"No\")\nassert(file_name_check(file_name:\
  \ \"_f4indsartal132.\") == \"No\")\nassert(file_name_check(file_name: \".txt\")\
  \ == \"No\")\nassert(file_name_check(file_name: \"s.\") == \"No\")"
completions: ["    // your solution is here\n    return \"\"", "  // Your code here\n\
    \  return \"\"", "    if let _ = file_name.rangeOfString(\"^[a-zA-Z]([a-zA-Z0-9])*\\\
    \\.txt$\", options: NSStringCompareOptions.RegularExpressionSearch) {\n      \
    \  return \"Yes\"\n    } else if let _ = file_name.rangeOfString(\"^[a-zA-Z]([a-zA-Z0-9])*\\\
    \\.exe$\", options: NSStringCompareOptions.RegularExpressionSearch) {\n      \
    \  return \"Yes\"\n    } else if let _ = file_name.rangeOfString(\"^[a-zA-Z]([a-zA-Z0-9])*\\\
    \\.dll$\", options: NSStringCompareOptions.RegularExpressionSearch) {\n      \
    \  return \"Yes\"\n    } else {\n        return \"No\"\n    }", "    let condition\
    \ = (file_name.characters.filter{$0 >= \"0\" && $0 <= \"9\"}.count <= 3) &&\n\
    \        (file_name.characters.filter{$0 == \".\"}.count == 1) &&\n        (file_name.characters.filter{$0\
    \ == \".\"}.first != file_name.characters.first) &&\n        (file_name.characters.filter{$0\
    \ == \".\"}.last != file_name.characters.last) &&\n        (file_name.components(separatedBy:\
    \ \".\")[0].characters.filter{$0 >= \"A\" && $0 <= \"Z\"}.count + file_name.components(separatedBy:\
    \ \".\")[0].characters.filter{$0 >= \"a\" && $0 <= \"z\"}.count != 0) &&\n   \
    \     (file_name.components(separatedBy: \".\")[1] == \"txt\" || file_name.components(separatedBy:\
    \ \".\")[1] == \"exe\" || file_name.components(separatedBy: \".\")[1] == \"dll\"\
    )\n    return condition ? \"Yes\" : \"No\"", "    let pat = \"\"\"\n    ^[a-zA-Z]{1}[a-zA-Z0-9]{0,2}\\\
    \\.[txt|exe|dll]$\n    \"\"\"\n    let nsfile_name = file_name as NSString\n \
    \   let file_ext = nsfile_name.pathExtension\n    let file_name = nsfile_name.deletingPathExtension\n\
    \    let reg = Regex(pat)\n    let file_ext_check = [\"txt\", \"exe\", \"dll\"\
    ].contains(file_ext)\n    return reg.isMatch(file_name) && file_ext_check ? \"\
    Yes\" : \"No\"", '    // Your code here!', '    return ""', '    if !(file_name.hasPrefix("a")
    || file_name.hasPrefix("b") || file_name.hasPrefix("c") || file_name.hasPrefix("d")
    || file_name.hasPrefix("e") || file_name.hasPrefix("f") || file_name.hasPrefix("g")
    || file_name.hasPrefix("h") || file_name.hasPrefix("i") || file_name.hasPrefix("j")
    || file_name.hasPrefix("k") || file_name.hasPrefix("l") || file_name.hasPrefix("m")
    || file_name.hasPrefix("n") || file_name.hasPrefix("o") || file_name.hasPrefix("p")
    || file_name.hasPrefix("q") || file_name.hasPrefix("r") || file_name.hasPrefix("s")
    || file_name.hasPrefix("t") || file_name.hasPrefix("u") || file_name.hasPrefix("v")
    || file_name.hasPrefix("w") || file_name.hasPrefix("x") || file_name.hasPrefix("y")
    || file_name.hasPrefix("z") || file_name.hasPrefix("A") || file_name.hasPrefix("B")
    || file_name.hasPrefix("C") || file_name.hasPrefix("D") || file_name.hasPrefix("E")
    || file_name.hasPrefix("F") || file_name.hasPrefix("G") || file_name.hasPrefix("H")
    || file_name.hasPrefix("I") || file_name.hasPrefix("J") || file_name.hasPrefix("K")
    || file_name.hasPrefix("L") || file_name.hasPrefix("M") || file_name.hasPrefix("N")
    || file_name.hasPrefix("O") || file_name.hasPrefix("P") || file_name.hasPrefix("Q")
    || file_name.hasPrefix("R") || file_name.hasPrefix("S") || file_name.hasPrefix("T")
    || file', '    return ""', "    // Your code here\n    let pattern = \"^[a-zA-Z]\\\
    \\w{1,3}\\\\.(txt|exe|dll)$\"\n    let regex = try! NSRegularExpression(pattern:\
    \ pattern, options: [])\n    let matches = regex.matches(in: file_name, options:\
    \ [], range: NSRange(location: 0, length: file_name.utf16.count))\n    return\
    \ matches.count > 0 ? \"Yes\" : \"No\"", "    let fileName = file_name\n    if\
    \ fileName.rangeOfString(\".\") == nil {\n        return \"No\"\n    } else {\n\
    \        let fileNameArray = fileName.componentsSeparatedByString(\".\")\n   \
    \     let fileNameFirst = fileNameArray[0]\n        let fileNameSecond = fileNameArray[1]\n\
    \        let numSet = NSCharacterSet.decimalDigitCharacterSet()\n        let stringSet\
    \ = NSCharacterSet.letterCharacterSet()\n        let numSetCount = fileNameFirst.unicodeScalars.filter({numSet.longCharacterIsMember($0.value)}).count\n\
    \        let stringSetCount = fileNameFirst.unicodeScalars.filter({stringSet.longCharacterIsMember($0.value)}).count\n\
    \        if numSetCount > 3 || stringSetCount == 0 || fileNameSecond != \"txt\"\
    \ && fileNameSecond != \"exe\" && fileNameSecond != \"dll\" {\n            return\
    \ \"No\"\n        } else {\n            return \"Yes\"\n        }\n    }", "\t",
  "    // write your code in Swift 3.0.1 (Linux)\n    var numberCount = 0\n    var\
    \ dotCount = 0\n    var validExtentions = [\"txt\", \"exe\", \"dll\"]\n    let\
    \ allowedCharacters = CharacterSet.alphanumerics\n    for char in file_name.characters\
    \ {\n        let character = String(char)\n        if Int(character) != nil {\n\
    \            numberCount += 1\n        }\n        if character == \".\" {\n  \
    \          dotCount += 1\n        }\n    }\n    let fileName = file_name.components(separatedBy:\
    \ \".\")\n    if fileName.count == 2 && dotCount == 1 && numberCount <= 3 && (validExtentions.contains(fileName[1]))\
    \ {\n        let firstWord = fileName[0]\n        let firstChar = firstWord.characters.first\n\
    \        if allowedCharacters.contains(UnicodeScalar(String(firstChar!))!) {\n\
    \            return \"Yes\"\n        }\n    }\n    return \"No\"", '    return
    ""', "    /// Determine if a string contains three or less digits (0-9)\n    func\
    \ contains_three_or_less_digits(str: String) -> Bool {\n        /// Count the\
    \ number of digits in a string\n        func count_digits(str: String) -> Int\
    \ {\n            var count = 0\n            for c in str.characters {\n      \
    \          if c >= \"0\" && c <= \"9\" {\n                    count += 1\n   \
    \             }\n            }\n            return count\n        }\n        return\
    \ count_digits(str) <= 3\n    }\n    /// The substring of a string after the last\
    \ '.'\n    func substring_after_last_dot(str: String) -> String {\n        if\
    \ let last_dot_index = str.characters.indexOf(\".\") {\n            return str.substringFromIndex(last_dot_index.advancedBy(1))\n\
    \        }\n        return \"\"\n    }\n    /// The substring of a string before\
    \ the last '.'\n    func substring_before_last_dot(str: String) -> String {\n\
    \        if let last_dot_index = str.characters.indexOf(\".\") {\n           \
    \ return str.substringToIndex(last_dot_index)\n        }\n        return \"\"\n\
    \    }\n    return file_name.characters.contains(\".\") &&\n        contains_three_or_less_digits(substring_before_last_dot(file_name))\
    \ &&\n        (substring_after_last_dot(file_name) == \"txt\" ||\n        substring_after_last_dot(file_name)\
    \ == \"exe\" ||\n        substring_after_last_dot(file_name) == \"dll\") &&\n\
    \        substring_before_last_dot(file_name).characters.first != nil &&\n   \
    \     (substring_before_last_dot(file_name).characters.first! >= \"a\" &&\n  \
    \      substring_before_last_dot(file_name).characters.first! <= \"z\" ||\n  \
    \      substring_before_last_dot(file_name).characters.first! >= \"A\" &&\n  \
    \      substring_before_last_dot(file_name).characters", "    if file_name.components(separatedBy:\
    \ CharacterSet.decimalDigits).count - 1 > 3 {\n        return \"No\"\n    }\n\
    \    let file_name_components = file_name.components(separatedBy: \".\")\n   \
    \ if file_name_components.count != 2 {\n        return \"No\"\n    }\n    if file_name_components[0].count\
    \ == 0 {\n        return \"No\"\n    }\n    if file_name_components[1] != \"txt\"\
    \ && file_name_components[1] != \"exe\" && file_name_components[1] != \"dll\"\
    \ {\n        return \"No\"\n    }\n    if !CharacterSet.letters.contains(file_name_components[0].unicodeScalars.first!)\
    \ {\n        return \"No\"\n    }\n    return \"Yes\"", '    return "No"', " \
    \   let parts = file_name.components(separatedBy: \".\")\n    if parts.count !=\
    \ 2 {\n        return \"No\"\n    }\n    if !parts[0].isEmpty && parts[0][parts[0].startIndex].isLetter\
    \ {\n        if parts[1] == \"txt\" || parts[1] == \"exe\" || parts[1] == \"dll\"\
    \ {\n            return \"Yes\"\n        }\n    }\n    return \"No\"", "    let\
    \ regex = try! NSRegularExpression(pattern: \"[a-zA-Z]{1}[a-zA-Z0-9]{1,}\\\\.(txt|exe|dll)\"\
    , options: [])\n    return regex.firstMatch(in: file_name, options: [], range:\
    \ NSRange(location: 0, length: file_name.count)) != nil ? \"Yes\" : \"No\"", '    //
    Your code here.']
stop_tokens:
- "\n}"
