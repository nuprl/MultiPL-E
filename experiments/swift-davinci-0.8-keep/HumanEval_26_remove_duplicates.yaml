name: HumanEval_26_remove_duplicates
language: swift
prompt: "\n/// From a list of integers, remove all elements that occur more than once.\n\
  /// Keep order of elements left the same as in the input.\n/// >>> remove_duplicates([1,\
  \ 2, 3, 2, 4])\n/// [1, 3, 4]\nfunc remove_duplicates(numbers: [Int]) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(remove_duplicates(numbers: [] as [Int])\
  \ == [] as [Int])\nassert(remove_duplicates(numbers: [1, 2, 3, 4]) == [1, 2, 3,\
  \ 4])\nassert(remove_duplicates(numbers: [1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])"
completions: ["    var results: [Int] = []\n    var unique: [Int: Bool] = [:]\n  \
    \  for number in numbers {\n        if let _ = unique[number] {\n            continue\n\
    \        }\n        results.append(number)\n        unique[number] = true\n  \
    \  }\n    return results", "    var retArr: [Int] = []\n    var tempDict: [Int:Int]\
    \ = [:]\n    for n in numbers {\n        if tempDict[n] == nil {\n           \
    \ tempDict[n] = 1\n            retArr.append(n)\n        }\n    }\n    return\
    \ retArr", "    var result: [Int] = []\n    var hashMap: [Int: Bool] = [:]\n \
    \   for number in numbers {\n        if hashMap[number] == nil {\n           \
    \ hashMap[number] = true\n            result.append(number)\n        }\n    }\n\
    \    return result", "    var newNumbers = [Int]()\n    for number in numbers\
    \ {\n        if !newNumbers.contains(number) {\n            newNumbers.append(number)\n\
    \        }\n    }\n    return newNumbers", "    var filteredNumbers: [Int] = []\n\
    \    for number in numbers {\n        if(!filteredNumbers.contains(number)) {\n\
    \            filteredNumbers.append(number)\n        }\n    }\n    return filteredNumbers",
  "    var elements = Set<Int>()\n    var result = [Int]()\n    for number in numbers\
    \ {\n        if elements.contains(number) {\n            continue\n        }\n\
    \        elements.insert(number)\n        result.append(number)\n    }\n    return\
    \ result", "    var uniqueNumbers = [Int]()\n    for num in numbers {\n      \
    \  if !uniqueNumbers.contains(num) {\n            uniqueNumbers.append(num)\n\
    \        }\n    }\n    return uniqueNumbers", "    var output: [Int] = []\n  \
    \  var seen: [Int] = []\n    for number in numbers {\n        if !seen.contains(number)\
    \ {\n            output.append(number)\n            seen.append(number)\n    \
    \    }\n    }\n    return output", "    var list = [Int]()\n    for element in\
    \ numbers {\n        if list.contains(element) {\n            continue\n     \
    \   }\n        list.append(element)\n    }\n    return list", "    return numbers.filter\
    \ { (n) -> Bool in\n        return numbers.filter({ $0 == n }).count == 1\n  \
    \  }", "    var uniqueNumbers: [Int] = []\n    var uniqueNumbersCount: [Int: Int]\
    \ = [:]\n    \n    for num in numbers {\n        if (uniqueNumbersCount[num] !=\
    \ nil) {\n            uniqueNumbersCount[num]! += 1\n        } else {\n      \
    \      uniqueNumbersCount[num] = 1\n        }\n    }\n    \n    for num in numbers\
    \ {\n        if (uniqueNumbersCount[num] == 1) {\n            uniqueNumbers.append(num)\n\
    \        }\n    }\n    \n    return uniqueNumbers", "  var final: [Int] = []\n\
    \  var set: Set<Int> = []\n  for num in numbers {\n    if set.contains(num) {\n\
    \      continue\n    }\n    final.append(num)\n    set.insert(num)\n  }\n  return\
    \ final", "    return numbers.reduce([]) {\n        if contains($0, $1) {\n  \
    \          return $0\n        } else {\n            return $0 + [$1]\n       \
    \ }\n    }", "    var unique_numbers = Set<Int>()\n    var unique_numbers_ordered\
    \ = [Int]()\n    for number in numbers {\n        if !unique_numbers.contains(number)\
    \ {\n            unique_numbers.insert(number)\n            unique_numbers_ordered.append(number)\n\
    \        }\n    }\n    return unique_numbers_ordered", "    var result: [Int]\
    \ = []\n    for n in numbers {\n        if !result.contains(n) {\n           \
    \ result.append(n)\n        }\n    }\n    return result", "    var result = [Int]()\n\
    \    for number in numbers {\n        if !result.contains(number) {\n        \
    \    result.append(number)\n        }\n    }\n    return result", "    let numSet\
    \ = Set(numbers)\n    return Array(numSet)", "    var uniqueNumbers: [Int] = []\n\
    \    for number in numbers {\n        if !uniqueNumbers.contains(number) {\n \
    \           uniqueNumbers.append(number)\n        }\n    }\n    return uniqueNumbers",
  "    let counts = numbers.reduce(into: [:]) { counts, number in counts[number, default:\
    \ 0] += 1 }\n    return numbers.filter { counts[$0] == 1 }", "    var result:\
    \ [Int] = []\n    for number in numbers {\n        if !result.contains(number)\
    \ {\n            result.append(number)\n        }\n    }\n    return result"]
stop_tokens:
- "\n}"
