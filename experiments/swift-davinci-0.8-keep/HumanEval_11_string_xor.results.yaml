language: swift
name: HumanEval_11_string_xor
results:
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n\tvar output = \"\"\n\tfor i in 0 ..< a.characters.count {\n\t\t\
    if a[i] == b[i] {\n\t\t\toutput += \"0\"\n\t\t} else {\n\t\t\toutput += \"1\"\n\
    \t\t}\n\t}\n\treturn output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp3oqnscp8.swift:8:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        for i in 0 ..< a.characters.count {\n         \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp3oqnscp8.swift:9:6: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n                if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp3oqnscp8.swift:9:14: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                if a[i] == b[i] {\n                           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824416
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let zipped = zip(a, b)\n    let result = zipped.map { (l, r)\
    \ -> String in\n        return String(Int(String(l))! ^ Int(String(r))!)\n   \
    \ }\n    return result.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824416
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var str = \"\"\n    if a.count != b.count {\n        return\
    \ str\n    }\n    for i in 0..<a.count {\n        let aChar = a[a.index(a.startIndex,\
    \ offsetBy: i)]\n        let bChar = b[b.index(b.startIndex, offsetBy: i)]\n \
    \       if aChar == bChar {\n            str.append(\"0\")\n        } else {\n\
    \            str.append(\"1\")\n        }\n    }\n    return str\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824416
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var res = \"\"\n    for i in 0..<a.count {\n        res +=\
    \ String(Int(String(a[i]))! ^ Int(String(b[i]))!)\n    }\n    return res\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpjwerb3pj.swift:9:34: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        res += String(Int(String(a[i]))!\
    \ ^ Int(String(b[i]))!)\n                                 ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpjwerb3pj.swift:9:55:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        res += String(Int(String(a[i]))! ^ Int(String(b[i]))!)\n\
    \                                                      ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824416
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    return String(zip(a, b).map{ $0 != $1 ? \"1\" : \"0\" })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824416
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n  var result = \"\"\n  for idx in 0..<a.characters.count {\n  \
    \  let ia = a.index(a.startIndex, offsetBy: idx)\n    let ib = b.index(b.startIndex,\
    \ offsetBy: idx)\n    let ca = a[ia]\n    let cb = b[ib]\n    if (ca == cb) {\n\
    \      result += \"0\"\n    } else {\n      result += \"1\"\n    }\n  }\n  return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpewf1urya.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n  for idx in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824416
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let n = a.count\n    var ret = \"\"\n    for i in 0..<n {\n\
    \        let ai = a[i]\n        let bi = b[i]\n        if ai == bi {\n       \
    \     ret += \"0\"\n        } else {\n            ret += \"1\"\n        }\n  \
    \  }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpglw9gywc.swift:10:18: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let ai =\
    \ a[i]\n                 ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpglw9gywc.swift:11:18: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let bi = b[i]\n                 ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824416
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = Int(a, radix: 2)!\n    let b = Int(b, radix: 2)!\n\
    \    let result = a ^ b\n    return String(result, radix: 2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: Exception
  stderr: 'tmpk70bso26/tmpk70bso26.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8fa31f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8fa2ee9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8fa2ee9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8fa2ee87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk70bso26                        0x0000558e000a55ab <unavailable> + 5547

    5    libc.so.6                          0x00002b8fa33de460 __libc_start_main +
    245

    6    tmpk70bso26                        0x0000558e000a51b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1659824416
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    // your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: Exception
  stderr: 'tmpt_i5fcbz/tmpt_i5fcbz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad4c4cfbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad4c49f2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad4c49f2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad4c49f17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt_i5fcbz                        0x000056349233433b <unavailable> + 4923

    5    libc.so.6                          0x00002ad4c4ee7460 __libc_start_main +
    245

    6    tmpt_i5fcbz                        0x0000563492333f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824416
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n  assert(a.characters.count == b.characters.count)\n  var result\
    \ = \"\"\n  for (charA, charB) in zip(a.characters, b.characters) {\n    if charA\
    \ == charB {\n      result.append(\"0\")\n    } else {\n      result.append(\"\
    1\")\n    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpgx3984l4.swift:7:12: error: 'characters' is unavailable: Please\
    \ use String directly\n  assert(a.characters.count == b.characters.count)\n  \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpgx3984l4.swift:7:34:\
    \ error: 'characters' is unavailable: Please use String directly\n  assert(a.characters.count\
    \ == b.characters.count)\n                                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpgx3984l4.swift:9:31: error: 'characters'\
    \ is unavailable: Please use String directly\n  for (charA, charB) in zip(a.characters,\
    \ b.characters) {\n                              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpgx3984l4.swift:9:45: error: 'characters'\
    \ is unavailable: Please use String directly\n  for (charA, charB) in zip(a.characters,\
    \ b.characters) {\n                                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824416
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    if a.count != b.count {\n        return \"\"\n    }\n    var\
    \ result = \"\"\n    for i in 0 ..< a.count {\n        let x = a[i]\n        let\
    \ y = b[i]\n        result += x ^ y ? \"1\" : \"0\"\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd5z0sd6.swift:12:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let x = a[i]\n\
    \                ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpwd5z0sd6.swift:13:17: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ y = b[i]\n                ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpwd5z0sd6.swift:14:21: error: binary operator\
    \ '^' cannot be applied to two 'Character' operands\n        result += x ^ y ?\
    \ \"1\" : \"0\"\n                    ^\nSwift.BinaryInteger:1:17: note: candidate\
    \ requires that 'Character' conform to 'BinaryInteger' (requirement specified\
    \ as 'Self' : 'BinaryInteger')\npublic protocol BinaryInteger : CustomStringConvertible,\
    \ Hashable, Numeric, Strideable where Self.Magnitude : BinaryInteger, Self.Magnitude\
    \ == Self.Magnitude.Magnitude {\n                ^\n/tmp/tmpwd5z0sd6.swift:14:21:\
    \ error: cannot convert value of type 'Character' to expected condition type 'Bool'\n\
    \        result += x ^ y ? \"1\" : \"0\"\n                  ~~^~~\n"
  stdout: ''
  timestamp: 1659824416
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let aBytes = Array(a.utf8)\n    let bBytes = Array(b.utf8)\n\
    \    var result = [UInt8]()\n    for i in 0..<aBytes.count {\n        result.append(aBytes[i]\
    \ ^ bBytes[i])\n    }\n    return String(bytes: result, encoding: .utf8)!\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpr5qay5u_.swift:13:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: result, encoding: .utf8)!\n           ^\n/tmp/tmpr5qay5u_.swift:13:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ result, encoding: .utf8)!\n           ^\n/tmp/tmpr5qay5u_.swift:13:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpr5qay5u_.swift:13:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpr5qay5u_.swift:13:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824416
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    return String(Int(a)! ^ Int(b)!, radix: 2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: Exception
  stderr: 'tmpbddc_zdq/tmpbddc_zdq.swift:23: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b66e7f07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b66e7bfeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b66e7bfe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b66e7bfd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbddc_zdq                        0x000056352aa3f52b <unavailable> + 5419

    5    libc.so.6                          0x00002b66e80f3460 __libc_start_main +
    245

    6    tmpbddc_zdq                        0x000056352aa3f139 <unavailable> + 4409

    '
  stdout: ''
  timestamp: 1659824416
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var c = \"\"\n    for i in 0..<a.characters.count {\n     \
    \   c += String(Int(String(a[a.index(a.startIndex, offsetBy: i)]))! ^ Int(String(b[b.index(b.startIndex,\
    \ offsetBy: i)]))!)\n    }\n    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpv10oxktb.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824416
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n  return String(a.utf8.enumerated().map({\n    String(UnicodeScalar(UInt8($0.element\
    \ ^ b[b.index(b.startIndex, offsetBy: $0.offset)]) & 0x7f))\n  }))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp4tl1womq.swift:7:10: error: no exact matches in call to initializer\
    \ \n  return String(a.utf8.enumerated().map({\n         ^\n/tmp/tmp4tl1womq.swift:7:10:\
    \ note: found candidate with type '([Character]) -> String'\n  return String(a.utf8.enumerated().map({\n\
    \         ^\n/tmp/tmp4tl1womq.swift:7:10: note: candidate expects value of type\
    \ '[String]' for parameter #1 (got '[String]')\n  return String(a.utf8.enumerated().map({\n\
    \         ^\n/tmp/tmp4tl1womq.swift:7:10: note: candidate expects value of type\
    \ '[String]' for parameter #1 (got '[String]')\n  return String(a.utf8.enumerated().map({\n\
    \         ^\n/tmp/tmp4tl1womq.swift:7:10: note: candidate expects value of type\
    \ '[String]' for parameter #1 (got '[String]')\n  return String(a.utf8.enumerated().map({\n\
    \         ^\n/tmp/tmp4tl1womq.swift:8:46: error: cannot convert value of type\
    \ 'Character' to expected argument type 'UInt8'\n    String(UnicodeScalar(UInt8($0.element\
    \ ^ b[b.index(b.startIndex, offsetBy: $0.offset)]) & 0x7f))\n                \
    \                             ^\n"
  stdout: ''
  timestamp: 1659824419
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let count = a.count\n    var aChars = Array(a.utf8)\n    var\
    \ bChars = Array(b.utf8)\n    var result = [UInt8]()\n    for i in 0..<count {\n\
    \        let a = Int(aChars[i])\n        let b = Int(bChars[i])\n        result.append(UInt8(a\
    \ ^ b))\n    }\n    return String(bytes: result, encoding: .utf8)!\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpbybhidph.swift:16:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: result, encoding: .utf8)!\n           ^\n/tmp/tmpbybhidph.swift:16:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ result, encoding: .utf8)!\n           ^\n/tmp/tmpbybhidph.swift:16:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpbybhidph.swift:16:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpbybhidph.swift:16:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824416
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let xor = zip(a, b).map { x, y in\n        switch (x, y) {\n\
    \        case (\"0\", \"0\"): return \"0\"\n        case (\"1\", \"1\"): return\
    \ \"0\"\n        default: return \"1\"\n        }\n    }\n    return String(xor)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpeqa_rv4o.swift:14:12: error: no exact matches in call to initializer\
    \ \n    return String(xor)\n           ^\nSwift.String:4:12: note: candidate requires\
    \ that the types 'String' and 'Character' be equivalent (requirement specified\
    \ as 'S.Element' == 'Character')\n    public init<S>(_ characters: S) where S\
    \ : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate requires that the types 'String.Element' (aka 'Character') and\
    \ 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\nSwift.String:2:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:3:23: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    @inlinable public\
    \ init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible\n\
    \                      ^\nSwift.String:6:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659824416
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var c = \"\"\n    for i in 0..<a.characters.count {\n     \
    \   c += xor(a: a[i], b: b[i])\n    }\n    return c\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpkca8xrpn.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpkca8xrpn.swift:9:14:\
    \ error: cannot find 'xor' in scope\n        c += xor(a: a[i], b: b[i])\n    \
    \         ^~~\n"
  stdout: ''
  timestamp: 1659824416
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    // Read all characters into an array\n    let ca = Array(a.characters)\n\
    \    let cb = Array(b.characters)\n    // Make sure both strings are of the same\
    \ length\n    guard ca.count == cb.count else {\n        fatalError(\"\\(a) and\
    \ \\(b) must be of the same length\")\n    }\n    // XOR the two strings\n   \
    \ let c = zip(ca, cb).map { $0 != $1 ? \"1\" : \"0\" }\n    // Return result\n\
    \    return String(c)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp7ia33145.swift:8:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let ca = Array(a.characters)\n                    \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp7ia33145.swift:9:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    let cb =\
    \ Array(b.characters)\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp7ia33145.swift:17:12: error: no exact matches\
    \ in call to initializer \n    return String(c)\n           ^\nSwift.String:4:12:\
    \ note: candidate requires that the types 'String' and 'Character' be equivalent\
    \ (requirement specified as 'S.Element' == 'Character')\n    public init<S>(_\
    \ characters: S) where S : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate requires that the types 'String.Element' (aka 'Character') and\
    \ 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\nSwift.String:2:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:3:23: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    @inlinable public\
    \ init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible\n\
    \                      ^\nSwift.String:6:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659824416
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var a = a\n    var b = b\n    let n = a.characters.count\n\
    \    let m = b.characters.count\n    if n > m {\n        for _ in 0..<n-m {\n\
    \            b = \"0\" + b\n        }\n    } else if m > n {\n        for _ in\
    \ 0..<m-n {\n            a = \"0\" + a\n        }\n    }\n    var result = \"\"\
    \n    for i in 0..<a.characters.count {\n        if a[i] == b[i] {\n         \
    \   result += \"0\"\n        } else {\n            result += \"1\"\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpmmdbs1ki.swift:9:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    let n = a.characters.count\n              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmmdbs1ki.swift:10:15:\
    \ error: 'characters' is unavailable: Please use String directly\n    let m =\
    \ b.characters.count\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpmmdbs1ki.swift:21:20: error: 'characters' is unavailable:\
    \ Please use String directly\n    for i in 0..<a.characters.count {\n        \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpmmdbs1ki.swift:22:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if a[i] == b[i] {\n\
    \           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpmmdbs1ki.swift:22:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824416
