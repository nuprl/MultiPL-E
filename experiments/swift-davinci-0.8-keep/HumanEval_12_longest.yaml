name: HumanEval_12_longest
language: swift
prompt: "\n/// Out of list of strings, return the longest one. Return the first one\
  \ in case of multiple\n/// strings of the same length. Return None in case the input\
  \ list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n/// 'a'\n\
  /// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings: [String])\
  \ -> String? {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\n\
  assert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings:\
  \ [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
completions: ["    let ordered = strings.sorted() { $0.characters.count > $1.characters.count\
    \ }\n    if ordered.count > 0 {\n        return ordered[0]\n    }\n    return\
    \ nil", "    var length = 0\n    var longest: String? = nil\n    for item in strings\
    \ {\n        if item.count > length {\n            length = item.count\n     \
    \       longest = item\n        }\n    }\n    return longest", "    // implement\
    \ your code here\n    guard !strings.isEmpty else { return nil }\n    var longest\
    \ = strings[0]\n    for i in 1 ..< strings.count {\n        if strings[i].count\
    \ > longest.count {\n            longest = strings[i]\n        }\n    }\n    return\
    \ longest", "    return strings.reduce(nil) {\n        return ($0?.count ?? 0)\
    \ > $1.count ? $0 : $1\n    }", "    var longestStr: String? = nil\n    for str\
    \ in strings {\n        if let currentStr = longestStr {\n            if str.count\
    \ > currentStr.count {\n                longestStr = str\n            }\n    \
    \    } else {\n            longestStr = str\n        }\n    }\n    return longestStr",
  "    var result: String? = nil\n    for string in strings {\n        if result ==\
    \ nil || string.count > result!.count {\n            result = string\n       \
    \ }\n    }\n    return result", "    var longestString = String()\n    var longestStringLength\
    \ = 0\n    for str in strings {\n        if str.characters.count > longestStringLength\
    \ {\n            longestString = str\n            longestStringLength = str.characters.count\n\
    \        }\n    }\n    return longestString", "    guard strings.count > 0 else\
    \ {\n        return nil\n    }\n    return strings.reduce(strings[0]) {\n    \
    \    return $0.count > $1.count ? $0 : $1\n    }", "    var longest = \"\"\n \
    \   for string in strings {\n        if string.characters.count > longest.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest.characters.count\
    \ > 0 ? longest : nil", '    return nil', "    guard let _ = strings.first else\
    \ {\n        return nil\n    }\n    var longestString = strings.first!\n    for\
    \ string in strings {\n        if string.characters.count > longestString.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString",
  "    return reduce(strings, nil) { (a: String?, b: String) -> String? in\n     \
    \   a == nil || a!.characters.count < b.characters.count ? b : a\n    }", "  \
    \  //TODO: Implement longest\n    return nil", "    guard strings.count > 0 else\
    \ {\n        return nil\n    }\n    var longestString = strings[0]\n    for string\
    \ in strings {\n        if string.count > longestString.count {\n            longestString\
    \ = string\n        }\n    }\n    return longestString", "    var longestString:\
    \ String?\n    for string in strings {\n        if longestString == nil || count(string)\
    \ > count(longestString!) {\n            longestString = string\n        }\n \
    \   }\n    return longestString", "    if let first = strings.first {\n      \
    \  return strings.reduce(first) { longest, string in\n            return string.characters.count\
    \ > longest.characters.count ? string : longest\n        }\n    }\n    return\
    \ nil", "    if strings.isEmpty {\n        return nil\n    }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }", "  if strings.isEmpty {\n    return nil\n\
    \  }\n  else {\n    var longestString = strings[0]\n    for string in strings\
    \ {\n      if string.count > longestString.count {\n        longestString = string\n\
    \      }\n    }\n    return longestString\n  }", "    guard strings.count > 0\
    \ else {\n        return nil\n    }\n    var longest: String = strings[0]\n  \
    \  for string in strings {\n        if string.count > longest.count {\n      \
    \      longest = string\n        }\n    }\n    return longest", "    guard !strings.isEmpty\
    \ else { return nil }\n    var longestString = strings[0]\n    for string in strings\
    \ {\n        if string.count > longestString.count {\n            longestString\
    \ = string\n        }\n    }\n    return longestString"]
stop_tokens:
- "\n}"
