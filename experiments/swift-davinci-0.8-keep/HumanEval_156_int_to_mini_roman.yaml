name: HumanEval_156_int_to_mini_roman
language: swift
prompt: "\n/// Given a positive integer, obtain its roman numeral equivalent as a\
  \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
  /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
  \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
  \ Int) -> String {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\"\
  )\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number:\
  \ 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number:\
  \ 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number:\
  \ 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number:\
  \ 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number:\
  \ 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number:\
  \ 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"
completions: ["    let dict = [\n        (1000, \"m\"),\n        (900, \"cm\"),\n\
    \        (500, \"d\"),\n        (400, \"cd\"),\n        (100, \"c\"),\n      \
    \  (90, \"xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n        (10, \"\
    x\"),\n        (9, \"ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n     \
    \   (1, \"i\")\n    ]\n    var remainder = number\n    var result = \"\"\n   \
    \ for entry in dict {\n        let (divisor, symbol) = entry\n        while remainder\
    \ >= divisor {\n            result += symbol\n            remainder -= divisor\n\
    \        }\n    }\n    return result", "    let number_string = String(number)\n\
    \    let digit_0 = number_string.chars.first!\n    let digit_1 = number_string.chars.skip(1).first\
    \ ?? \"0\"\n    let digit_2 = number_string.chars.skip(2).first ?? \"0\"\n   \
    \ let digit_3 = number_string.chars.skip(3).first ?? \"0\"\n    let digit_4 =\
    \ number_string.chars.skip(4).first ?? \"0\"\n    let digit_5 = number_string.chars.skip(5).first\
    \ ?? \"0\"\n    let digit_6 = number_string.chars.skip(6).first ?? \"0\"\n   \
    \ let digit_7 = number_string.chars.skip(7).first ?? \"0\"\n    let digit_8 =\
    \ number_string.chars.skip(8).first ?? \"0\"\n    let digit_9 = number_string.chars.skip(9).first\
    \ ?? \"0\"\n    let digit_10 = number_string.chars.skip(10).first ?? \"0\"\n \
    \   let digit_11 = number_string.chars.skip(11).first ?? \"0\"\n    let digit_12\
    \ = number_string.chars.skip(12).first ?? \"0\"\n    let digit_13 = number_string.chars.skip(13).first\
    \ ?? \"0\"\n    let digit_14 = number_string.chars.skip(14).first ?? \"0\"\n \
    \   let digit_15 = number_string.chars.skip(15).first ?? \"0\"\n    let digit_16\
    \ = number_string.chars.skip(16).first ?? \"0\"\n    let digit_17 = number_string.chars.skip(17).first\
    \ ?? \"0\"\n    let digit_18 = number_string.chars.skip(18).first ?? \"0\"\n \
    \   let digit_19 = number_string.chars.skip(19).first ?? \"0\"\n    let digit_20\
    \ = number_string.chars.skip(20).first ?? \"0\"\n    let digit_21 = number_string.chars.skip(21).first\
    \ ?? \"0\"\n   ", "  // Convert an integer to its numeral equivalent in the MiniRoman\
    \ style.\n  // We will use a string-based approach to build the result from the\
    \ input.\n  // Note that we have a base lookup table that maps integer values\
    \ to\n  // their corresponding numeral characters. We begin with an empty string\n\
    \  // for our result, and for each character in the table we add that character\n\
    \  // to the result for as many times as we can divide the input integer by\n\
    \  // the current character's base value. Once we can no longer divide the\n \
    \ // input integer by the base value of the current character, we continue\n \
    \ // with the next character in the table.\n  var result = \"\"\n  let mini_roman_lookup_table\
    \ = [ (1000, \"m\"), (900, \"cm\"), (500, \"d\"),\n                          \
    \        (400, \"cd\"), (100, \"c\"), (90, \"xc\"),\n                        \
    \          (50, \"l\"), (40, \"xl\"), (10, \"x\"),\n                         \
    \         (9, \"ix\"), (5, \"v\"), (4, \"iv\"), (1, \"i\") ]\n  var number = number\n\
    \  for (base, char) in mini_roman_lookup_table {\n    // We will continue to add\
    \ the current character to the result until\n    // it is no longer possible to\
    \ divide the input integer by the current\n    // character's base value.\n  \
    \  while number >= base {\n      result += char\n      number -= base\n    }\n\
    \  }\n  return result", "    var output = \"\"\n    let lookup = [\n        1000:\
    \ \"m\",\n        900: \"cm\",\n        500: \"d\",\n        400: \"cd\",\n  \
    \      100: \"c\",\n        90: \"xc\",\n        50: \"l\",\n        40: \"xl\"\
    ,\n        10: \"x\",\n        9: \"ix\",\n        5: \"v\",\n        4: \"iv\"\
    ,\n        1: \"i\",\n    ]\n    for (key, value) in lookup {\n        if number\
    \ / key > 0 {\n            output += String(repeating: value, count: number /\
    \ key)\n            number -= (number / key) * key\n        }\n    }\n    return\
    \ output", "    let numerals = [(\"m\", 1000), (\"cm\", 900), (\"d\", 500), (\"\
    cd\", 400),\n                    (\"c\", 100), (\"xc\", 90), (\"l\", 50), (\"\
    xl\", 40),\n                    (\"x\", 10), (\"ix\", 9), (\"v\", 5), (\"iv\"\
    , 4),\n                    (\"i\", 1)]\n    var remaining = number\n    var result\
    \ = \"\"\n    for (numeral, value) in numerals {\n        while remaining >= value\
    \ {\n            result += numeral\n            remaining -= value\n        }\n\
    \    }\n    return result", '    return ""', "    let roman_numerals = [\"m\"\
    , \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"\
    iv\", \"i\"]\n    let int_values = [1000, 900, 500, 400, 100, 90, 50, 40, 10,\
    \ 9, 5, 4, 1]\n    var result = \"\"\n    var n = number\n    for (i, roman_numeral)\
    \ in roman_numerals.enumerate() {\n        let int_value = int_values[i]\n   \
    \     while n >= int_value {\n            result += roman_numeral\n          \
    \  n -= int_value\n        }\n    }\n    return result", "    var str : String\
    \ = \"\"\n    let romans = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var num = number\n    for i\
    \ in 0..<numbers.count {\n        while num >= numbers[i] {\n            str +=\
    \ romans[i]\n            num -= numbers[i]\n        }\n    }\n    return str",
  "    let mapper = [\n        (num: 1, letter: \"i\"),\n        (num: 5, letter:\
    \ \"v\"),\n        (num: 10, letter: \"x\"),\n        (num: 50, letter: \"l\"\
    ),\n        (num: 100, letter: \"c\"),\n        (num: 500, letter: \"d\"),\n \
    \       (num: 1000, letter: \"m\")\n    ]\n    var result = \"\"\n    var n =\
    \ number\n    for (i, map) in mapper.enumerate() {\n        if i == mapper.count\
    \ - 1 {\n            let digit = n / map.num\n            for _ in 0..<digit {\n\
    \                result += map.letter\n            }\n            break\n    \
    \    }\n        if n < map.num {\n            continue\n        }\n        if\
    \ n >= 4 * mapper[i + 1].num {\n            result += map.letter + mapper[i +\
    \ 2].letter\n            n -= 4 * mapper[i + 1].num\n        } else if n >= 3\
    \ * mapper[i + 1].num {\n            result += map.letter + mapper[i + 1].letter\n\
    \            n -= 3 * mapper[i + 1].num\n        } else if n >= 2 * mapper[i +\
    \ 1].num {\n            result += map.letter + map.letter\n            n -= 2\
    \ * mapper[i + 1].num\n        } else if n >= mapper[i + 1].num {\n          \
    \  result += map.letter + mapper[i + 1].letter\n            n -= mapper[i + 1].num\n\
    \        } else {\n            let digit = n / map.num\n            for _ in 0..<digit\
    \ {\n                result += map.letter\n            }\n            n -= digit\
    \ * map.num\n        }\n    }\n    return result", "    var result = \"\"\n  \
    \  var rest = number\n    while rest > 0 {\n        if rest >= 1000 {\n      \
    \      result += \"m\"\n            rest -= 1000\n        } else if rest >= 900\
    \ {\n            result += \"cm\"\n            rest -= 900\n        } else if\
    \ rest >= 500 {\n            result += \"d\"\n            rest -= 500\n      \
    \  } else if rest >= 400 {\n            result += \"cd\"\n            rest -=\
    \ 400\n        } else if rest >= 100 {\n            result += \"c\"\n        \
    \    rest -= 100\n        } else if rest >= 90 {\n            result += \"xc\"\
    \n            rest -= 90\n        } else if rest >= 50 {\n            result +=\
    \ \"l\"\n            rest -= 50\n        } else if rest >= 40 {\n            result\
    \ += \"xl\"\n            rest -= 40\n        } else if rest >= 10 {\n        \
    \    result += \"x\"\n            rest -= 10\n        } else if rest >= 9 {\n\
    \            result += \"ix\"\n            rest -= 9\n        } else if rest >=\
    \ 5 {\n            result += \"v\"\n            rest -= 5\n        } else if rest\
    \ >= 4 {\n            result += \"iv\"\n            rest -= 4\n        } else\
    \ if rest >= 1 {\n            result += \"i\"\n            rest -= 1\n       \
    \ }\n    }\n    return result", "    let mini_roman_digits = [\"i\", \"v\", \"\
    x\", \"l\", \"c\", \"d\", \"m\"]\n    return int_to_roman(number, digits: mini_roman_digits)",
  "    var result = \"\"\n    var n = number\n    let digits = [\n        (1, \"i\"\
    ),\n        (4, \"iv\"),\n        (5, \"v\"),\n        (9, \"ix\"),\n        (10,\
    \ \"x\"),\n        (40, \"xl\"),\n        (50, \"l\"),\n        (90, \"xc\"),\n\
    \        (100, \"c\"),\n        (400, \"cd\"),\n        (500, \"d\"),\n      \
    \  (900, \"cm\"),\n        (1000, \"m\")\n    ]\n    for i in stride(from: digits.count\
    \ - 1, through: 0, by: -1) {\n        while n >= digits[i].0 {\n            result\
    \ += digits[i].1\n            n -= digits[i].0\n        }\n    }\n    return result",
  "    // Create a mapping of arabic numerals to roman numerals in the same order\n\
    \    // as they appear in the number system.\n    let arabic_to_roman = [\n  \
    \      1: \"i\", 4: \"iv\", 5: \"v\", 9: \"ix\", 10: \"x\", 40: \"xl\", 50: \"\
    l\",\n        90: \"xc\", 100: \"c\", 400: \"cd\", 500: \"d\", 900: \"cm\", 1000:\
    \ \"m\"\n    ]\n    // Split the number into powers of 10 and use them to access\
    \ arabic_to_roman.\n    // Map those values to their corresponding roman numeral\
    \ and join them.\n    return String(\n        number.decompose_to_powers_of_ten()\n\
    \            .map { arabic_to_roman[$0]! }\n            .joined()\n    )", " \
    \   if number > 1000 || number < 1 {\n        return \"out of range\"\n    }\n\
    \    let roman_digits = [(\"M\", 1000), (\"CM\", 900), (\"D\", 500), (\"CD\",\
    \ 400), (\"C\", 100), (\"XC\", 90), (\"L\", 50), (\"XL\", 40), (\"X\", 10), (\"\
    IX\", 9), (\"V\", 5), (\"IV\", 4), (\"I\", 1)]\n    var result = \"\"\n    var\
    \ remainder = number\n    for roman_digit in roman_digits {\n        let digit\
    \ = roman_digit.1\n        let roman = roman_digit.0\n        let times = remainder\
    \ / digit\n        if times > 0 {\n            result += String(count: times,\
    \ repeatedValue: Character(roman))\n            remainder -= times * digit\n \
    \       }\n    }\n    return result", "    if number < 1 || number > 1000 {\n\
    \        // Do something in case of illegal input\n        return \"\"\n    }\n\
    \    return String(number).characters.map(int_to_mini_roman_char).reduce(\"\"\
    , combine: +)", "    if let (result, _) = int_to_mini_roman_helper(number, \"\"\
    ) {\n        return result\n    }\n    else {\n        fatalError(\"number: \\\
    (number) must be in 1..<1000\")\n    }", "    let dictionary = [1: \"i\", 4: \"\
    iv\", 5: \"v\", 9: \"ix\", 10: \"x\", 40: \"xl\", 50: \"l\", 90: \"xc\", 100:\
    \ \"c\", 400: \"cd\", 500: \"d\", 900: \"cm\", 1000: \"m\"]\n    return \"\"",
  "    let numerals: Dictionary<Int, String> = [\n        1000: \"m\",\n        900:\
    \ \"cm\",\n        500: \"d\",\n        400: \"cd\",\n        100: \"c\",\n  \
    \      90: \"xc\",\n        50: \"l\",\n        40: \"xl\",\n        10: \"x\"\
    ,\n        9: \"ix\",\n        5: \"v\",\n        4: \"iv\",\n        1: \"i\"\
    ,\n    ]\n    var result = \"\"\n    var currentNumber = number\n    for (number,\
    \ numeral) in numerals {\n        while currentNumber >= number {\n          \
    \  result += numeral\n            currentNumber -= number\n        }\n    }\n\
    \    return result", "    var roman = \"\"\n    let lookup = [\n        1: \"\
    i\", 4: \"iv\", 5: \"v\", 9: \"ix\",\n        10: \"x\", 40: \"xl\", 50: \"l\"\
    , 90: \"xc\",\n        100: \"c\", 400: \"cd\", 500: \"d\", 900: \"cm\",\n   \
    \     1000: \"m\"\n    ]\n    var remainder = number\n    for (divisor, roman_numeral)\
    \ in [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1].reverse() {\n    \
    \    while remainder >= divisor {\n            roman += lookup[divisor]!\n   \
    \         remainder -= divisor\n        }\n    }\n    return roman", "    // Implement\
    \ your solution here\n    return \"\";"]
stop_tokens:
- "\n}"
