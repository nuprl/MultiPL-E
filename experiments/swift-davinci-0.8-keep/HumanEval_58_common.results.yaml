language: swift
name: HumanEval_58_common
results:
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \  let set1 = Set(l1)\n  let set2 = Set(l2)\n  let common = set1.intersection(set2)\n\
    \  return Array(common).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    return l1.intersection(l2).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp582cf3do.swift:8:15: error: value of type '[Int]' has no member\
    \ 'intersection'\n    return l1.intersection(l2).sorted()\n           ~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824670
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    let l1 = l1.sort()\n    let l2 = l2.sort()\n    var result = [Int]()\n  \
    \  var i = 0\n    var j = 0\n    while i < l1.count && j < l2.count {\n      \
    \  if l1[i] < l2[j] {\n            i += 1\n        } else if l1[i] > l2[j] {\n\
    \            j += 1\n        } else {\n            result.append(l1[i])\n    \
    \        i += 1\n            j += 1\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpfc4s0cpn.swift:8:17: error: cannot use mutating member on immutable\
    \ value: 'l1' is a 'let' constant\n    let l1 = l1.sort()\n             ~~ ^\n\
    /tmp/tmpfc4s0cpn.swift:9:17: error: cannot use mutating member on immutable value:\
    \ 'l2' is a 'let' constant\n    let l2 = l2.sort()\n             ~~ ^\n"
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \t// write your code here\n\tvar unique_l1 = [Int]()\n\tvar unique_l2 = [Int]()\n\
    \tvar common_elements = [Int]()\n\t\n\t// Find unique elements in l1, l2\n\tfor\
    \ i in l1 {\n\t\tif !unique_l1.contains(i) {\n\t\t\tunique_l1.append(i)\n\t\t\
    }\n\t}\n\tfor i in l2 {\n\t\tif !unique_l2.contains(i) {\n\t\t\tunique_l2.append(i)\n\
    \t\t}\n\t}\n\t// Find common elements\n\tfor i in unique_l1 {\n\t\tif unique_l2.contains(i)\
    \ {\n\t\t\tcommon_elements.append(i)\n\t\t}\n\t}\n\t// Sort the common_elements\n\
    \tcommon_elements.sort()\n\treturn common_elements\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    return unique(l1.filter { l2.contains($0) })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpnv15aksd.swift:8:12: error: cannot find 'unique' in scope\n   \
    \ return unique(l1.filter { l2.contains($0) })\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return Array(set1.intersection(set2)).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824619
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    var result = [Int]()\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n    for\
    \ i in s1 {\n        if s2.contains(i) {\n            result.append(i)\n     \
    \   }\n    }\n    return result.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmpjeo9i9xt/tmpjeo9i9xt.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b893de30c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b893db27b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b893db27988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b893db267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjeo9i9xt                        0x000055fbd186e44c <unavailable> + 5196

    5    libc.so.6                          0x00002b893e01c460 __libc_start_main +
    245

    6    tmpjeo9i9xt                        0x000055fbd186dfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    let s1 = Set(l1), s2 = Set(l2)\n    let common = Array(s1.intersection(s2))\n\
    \    return common.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    return l1.filter({ x in l2.contains(x) }).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \  return l1.filter({ l2.contains($0) }).unique()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmptx_51jqr.swift:8:41: error: value of type '[Int]' has no member\
    \ 'unique'\n  return l1.filter({ l2.contains($0) }).unique()\n         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    return l1.filter{ l2.contains($0) }.sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    let c1 = l1.unique().sorted()\n    let c2 = l2.unique().sorted()\n    let\
    \ common = c1.filter { c2.contains($0) }\n    return common\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpd5foxgmx.swift:8:17: error: value of type '[Int]' has no member\
    \ 'unique'\n    let c1 = l1.unique().sorted()\n             ~~ ^~~~~~\n/tmp/tmpd5foxgmx.swift:9:17:\
    \ error: value of type '[Int]' has no member 'unique'\n    let c2 = l2.unique().sorted()\n\
    \             ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    return l1.filter { l2.contains($0) }.sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824619
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    // TODO: Implement common\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpnkmvydje/tmpnkmvydje.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b223a101c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2239df8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2239df8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2239df77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnkmvydje                        0x000056306ae2f44c <unavailable> + 5196

    5    libc.so.6                          0x00002b223a2ed460 __libc_start_main +
    245

    6    tmpnkmvydje                        0x000056306ae2efc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    var d = [Int: Bool]()\n    for n in l1 {\n        d[n] = true\n    }\n  \
    \  var result = [Int]()\n    for n in l2 {\n        if d[n] == true {\n      \
    \      result.append(n)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpudv9yqcu/tmpudv9yqcu.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92ad545c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92ad23cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92ad23c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92ad23b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpudv9yqcu                        0x000055cf839f97cc <unavailable> + 6092

    5    libc.so.6                          0x00002b92ad731460 __libc_start_main +
    245

    6    tmpudv9yqcu                        0x000055cf839f9349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    return Array(Set(l1).intersect(Set(l2)))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbgcuawek.swift:8:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2)))\n                \
    \ ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824619
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    return Array(Set(l1).intersect(Set(l2))).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpz0g5rclw.swift:8:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824619
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    return Set(l1).intersection(Set(l2)).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\
    \    let set1 = Set(l1)\n    let set2 = Set(l2)\n    let commonSet = set1.intersection(set2)\n\
    \    let commonArray = Array(commonSet)\n    return commonArray.sorted()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
