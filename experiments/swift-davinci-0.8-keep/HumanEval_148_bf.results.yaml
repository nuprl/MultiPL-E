language: swift
name: HumanEval_148_bf
results:
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n  let solarSystem: [String]\
    \ = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"]\n  var start = 0\n  var end = 0\n  for (index, planet)\
    \ in solarSystem.enumerated() {\n    if planet == planet1 {\n      start = index\n\
    \    }\n    if planet == planet2 {\n      end = index\n    }\n  }\n  var planets\
    \ = solarSystem\n  if start > end {\n    planets = Array(solarSystem.dropFirst(end))\n\
    \    planets = Array(planets.dropLast(planets.count - start))\n  } else {\n  \
    \  planets = Array(solarSystem.dropFirst(start))\n    planets = Array(planets.dropLast(planets.count\
    \ - end))\n  }\n  return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/BidirectionalCollection.swift:380: Fatal error: Can''t drop a negative
    number of elements from a collection

    Current stack trace:

    0    libswiftCore.so                    0x00002b915f013c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b915ed0a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b915ed0a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b915ed0a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b915ed09bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b915ed10a70 BidirectionalCollection.dropLast(_:)
    + 1269

    6    tmpxg_gd8m5                        0x000056077cfebc34 <unavailable> + 11316

    7    tmpxg_gd8m5                        0x000056077cfea8f1 <unavailable> + 6385

    8    libc.so.6                          0x00002b915f1ff460 __libc_start_main +
    245

    9    tmpxg_gd8m5                        0x000056077cfea5c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n  var res: [String] =\
    \ []\n  let planets = [\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n  \
    \  \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\"\
    \n  ]\n  var start: Int = 0\n  var end: Int = 0\n  for (index, planet) in planets.enumerated()\
    \ {\n    if planet == planet1 {\n      start = index\n    }\n    if planet ==\
    \ planet2 {\n      end = index\n    }\n  }\n  for i in (start + 1)..<end {\n \
    \   res.append(planets[i])\n  }\n  return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b892754cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8927243561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8927243286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b892724313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8927242bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpw8_xdno8                        0x000055a8fa7eb93b <unavailable> + 10555

    6    tmpw8_xdno8                        0x000055a8fa7eaa24 <unavailable> + 6692

    7    libc.so.6                          0x00002b8927738460 __libc_start_main +
    245

    8    tmpw8_xdno8                        0x000055a8fa7ea569 <unavailable> + 5481

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1_index = planets.firstIndex(of: planet1)\n    let\
    \ planet2_index = planets.firstIndex(of: planet2)\n    var result: [String] =\
    \ []\n    if planet1_index == nil || planet2_index == nil {\n        return result\n\
    \    }\n    if planet1_index! > planet2_index! {\n        for planet in planets[planet2_index!...planet1_index!]\
    \ {\n            result.append(planet)\n        }\n    } else {\n        for planet\
    \ in planets[planet1_index!...planet2_index!] {\n            result.append(planet)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmp2ung8_2u/tmp2ung8_2u.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b16c225fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16c1f56b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b16c1f56988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16c1f557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2ung8_2u                        0x0000561797d1e97b <unavailable> + 6523

    5    libc.so.6                          0x00002b16c244b460 __libc_start_main +
    245

    6    tmp2ung8_2u                        0x0000561797d1e529 <unavailable> + 5417

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var res = [String]()\n\
    \    let planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\", \"Neptune\"]\n    if let idx1 = planets.firstIndex(of:\
    \ planet1), let idx2 = planets.firstIndex(of: planet2) {\n        let p1 = min(idx1,\
    \ idx2)\n        let p2 = max(idx1, idx2)\n        for i in p1+1..<p2 {\n    \
    \        res.append(planets[i])\n        }\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b0129350c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0129047561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0129047286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b012904713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0129046bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpc7d8j8f3                        0x0000558e505118d0 <unavailable> + 10448

    6    tmpc7d8j8f3                        0x0000558e50510fcb <unavailable> + 8139

    7    libc.so.6                          0x00002b012953c460 __libc_start_main +
    245

    8    tmpc7d8j8f3                        0x0000558e505104f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var solarSystem =\
    \ [\n        \"Mercury\": 1,\n        \"Venus\": 2,\n        \"Earth\": 3,\n \
    \       \"Mars\": 4,\n        \"Jupiter\": 5,\n        \"Saturn\": 6,\n      \
    \  \"Uranus\": 7,\n        \"Neptune\": 8\n    ]\n    guard solarSystem[planet1]\
    \ != nil && solarSystem[planet2] != nil else { return [] }\n    var result: [String]\
    \ = []\n    let planet1Orbit = solarSystem[planet1]!\n    let planet2Orbit = solarSystem[planet2]!\n\
    \    var firstPlanet = planet1Orbit > planet2Orbit ? planet2Orbit : planet1Orbit\n\
    \    var secondPlanet = planet1Orbit > planet2Orbit ? planet1Orbit : planet2Orbit\n\
    \    for (planet, orbit) in solarSystem {\n        if orbit > firstPlanet && orbit\
    \ < secondPlanet {\n            result.append(planet)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmppfapa3dp/tmppfapa3dp.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5127f0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae5124e7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae5124e7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae5124e67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppfapa3dp                        0x00005593b3602c48 <unavailable> + 7240

    5    libc.so.6                          0x00002ae5129dc460 __libc_start_main +
    245

    6    tmppfapa3dp                        0x00005593b3602429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    var result = [String]()\n    var from: Int?\n    var to: Int?\n\
    \    for (i, n) in planets.enumerated() {\n        if n == planet1 {\n       \
    \     from = i\n        }\n        if n == planet2 {\n            to = i\n   \
    \     }\n    }\n    if let from = from, let to = to {\n        for i in from...to\
    \ {\n            result.append(planets[i])\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpu2gcdbt2/tmpu2gcdbt2.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5482f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af547fedb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af547fed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af547fec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu2gcdbt2                        0x000055bb2c05ba1b <unavailable> + 6683

    5    libc.so.6                          0x00002af5484e2460 __libc_start_main +
    245

    6    tmpu2gcdbt2                        0x000055bb2c05b5c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n  let planets = [\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n  let planet1Index = planets.firstIndex(of: planet1)\n  let planet2Index =\
    \ planets.firstIndex(of: planet2)\n  guard let p1 = planet1Index, let p2 = planet2Index\
    \ else { return [] }\n  return p1 < p2 ? Array(planets[p1...p2]) : Array(planets[p2...p1]).reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmplfn85gem/tmplfn85gem.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31e5c63c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31e595ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31e595a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31e59597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfn85gem                        0x000055a51cecb8bb <unavailable> + 6331

    5    libc.so.6                          0x00002b31e5e4f460 __libc_start_main +
    245

    6    tmplfn85gem                        0x000055a51cecb469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let f = planets.firstIndex(of: planet1),\n        let\
    \ s = planets.firstIndex(of: planet2) else { return [] }\n    let lowerBound =\
    \ min(f, s)\n    let upperBound = max(f, s)\n    return Array(planets[lowerBound\
    \ + 1...upperBound - 1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ab2efec0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab2efbb7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab2efbb7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab2efbb713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab2efbb6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzgy0vbj4                        0x0000562b313ec9b2 <unavailable> + 10674

    6    tmpzgy0vbj4                        0x0000562b313ebfcb <unavailable> + 8139

    7    libc.so.6                          0x00002ab2f00ac460 __libc_start_main +
    245

    8    tmpzgy0vbj4                        0x0000562b313eb4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let planet1Index = planets.firstIndex(of: planet1),\n\
    \        let planet2Index = planets.firstIndex(of: planet2) else {\n         \
    \   return []\n    }\n    if planet1Index > planet2Index {\n        return Array(planets[planet2Index...planet1Index])\n\
    \    } else {\n        return Array(planets[planet1Index...planet2Index])\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2:\
    \ \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\"\
    ) == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1:\
    \ \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpleauuool/tmpleauuool.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2294d14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2294a0bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2294a0b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2294a0a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpleauuool                        0x000055695f49a85b <unavailable> + 6235

    5    libc.so.6                          0x00002b2294f00460 __libc_start_main +
    245

    6    tmpleauuool                        0x000055695f49a409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var final:[String]\
    \ = []\n    let order = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n    if order.contains(planet1) && order.contains(planet2)\
    \ {\n        let index1 = order.firstIndex(of: planet1)!\n        let index2 =\
    \ order.firstIndex(of: planet2)!\n        var indexLow = 0\n        var indexHigh\
    \ = 0\n        if index1 < index2 {\n            indexLow = index1\n         \
    \   indexHigh = index2\n        } else {\n            indexLow = index2\n    \
    \        indexHigh = index1\n        }\n        for i in indexLow+1...indexHigh-1\
    \ {\n            final.append(order[i])\n        }\n    }\n    return final\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ac807400c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac8070f7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac8070f7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac8070f713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac8070f6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp_4pped0t                        0x0000555962d429b2 <unavailable> + 10674

    6    tmp_4pped0t                        0x0000555962d41eeb <unavailable> + 7915

    7    libc.so.6                          0x00002ac8075ec460 __libc_start_main +
    245

    8    tmp_4pped0t                        0x0000555962d41419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var distances = [String:Int]()\n\
    \    distances[\"Mercury\"] = 1\n    distances[\"Venus\"] = 2\n    distances[\"\
    Earth\"] = 3\n    distances[\"Mars\"] = 4\n    distances[\"Jupiter\"] = 5\n  \
    \  distances[\"Saturn\"] = 6\n    distances[\"Uranus\"] = 7\n    distances[\"\
    Neptune\"] = 8\n    \n    var r = [String]()\n    if let d1 = distances[planet1],\
    \ d2 = distances[planet2] {\n        let sorted = [d1, d2].sort { $0 < $1 }\n\
    \        let p1 = sorted[0]\n        let p2 = sorted[1]\n        for (name, index)\
    \ in distances {\n            if index > p1 && index < p2 {\n                r.append(name)\n\
    \            }\n        }\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpr2_yr2vz.swift:27:37: error: expected 'let' in conditional\n  \
    \  if let d1 = distances[planet1], d2 = distances[planet2] {\n               \
    \                     ^\n                                    let \n/tmp/tmpr2_yr2vz.swift:28:31:\
    \ error: cannot use mutating member on immutable value of type '[Int]'\n     \
    \   let sorted = [d1, d2].sort { $0 < $1 }\n                     ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets: [String]\
    \ = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"]\n    guard let firstIndex = planets.firstIndex(of: planet1),\
    \ let secondIndex = planets.firstIndex(of: planet2) else {\n        return []\n\
    \    }\n    let minIndex = min(firstIndex, secondIndex)\n    let maxIndex = max(firstIndex,\
    \ secondIndex)\n    return Array(planets[minIndex...maxIndex])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpefutcmhm/tmpefutcmhm.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f6e4d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f6e1cab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f6e1ca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f6e1c97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpefutcmhm                        0x0000558b2a85894b <unavailable> + 6475

    5    libc.so.6                          0x00002b2f6e6bf460 __libc_start_main +
    245

    6    tmpefutcmhm                        0x0000558b2a8584f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let first = planets.firstIndex(of: planet1) ?? -1\n    let\
    \ second = planets.firstIndex(of: planet2) ?? -1\n    if (first < 0 || second\
    \ < 0) {\n        return []\n    }\n    return first < second ? Array(planets[first+1..<second])\
    \ : Array(planets[second+1..<first])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a974fbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a971f2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4a971f2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4a971f213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4a971f1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp29h1gtkz                        0x000055c42638d846 <unavailable> + 10310

    6    tmp29h1gtkz                        0x000055c42638ce4b <unavailable> + 7755

    7    libc.so.6                          0x00002b4a976e7460 __libc_start_main +
    245

    8    tmp29h1gtkz                        0x000055c42638c379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    if ![\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"].contains(planet1) {\n        return result\n    }\n\
    \    if ![\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"].contains(planet2) {\n        return result\n    }\n\
    \    let planetMap = [\"Mercury\": 0, \"Venus\": 1, \"Earth\": 2, \"Mars\": 3,\
    \ \"Jupiter\": 4, \"Saturn\": 5, \"Uranus\": 6, \"Neptune\": 7]\n    let planet1Index\
    \ = planetMap[planet1]!\n    let planet2Index = planetMap[planet2]!\n    if planet1Index\
    \ < planet2Index {\n        for i in planet1Index..<planet2Index {\n         \
    \   result.append([\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"][i])\n        }\n    } else {\n        for i\
    \ in planet2Index..<planet1Index {\n            result.append([\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ][i])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp4evrjdar/tmp4evrjdar.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adf92a98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf9278fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adf9278f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adf9278e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4evrjdar                        0x000056482274990b <unavailable> + 6411

    5    libc.so.6                          0x00002adf92c84460 __libc_start_main +
    245

    6    tmp4evrjdar                        0x00005648227494b9 <unavailable> + 5305

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planet = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let range = planet.firstIndex(of: planet1)!...planet.firstIndex(of:\
    \ planet2)!\n    var result = [String]()\n    for i in range {\n        result.append(planet[i])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp_pk67bm2/tmp_pk67bm2.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b910d836c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b910d52db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b910d52d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b910d52c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_pk67bm2                        0x000055c98cabd85b <unavailable> + 6235

    5    libc.so.6                          0x00002b910da22460 __libc_start_main +
    245

    6    tmp_pk67bm2                        0x000055c98cabd409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n  var firstPlanetPosition:\
    \ Int!\n  var secondPlanetPosition: Int!\n  var result: [String] = []\n  let planetArray\
    \ = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"]\n  for (index, planet) in planetArray.enumerated() {\n\
    \    if planet == planet1 {\n      firstPlanetPosition = index\n    }\n    if\
    \ planet == planet2 {\n      secondPlanetPosition = index\n    }\n  }\n  if firstPlanetPosition\
    \ > secondPlanetPosition {\n    let temp = firstPlanetPosition\n    firstPlanetPosition\
    \ = secondPlanetPosition\n    secondPlanetPosition = temp\n  }\n  if firstPlanetPosition\
    \ == nil || secondPlanetPosition == nil {\n    return result\n  }\n  for i in\
    \ firstPlanetPosition...secondPlanetPosition {\n    result.append(planetArray[i])\n\
    \  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp0aoe8mqh/tmp0aoe8mqh.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b24e2c86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24e297db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b24e297d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b24e297c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0aoe8mqh                        0x000055922f91c9bb <unavailable> + 6587

    5    libc.so.6                          0x00002b24e2e72460 __libc_start_main +
    245

    6    tmp0aoe8mqh                        0x000055922f91c569 <unavailable> + 5481

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var bf = [String]()\n\
    \    var planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planets.contains(planet1) && planets.contains(planet2)\
    \ {\n        var ind1 = planets.firstIndex(of: planet1)!\n        var ind2 = planets.firstIndex(of:\
    \ planet2)!\n        if ind1 < ind2 {\n            for i in ind1 + 1..<ind2 {\n\
    \                bf.append(planets[i])\n            }\n        } else {\n    \
    \        for i in ind2 + 1..<ind1 {\n                bf.append(planets[i])\n \
    \           }\n        }\n    }\n    return bf\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b3643c5cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3643953561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3643953286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b364395313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3643952bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp4np5jzls                        0x000055f06f8cebe4 <unavailable> + 11236

    6    tmp4np5jzls                        0x000055f06f8cdf3b <unavailable> + 7995

    7    libc.so.6                          0x00002b3643e48460 __libc_start_main +
    245

    8    tmp4np5jzls                        0x000055f06f8cd469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let planetOneIndex = planets.firstIndex(of: planet1),\
    \ let planetTwoIndex = planets.firstIndex(of: planet2) else {\n        return\
    \ []\n    }\n    let startIndex = min(planetOneIndex, planetTwoIndex)\n    let\
    \ endIndex = max(planetOneIndex, planetTwoIndex)\n    return Array(planets[startIndex...endIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp1col6e_e/tmp1col6e_e.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b72fc8b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b72fc5a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b72fc5a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b72fc5a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1col6e_e                        0x000055609739894b <unavailable> + 6475

    5    libc.so.6                          0x00002b72fca9d460 __libc_start_main +
    245

    6    tmp1col6e_e                        0x00005560973984f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let i1 = planets.firstIndex(of: planet1), let i2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    let x = planets[i1 + 1 ..< i2]\n    return\
    \ Array(x)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ac836b2ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac836821561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac836821286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac83682113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac836820bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpcrmdokb0                        0x0000556e8067071b <unavailable> + 10011

    6    tmpcrmdokb0                        0x0000556e8066f834 <unavailable> + 6196

    7    libc.so.6                          0x00002ac836d16460 __libc_start_main +
    245

    8    tmpcrmdokb0                        0x0000556e8066f379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823228
- exit_code: 0
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let index1 = planets.firstIndex(of: planet1), let index2\
    \ = planets.firstIndex(of: planet2) else { return [] }\n    if index1 == index2\
    \ { return [] }\n    return Array(planets[min(index1, index2)+1..<max(index1,\
    \ index2)])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823228
