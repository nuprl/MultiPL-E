name: HumanEval_87_get_row
language: swift
prompt: "\n/// You are given a 2 dimensional data, as a nested lists,\n/// which is\
  \ similar to matrix, however, unlike matrices,\n/// each row may contain a different\
  \ number of columns.\n/// Given lst, and integer x, find integers x in the list,\n\
  /// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n/// each tuple\
  \ is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates initially\
  \ by rows in ascending order.\n/// Also, sort coordinates of the row by columns\
  \ in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n/// [1,2,3,4,1,6],\n\
  /// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// get_row([],\
  \ 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc get_row(lst:\
  \ [[Int]], x: Int) -> [(Int, Int)] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
  \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
  \ 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
  \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0,\
  \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
  \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1,\
  \ 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2,\
  \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
  assert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
  \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1,\
  \ 2, 3]], x: 3) == [(2, 2)])"
completions: ["    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated()\
    \ {\n        for (j, e) in row.enumerated() {\n            if e == x {\n     \
    \           result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: {$0.0 < $1.0})", "    var result: [(Int, Int)] = []\n    for\
    \ (indexRow, row) in lst.enumerated() {\n        for (indexColumn, item) in row.enumerated()\
    \ {\n            if item == x {\n                result.append((indexRow, indexColumn))\n\
    \            }\n        }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by:\
    \ { $0.1 > $1.1 })", "    let x = x\n    let z = zip(lst, 0...lst.count - 1)\n\
    \    let y = z.map { (r, i) -> [(Int, Int)] in\n        return r.enumerated().filter\
    \ { $0.element == x }.map { (j, _) in (i, j) }\n    }\n    let a = y.flatMap {\
    \ $0 }\n    return a.sorted { (e1, e2) -> Bool in\n        return e1.0 < e2.0\
    \ || (e1.0 == e2.0 && e1.1 > e2.1)\n    }", "    var r = [(Int, Int)]()\n    var\
    \ i = 0\n    for row in lst {\n        if let j = row.index(of: x) {\n       \
    \     r.append((i, j))\n        }\n        i += 1\n    }\n    return r.sorted{$0.0\
    \ < $1.0}.sorted{$0.1 > $1.1}", "    let coordinates = lst.enumerated().flatMap\
    \ { (y, row) -> [(Int, Int)] in\n        row.enumerated().filter { $0.element\
    \ == x }.map { (y, $0.offset) }\n    }\n    return coordinates.sorted { $0.0 !=\
    \ $1.0 ? $0.0 < $1.0 : $0.1 > $1.1 }", "    var res: [(Int, Int)] = []\n    for\
    \ (r, row) in lst.enumerated() {\n        for (c, col) in row.enumerated() {\n\
    \            if col == x {\n                res.append((r, c))\n            }\n\
    \        }\n    }\n    let ordered_res = res.sorted { (t1, t2) -> Bool in\n  \
    \      if t1.0 == t2.0 {\n            return t1.1 > t2.1\n        }\n        return\
    \ t1.0 < t2.0\n    }\n    return ordered_res", "    var result: [(Int, Int)] =\
    \ []\n    for (row, value) in lst.enumerated() {\n        if let index = value.firstIndex(of:\
    \ x) {\n            result.append((row, index))\n        }\n    }\n    return\
    \ result.sorted(by: { (lhs, rhs) -> Bool in\n        if lhs.0 == rhs.0 {\n   \
    \         return lhs.1 > rhs.1\n        }\n        return lhs.0 < rhs.0\n    })",
  "    var result: [(Int, Int)] = []\n    for (y, xs) in lst.enumerated() {\n    \
    \    for (x2, x) in xs.enumerated() {\n            if x == x {\n             \
    \   result.append((y, x2))\n            }\n        }\n    }\n    return result.sorted(by:\
    \ { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })", "    var ret: [(Int, Int)] =\
    \ []\n    for (y, row) in lst.enumerated() {\n        for (x, col) in row.enumerated()\
    \ {\n            if col == x {\n                ret.append((y, x))\n         \
    \   }\n        }\n    }\n    ret.sort(by: { $0.0 < $1.0 || ($0.0 == $1.0 && $0.1\
    \ > $1.1) })\n    return ret", "\tvar result: [(Int, Int)] = []\n\tvar rows =\
    \ 0\n\tvar columns = 0\n\tfor row in lst {\n\t\tfor column in row {\n\t\t\tif\
    \ column == x {\n\t\t\t\tresult.append((rows, columns))\n\t\t\t}\n\t\t\tcolumns\
    \ += 1\n\t\t}\n\t\trows += 1\n\t\tcolumns = 0\n\t}\n\tresult.sort(by: { (a, b)\
    \ -> Bool in\n\t\tif a.0 == b.0 {\n\t\t\treturn a.1 > b.1\n\t\t}\n\t\treturn a.0\
    \ < b.0\n\t})\n\treturn result", "    var result: [(Int, Int)] = []\n    for (row,\
    \ arr) in lst.enumerated() {\n        for (col, val) in arr.enumerated() {\n \
    \           if val == x {\n                result.append((row, col))\n       \
    \     }\n        }\n    }\n    return result.sorted(by: { (a, b) -> Bool in\n\
    \        return a.0 < b.0\n    }).sorted(by: { (a, b) -> Bool in\n        return\
    \ a.1 > b.1\n    })", "    var result: [(Int, Int)] = []\n    for i in 0..<lst.count\
    \ {\n        for j in 0..<lst[i].count {\n            if lst[i][j] == x {\n  \
    \              result.append((i, j))\n            }\n        }\n    }\n    let\
    \ sorted = result.sorted { $0.0 < $1.0 }\n    return sorted.sorted { $0.1 > $1.1\
    \ }", "    var result = [(Int, Int)]()\n    for (row, list) in lst.enumerated()\
    \ {\n        for (column, element) in list.enumerated() {\n            if element\
    \ == x {\n                result.append((row, column))\n            }\n      \
    \  }\n    }\n    return result.sorted(by: { (left, right) -> Bool in\n       \
    \ left.0 < right.0\n    }).sorted(by: { (left, right) -> Bool in\n        left.1\
    \ > right.1\n    })", '    return []', "    var result = [(Int, Int)]()\n    for\
    \ (row, col) in lst.enumerated() {\n        for (col, num) in col.enumerated()\
    \ {\n            if num == x {\n                result.append((row, col))\n  \
    \          }\n        }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by:\
    \ { $0.1 > $1.1 })", "    var res: [(Int, Int)] = []\n    for (y, row) in lst.enumerated()\
    \ {\n        for (z, item) in row.enumerated() {\n            if item == x {\n\
    \                res.append((y, z))\n            }\n        }\n    }\n    return\
    \ res.sorted(by: { $0.0 < $1.0 || ($0.0 == $1.0 && $0.1 > $1.1) })", "\tvar res\
    \ = [(Int, Int)]()\n\tif lst.count == 0 {\n\t\treturn res\n\t}\n\tfor (i, row)\
    \ in lst.enumerated() {\n\t\tvar inds = [Int]()\n\t\tfor (j, value) in row.enumerated()\
    \ {\n\t\t\tif value == x {\n\t\t\t\tinds.append(j)\n\t\t\t}\n\t\t}\n\t\tfor ind\
    \ in inds.sorted(by: >) {\n\t\t\tres.append((i, ind))\n\t\t}\n\t}\n\treturn res",
  "    var result = [(Int, Int)]()\n    for (index, sublst) in lst.enumerated() {\n\
    \        for (subindex, element) in sublst.enumerated() {\n            if element\
    \ == x {\n                result.append((index, subindex))\n            }\n  \
    \      }\n    }\n    return result.sorted{ $0.0 == $1.0 ? $0.1 > $1.1 : $0.0 <\
    \ $1.0 }", "    let count = lst.reduce(0) { (sum, row) -> Int in\n        return\
    \ sum + row.filter { $0 == x }.count\n    }\n    var tuple = [(Int, Int)]()\n\
    \    tuple.reserveCapacity(count)\n    for (y, row) in lst.enumerated() {\n  \
    \      for (x, n) in row.enumerated() {\n            if n == x {\n           \
    \     tuple.append((y, x))\n            }\n        }\n    }\n    return tuple.sorted\
    \ { $0.0 < $1.0 }.sorted { $0.1 > $1.1 }", "    var result: [(Int, Int)] = []\n\
    \    for i in 0..<lst.count {\n        for j in 0..<lst[i].count {\n         \
    \   if lst[i][j] == x {\n                result.append((i, j))\n            }\n\
    \        }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: {\
    \ $0.1 > $1.1 })"]
stop_tokens:
- "\n}"
