name: HumanEval_160_do_algebra
language: swift
prompt: "\n/// Given two lists operator, and operand. The first list has basic algebra\
  \ operations, and \n/// the second list is a list of integers. Use the two given\
  \ lists to build the algebric \n/// expression and return the evaluation of this\
  \ expression.\n/// The basic algebra operations:\n/// Addition ( + ) \n/// Subtraction\
  \ ( - ) \n/// Multiplication ( * ) \n/// Floor division ( // ) \n/// Exponentiation\
  \ ( ** ) \n/// Example:\n/// operator['+', '*', '-']\n/// array = [2, 3, 4, 5]\n\
  /// result = 2 + 3 * 4 - 5\n/// => result = 9\n/// Note:\n/// The length of operator\
  \ list is equal to the length of operand list minus one.\n/// Operand is a list\
  \ of of non-negative integers.\n/// Operator list has at least one operator, and\
  \ operand list has at least two operands.\nfunc do_algebra(operator: [String], operand:\
  \ [Int]) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(do_algebra(operator: [\"**\", \"*\", \"\
  +\"], operand: [2, 3, 4, 5]) == 37)\nassert(do_algebra(operator: [\"+\", \"*\",\
  \ \"-\"], operand: [2, 3, 4, 5]) == 9)\nassert(do_algebra(operator: [\"//\", \"\
  *\"], operand: [7, 3, 4]) == 8)"
completions: ["  var operand = operand\n  for ops in operator {\n    if ops == \"\
    //\" {\n      let num1 = operand.removeFirst()\n      let num2 = operand.removeFirst()\n\
    \      operand.insert(num1 / num2, at: 0)\n    } else if ops == \"**\" {\n   \
    \   let num1 = operand.removeFirst()\n      let num2 = operand.removeFirst()\n\
    \      operand.insert(Int(pow(Double(num1), Double(num2))), at: 0)\n    } else\
    \ {\n      let num1 = operand.removeFirst()\n      let num2 = operand.removeFirst()\n\
    \      switch ops {\n      case \"+\":\n        operand.insert(num1 + num2, at:\
    \ 0)\n      case \"-\":\n        operand.insert(num1 - num2, at: 0)\n      case\
    \ \"*\":\n        operand.insert(num1 * num2, at: 0)\n      default:\n       \
    \ break\n      }\n    }\n  }\n  return operand[0]", "\tvar operand = operand\n\
    \t\n\tvar operators = operator\n\twhile operators.count > 0 {\n\t\t// Find index\
    \ of first + or -\n\t\tvar addSubtractIndex = operators.index(where: { $0 == \"\
    +\" || $0 == \"-\" })\n\t\tif addSubtractIndex == nil {\n\t\t\taddSubtractIndex\
    \ = operators.count\n\t\t}\n\t\t\n\t\t// Apply all * and / operators\n\t\tfor\
    \ i in 0..<addSubtractIndex! {\n\t\t\tlet op = operators[i]\n\t\t\tswitch op {\n\
    \t\t\tcase \"*\":\n\t\t\t\toperand[i] *= operand[i + 1]\n\t\t\tcase \"/\":\n\t\
    \t\t\toperand[i] /= operand[i + 1]\n\t\t\tcase \"**\":\n\t\t\t\toperand[i] = Int(pow(Double(operand[i]),\
    \ Double(operand[i + 1])))\n\t\t\tdefault:\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t\n\t\
    \t\toperand.remove(at: i + 1)\n\t\t\toperators.remove(at: i)\n\t\t}\n\t\t\n\t\t\
    for i in 0..<operators.count {\n\t\t\tlet op = operators[i]\n\t\t\tswitch op {\n\
    \t\t\tcase \"+\":\n\t\t\t\toperand[i] += operand[i + 1]\n\t\t\tcase \"-\":\n\t\
    \t\t\toperand[i] -= operand[i + 1]\n\t\t\tdefault:\n\t\t\t\tbreak\n\t\t\t}\n\t\
    \t\t\n\t\t\toperand.remove(at: i + 1)\n\t\t\toperators.remove(at: i)\n\t\t}\n\t\
    }\n\t\n\treturn operand[0]", "    var res = operand[0]\n    for i in 0..<operator.count\
    \ {\n        let op = operator[i]\n        let num = operand[i+1]\n        switch\
    \ op {\n        case \"+\":\n            res += num\n        case \"-\":\n   \
    \         res -= num\n        case \"*\":\n            res *= num\n        case\
    \ \"//\":\n            res /= num\n        case \"**\":\n            res = Int(pow(Double(res),\
    \ Double(num)))\n        default:\n            break\n        }\n    }\n    return\
    \ res", "  let op1 = operand[0]\n  let op2 = operand[1]\n  switch operator[0]\
    \ {\n  case \"+\":\n    return op1 + op2\n  case \"-\":\n    return op1 - op2\n\
    \  case \"*\":\n    return op1 * op2\n  case \"//\":\n    return op1 / op2\n \
    \ case \"**\":\n    return op1 ^ op2\n  default:\n    return 0\n  }", "    var\
    \ total: Int = operand[0]\n    for i in 0..<operator.count {\n        let op =\
    \ operator[i]\n        let num = operand[i+1]\n        switch op {\n        case\
    \ \"+\":\n            total += num\n        case \"-\":\n            total -=\
    \ num\n        case \"*\":\n            total *= num\n        case \"//\":\n \
    \           total /= num\n        case \"**\":\n            total = Int(pow(Double(total),\
    \ Double(num)))\n        default:\n            return -1\n        }\n    }\n \
    \   return total", "\tvar result = operand[0]\n\tfor i in 0..<operator.count {\n\
    \t\tswitch operator[i] {\n\t\tcase \"+\":\n\t\t\tresult += operand[i + 1]\n\t\t\
    case \"-\":\n\t\t\tresult -= operand[i + 1]\n\t\tcase \"*\":\n\t\t\tresult *=\
    \ operand[i + 1]\n\t\tcase \"//\":\n\t\t\tresult /= operand[i + 1]\n\t\tcase \"\
    **\":\n\t\t\tresult = Int(pow(Double(result), Double(operand[i + 1])))\n\t\tdefault:\n\
    \t\t\tresult = 0\n\t\t}\n\t}\n\treturn result", "    var result = operand[0]\n\
    \    for index in 0..<operator.count {\n        switch operator[index] {\n   \
    \     case \"+\":\n            result += operand[index + 1]\n        case \"-\"\
    :\n            result -= operand[index + 1]\n        case \"*\":\n           \
    \ result *= operand[index + 1]\n        case \"//\":\n            result /= operand[index\
    \ + 1]\n        case \"**\":\n            result = Int(pow(Double(result), Double(operand[index\
    \ + 1])))\n        default:\n            print(\"Invalid operator\")\n       \
    \ }\n    }\n    return result", '    return 1', "    if operator.count == 0 ||\
    \ operand.count == 0 {\n        return 0\n    }\n    if operator.count != operand.count\
    \ - 1 {\n        return 0\n    }\n    var c = (operand: operand, operator: operator)\n\
    \    var newOperand = [Int]()\n    var newOperator = [String]()\n    for i in\
    \ 0..<c.operator.count {\n        if c.operator[i] == \"*\" || c.operator[i] ==\
    \ \"/\" {\n            if c.operator[i] == \"*\" {\n                newOperand.append(c.operand[i]\
    \ * c.operand[i + 1])\n            } else {\n                newOperand.append(c.operand[i]\
    \ / c.operand[i + 1])\n            }\n            if i != c.operator.count - 1\
    \ {\n                newOperator.append(c.operator[i + 1])\n            }\n  \
    \      } else {\n            newOperand.append(c.operand[i])\n            newOperator.append(c.operator[i])\n\
    \        }\n    }\n    c = (operand: newOperand, operator: newOperator)\n    var\
    \ result = c.operand[0]\n    for i in 0..<c.operator.count {\n        if c.operator[i]\
    \ == \"+\" {\n            result += c.operand[i + 1]\n        } else {\n     \
    \       result -= c.operand[i + 1]\n        }\n    }\n    return result", '    return
    0', "    var operand = operand\n    guard operand.count > 1 else { return 0 }\n\
    \    while operator.count > 0 {\n        if operand.count < 2 { return 0 }\n \
    \       let op = operator.removeFirst()\n        switch op {\n        case \"\
    +\":\n            operand[0] += operand.removeLast()\n        case \"-\":\n  \
    \          operand[0] -= operand.removeLast()\n        case \"*\":\n         \
    \   operand[0] *= operand.removeLast()\n        case \"//\":\n            operand[0]\
    \ /= operand.removeLast()\n        case \"**\":\n            operand[0] = Int(pow(Double(operand[0]),\
    \ Double(operand.removeLast())))\n        default:\n            return 0\n   \
    \     }\n    }\n    return operand[0]", "  var result = operand[0]\n  for i in\
    \ 0..<operator.count {\n    switch operator[i] {\n    case \"+\":\n      result\
    \ += operand[i + 1]\n    case \"-\":\n      result -= operand[i + 1]\n    case\
    \ \"*\":\n      result *= operand[i + 1]\n    case \"//\":\n      result /= operand[i\
    \ + 1]\n    case \"**\":\n      result = Int(pow(Double(result), Double(operand[i\
    \ + 1])))\n    default:\n      break\n    }\n  }\n  return result", "    var operand\
    \ = operand\n    var expression = \"\"\n    for (index, op) in operator.enumerated()\
    \ {\n        expression += \"\\(operand[index]) \\(op) \\(operand[index + 1])\"\
    \n    }\n    return eval(expression: expression)", "    var result = operand[0]\n\
    \    for i in 0..<operator.count {\n        if operator[i] == \"+\" {\n      \
    \      result += operand[i+1]\n        } else if operator[i] == \"-\" {\n    \
    \        result -= operand[i+1]\n        } else if operator[i] == \"*\" {\n  \
    \          result *= operand[i+1]\n        } else if operator[i] == \"//\" {\n\
    \            result /= operand[i+1]\n        } else if operator[i] == \"**\" {\n\
    \            result = Int(pow(Double(result), Double(operand[i+1])))\n       \
    \ }\n    }\n    return result", "    var answer = operand[0]\n    for x in 0...operator.count\
    \ - 1 {\n        switch operator[x] {\n        case \"+\":\n            answer\
    \ += operand[x + 1]\n        case \"-\":\n            answer -= operand[x + 1]\n\
    \        case \"*\":\n            answer *= operand[x + 1]\n        case \"//\"\
    :\n            answer /= operand[x + 1]\n        case \"**\":\n            answer\
    \ = Int(pow(Double(answer), Double(operand[x + 1])))\n        default:\n     \
    \       break\n        }\n    }\n    return answer", "\t// Define an operation\
    \ to do an operation\n\tfunc doOperation(firstNum: Int, secondNum: Int, operator:\
    \ String) -> Int {\n\t\tswitch operator {\n\t\tcase \"+\":\n\t\t\treturn firstNum\
    \ + secondNum\n\t\tcase \"-\":\n\t\t\treturn firstNum - secondNum\n\t\tcase \"\
    *\":\n\t\t\treturn firstNum * secondNum\n\t\tcase \"//\":\n\t\t\treturn firstNum\
    \ / secondNum\n\t\tcase \"**\":\n\t\t\treturn Int(pow(Double(firstNum), Double(secondNum)))\n\
    \t\tdefault:\n\t\t\treturn 0\n\t\t}\n\t}\n\t\n\t// Define the next operation\n\
    \tfunc nextOperation(operand: [Int], operator: [String]) -> Int {\n\t\tif operator.count\
    \ == 0 {\n\t\t\treturn operand[0]\n\t\t}\n\t\tif operator[0] == \"*\" || operator[0]\
    \ == \"//\" {\n\t\t\treturn doOperation(firstNum: operand[0], secondNum: operand[1],\
    \ operator: operator[0])\n\t\t}\n\t\treturn doOperation(firstNum: operand[0],\
    \ secondNum: nextOperation(operand: [operand[1]], operator: Array(operator[1...])),\
    \ operator: operator[0])\n\t}\n\t\n\t// Give the result\n\treturn nextOperation(operand:\
    \ operand, operator: operator)", "    var result = operand[0]\n    var i = 0\n\
    \    while i < operator.count {\n        switch operator[i] {\n        case \"\
    +\":\n            result += operand[i + 1]\n        case \"-\":\n            result\
    \ -= operand[i + 1]\n        case \"*\":\n            result *= operand[i + 1]\n\
    \        case \"//\":\n            result /= operand[i + 1]\n        case \"**\"\
    :\n            result = Int(pow(Double(result), Double(operand[i + 1])))\n   \
    \     default:\n            return -1\n        }\n        i += 1\n    }\n    return\
    \ result", "    var result = operand[0]\n    for (index, value) in operand.enumerated()\
    \ {\n        if index == 0 {\n            continue\n        }\n        switch\
    \ operator[index - 1] {\n        case \"+\":\n            result += value\n  \
    \      case \"-\":\n            result -= value\n        case \"*\":\n       \
    \     result *= value\n        case \"//\":\n            result /= value\n   \
    \     case \"**\":\n            result = Int(pow(Double(result), Double(value)))\n\
    \        default:\n            break\n        }\n    }\n    return result", " \
    \   let op = operator.reduce([], {\n        if $0.count == 0 {\n            return\
    \ [$1]\n        } else {\n            var pre = $0\n            pre.append($1)\n\
    \            return pre\n        }\n    })\n    let opr = operand.reduce([], {\n\
    \        if $0.count == 0 {\n            return [$1]\n        } else {\n     \
    \       var pre = $0\n            pre.append($1)\n            return pre\n   \
    \     }\n    })\n    func _do_algebra(op: [String], opr: [Int]) -> Int {\n   \
    \     if op.count == 0 {\n            return opr[0]\n        } else {\n      \
    \      if op[0] == \"+\" {\n                return opr[0] + _do_algebra(op: op.dropFirst(),\
    \ opr: opr.dropFirst())\n            } else if op[0] == \"-\" {\n            \
    \    return opr[0] - _do_algebra(op: op.dropFirst(), opr: opr.dropFirst())\n \
    \           } else if op[0] == \"*\" {\n                return opr[0] * _do_algebra(op:\
    \ op.dropFirst(), opr: opr.dropFirst())\n            } else if op[0] == \"//\"\
    \ {\n                return opr[0] / _do_algebra(op: op.dropFirst(), opr: opr.dropFirst())\n\
    \            } else if op[0] == \"**\" {\n                return Int(pow(Double(opr[0]),\
    \ Double(_do_algebra(op: op.dropFirst(), opr: opr.dropFirst()))))\n          \
    \  } else {\n                return 0\n            }\n        }\n    }\n    return\
    \ _do_algebra(op: op, opr: opr)", "    if operator.count == 0 || operand.count\
    \ == 0 {\n        return 0\n    }\n    var result = operand[0]\n    for i in 0..<operator.count\
    \ {\n        if i == 0 {\n            result = Operation.init(rawValue: operator[i])!.operate(operand[i],\
    \ operand[i+1])\n        } else {\n            result = Operation.init(rawValue:\
    \ operator[i])!.operate(result, operand[i+1])\n        }\n    }\n    return result"]
stop_tokens:
- "\n}"
