name: HumanEval_68_pluck
language: swift
prompt: "\n/// \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
  \ The plucked node should be the node with the smallest even value.\n/// If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n/// The plucked node should be returned in a list, [ smalest_value, its\
  \ index ],\n/// If there are no even values or the given array is empty, return\
  \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
  /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
  \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
  \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
  \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
  \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
  \ <= 10000\n/// * 0 <= node.value\nfunc pluck(arr: [Int]) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
  \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
  \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
  assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) ==\
  \ [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
completions: ['    return []', "\tguard arr.count > 0 else { return [] }\n\tlet minIndex\
    \ = arr.enumerated().min { a, b in\n\t\ta.element % 2 == 0 && b.element % 2 ==\
    \ 0 ? a.element < b.element : a.element % 2 == 0\n\t}\n\treturn minIndex?.element\
    \ % 2 == 0 ? [minIndex!.element, minIndex!.offset] : []", "    var result = arr.filter\
    \ { $0 % 2 == 0 }\n    if result.isEmpty {\n        return []\n    }\n    result.sort()\n\
    \    let val = result[0]\n    return [val, arr.firstIndex(of: val)!]", "    var\
    \ result = [Int]()\n    var index = 0\n    var minVal = Int.max\n    for item\
    \ in arr {\n        if item < minVal && item > 0 && item % 2 == 0 {\n        \
    \    minVal = item\n            result = [minVal, index]\n        }\n        index\
    \ += 1\n    }\n    return result", "    var result = [Int]()\n    var minEven\
    \ = Int.max\n    var index = 0\n    var i = 0\n    for num in arr {\n        if\
    \ num % 2 == 0 {\n            if num < minEven {\n                minEven = num\n\
    \                index = i\n            }\n        }\n        i += 1\n    }\n\
    \    if minEven != Int.max {\n        result.append(minEven)\n        result.append(index)\n\
    \    }\n    return result", "    guard !arr.isEmpty else { return [] }\n    let\
    \ evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return []\
    \ }\n    let value = evens.min()!\n    let index = arr.firstIndex(of: value)!\n\
    \    return [value, index]", "    var result = [Int]()\n    var min = Int.max\n\
    \    var index = -1\n    for i in 0..<arr.count {\n        if arr[i] > 0 && arr[i]\
    \ % 2 == 0 && arr[i] < min {\n            min = arr[i]\n            index = i\n\
    \        }\n    }\n    if index >= 0 {\n        result.append(min)\n        result.append(index)\n\
    \    }\n    return result", "    guard !arr.isEmpty else { return [] }\n    let\
    \ ans = arr.enumerated().filter { $0.element % 2 == 0 }.min { $0.element < $1.element\
    \ }\n    return ans == nil ? [] : [ans!.element, ans!.offset]", "    if arr.count\
    \ == 0 {\n        return []\n    }\n    var minEvenIndex = -1\n    var minEvenValue\
    \ = Int.max\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 && value < minEvenValue {\n            minEvenIndex = index\n       \
    \     minEvenValue = value\n        }\n    }\n    if minEvenIndex == -1 {\n  \
    \      return []\n    }\n    return [minEvenValue, minEvenIndex]", "    var result\
    \ = [Int]()\n    var evens = [Int]()\n    var evensIndex = [Int]()\n    var minIndex\
    \ = Int.max\n    for (index, element) in arr.enumerated() {\n        if element\
    \ % 2 == 0 {\n            evens.append(element)\n            evensIndex.append(index)\n\
    \        }\n    }\n    guard !evens.isEmpty else { return result }\n    let minEven\
    \ = evens.min()\n    for (index, element) in evens.enumerated() {\n        if\
    \ element == minEven! {\n            minIndex = min(minIndex, evensIndex[index])\n\
    \        }\n    }\n    result.append(minEven!)\n    result.append(minIndex)\n\
    \    return result", "    var smallestEvenNode: (value: Int, index: Int)?\n  \
    \  for i in 0..<arr.count {\n        let n = arr[i]\n        if n % 2 == 0 {\n\
    \            if smallestEvenNode == nil {\n                smallestEvenNode =\
    \ (n, i)\n            } else if n < smallestEvenNode!.value {\n              \
    \  smallestEvenNode = (n, i)\n            }\n        }\n    }\n    if let node\
    \ = smallestEvenNode {\n        return [node.value, node.index]\n    }\n    return\
    \ []", "    // TODO: Code\n    return []", "    // For empty array\n    guard\
    \ !arr.isEmpty else {\n        return [Int]()\n    }\n    // For array that only\
    \ has even numbers\n    guard arr.filter({ $0 % 2 != 0 }).count != arr.count else\
    \ {\n        return [Int]()\n    }\n    // Create variable to hold even numbers\
    \ array\n    var evens = [Int]()\n    // Create variable to hold indexes of even\
    \ numbers\n    var indexes = [Int]()\n    // Create variable to hold the lowest\
    \ even number\n    var lowestEven = 10001\n    // Run loop to find lowest even\
    \ number and its index\n    for i in 0..<arr.count {\n        // If the number\
    \ is even, add it to evens array\n        if arr[i] % 2 == 0 {\n            evens.append(arr[i])\n\
    \            // If the number is even and it is lower than the lowest even, add\
    \ it to lowestEven\n            if arr[i] < lowestEven {\n                lowestEven\
    \ = arr[i]\n            }\n        }\n    }\n    // Create variable to hold index\
    \ of the first lowest even number\n    var firstLowestEvenIndex = arr.count\n\
    \    // Run loop to find the index of the first lowest even number\n    for i\
    \ in 0..<arr.count {\n        // If the number is equal to the lowest even, add\
    \ its index to indexes array\n        if arr[i] == lowestEven {\n            indexes.append(i)\n\
    \            // If the index is lower than the first lowest even index, add it\
    \ to firstLowestEvenIndex\n            if i < firstLowestEvenIndex {\n       \
    \         firstLowestEvenIndex = i\n            }\n        }\n    }\n    // Return\
    \ an array containing the lowest even number and its index\n    return [lowestEven,\
    \ firstLowestEvenIndex]", "    var smallestValue = -1\n    var smallestIndex =\
    \ -1\n    for (i, value) in arr.enumerated() {\n        if value == 0 && smallestValue\
    \ == -1 {\n            smallestValue = value\n            smallestIndex = i\n\
    \        } else if value > 0 && value % 2 == 0 && (smallestValue == -1 || value\
    \ < smallestValue) {\n            smallestValue = value\n            smallestIndex\
    \ = i\n        }\n    }\n    return smallestValue != -1 ? [smallestValue, smallestIndex]\
    \ : []", "    // we should find the smallest value\n    // then we should find\
    \ the smallest index\n    // so first we should find the smallest value\n    //\
    \ then we should find the smallest index\n    // with the smallest value.\n  \
    \  var sortedArr = arr.sorted(by: <)\n    var foundIndex = 0\n    var smallestEvenValue\
    \ = Int.max\n    for (index, value) in sortedArr.enumerated() {\n        if value\
    \ % 2 == 0 && value < smallestEvenValue {\n            smallestEvenValue = value\n\
    \            foundIndex = index\n        }\n    }\n    if smallestEvenValue ==\
    \ Int.max {\n        return []\n    }\n    let result = [smallestEvenValue, foundIndex]\n\
    \    return result", "    var result = [Int]()\n    if arr.count == 0 {\n    \
    \    return result\n    }\n    if arr.min()! % 2 == 0 {\n        let smallest\
    \ = arr.filter{ $0 % 2 == 0 }.min()!\n        let smallestIndex = arr.firstIndex(of:\
    \ smallest)!\n        result.append(smallest)\n        result.append(smallestIndex)\n\
    \    }\n    return result", "    guard arr.count > 0 else { return [] }\n    var\
    \ smallestEven = Int.max\n    var smallestEvenIndex = 0\n    for (index, num)\
    \ in arr.enumerated() {\n        if num % 2 == 0 && num < smallestEven {\n   \
    \         smallestEven = num\n            smallestEvenIndex = index\n        }\n\
    \    }\n    return smallestEven == Int.max ? [] : [smallestEven, smallestEvenIndex]",
  "    // find the smallest even value, and return the node's value and index\n  \
    \  // if it is empty, or there are no even values, return []\n    guard arr.count\
    \ > 0 else { return [] }\n    let evenNodes = arr.enumerated().filter { $0.element\
    \ % 2 == 0 }\n    guard evenNodes.count > 0 else { return [] }\n    return evenNodes.reduce(evenNodes[0])\
    \ { $0.element < $1.element ? $0 : $1 }", "    guard !arr.isEmpty else { return\
    \ [] }\n    guard let minEven = arr.filter({ $0 % 2 == 0 }).min() else { return\
    \ [] }\n    guard let idx = arr.firstIndex(of: minEven) else { return [] }\n \
    \   return [minEven, idx]", "    guard !arr.isEmpty else { return [] }\n    var\
    \ smallestEven: Int?\n    var smallestEvenIndex: Int?\n    for (index, value)\
    \ in arr.enumerated() {\n        if value % 2 == 0 {\n            if smallestEven\
    \ == nil || value < smallestEven! {\n                smallestEven = value\n  \
    \              smallestEvenIndex = index\n            }\n        }\n    }\n  \
    \  guard let smallestEvenValue = smallestEven, let smallestEvenIdx = smallestEvenIndex\
    \ else { return [] }\n    return [smallestEvenValue, smallestEvenIdx]"]
stop_tokens:
- "\n}"
