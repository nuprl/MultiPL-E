name: HumanEval_57_monotonic
language: swift
prompt: "\n/// Return True is list elements are monotonically increasing or decreasing.\n\
  /// >>> monotonic([1, 2, 4, 20])\n/// True\n/// >>> monotonic([1, 20, 4, 10])\n\
  /// False\n/// >>> monotonic([4, 1, 0, -10])\n/// True\nfunc monotonic(l: [Int])\
  \ -> Bool {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
  \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
  \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
  \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\n\
  assert(monotonic(l: [9, 9, 9, 9]) == true)"
completions: ["    var pos = true\n    var neg = true\n    for i in 1..<l.count {\n\
    \        pos = pos && l[i] >= l[i - 1]\n        neg = neg && l[i] <= l[i - 1]\n\
    \    }\n    return pos || neg", "    guard let first = l.first else { return true\
    \ }\n    var isInc = first < l[1]\n    var isDec = first > l[1]\n    for i in\
    \ 0..<l.count - 1 {\n        if isInc {\n            if l[i] > l[i + 1] {\n  \
    \              return false\n            }\n        } else if isDec {\n      \
    \      if l[i] < l[i + 1] {\n                return false\n            }\n   \
    \     } else {\n            if l[i] != l[i + 1] {\n                isInc = l[i]\
    \ < l[i + 1]\n                isDec = l[i] > l[i + 1]\n            }\n       \
    \ }\n    }\n    return true", "    var increasing = true\n    var decreasing =\
    \ true\n    for i in 1 ..< l.count {\n        if l[i - 1] < l[i] {\n         \
    \   decreasing = false\n        }\n        if l[i - 1] > l[i] {\n            increasing\
    \ = false\n        }\n    }\n    return increasing || decreasing", '    return
    isStrictlyIncreasing(l) || isStrictlyDecreasing(l)', "    if l.count < 2 {\n \
    \       return true\n    }\n    if l[0] == l[1] {\n        return monotonic(Array(l[1..<l.count]))\n\
    \    }\n    var flag = false\n    for i in 1..<l.count {\n        if flag {\n\
    \            if l[i - 1] < l[i] {\n                return false\n            }\n\
    \        } else {\n            if l[i - 1] > l[i] {\n                return false\n\
    \            }\n        }\n        flag = true\n    }\n    return true", "   \
    \ if l.count <= 2 {\n        return true\n    }\n    var direction = 1\n    for\
    \ i in 0..<l.count-1 {\n        if l[i] > l[i+1] {\n            direction = -1\n\
    \            break\n        }\n    }\n    for i in 0..<l.count-1 {\n        if\
    \ l[i] * direction > l[i+1] * direction {\n            return false\n        }\n\
    \    }\n    return true", "    if l.count == 0 {\n        return true\n    }\n\
    \    var inc = l[0] < l[1]\n    for i in 1..<l.count-1 {\n        if l[i] == l[i+1]\
    \ {\n            continue\n        }\n        if l[i] < l[i+1] != inc {\n    \
    \        return false\n        }\n    }\n    return true", "    // Fill this in\n\
    \    if l.count <= 1 {\n        return true\n    } else {\n        var m = true\n\
    \        if l[0] < l[1] {\n            m = true\n        } else {\n          \
    \  m = false\n        }\n        for i in 0...l.count-2 {\n            if m ==\
    \ true {\n                if l[i] <= l[i+1] {\n                    continue\n\
    \                } else {\n                    return false\n                }\n\
    \            } else {\n                if l[i] >= l[i+1] {\n                 \
    \   continue\n                } else {\n                    return false\n   \
    \             }\n            }\n        }\n        return true\n    }", "    var\
    \ sorted = l.sorted()\n    if sorted == l {\n        return true\n    }\n    sorted.reverse()\n\
    \    return sorted == l", "  if l.count < 2 {\n    return true\n  }\n  if l[0]\
    \ < l[1] {\n    for i in 1..<l.count-1 {\n      if l[i] > l[i+1] {\n        return\
    \ false\n      }\n    }\n  } else {\n    for i in 1..<l.count-1 {\n      if l[i]\
    \ < l[i+1] {\n        return false\n      }\n    }\n  }\n  return true", '    return
    increasing(l) || decreasing(l)', "    let diff = l.enumerated().map({\n      \
    \  $0 == 0 ? 0 : $1 - l[$0 - 1]\n    })\n    let dir = diff.filter({ $0 != 0 })\n\
    \    return dir.all({ abs($0) > 0 })", '    return !isIncreasing(l) || !isDecreasing(l)',
  "    if l.count <= 2 {\n        return true\n    }\n    if l[0] < l[1] {\n     \
    \   for i in 1..<l.count - 1 {\n            if l[i] > l[i + 1] {\n           \
    \     return false\n            }\n        }\n    } else {\n        for i in 1..<l.count\
    \ - 1 {\n            if l[i] < l[i + 1] {\n                return false\n    \
    \        }\n        }\n    }\n    return true", "    if l.count < 2 {\n      \
    \  return true\n    }\n    let fv = l[0]\n    var sign: Int\n    if fv < l[1]\
    \ {\n        sign = 1\n    } else if fv > l[1] {\n        sign = -1\n    } else\
    \ {\n        return monotonic(Array(l[1..<l.count]))\n    }\n    return zip(l,\
    \ l[1..<l.count]).reduce(true) { $0 && ($1.0 - $1.1 == sign) }", "    if l.count\
    \ < 2 {\n        return true\n    }\n    var i = 1\n    let d = l[1] > l[0] ?\
    \ 1 : -1\n    while i < l.count && d * l[i] >= d * l[i - 1] {\n        i += 1\n\
    \    }\n    return i == l.count", "    if l.count < 2 {\n        return true\n\
    \    }\n    let f = l[0]\n    var p = f\n    for e in l {\n        if p < e {\n\
    \            if f > e {\n                return false\n            }\n       \
    \ } else if p > e {\n            if f < e {\n                return false\n  \
    \          }\n        }\n        p = e\n    }\n    return true", "    let first\
    \ = l[0]\n    for i in 1..<l.count {\n        if l[i] - first < 0 {\n        \
    \    if l[i] - first < first - l[i-1] {\n                return false\n      \
    \      }\n        } else {\n            if l[i] - first > first - l[i-1] {\n \
    \               return false\n            }\n        }\n    }\n    return true",
  "    guard l.count > 1 else {\n        return true\n    }\n    var trend = 0\n \
    \   for i in 1..<l.count {\n        if l[i] - l[i - 1] < 0 {\n            if trend\
    \ == 1 {\n                return false\n            }\n            trend = -1\n\
    \        } else if l[i] - l[i - 1] > 0 {\n            if trend == -1 {\n     \
    \           return false\n            }\n            trend = 1\n        }\n  \
    \  }\n    return true", "    var done = false\n    var cur = l[0]\n    var step\
    \ = -1\n    return l.reduce(true) { isMono, n -> Bool in\n        if step == -1\
    \ {\n            if n > cur {\n                step = 1\n            } else if\
    \ n < cur {\n                step = 0\n            }\n        }\n        if step\
    \ == 1 {\n            if n < cur {\n                return false\n           \
    \ }\n        } else if step == 0 {\n            if n > cur {\n               \
    \ return false\n            }\n        }\n        cur = n\n        return isMono\n\
    \    }"]
stop_tokens:
- "\n}"
