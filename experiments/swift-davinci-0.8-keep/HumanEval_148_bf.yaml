name: HumanEval_148_bf
language: swift
prompt: "\n/// There are eight planets in our solar system: the closerst to the Sun\
  \ \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
  /// Uranus, Neptune.\n/// Write a function that takes two planet names as strings\
  \ planet1 and planet2. \n/// The function should return a tuple containing all planets\
  \ whose orbits are \n/// located between the orbit of planet1 and the orbit of planet2,\
  \ sorted by \n/// the proximity to the sun. \n/// The function should return an\
  \ empty tuple if planet1 or planet2\n/// are not correct planet names. \n/// Examples\n\
  /// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n/// bf(\"Earth\"\
  , \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\",\
  \ \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1: String, planet2:\
  \ String) -> [String] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
  ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
  ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
  , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
  , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
  ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
  \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
  , planet2: \"Makemake\") == [] as [String])"
completions: ["  let solarSystem: [String] = [\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  var start = 0\n \
    \ var end = 0\n  for (index, planet) in solarSystem.enumerated() {\n    if planet\
    \ == planet1 {\n      start = index\n    }\n    if planet == planet2 {\n     \
    \ end = index\n    }\n  }\n  var planets = solarSystem\n  if start > end {\n \
    \   planets = Array(solarSystem.dropFirst(end))\n    planets = Array(planets.dropLast(planets.count\
    \ - start))\n  } else {\n    planets = Array(solarSystem.dropFirst(start))\n \
    \   planets = Array(planets.dropLast(planets.count - end))\n  }\n  return planets",
  "  var res: [String] = []\n  let planets = [\n    \"Mercury\",\n    \"Venus\",\n\
    \    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\"\
    ,\n    \"Neptune\"\n  ]\n  var start: Int = 0\n  var end: Int = 0\n  for (index,\
    \ planet) in planets.enumerated() {\n    if planet == planet1 {\n      start =\
    \ index\n    }\n    if planet == planet2 {\n      end = index\n    }\n  }\n  for\
    \ i in (start + 1)..<end {\n    res.append(planets[i])\n  }\n  return res", " \
    \   let planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"]\n    let planet1_index = planets.firstIndex(of:\
    \ planet1)\n    let planet2_index = planets.firstIndex(of: planet2)\n    var result:\
    \ [String] = []\n    if planet1_index == nil || planet2_index == nil {\n     \
    \   return result\n    }\n    if planet1_index! > planet2_index! {\n        for\
    \ planet in planets[planet2_index!...planet1_index!] {\n            result.append(planet)\n\
    \        }\n    } else {\n        for planet in planets[planet1_index!...planet2_index!]\
    \ {\n            result.append(planet)\n        }\n    }\n    return result",
  "    var res = [String]()\n    let planets = [\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if let idx1\
    \ = planets.firstIndex(of: planet1), let idx2 = planets.firstIndex(of: planet2)\
    \ {\n        let p1 = min(idx1, idx2)\n        let p2 = max(idx1, idx2)\n    \
    \    for i in p1+1..<p2 {\n            res.append(planets[i])\n        }\n   \
    \ }\n    return res", "    var solarSystem = [\n        \"Mercury\": 1,\n    \
    \    \"Venus\": 2,\n        \"Earth\": 3,\n        \"Mars\": 4,\n        \"Jupiter\"\
    : 5,\n        \"Saturn\": 6,\n        \"Uranus\": 7,\n        \"Neptune\": 8\n\
    \    ]\n    guard solarSystem[planet1] != nil && solarSystem[planet2] != nil else\
    \ { return [] }\n    var result: [String] = []\n    let planet1Orbit = solarSystem[planet1]!\n\
    \    let planet2Orbit = solarSystem[planet2]!\n    var firstPlanet = planet1Orbit\
    \ > planet2Orbit ? planet2Orbit : planet1Orbit\n    var secondPlanet = planet1Orbit\
    \ > planet2Orbit ? planet1Orbit : planet2Orbit\n    for (planet, orbit) in solarSystem\
    \ {\n        if orbit > firstPlanet && orbit < secondPlanet {\n            result.append(planet)\n\
    \        }\n    }\n    return result", "    let planets = [\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n   \
    \ var result = [String]()\n    var from: Int?\n    var to: Int?\n    for (i, n)\
    \ in planets.enumerated() {\n        if n == planet1 {\n            from = i\n\
    \        }\n        if n == planet2 {\n            to = i\n        }\n    }\n\
    \    if let from = from, let to = to {\n        for i in from...to {\n       \
    \     result.append(planets[i])\n        }\n    }\n    return result", "  let\
    \ planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n  let planet1Index = planets.firstIndex(of: planet1)\n\
    \  let planet2Index = planets.firstIndex(of: planet2)\n  guard let p1 = planet1Index,\
    \ let p2 = planet2Index else { return [] }\n  return p1 < p2 ? Array(planets[p1...p2])\
    \ : Array(planets[p2...p1]).reversed()", "    let planets = [\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n   \
    \ guard let f = planets.firstIndex(of: planet1),\n        let s = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    let lowerBound = min(f, s)\n    let upperBound\
    \ = max(f, s)\n    return Array(planets[lowerBound + 1...upperBound - 1])", " \
    \   let planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"]\n    guard let planet1Index = planets.firstIndex(of:\
    \ planet1),\n        let planet2Index = planets.firstIndex(of: planet2) else {\n\
    \            return []\n    }\n    if planet1Index > planet2Index {\n        return\
    \ Array(planets[planet2Index...planet1Index])\n    } else {\n        return Array(planets[planet1Index...planet2Index])\n\
    \    }", "    var final:[String] = []\n    let order = [\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n   \
    \ if order.contains(planet1) && order.contains(planet2) {\n        let index1\
    \ = order.firstIndex(of: planet1)!\n        let index2 = order.firstIndex(of:\
    \ planet2)!\n        var indexLow = 0\n        var indexHigh = 0\n        if index1\
    \ < index2 {\n            indexLow = index1\n            indexHigh = index2\n\
    \        } else {\n            indexLow = index2\n            indexHigh = index1\n\
    \        }\n        for i in indexLow+1...indexHigh-1 {\n            final.append(order[i])\n\
    \        }\n    }\n    return final", "    var distances = [String:Int]()\n  \
    \  distances[\"Mercury\"] = 1\n    distances[\"Venus\"] = 2\n    distances[\"\
    Earth\"] = 3\n    distances[\"Mars\"] = 4\n    distances[\"Jupiter\"] = 5\n  \
    \  distances[\"Saturn\"] = 6\n    distances[\"Uranus\"] = 7\n    distances[\"\
    Neptune\"] = 8\n    \n    var r = [String]()\n    if let d1 = distances[planet1],\
    \ d2 = distances[planet2] {\n        let sorted = [d1, d2].sort { $0 < $1 }\n\
    \        let p1 = sorted[0]\n        let p2 = sorted[1]\n        for (name, index)\
    \ in distances {\n            if index > p1 && index < p2 {\n                r.append(name)\n\
    \            }\n        }\n    }\n    return r", "    let planets: [String] =\
    \ [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let firstIndex = planets.firstIndex(of: planet1), let\
    \ secondIndex = planets.firstIndex(of: planet2) else {\n        return []\n  \
    \  }\n    let minIndex = min(firstIndex, secondIndex)\n    let maxIndex = max(firstIndex,\
    \ secondIndex)\n    return Array(planets[minIndex...maxIndex])", "    let planets\
    \ = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"]\n    let first = planets.firstIndex(of: planet1) ?? -1\n\
    \    let second = planets.firstIndex(of: planet2) ?? -1\n    if (first < 0 ||\
    \ second < 0) {\n        return []\n    }\n    return first < second ? Array(planets[first+1..<second])\
    \ : Array(planets[second+1..<first])", "    var result = [String]()\n    if ![\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"].contains(planet1) {\n        return result\n    }\n    if ![\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"].contains(planet2) {\n        return result\n    }\n    let planetMap\
    \ = [\"Mercury\": 0, \"Venus\": 1, \"Earth\": 2, \"Mars\": 3, \"Jupiter\": 4,\
    \ \"Saturn\": 5, \"Uranus\": 6, \"Neptune\": 7]\n    let planet1Index = planetMap[planet1]!\n\
    \    let planet2Index = planetMap[planet2]!\n    if planet1Index < planet2Index\
    \ {\n        for i in planet1Index..<planet2Index {\n            result.append([\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"][i])\n        }\n    } else {\n        for i in planet2Index..<planet1Index\
    \ {\n            result.append([\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"][i])\n        }\n    }\n    return\
    \ result", "    let planet = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    let range = planet.firstIndex(of:\
    \ planet1)!...planet.firstIndex(of: planet2)!\n    var result = [String]()\n \
    \   for i in range {\n        result.append(planet[i])\n    }\n    return result",
  "  var firstPlanetPosition: Int!\n  var secondPlanetPosition: Int!\n  var result:\
    \ [String] = []\n  let planetArray = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  for (index, planet) in\
    \ planetArray.enumerated() {\n    if planet == planet1 {\n      firstPlanetPosition\
    \ = index\n    }\n    if planet == planet2 {\n      secondPlanetPosition = index\n\
    \    }\n  }\n  if firstPlanetPosition > secondPlanetPosition {\n    let temp =\
    \ firstPlanetPosition\n    firstPlanetPosition = secondPlanetPosition\n    secondPlanetPosition\
    \ = temp\n  }\n  if firstPlanetPosition == nil || secondPlanetPosition == nil\
    \ {\n    return result\n  }\n  for i in firstPlanetPosition...secondPlanetPosition\
    \ {\n    result.append(planetArray[i])\n  }\n  return result", "    var bf = [String]()\n\
    \    var planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planets.contains(planet1) && planets.contains(planet2)\
    \ {\n        var ind1 = planets.firstIndex(of: planet1)!\n        var ind2 = planets.firstIndex(of:\
    \ planet2)!\n        if ind1 < ind2 {\n            for i in ind1 + 1..<ind2 {\n\
    \                bf.append(planets[i])\n            }\n        } else {\n    \
    \        for i in ind2 + 1..<ind1 {\n                bf.append(planets[i])\n \
    \           }\n        }\n    }\n    return bf", "    let planets = [\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n    guard let planetOneIndex = planets.firstIndex(of: planet1), let planetTwoIndex\
    \ = planets.firstIndex(of: planet2) else {\n        return []\n    }\n    let\
    \ startIndex = min(planetOneIndex, planetTwoIndex)\n    let endIndex = max(planetOneIndex,\
    \ planetTwoIndex)\n    return Array(planets[startIndex...endIndex])", "    let\
    \ planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    guard let i1 = planets.firstIndex(of: planet1),\
    \ let i2 = planets.firstIndex(of: planet2) else { return [] }\n    let x = planets[i1\
    \ + 1 ..< i2]\n    return Array(x)", "    let planets = [\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n   \
    \ guard let index1 = planets.firstIndex(of: planet1), let index2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    if index1 == index2 { return [] }\n    return\
    \ Array(planets[min(index1, index2)+1..<max(index1, index2)])"]
stop_tokens:
- "\n}"
