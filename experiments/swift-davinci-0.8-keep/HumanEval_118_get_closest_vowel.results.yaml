language: swift
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"AEIOUaeiou\"\n    let consontants =\
    \ \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\n    var pos = -1\n    for (index,\
    \ letter) in word.characters.enumerated() {\n        if consontants.contains(String(letter))\
    \ {\n            for (vIndex, vLetter) in vowels.characters.enumerated() {\n \
    \               if consontants.contains(String(vLetter)) {\n                 \
    \   continue\n                }\n                if index == 0 {\n           \
    \         if word.contains(String(vLetter)) {\n                        pos = vIndex\n\
    \                        break\n                    }\n                } else\
    \ {\n                    let left = String(word.characters.prefix(index))\n  \
    \                  let right = String(word.characters.suffix(word.characters.count\
    \ - index))\n                    if right.contains(String(vLetter)) && !left.contains(String(vLetter))\
    \ {\n                        pos = vIndex\n                        break\n   \
    \                 }\n                }\n            }\n        }\n    }\n    if\
    \ pos != -1 {\n        return String(vowels.characters.suffix(vowels.characters.count\
    \ - pos))\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpp8vuzmgh.swift:16:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, letter) in word.characters.enumerated()\
    \ {\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpp8vuzmgh.swift:18:45: error: 'characters' is unavailable:\
    \ Please use String directly\n            for (vIndex, vLetter) in vowels.characters.enumerated()\
    \ {\n                                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpp8vuzmgh.swift:28:44: error: 'characters'\
    \ is unavailable: Please use String directly\n                    let left = String(word.characters.prefix(index))\n\
    \                                           ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpp8vuzmgh.swift:29:45: error: 'characters'\
    \ is unavailable: Please use String directly\n                    let right =\
    \ String(word.characters.suffix(word.characters.count - index))\n            \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpp8vuzmgh.swift:29:68: error: 'characters' is unavailable:\
    \ Please use String directly\n                    let right = String(word.characters.suffix(word.characters.count\
    \ - index))\n                                                                \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpp8vuzmgh.swift:39:30:\
    \ error: 'characters' is unavailable: Please use String directly\n        return\
    \ String(vowels.characters.suffix(vowels.characters.count - pos))\n          \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift "
  stdout: ''
  timestamp: 1660013626
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n  let vowelList = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\
    \  let wordList = Array(word)\n  let wordListLen = wordList.count\n  var vowelPos\
    \ = -1\n  var i = wordListLen - 1\n  while i >= 0 {\n    if vowelList.contains(String(wordList[i]))\
    \ {\n      vowelPos = i\n      break\n    }\n    i -= 1\n  }\n  if vowelPos ==\
    \ -1 {\n    return \"\"\n  }\n  i = vowelPos - 1\n  while i >= 0 {\n    if !vowelList.contains(String(wordList[i]))\
    \ {\n      return String(wordList[vowelPos])\n    }\n    i -= 1\n  }\n  return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp0ga8jt9s/tmp0ga8jt9s.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea22545c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea2223cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea2223c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea2223b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0ga8jt9s                        0x00005606f1c50b0b <unavailable> + 6923

    5    libc.so.6                          0x00002aea22731460 __libc_start_main +
    245

    6    tmp0ga8jt9s                        0x00005606f1c50309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013626
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    var res: String = \"\"\n    let vowels: [Character]\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let letters: [Character] = Array(word)\n\
    \    if vowels.contains(letters[0]) || vowels.contains(letters[letters.count -\
    \ 1]) {\n        return res\n    }\n    for i in 0..<letters.count {\n       \
    \ if vowels.contains(letters[i]) {\n            if i > 0 && !vowels.contains(letters[i\
    \ - 1]) {\n                res = String(letters[i])\n                break\n \
    \           }\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpwwa4he71/tmpwwa4he71.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad521c3ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad521931b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad521931988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad5219307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwwa4he71                        0x0000558980bd08e7 <unavailable> + 6375

    5    libc.so.6                          0x00002ad521e26460 __libc_start_main +
    245

    6    tmpwwa4he71                        0x0000558980bd0529 <unavailable> + 5417

    '
  stdout: ''
  timestamp: 1660013626
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    let vowelSet = Set<Character>([\"a\", \"e\", \"i\"\
    , \"o\", \"u\"])\n    let consonantSet = Set<Character>([\"b\", \"c\", \"d\",\
    \ \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"])\n    let charArray = Array(word)\n\
    \    let lastVowel: String = charArray.filter{ vowelSet.contains($0) }.last !=\
    \ nil ? String(charArray.filter{ vowelSet.contains($0) }.last!) : \"\"\n    var\
    \ tempArray = Array(word.reversed())\n    tempArray = tempArray.filter{ consonantSet.contains($0)\
    \ }\n    guard let first = tempArray.first, let last = tempArray.last else { return\
    \ lastVowel }\n    guard tempArray.count > 1 else { return String(first) }\n \
    \   guard let lastVowelIndex = charArray.firstIndex(of: Character(lastVowel))\
    \ else { return String(last) }\n    if first > last {\n        if word.count >\
    \ lastVowelIndex + 1 {\n            return String(charArray[lastVowelIndex + 1])\n\
    \        } else {\n            return String(last)\n        }\n    } else {\n\
    \        if word.count > lastVowelIndex + 1 {\n            return String(charArray[lastVowelIndex\
    \ + 1])\n        } else {\n            return String(first)\n        }\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmposhjlov8/tmposhjlov8.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af8325c1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af8322b8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af8322b8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8322b77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmposhjlov8                        0x000055846ef63d67 <unavailable> + 7527

    5    libc.so.6                          0x00002af8327ad460 __libc_start_main +
    245

    6    tmposhjlov8                        0x000055846ef639a9 <unavailable> + 6569

    '
  stdout: ''
  timestamp: 1660013626
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\"\n    var result = \"\"\n\
    \    var check = false\n    let reverseWord = String(word.reversed())\n    for\
    \ c in reverseWord {\n        if vowels.contains(c) {\n            result = String(c)\n\
    \            check = true\n        } else if check {\n            break\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp2jjrewz4/tmp2jjrewz4.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0144a54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b014474bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b014474b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b014474a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2jjrewz4                        0x000055c681fb08e3 <unavailable> + 6371

    5    libc.so.6                          0x00002b0144c40460 __libc_start_main +
    245

    6    tmp2jjrewz4                        0x000055c681fb0319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1660013626
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n  // your code goes here\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: '/tmp/tmp_3u4g5kf.swift:14:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660013626
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n  let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  var\
    \ found_vowel: String = \"\"\n  let last_idx = word.count - 1\n  var prev_idx\
    \ = last_idx\n  var curr_idx = last_idx\n  var is_a_consonant = false\n  var is_previous_consonant\
    \ = false\n  while curr_idx >= 0 {\n    let char = String(word[word.index(word.startIndex,\
    \ offsetBy: curr_idx)])\n    is_a_consonant = vowels.contains(char) ? false :\
    \ true\n    if is_a_consonant && is_previous_consonant {\n      found_vowel =\
    \ String(word[word.index(word.startIndex, offsetBy: prev_idx)])\n      break\n\
    \    }\n    prev_idx = curr_idx\n    curr_idx -= 1\n    is_previous_consonant\
    \ = is_a_consonant\n  }\n  return found_vowel\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp_6p2ceu1/tmp_6p2ceu1.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b093a08cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0939d83b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0939d83988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0939d827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_6p2ceu1                        0x0000559df6de1697 <unavailable> + 5783

    5    libc.so.6                          0x00002b093a278460 __libc_start_main +
    245

    6    tmp_6p2ceu1                        0x0000559df6de12d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660013626
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp7uxqg_to/tmp7uxqg_to.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2236befc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b22368e6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b22368e6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b22368e57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7uxqg_to                        0x0000559a75d85307 <unavailable> + 4871

    5    libc.so.6                          0x00002b2236ddb460 __libc_start_main +
    245

    6    tmp7uxqg_to                        0x0000559a75d84f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013626
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    if word.isEmpty {\n        return \"\"\n    }\n   \
    \ var vowels = \"aeiou\"\n    var closest: String = \"\"\n    var min: Int = Int.max\n\
    \    var found = false\n    for i in stride(from: word.count - 1, through: 0,\
    \ by: -1) {\n        let c = word[i]\n        if c.isVowel {\n            closest\
    \ = c.description\n            found = true\n            min = i\n           \
    \ break\n        }\n    }\n    if !found {\n        return \"\"\n    }\n    for\
    \ i in stride(from: word.count - 1, through: 0, by: -1) {\n        let c = word[i]\n\
    \        if c.isVowel {\n            if abs(i - min) < min {\n               \
    \ closest = c.description\n                min = i\n            }\n        }\n\
    \    }\n    return closest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp5drdxjxg.swift:21:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let c = word[i]\n\
    \                ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp5drdxjxg.swift:22:14: error: value of type 'Character'\
    \ has no member 'isVowel'\n        if c.isVowel {\n           ~ ^~~~~~~\n/tmp/tmp5drdxjxg.swift:33:17:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let c = word[i]\n                ^~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp5drdxjxg.swift:34:14:\
    \ error: value of type 'Character' has no member 'isVowel'\n        if c.isVowel\
    \ {\n           ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013626
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\
    \    var wordConsonents = word.filter { !vowels.contains($0.lowercased()) }\n\
    \    var wordVowels = word.filter { vowels.contains($0.lowercased()) }\n    for\
    \ index in stride(from: wordConsonents.count-1, through: 0, by: -1) {\n      \
    \  if let vowel = wordVowels.last,\n            vowels.contains(wordConsonents[wordConsonents.index(wordConsonents.startIndex,\
    \ offsetBy: index)].lowercased()) &&\n            vowels.contains(wordConsonents[wordConsonents.index(wordConsonents.startIndex,\
    \ offsetBy: index-1)].lowercased()) {\n            return String(vowel)\n    \
    \    }\n        wordVowels.removeLast()\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'Swift/RangeReplaceableCollection.swift:870: Fatal error: Can''t remove
    last element from an empty collection

    Current stack trace:

    0    libswiftCore.so                    0x00002afc12908c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc125ff561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afc125ff286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afc125ff13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afc125febb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002afc12700c1d <unavailable> + 2489373

    6    tmpl0sqbido                        0x00005565a1ba9181 <unavailable> + 12673

    7    tmpl0sqbido                        0x00005565a1ba7a06 <unavailable> + 6662

    8    libc.so.6                          0x00002afc12af4460 __libc_start_main +
    245

    9    tmpl0sqbido                        0x00005565a1ba7709 <unavailable> + 5897

    '
  stdout: ''
  timestamp: 1660013626
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = Set(\"aeiouAEIOU\")\n    let consonants\
    \ = Set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    var vowel_index =\
    \ -1\n    for (index, character) in word.characters.enumerated() {\n        if\
    \ vowels.contains(character) {\n            vowel_index = index\n        }\n \
    \       if vowel_index != -1 {\n            if consonants.contains(character)\
    \ {\n                return String(word[word.index(word.startIndex, offsetBy:\
    \ vowel_index)])\n            }\n        }\n    }\n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpnlcl5w39.swift:16:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, character) in word.characters.enumerated()\
    \ {\n                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013626
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp7uxqg_to/tmp7uxqg_to.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2236befc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b22368e6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b22368e6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b22368e57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7uxqg_to                        0x0000559a75d85307 <unavailable> + 4871

    5    libc.so.6                          0x00002b2236ddb460 __libc_start_main +
    245

    6    tmp7uxqg_to                        0x0000559a75d84f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013626
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    // Note: in Swift, \"..<\" is a half-open range (exclusive):\
    \ it includes the first value, but not the last.\n    // The ..< operator creates\
    \ ranges up to, but excluding, the final value.\n    // let indices = word.characters.indices.dropLast()\n\
    \    let indices = word.startIndex ..< word.endIndex\n    var first_consonant_index\
    \ = 0\n    var last_consonant_index = 0\n    var first_vowel_index = 0\n    var\
    \ last_vowel_index = 0\n    var next_consonant_index = 0\n    var next_vowel_index\
    \ = 0\n    var vowel_index_array: [Int] = []\n    var consonant_index_array: [Int]\
    \ = []\n    var result_letter = \"\"\n    for i in indices {\n        let char\
    \ = word[i]\n        let char_value = String(char)\n        if char_value == \"\
    a\" || char_value == \"e\" || char_value == \"i\" || char_value == \"o\" || char_value\
    \ == \"u\" || char_value == \"A\" || char_value == \"E\" || char_value == \"I\"\
    \ || char_value == \"O\" || char_value == \"U\" {\n            vowel_index_array.append(word.characters.distance(from:\
    \ word.startIndex, to: i))\n        } else {\n            consonant_index_array.append(word.characters.distance(from:\
    \ word.startIndex, to: i))\n        }\n    }\n    first_consonant_index = consonant_index_array.first!\n\
    \    last_consonant_index = consonant_index_array.last!\n    first_vowel_index\
    \ = vowel_index_array.first!\n    last_vowel_index = vowel_index_array.last!\n\
    \    if first_consonant_index < first_vowel_index {\n        return \"\"\n   \
    \ }\n    if last_consonant_index > last_vowel_index {\n        return \"\"\n \
    \   }\n    next_consonant_index = consonant_index_array\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpe7jwzn2c.swift:26:14: error: protocol 'Sequence' requires that\
    \ 'String.Index' conform to 'Strideable'\n    for i in indices {\n           \
    \  ^\nSwift.Range:1:11: note: requirement from conditional conformance of 'Range<String.Index>'\
    \ to 'Sequence'\nextension Range : Sequence where Bound : Strideable, Bound.Stride\
    \ : SignedInteger {\n          ^\n/tmp/tmpe7jwzn2c.swift:26:14: error: referencing\
    \ instance method 'makeIterator()' on 'Range' requires that 'String.Index' conform\
    \ to 'Strideable'\n    for i in indices {\n             ^\nSwift.Range:1:11: note:\
    \ requirement from conditional conformance of 'Range<String.Index>' to 'Collection'\n\
    extension Range : Collection, BidirectionalCollection, RandomAccessCollection\
    \ where Bound : Strideable, Bound.Stride : SignedInteger {\n          ^\n<unknown>:0:\
    \ error: referencing instance method 'next()' on 'Range' requires that 'String.Index'\
    \ conform to 'Strideable'\nSwift.Range:1:11: note: requirement from conditional\
    \ conformance of 'Range<String.Index>' to 'Collection'\nextension Range : Collection,\
    \ BidirectionalCollection, RandomAccessCollection where Bound : Strideable, Bound.Stride\
    \ : SignedInteger {\n          ^\n/tmp/tmpe7jwzn2c.swift:45:28: error: cannot\
    \ assign value of type '[Int]' to type 'Int'\n    next_consonant_index = consonant_index_array\n\
    \                           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013626
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\"\n    let consonants = \"bcdfghjklmnpqrstvwxyz\"\
    \n    var result = \"\"\n    var closest = Int.max\n    for (index, char) in word.characters.enumerated()\
    \ {\n        if vowels.contains(char) {\n            guard let cIndex = word.characters.index(of:\
    \ char) else { continue }\n            let left = word.characters.index(before:\
    \ cIndex)\n            let right = word.characters.index(after: cIndex)\n    \
    \        if consonants.contains(word[left]) && consonants.contains(word[right])\
    \ {\n                let diff = index - word.characters.count\n              \
    \  if abs(diff) < closest {\n                    closest = abs(diff)\n       \
    \             result = String(char)\n                }\n            }\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp92qrha14.swift:17:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, char) in word.characters.enumerated() {\n\
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp92qrha14.swift:19:37: error: 'characters' is unavailable:\
    \ Please use String directly\n            guard let cIndex = word.characters.index(of:\
    \ char) else { continue }\n                                    ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp92qrha14.swift:19:48: warning: 'index(of:)'\
    \ is deprecated: renamed to 'firstIndex(of:)'\n            guard let cIndex =\
    \ word.characters.index(of: char) else { continue }\n                        \
    \                       ^\n/tmp/tmp92qrha14.swift:19:48: note: use 'firstIndex(of:)'\
    \ instead\n            guard let cIndex = word.characters.index(of: char) else\
    \ { continue }\n                                               ^~~~~\n       \
    \                                        firstIndex\n/tmp/tmp92qrha14.swift:20:29:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ let left = word.characters.index(before: cIndex)\n                         \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp92qrha14.swift:21:30:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ let right = word.characters.index(after: cIndex)\n                         \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp92qrha14.swift:23:41:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \     let diff = index - word.characters.count\n                             \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted i"
  stdout: ''
  timestamp: 1660013626
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\
    \    var reversedWord = String(word.reversed())\n    var vowel = String()\n  \
    \  for i in 0..<reversedWord.count - 1 {\n        if vowels.contains(String(reversedWord[reversedWord.index(reversedWord.startIndex,\
    \ offsetBy: i)])) && !vowels.contains(String(reversedWord[reversedWord.index(reversedWord.startIndex,\
    \ offsetBy: i + 1)])) {\n            vowel = String(reversedWord[reversedWord.index(reversedWord.startIndex,\
    \ offsetBy: i)])\n            break\n        }\n    }\n    return vowel\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpa51dcddm/tmpa51dcddm.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba1e7620c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba1e7317b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba1e7317988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba1e73167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa51dcddm                        0x000055f6fa468e6b <unavailable> + 7787

    5    libc.so.6                          0x00002ba1e780c460 __libc_start_main +
    245

    6    tmpa51dcddm                        0x000055f6fa468669 <unavailable> + 5737

    '
  stdout: ''
  timestamp: 1660013626
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    var vowels: [Character] = [\"a\", \"e\", \"i\", \"\
    o\", \"u\"]\n    var cons: [Character] = [\"b\", \"c\", \"d\", \"f\", \"g\", \"\
    h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"]\n    var non_vowels: [Character] = []\n    var\
    \ vow: [Character] = []\n    for char in word {\n        if vowels.contains(char)\
    \ {\n            vow.append(char)\n        } else if cons.contains(char) {\n \
    \           non_vowels.append(char)\n        }\n    }\n    if vow.count == 0 ||\
    \ non_vowels.count == 0 {\n        return \"\"\n    }\n    var char1: Character\
    \ = vow[vow.count - 1]\n    var char2: Character = non_vowels[non_vowels.count\
    \ - 1]\n    var index = word.firstIndex(of: char1)!\n    var count = 0\n    while\
    \ index != word.endIndex {\n        if count > 1 {\n            break\n      \
    \  }\n        if word[index] == char2 {\n            count += 1\n        }\n \
    \       index = word.index(after: index)\n    }\n    if count > 1 {\n        return\
    \ String(char1)\n    } else {\n        return \"\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpja2ftd1c/tmpja2ftd1c.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6980dc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6980ab9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6980ab9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6980ab87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpja2ftd1c                        0x00005561a7ec6a67 <unavailable> + 6759

    5    libc.so.6                          0x00002b6980fae460 __libc_start_main +
    245

    6    tmpja2ftd1c                        0x00005561a7ec66a9 <unavailable> + 5801

    '
  stdout: ''
  timestamp: 1660013626
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    let v = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var\
    \ index = word.characters.count - 1\n    var s = \"\"\n    while index > 0 {\n\
    \        if v.contains(String(word[word.index(word.startIndex, offsetBy: index)]))\
    \ {\n            s = String(word[word.index(word.startIndex, offsetBy: index)])\n\
    \            index -= 1\n            if v.contains(String(word[word.index(word.startIndex,\
    \ offsetBy: index)])) {\n                s = \"\"\n            }\n           \
    \ break\n        }\n        index -= 1\n    }\n    return s\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp3wl31p8n.swift:14:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var index = word.characters.count - 1\n           \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013626
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    if word.isEmpty {\n        return \"\"\n    }\n   \
    \ let vowels = \"aeiouAEIOU\"\n    var consonantsCount = 0\n    for letter in\
    \ word.reversed() {\n        if vowels.contains(letter) {\n            consonantsCount\
    \ += 1\n        } else {\n            if consonantsCount >= 2 {\n            \
    \    return String(letter)\n            }\n        }\n    }\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpqx8ip7nd/tmpqx8ip7nd.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0fc65dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0fc62d5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0fc62d5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0fc62d47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqx8ip7nd                        0x000055c3ebc1d6f7 <unavailable> + 5879

    5    libc.so.6                          0x00002b0fc67ca460 __libc_start_main +
    245

    6    tmpqx8ip7nd                        0x000055c3ebc1d339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660013626
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.lowercased()\n    var leftVowel = \"\
    \"\n    var rightVowel = \"\"\n    var i = word.count - 1\n    while i >= 0 {\n\
    \        let left = word.index(word.startIndex, offsetBy: i)\n        let leftChar\
    \ = word[left]\n        if leftChar == \"a\" || leftChar == \"e\" || leftChar\
    \ == \"i\" || leftChar == \"o\" || leftChar == \"u\" {\n            leftVowel\
    \ = String(leftChar)\n            break\n        }\n        i -= 1\n    }\n  \
    \  if i == 0 {\n        return \"\"\n    }\n    i -= 1\n    while i >= 0 {\n \
    \       let left = word.index(word.startIndex, offsetBy: i)\n        let leftChar\
    \ = word[left]\n        if leftChar == \"a\" || leftChar == \"e\" || leftChar\
    \ == \"i\" || leftChar == \"o\" || leftChar == \"u\" {\n            rightVowel\
    \ = String(leftChar)\n            break\n        }\n        i -= 1\n    }\n  \
    \  return leftVowel.count > rightVowel.count ? rightVowel : leftVowel\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp9itun4_6/tmp9itun4_6.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba28ba01c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba28b6f8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba28b6f8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba28b6f77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9itun4_6                        0x0000561ee6b306f7 <unavailable> + 5879

    5    libc.so.6                          0x00002ba28bbed460 __libc_start_main +
    245

    6    tmp9itun4_6                        0x0000561ee6b30249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013626
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word:\
    \ String) -> String {\n    var vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\
    \    var consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\"\
    , \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\"]\n    var answer = \"\"\n    var reversed_word = String(word.reversed())\n\
    \    for i in 0..<reversed_word.count {\n        let current_index = reversed_word.index(reversed_word.startIndex,\
    \ offsetBy: i)\n        let current_letter = String(reversed_word[current_index])\n\
    \        if vowels.contains(current_letter) {\n            if i < reversed_word.count\
    \ - 1 {\n                let previous_index = reversed_word.index(reversed_word.startIndex,\
    \ offsetBy: i + 1)\n                let previous_letter = String(reversed_word[previous_index])\n\
    \                if consonants.contains(previous_letter) {\n                 \
    \   answer = current_letter\n                    break\n                }\n  \
    \          }\n        }\n    }\n    return answer\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpyyzk419l/tmpyyzk419l.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06abb36c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06ab82db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06ab82d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06ab82c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyyzk419l                        0x000055720137ee0b <unavailable> + 7691

    5    libc.so.6                          0x00002b06abd22460 __libc_start_main +
    245

    6    tmpyyzk419l                        0x000055720137e609 <unavailable> + 5641

    '
  stdout: ''
  timestamp: 1660013626
