name: HumanEval_132_is_nested
language: swift
prompt: "\n/// Create a function that takes a string as input which contains only\
  \ square brackets.\n/// The function should return True if and only if there is\
  \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
  \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
  \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E False\n\
  /// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\nfunc is_nested(string:\
  \ String) -> Bool {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
  \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
  assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
  ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
  \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
  \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
  \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
  \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
completions: ["\tvar stack: [Character] = []\n\tfor i in string {\n\t\tif !stack.isEmpty\
    \ && i == \"]\" && stack.last == \"[\" {\n\t\t\tstack.removeLast()\n\t\t} else\
    \ {\n\t\t\tstack.append(i)\n\t\t}\n\t}\n\treturn stack.isEmpty", "\tvar inBrackets\
    \ = 0\n\tfor i in string {\n\t\tif i == \"[\" {\n\t\t\tinBrackets += 1\n\t\t}\
    \ else if i == \"]\" {\n\t\t\tinBrackets -= 1\n\t\t}\n\t\tif inBrackets < 0 {\n\
    \t\t\treturn false\n\t\t}\n\t}\n\treturn inBrackets > 0", "    var stack = [String]()\n\
    \    for char in string {\n        if stack.isEmpty {\n            stack.append(String(char))\n\
    \        } else {\n            if String(char) == \"]\" && stack.last == \"[\"\
    \ {\n                stack.removeLast()\n            } else {\n              \
    \  stack.append(String(char))\n            }\n        }\n    }\n    return stack.isEmpty",
  "    let brackets = string.filter({$0 == \"[\" || $0 == \"]\"})\n    let stack =\
    \ Stack<Character>()\n    for bracket in brackets {\n        if stack.isEmpty\
    \ {\n            stack.push(bracket)\n        } else {\n            if stack.peek()\
    \ == \"[\" && bracket == \"]\" {\n                stack.pop()\n            } else\
    \ {\n                stack.push(bracket)\n            }\n        }\n    }\n  \
    \  return stack.isEmpty", "\t//in: [][]\n\t//out: true\n\t//in: [][]\n\t//out:\
    \ true\n\t//in: [][]\n\t//out: true\n\t\n\t//at least one bracket in the subsequence\
    \ is nested \n\t//subsequence of brackets\n\t\n\treturn false", '    return string.firstIndex(of:
    "[")! < string.lastIndex(of: "]")!', "    var leftBrackets = 0\n    var isFirst\
    \ = true\n    for character in string {\n        if character == \"[\" {\n   \
    \         leftBrackets += 1\n            isFirst = false\n        } else if character\
    \ == \"]\" {\n            if isFirst {\n                return false\n       \
    \     }\n            leftBrackets -= 1\n            if leftBrackets < 0 {\n  \
    \              return false\n            }\n        }\n    }\n    return leftBrackets\
    \ == 0", '    return string.contains("[]")', '    return true', '    return string.contains("[]")',
  "  var counter = 0\n  for char in string {\n    if char == \"[\" {\n      counter\
    \ += 1\n    } else if char == \"]\" {\n      counter -= 1\n    }\n    if counter\
    \ < 0 {\n      return false\n    }\n  }\n  return counter == 0", "    var stack\
    \ = Stack<Character>()\n    for char in string {\n        if char == \"[\" {\n\
    \            stack.push(char)\n        } else if char == \"]\" {\n           \
    \ if stack.isEmpty() {\n                return false\n            } else {\n \
    \               stack.pop()\n            }\n        }\n    }\n    return stack.isEmpty()",
  "    var stack = [Character]()\n    for ch in string {\n        if ch == \"[\" {\n\
    \            stack.append(ch)\n        } else if ch == \"]\" {\n            if\
    \ stack.isEmpty {\n                return false\n            } else {\n      \
    \          stack.removeLast()\n            }\n        }\n    }\n    return stack.isEmpty",
  "    var result = false\n    var inBrackets = 0\n    for bracket in string {\n \
    \       if bracket == \"[\" {\n            inBrackets += 1\n        } else if\
    \ bracket == \"]\" {\n            inBrackets -= 1\n        }\n        if inBrackets\
    \ < 0 {\n            return false\n        }\n        if inBrackets > 0 {\n  \
    \          result = true\n        }\n    }\n    return result", "    var count\
    \ = 0\n    for char in string {\n        if char == \"[\" {\n            count\
    \ += 1\n        } else if char == \"]\" {\n            count -= 1\n        }\n\
    \        if count < 0 {\n            return false\n        }\n    }\n    return\
    \ count == 0", "    var left = 0\n    var right = 0\n    for character in string\
    \ {\n        if character == \"[\" {\n            left += 1\n        } else if\
    \ character == \"]\" {\n            right += 1\n        }\n        if right >\
    \ left {\n            return false\n        }\n    }\n    return left == right",
  "    let openingBrackets = [\"[\"]\n    let closingBrackets = [\"]\"]\n    var stack\
    \ = [Character]()\n    for char in string {\n        if openingBrackets.contains(String(char))\
    \ {\n            stack.append(char)\n        } else if closingBrackets.contains(String(char))\
    \ {\n            if stack.isEmpty {\n                return false\n          \
    \  } else {\n                let lastOpen = stack.popLast()\n                if\
    \ String(lastOpen!) != \"[\" {\n                    return false\n           \
    \     }\n            }\n        }\n    }\n    return stack.isEmpty", "    var\
    \ a = 0\n    var b = 0\n    for i in string {\n        if i == \"[\" {\n     \
    \       a += 1\n        } else if i == \"]\" {\n            b += 1\n        }\n\
    \    }\n    return a > b ? true : false", "    var stack = [Character]()\n   \
    \ for c in string {\n        if c == \"[\" {\n            stack.append(c)\n  \
    \      } else if c == \"]\" {\n            if stack.isEmpty {\n              \
    \  return false\n            } else {\n                stack.removeLast()\n  \
    \          }\n        }\n    }\n    return stack.isEmpty", "    var open = 0\n\
    \    var close = 0\n    var two = 0\n    var one = 0\n    var check:Bool = false\n\
    \    var brackets = string.compactMap {String($0)}\n    for i in 0..<brackets.count{\n\
    \        if brackets[i] == \"[\" {\n            open += 1\n        }\n       \
    \ if brackets[i] == \"]\" {\n            close += 1\n        }\n        if brackets[i]\
    \ == \"[\" && brackets[i+1] == \"[\"{\n            two += 1\n        }\n     \
    \   if brackets[i] == \"]\" && brackets[i+1] == \"]\"{\n            two += 1\n\
    \        }\n        if brackets[i] == \"[\" && brackets[i+1] == \"]\"{\n     \
    \       one += 1\n        }\n        if brackets[i] == \"]\" && brackets[i+1]\
    \ == \"[\"{\n            one += 1\n        }\n    }\n    if open == close && one\
    \ == 1 && two == 0{\n        check = true\n    }\n    return check"]
stop_tokens:
- "\n}"
