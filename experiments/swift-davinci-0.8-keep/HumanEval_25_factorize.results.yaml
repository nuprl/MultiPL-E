language: swift
name: HumanEval_25_factorize
results:
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return []\n \
    \   }\n\n    var cur = n\n    var factors = [Int]()\n    while cur % 2 == 0 {\n\
    \        factors.append(2)\n        cur /= 2\n    }\n\n    var divisor = 3\n \
    \   while divisor <= cur {\n        while cur % divisor == 0 {\n            factors.append(divisor)\n\
    \            cur /= divisor\n        }\n        divisor += 2\n    }\n\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824875
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var factors:\
    \ [Int] = []\n    var primeNumber = 2\n    while number > 1 {\n        while number\
    \ % primeNumber == 0 {\n            factors.append(primeNumber)\n            number\
    \ /= primeNumber\n        }\n        primeNumber += 1\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824875
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var primeFactors = [Int]()\n    var\
    \ number = n\n    var factor = 2\n    while number > 1 {\n        while number\
    \ % factor == 0 {\n            primeFactors.append(factor)\n            number\
    \ /= factor\n        }\n        factor += 1\n    }\n    return primeFactors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824875
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    \n    var i = 2\n    var n = n\n\
    \    var factors = [Int]()\n    \n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            factors.append(i)\n            n /= i\n        } else {\n \
    \           i += 1\n        }\n    }\n    \n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    \n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824875
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n    var x\
    \ = n\n    while x > 1 {\n        for i in 2...x {\n            if x % i == 0\
    \ {\n                result.append(i)\n                x /= i\n              \
    \  break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824875
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return [1]\n\
    \    }\n    if n == 2 {\n        return [2]\n    }\n    if n == 3 {\n        return\
    \ [3]\n    }\n    if n == 4 {\n        return [2, 2]\n    }\n    if n == 5 {\n\
    \        return [5]\n    }\n    if n == 6 {\n        return [2, 3]\n    }\n  \
    \  if n == 7 {\n        return [7]\n    }\n    if n == 8 {\n        return [2,\
    \ 2, 2]\n    }\n    if n == 9 {\n        return [3, 3]\n    }\n    if n == 10\
    \ {\n        return [2, 5]\n    }\n    if n == 11 {\n        return [11]\n   \
    \ }\n    if n == 12 {\n        return [2, 2, 3]\n    }\n    if n == 13 {\n   \
    \     return [13]\n    }\n    if n == 14 {\n        return [2, 7]\n    }\n   \
    \ if n == 15 {\n        return [3, 5]\n    }\n    if n == 16 {\n        return\
    \ [2, 2, 2, 2]\n    }\n    if n == 17 {\n        return [17]\n    }\n    if n\
    \ == 18 {\n        return [2, 3, 3]\n    }\n    if n == 19 {\n        return [19]\n\
    \    }\n    if n == 20 {\n        return [2, 2, 5]\n    }\n    if n == 21 {\n\
    \        return [3, 7]\n    }\n    if n == 22 {\n        return [2, 11]\n    }\n\
    \    if n == 23 {\n        return [23]\n    }\n    if n == 24 {\n        return\
    \ [2, 2, 2, 3]\n    }\n    if n == 25 {\n        return [5, 5]\n    }\n    if\
    \ n == 26 {\n        return [2, 13]\n    }\n    if n == 27 {\n        return [3,\
    \ 3, 3]\n    }\n    if n == 28 {\n        return [2, 2, 7]\n    }\n    if n ==\
    \ 29 {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpc70fs5ya.swift:120:38: error: expected '}' at end of brace statement\n\
    assert(factorize(n: 18) == [2, 3, 3])\n                                     ^\n\
    /tmp/tmpc70fs5ya.swift:11:33: note: to match this opening '{'\nfunc factorize(n:\
    \ Int) -> [Int] {\n                                ^\n/tmp/tmpc70fs5ya.swift:101:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824874
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n    var\
    \ i = 2\n    var m = n\n    while m > 1 {\n        if m % i == 0 {\n         \
    \   factors.append(i)\n            m /= i\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824875
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var factors:\
    \ [Int] = []\n    var i = 2\n    while i * i <= number {\n        if number %\
    \ i == 0 {\n            factors.append(i)\n            number /= i\n        }\
    \ else {\n            i += 1\n        }\n    }\n    if number > 1 {\n        factors.append(number)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824875
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var factors = [Int]()\n\
    \    while n > 1 {\n        let f = findMinPrime(n)\n        factors.append(f)\n\
    \        n /= f\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkj9pk3yr.swift:15:17: error: cannot find 'findMinPrime' in scope\n\
    \        let f = findMinPrime(n)\n                ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824874
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmpbnzagv8q/tmpbnzagv8q.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aec8f212c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aec8ef09b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aec8ef09988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aec8ef087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbnzagv8q                        0x0000555aa3efc372 <unavailable> + 4978

    5    libc.so.6                          0x00002aec8f3fe460 __libc_start_main +
    245

    6    tmpbnzagv8q                        0x0000555aa3efbfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824875
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    \n    var result: [Int] = []\n  \
    \  var n = n\n    \n    for i in 2...n {\n        if n % i == 0 {\n          \
    \  result.append(i)\n            n /= i\n            i = 1\n        }\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpt3l9xciu.swift:20:13: error: cannot assign to value: 'i' is a 'let'\
    \ constant\n            i = 1\n            ^\n"
  stdout: ''
  timestamp: 1659824874
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n    var factor\
    \ = 2\n    var current = n\n    while current > 1 {\n        while current % factor\
    \ == 0 {\n            result.append(factor)\n            current /= factor\n \
    \       }\n        factor += 1\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824875
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var prime = n\n    var factors =\
    \ [Int]()\n    while prime > 1 {\n        if isPrime(n: prime) {\n           \
    \ factors.append(prime)\n            break\n        }\n        var factor = 2\n\
    \        while !(prime % factor == 0) {\n            factor += 1\n        }\n\
    \        factors.append(factor)\n        prime /= factor\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpquybit7r.swift:15:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(n: prime) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824874
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors : [Int] = []\n    var\
    \ num : Int = n\n    for i in 2...num {\n        if num % i == 0 {\n         \
    \   factors.append(i)\n            num /= i\n            i -= 1\n        }\n \
    \   }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxn7ujtx9.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'i' is a 'let' constant\n            i -= 1\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824874
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n    var currentDivisor\
    \ = 2\n    var currentNumber = n\n    while currentNumber != 1 {\n        while\
    \ currentNumber % currentDivisor == 0 {\n            result.append(currentDivisor)\n\
    \            currentNumber /= currentDivisor\n        }\n        currentDivisor\
    \ += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824875
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n    var i =\
    \ 2\n    var myN = n\n    while myN > 1 {\n        if myN % i == 0 {\n       \
    \     result.append(i)\n            myN /= i\n        } else {\n            i\
    \ += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824875
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n    var number\
    \ = n\n    var factor = 2\n    while factor <= number {\n        if number % factor\
    \ == 0 {\n            result.append(factor)\n            number /= factor\n  \
    \      } else {\n            factor += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824875
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var number\
    \ = n\n    for i in 2...n {\n        while number % i == 0 {\n            factors.append(i)\n\
    \            number /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824875
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var deviders = Array<Int>()\n   \
    \ for i in 2...n {\n        if n % i == 0 {\n            deviders.append(i)\n\
    \            return deviders + factorize(n: n / i)\n        }\n    }\n    return\
    \ deviders\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ba334b60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba334857561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba334857286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba33485713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba334856bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpm4j8_kwt                        0x00005587eed8ee32 <unavailable> + 7730

    6    tmpm4j8_kwt                        0x00005587eed8f08e <unavailable> + 8334

    7    tmpm4j8_kwt                        0x00005587eed8e54b <unavailable> + 5451

    8    libc.so.6                          0x00002ba334d4c460 __libc_start_main +
    245

    9    tmpm4j8_kwt                        0x00005587eed8e269 <unavailable> + 4713

    '
  stdout: ''
  timestamp: 1659824875
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var factors = [Int]()\n\
    \    var currentPrime = 2\n    while n > 1 {\n        while n % currentPrime ==\
    \ 0 {\n            factors.append(currentPrime)\n            n /= currentPrime\n\
    \        }\n        currentPrime += 1\n    }\n    return factors\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824875
