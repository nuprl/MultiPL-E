name: HumanEval_48_is_palindrome
language: swift
prompt: "\n/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
  /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
  /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfunc is_palindrome(text: String)\
  \ -> Bool {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(is_palindrome(text: \"\") == true)\nassert(is_palindrome(text:\
  \ \"aba\") == true)\nassert(is_palindrome(text: \"aaaaa\") == true)\nassert(is_palindrome(text:\
  \ \"zbcd\") == false)\nassert(is_palindrome(text: \"xywyx\") == true)\nassert(is_palindrome(text:\
  \ \"xywyz\") == false)\nassert(is_palindrome(text: \"xywzx\") == false)"
completions: ["    if text.isEmpty {\n        return true\n    }\n\n    let length\
    \ = text.characters.count\n    let middle = length / 2\n\n    let first_half =\
    \ text.substringToIndex(text.startIndex.advancedBy(middle))\n    let second_half\
    \ = text.substringFromIndex(text.startIndex.advancedBy(middle + length % 2))\n\
    \n    return first_half == String(second_half.characters.reverse())", '    return
    text == String(text.characters.reverse())', '    return text == String(text.characters.reverse())',
  '    return text == reverse(text)', "    let size = text.count\n    for i in 0..<size/2\
    \ {\n        if text[i] != text[size-i-1] {\n            return false\n      \
    \  }\n    }\n    return true", "    // Complete this function so that it returns\
    \ true if the text is a palindrome\n    // and false otherwise\n    return false",
  "    // TODO: complete the implementation of this function\n    // according to\
    \ the docstring above.\n    if text.characters.count == 0 {\n        return true\n\
    \    } else {\n        var reversed: String = \"\"\n        for var i = text.characters.count\
    \ - 1; i >= 0; i-- {\n            let index = text.index(text.startIndex, offsetBy:\
    \ i)\n            reversed += \"\\(text[index])\"\n        }\n        return reversed\
    \ == text\n    }", '    return false', "    if text.isEmpty {\n        return\
    \ true\n    }\n    if text.characters.count == 1 {\n        return true\n    }\n\
    \    let firstChar = text.characters.first!\n    let lastChar = text.characters.last!\n\
    \    let endIndex = text.index(before: text.endIndex)\n    let startIndex = text.index(after:\
    \ text.startIndex)\n    if firstChar == lastChar {\n        return is_palindrome(text:\
    \ text[startIndex..<endIndex])\n    }\n    return false", "    let chars = Array(text)\n\
    \    var start = 0\n    var end = chars.count - 1\n    while (start < end) {\n\
    \        if (chars[start] != chars[end]) {\n            return false\n       \
    \ }\n        start += 1\n        end -= 1\n    }\n    return true", '    return
    text == reverse(text)', "    if text.isEmpty {\n        return true\n    }\n \
    \   let n = text.count\n    let half = n / 2\n    var firstHalf = text[..<text.index(text.startIndex,\
    \ offsetBy: half)]\n    var secondHalf = text[text.index(text.startIndex, offsetBy:\
    \ half)...]\n    if n % 2 == 1 {\n        secondHalf = secondHalf[text.index(after:\
    \ secondHalf.startIndex)...]\n    }\n    let reversed = String(secondHalf.reversed())\n\
    \    return firstHalf == reversed", "    let len = text.characters.count\n   \
    \ if len == 0 {\n        return true\n    }\n\n    var start_index = text.startIndex\n\
    \    var end_index = text.endIndex.predecessor()\n\n    for _ in 0..<len / 2 {\n\
    \        if text[start_index] != text[end_index] {\n            return false\n\
    \        }\n        start_index = start_index.successor()\n        end_index =\
    \ end_index.predecessor()\n    }\n\n    return true", "    let filteredText =\
    \ text.filter { $0.isLetter }.lowercased()\n    return filteredText == String(filteredText.reversed())",
  "    let textCount = text.count\n    guard textCount > 1 else {\n        return\
    \ true\n    }\n    let mid = textCount / 2\n    let start = text.index(text.startIndex,\
    \ offsetBy: 0)\n    let end = text.index(text.startIndex, offsetBy: mid)\n   \
    \ let firstPart = text[start..<end]\n    let reversedSecondPart = text[mid..<textCount].reversed()\n\
    \    for (a, b) in zip(firstPart, reversedSecondPart) {\n        if a != b {\n\
    \            return false\n        }\n    }\n    return true", "    if text.isEmpty\
    \ {\n        return true\n    }\n    var text = text\n    text = String(text.lowercased().reversed())\n\
    \    return text == text.lowercased()", '    return text == String(text.characters.reverse())',
  '    return text == String(text.characters.reverse())', "    if text.isEmpty {\n\
    \        return true\n    }\n    let chars = Array(text)\n    for i in 0...text.count/2\
    \ {\n        if chars[i] != chars[text.count - i - 1] {\n            return false\n\
    \        }\n    }\n    return true", "\tif text.isEmpty {\n\t\treturn true\n\t\
    }\n\n\tif text.count == 1 {\n\t\treturn true\n\t}\n\n\treturn text[text.startIndex]\
    \ == text[text.index(before: text.endIndex)] && is_palindrome(text: String(text.dropFirst().dropLast()))"]
stop_tokens:
- "\n}"
