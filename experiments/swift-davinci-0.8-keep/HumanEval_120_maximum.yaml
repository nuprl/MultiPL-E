name: HumanEval_120_maximum
language: swift
prompt: "\n/// Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n///\
  \ Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example 2:\n///\
  \ Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n/// Input:\
  \ arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n/// 1. The\
  \ length of the array will be in the range of [1, 1000].\n/// 2. The elements in\
  \ the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\n\
  func maximum(arr: [Int], k: Int) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4,\
  \ -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr:\
  \ [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0,\
  \ 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3],\
  \ k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7)\
  \ == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
  \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
  \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
  assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
completions: ["    guard arr.count > 0, k > 0 else {\n        return []\n    }\n \
    \   var result = [Int]()\n    for i in 0..<k {\n        result.append(arr[i])\n\
    \    }\n    result.sort()\n    for i in k..<arr.count {\n        if arr[i] > result[0]\
    \ {\n            result.removeFirst()\n            result.append(arr[i])\n   \
    \         result.sort()\n        }\n    }\n    return result", "    var stack\
    \ = [Int]()\n    var i = 0\n    while i < arr.count {\n        while stack.count\
    \ > 0 && stack.count + arr.count - i > k && arr[i] > stack.last! {\n         \
    \   stack.removeLast()\n        }\n        if stack.count < k {\n            stack.append(arr[i])\n\
    \        }\n        i += 1\n    }\n    return stack", '    return [1]', "    var\
    \ stack = [Int]()\n    for i in 0..<arr.count {\n        while stack.count > 0\
    \ && arr[i] > stack.last! && (stack.count + arr.count - i) > k {\n           \
    \ stack.removeLast()\n        }\n        if stack.count < k {\n            stack.append(arr[i])\n\
    \        }\n    }\n    return stack", "    var result = [Int]()\n    var min =\
    \ 0\n    for number in arr {\n        if result.count < k {\n            result.append(number)\n\
    \            if result.count == k {\n                min = result.index(of: result.min()!)!\n\
    \            }\n        } else {\n            if number > result[min] {\n    \
    \            result[min] = number\n                min = result.index(of: result.min()!)!\n\
    \            }\n        }\n    }\n    return result", "    var result = [Int]()\n\
    \    let count = arr.count\n    if count == 0 || k == 0 {\n        return result\n\
    \    }\n    for index in 0..<count {\n        while result.count > 0 && result.count\
    \ + count - index > k && result.last! < arr[index] {\n            result.removeLast()\n\
    \        }\n        if result.count < k {\n            result.append(arr[index])\n\
    \        }\n    }\n    return result", "    guard arr.count > k else {\n     \
    \   return arr\n    }\n    var stack = [Int]()\n    for number in arr {\n    \
    \    while !stack.isEmpty && stack.count + arr.count - number >= k && stack.last!\
    \ < number {\n            stack.removeLast()\n        }\n        stack.append(number)\n\
    \    }\n    return Array(stack.prefix(k))", "    var heap = Heap(arr: arr, sort:\
    \ <, shouldRemove: {\n        $0.count > k\n    })\n    return heap.arr", "  \
    \  var result = [Int]()\n    if arr.count < k {\n        return result\n    }\n\
    \    for i in 0..<k {\n        let max = findMax(arr: arr, start: i)\n       \
    \ result.append(max)\n    }\n    return result", "    var result = [Int]()\n \
    \   guard arr.count > 0 else {\n        return result\n    }\n    guard arr.count\
    \ > k else {\n        return arr\n    }\n    var heap = PriorityQueue<Int>(sort:\
    \ {$0 > $1})\n    arr.forEach { heap.enqueue($0) }\n    for _ in 0..<k {\n   \
    \     result.append(heap.dequeue()!)\n    }\n    return result", '    return []',
  "    var result = [Int]()\n    for i in 0..<k {\n        var maxNum = Int.min\n\
    \        var maxIndex = -1\n        for j in i..<arr.count {\n            if arr[j]\
    \ > maxNum {\n                maxNum = arr[j]\n                maxIndex = j\n\
    \            }\n        }\n        result.append(maxNum)\n        if maxIndex\
    \ != i {\n            (arr[i], arr[maxIndex]) = (arr[maxIndex], arr[i])\n    \
    \    }\n    }\n    return result", "    var result = [Int]()\n    guard arr.count\
    \ > 0 else {\n        return result\n    }\n    guard arr.count > k else {\n \
    \       return arr\n    }\n    var start = 0\n    var end = k - 1\n    while end\
    \ < arr.count {\n        result.append(arr[start..<end].max()!)\n        start\
    \ += 1\n        end += 1\n    }\n    return result", "    let sorted = arr.sorted()\n\
    \    return Array(sorted.suffix(k))", "    var res = [Int]()\n    for n in arr\
    \ {\n        insert(&res, n, k)\n    }\n    return res", "    guard k > 0 else\
    \ {\n        return []\n    }\n    var result = [Int]()\n    var maxHeap = Heap(array:\
    \ arr, sort: >)\n    while !maxHeap.isEmpty && result.count < k {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var arr = arr\n   \
    \ var i = 0\n    while i < k {\n        var max = arr[0]\n        var maxIndex\
    \ = 0\n        for j in 1..<arr.count {\n            if arr[j] > max {\n     \
    \           max = arr[j]\n                maxIndex = j\n            }\n      \
    \  }\n        arr.remove(at: maxIndex)\n        result.append(max)\n        i\
    \ += 1\n    }\n    return result", "    guard arr.count > 0 else {\n        return\
    \ []\n    }\n    var result = [Int]()\n    for i in 0..<k {\n        var maxIdx\
    \ = i\n        for j in i+1..<arr.count {\n            if arr[j] > arr[maxIdx]\
    \ {\n                maxIdx = j\n            }\n        }\n        result.append(arr[maxIdx])\n\
    \        arr.swapAt(i, maxIdx)\n    }\n    return result", "    var result = [Int]()\n\
    \    for i in 0..<k {\n        result.append(arr[i])\n    }\n    result.sort()\n\
    \    for i in k..<arr.count {\n        var index = 0\n        while index < k\
    \ && arr[i] < result[index] {\n            index += 1\n        }\n        if index\
    \ < k {\n            result.insert(arr[i], at: index)\n            result.removeLast()\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n    var num\
    \ = 0\n    var index = -1\n    var i = 0\n    while i < k {\n        num = arr[i]\n\
    \        index = i\n        for j in i+1..<arr.count {\n            if num < arr[j]\
    \ {\n                num = arr[j]\n                index = j\n            }\n\
    \        }\n        result.append(num)\n        arr.swapAt(i, index)\n       \
    \ i += 1\n    }\n    return result"]
stop_tokens:
- "\n}"
