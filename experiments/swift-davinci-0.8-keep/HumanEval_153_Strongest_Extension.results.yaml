language: swift
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n\t// Your code here\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmpx20eb9xa.swift:19:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1659820750
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    // Find the strongest extension.\n  \
    \  let strongest = extensions.reduce(into: (extension: \"\", CAP: 0, SM: 0)) {\n\
    \        if $1.uppercased() == $1 {\n            $0.CAP += 1\n        } else {\n\
    \            $0.SM += 1\n        }\n        let tmp = $0.CAP - $0.SM\n       \
    \ if tmp > $0.CAP - $0.SM {\n            $0.extension = $1\n        }\n    }\n\
    \    return class_name + \".\" + strongest.extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpb2f18k8j/tmpb2f18k8j.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afad68abc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afad65a2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afad65a2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afad65a17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb2f18k8j                        0x00005592608d961d <unavailable> + 5661

    5    libc.so.6                          0x00002afad6a97460 __libc_start_main +
    245

    6    tmpb2f18k8j                        0x00005592608d91a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659820750
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n\tvar strongest_extension_strength = 0.0\n\
    \tvar strongest_extension_string = \"\"\n\tfor ext in extensions {\n\t\tvar ext_strength\
    \ = Double(get_number_of_caps(string: ext)) - Double(get_number_of_lower_case(string:\
    \ ext))\n\t\tif ext_strength > strongest_extension_strength {\n\t\t\tstrongest_extension_strength\
    \ = ext_strength\n\t\t\tstrongest_extension_string = ext\n\t\t}\n\t}\n\treturn\
    \ class_name + \".\" + strongest_extension_string\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpam517vo6.swift:21:29: error: cannot find 'get_number_of_caps' in\
    \ scope\n                var ext_strength = Double(get_number_of_caps(string:\
    \ ext)) - Double(get_number_of_lower_case(string: ext))\n                    \
    \                      ^~~~~~~~~~~~~~~~~~\n/tmp/tmpam517vo6.swift:21:71: error:\
    \ cannot find 'get_number_of_lower_case' in scope\n                var ext_strength\
    \ = Double(get_number_of_caps(string: ext)) - Double(get_number_of_lower_case(string:\
    \ ext))\n                                                                    \
    \                ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820750
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var class_name = class_name, strongest_extension\
    \ = extensions[0]\n    var strongest_strength = 0.0\n    for var ext in extensions\
    \ {\n        let upper_count = ext.uppercaseString.characters.count\n        let\
    \ lower_count = ext.lowercaseString.characters.count\n        let strength = Double(upper_count\
    \ - lower_count)\n        if strength > strongest_strength {\n            strongest_strength\
    \ = strength\n            strongest_extension = ext\n        }\n    }\n    return\
    \ \"\\(class_name).\\(strongest_extension)\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpqd1opmdo.swift:21:31: error: value of type 'String' has no member\
    \ 'uppercaseString'\n        let upper_count = ext.uppercaseString.characters.count\n\
    \                          ~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpqd1opmdo.swift:22:31:\
    \ error: value of type 'String' has no member 'lowercaseString'\n        let lower_count\
    \ = ext.lowercaseString.characters.count\n                          ~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpqd1opmdo.swift:23:24: error: no exact matches in call to initializer \n\
    \        let strength = Double(upper_count - lower_count)\n                  \
    \     ^\n/tmp/tmpqd1opmdo.swift:23:24: note: found candidate with type '(Builtin.FPIEEE64)\
    \ -> Double'\n        let strength = Double(upper_count - lower_count)\n     \
    \                  ^\n/tmp/tmpqd1opmdo.swift:23:24: note: found candidate with\
    \ type '(Substring) -> Double?'\n        let strength = Double(upper_count - lower_count)\n\
    \                       ^\n/tmp/tmpqd1opmdo.swift:23:24: note: found candidate\
    \ with type '(Int) -> Double'\n        let strength = Double(upper_count - lower_count)\n\
    \                       ^\n/tmp/tmpqd1opmdo.swift:23:24: note: found candidate\
    \ with type '(Float16) -> Double'\n        let strength = Double(upper_count -\
    \ lower_count)\n                       ^\n/tmp/tmpqd1opmdo.swift:23:24: note:\
    \ found candidate with type '(Float) -> Double'\n        let strength = Double(upper_count\
    \ - lower_count)\n                       ^\n/tmp/tmpqd1opmdo.swift:23:24: note:\
    \ found candidate with type '(Double) -> Double'\n        let strength = Double(upper_count\
    \ - lower_count)\n                       ^\n/tmp/tmpqd1opmdo.swift:23:24: note:\
    \ found candidate with type '(Float80) -> Double'\n        let strength = Double(upper_count\
    \ - lower_count)\n                       ^\n"
  stdout: ''
  timestamp: 1659820750
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n\tlet strongest = extensions.map { (extension_name)\
    \ -> Double in\n\t\tvar cap = 0\n\t\tvar sm = 0\n\t\tfor char in extension_name\
    \ {\n\t\t\tif char.isUppercase {\n\t\t\t\tcap += 1\n\t\t\t} else {\n\t\t\t\tsm\
    \ += 1\n\t\t\t}\n\t\t}\n\t\treturn Double(cap - sm)\n\t}\n\treturn \"\\(class_name).\\\
    (extensions[strongest.index(of: strongest.max()!)!])\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp2_cck90i/tmp2_cck90i.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b912efc6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b912ecbdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b912ecbd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b912ecbc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2_cck90i                        0x000055c27292bbed <unavailable> + 7149

    5    libc.so.6                          0x00002b912f1b2460 __libc_start_main +
    245

    6    tmp2_cck90i                        0x000055c27292b779 <unavailable> + 6009

    '
  stdout: ''
  timestamp: 1659820750
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    let class_name = class_name\n    let\
    \ extensions = extensions\n    var strongest = [\"name\": \"\", \"strength\":\
    \ 0.0]\n    for extension_name in extensions {\n        var small_letter_count\
    \ = 0\n        var capital_letter_count = 0\n        for letter in extension_name\
    \ {\n            if letter.isLowercase {\n                small_letter_count +=\
    \ 1\n            } else {\n                capital_letter_count += 1\n       \
    \     }\n        }\n        let strength = Double(capital_letter_count) - Double(small_letter_count)\n\
    \        if strength > strongest[\"strength\"] as! Double {\n            strongest[\"\
    name\"] = extension_name\n            strongest[\"strength\"] = strength\n   \
    \     }\n    }\n    return class_name + \".\" + (strongest[\"name\"] as! String)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpziqzi3wg.swift:20:21: error: heterogeneous collection literal could\
    \ only be inferred to '[String : Any]'; add explicit type annotation if this is\
    \ intentional\n    var strongest = [\"name\": \"\", \"strength\": 0.0]\n     \
    \               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                              \
    \                    as [String : Any]\n"
  stdout: ''
  timestamp: 1659820750
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest: Double = 0\n    var strongest_extension\
    \ = \"\"\n    for ext in extensions {\n        var upper = 0\n        var lower\
    \ = 0\n        for s in ext {\n            if s.isLowercase {\n              \
    \  lower += 1\n            } else {\n                upper += 1\n            }\n\
    \        }\n        let strength = Double(upper) - Double(lower)\n        if strength\
    \ > strongest {\n            strongest = strength\n            strongest_extension\
    \ = ext\n        }\n    }\n    return \"\\(class_name).\\(strongest_extension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpl7x0fkva/tmpl7x0fkva.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6938f06c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6938bfdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6938bfd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6938bfc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl7x0fkva                        0x0000562129e8febc <unavailable> + 7868

    5    libc.so.6                          0x00002b69390f2460 __libc_start_main +
    245

    6    tmpl7x0fkva                        0x0000562129e8f5c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1659820750
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n\tvar strongest_extension = \"\";\n\tvar\
    \ strongest_extension_strength = 0;\n\t\n\tfor ext in extensions {\n\t\tvar num_upper\
    \ = 0;\n\t\tvar num_lower = 0;\n\t\tfor char in ext {\n\t\t\tif char.isUppercase\
    \ {\n\t\t\t\tnum_upper += 1;\n\t\t\t} else {\n\t\t\t\tnum_lower += 1;\n\t\t\t\
    }\n\t\t}\n\t\tif (num_upper - num_lower) > strongest_extension_strength {\n\t\t\
    \tstrongest_extension = ext;\n\t\t\tstrongest_extension_strength = num_upper -\
    \ num_lower;\n\t\t}\n\t}\n\t\n\treturn class_name + \".\" + strongest_extension;\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpsm6jtvw3/tmpsm6jtvw3.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b58e57b8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b58e54afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b58e54af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b58e54ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsm6jtvw3                        0x0000557c5995a7cd <unavailable> + 6093

    5    libc.so.6                          0x00002b58e59a4460 __libc_start_main +
    245

    6    tmpsm6jtvw3                        0x0000557c5995a359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659820750
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongestExtension = \"\"\n    var\
    \ strongestExtensionStrength = 0.0\n    for extension in extensions {\n      \
    \  let strength = Double(extension.filter({$0.isUppercase}).count) - Double(extension.filter({$0.isLowercase}).count)\n\
    \        if (strength > strongestExtensionStrength) {\n            strongestExtensionStrength\
    \ = strength\n            strongestExtension = extension\n        }\n    }\n \
    \   return \"\\(class_name).\\(strongestExtension)\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpm_66tziy.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpm_66tziy.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpm_66tziy.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpm_66tziy.swift:21:31:\
    \ error: expected expression in list of expressions\n        let strength = Double(extension.filter({$0.isUppercase}).count)\
    \ - Double(extension.filter({$0.isLowercase}).count)\n                       \
    \       ^\n/tmp/tmpm_66tziy.swift:21:31: error: consecutive statements on a line\
    \ must be separated by ';'\n        let strength = Double(extension.filter({$0.isUppercase}).count)\
    \ - Double(extension.filter({$0.isLowercase}).count)\n                       \
    \       ^\n                              ;\n/tmp/tmpm_66tziy.swift:21:40: error:\
    \ expected type name in extension declaration\n        let strength = Double(extension.filter({$0.isUppercase}).count)\
    \ - Double(extension.filter({$0.isLowercase}).count)\n                       \
    \                ^\n/tmp/tmpm_66tziy.swift:21:40: error: expected '{' in extension\n\
    \        let strength = Double(extension.filter({$0.isUppercase}).count) - Double(extension.filter({$0.isLowercase}).count)\n\
    \                                       ^\n/tmp/tmpm_66tziy.swift:21:31: error:\
    \ declaration is only valid at file scope\n        let strength = Double(extension.filter({$0.isUppercase}).count)\
    \ - Double(extension.filter({$0.isLowercase}).count)\n                       \
    \       ^\n/tmp/tmpm_66tziy.swift:24:34: error: expected expression in assignment\n\
    \            strongestExtension = extension\n                                \
    \ ^\n/tmp/tmpm_66tziy.swift:25:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpm_66tziy.swift:24:43: error: expected '{' in extension\n\
    \            strongestExtension = extension\n                                \
    \          ^\n/tmp/tmpm_66tziy.swift:24:34: error: declaration is only valid at\
    \ file scope"
  stdout: ''
  timestamp: 1659820750
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var dict = [Int: String]()\n    for ext\
    \ in extensions {\n        var cap = 0\n        var sm = 0\n        for c in ext\
    \ {\n            if c.isUppercase {\n                cap += 1\n            } else\
    \ {\n                sm += 1\n            }\n        }\n        dict[cap - sm]\
    \ = ext\n    }\n    let max = dict.keys.max()\n    return \"\\(class_name).\\\
    (dict[max!]!)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp0c6emedy/tmp0c6emedy.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acc7cdadc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc7caa4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acc7caa4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acc7caa37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0c6emedy                        0x000056501734b1fc <unavailable> + 8700

    5    libc.so.6                          0x00002acc7cf99460 __libc_start_main +
    245

    6    tmp0c6emedy                        0x000056501734a909 <unavailable> + 6409

    '
  stdout: ''
  timestamp: 1659820750
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n  var strength = -Double.infinity\n  var\
    \ highest: String = \"\"\n  for extension in extensions {\n    let caps = extension.characters.filter\
    \ { $0.isUppercase }.count\n    let sml = extension.characters.filter { $0.isLowercase\
    \ }.count\n    let curr_strength = Double(caps - sml)\n    if curr_strength >\
    \ strength {\n      strength = curr_strength\n      highest = extension\n    }\n\
    \  }\n  return \"\\(class_name).\\(highest)\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpbly70koe.swift:20:7: error: expected pattern\n  for extension in\
    \ extensions {\n      ^\n/tmp/tmpbly70koe.swift:20:7: error: expected Sequence\
    \ expression for for-each loop\n  for extension in extensions {\n      ^\n/tmp/tmpbly70koe.swift:20:7:\
    \ error: expected '{' to start the body of for-each loop\n  for extension in extensions\
    \ {\n      ^\n/tmp/tmpbly70koe.swift:21:16: error: expected initial value after\
    \ '='\n    let caps = extension.characters.filter { $0.isUppercase }.count\n \
    \              ^\n/tmp/tmpbly70koe.swift:21:15: error: consecutive statements\
    \ on a line must be separated by ';'\n    let caps = extension.characters.filter\
    \ { $0.isUppercase }.count\n              ^\n              ;\n/tmp/tmpbly70koe.swift:21:25:\
    \ error: expected type name in extension declaration\n    let caps = extension.characters.filter\
    \ { $0.isUppercase }.count\n                        ^\n/tmp/tmpbly70koe.swift:21:25:\
    \ error: expected '{' in extension\n    let caps = extension.characters.filter\
    \ { $0.isUppercase }.count\n                        ^\n/tmp/tmpbly70koe.swift:21:16:\
    \ error: declaration is only valid at file scope\n    let caps = extension.characters.filter\
    \ { $0.isUppercase }.count\n               ^\n/tmp/tmpbly70koe.swift:22:15: error:\
    \ expected initial value after '='\n    let sml = extension.characters.filter\
    \ { $0.isLowercase }.count\n              ^\n/tmp/tmpbly70koe.swift:22:14: error:\
    \ consecutive statements on a line must be separated by ';'\n    let sml = extension.characters.filter\
    \ { $0.isLowercase }.count\n             ^\n             ;\n/tmp/tmpbly70koe.swift:22:24:\
    \ error: expected type name in extension declaration\n    let sml = extension.characters.filter\
    \ { $0.isLowercase }.count\n                       ^\n/tmp/tmpbly70koe.swift:22:24:\
    \ error: expected '{' in extension\n    let sml = extension.characters.filter\
    \ { $0.isLowercase }.count\n                       ^\n/tmp/tmpbly70koe.swift:22:15:\
    \ error: declaration is only valid at file scope\n    let sml = extension.characters.filter\
    \ { $0.isLowercase }.count\n              ^\n/tmp/tmpbly70koe.swift:26:17: e"
  stdout: ''
  timestamp: 1659820750
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n  var strongest = \"\"\n  var strongest_strength\
    \ = 0\n  for ext in extensions {\n    let cap = ext.filter { $0.isUppercase }.count\n\
    \    let sm = ext.filter { $0.isLowercase }.count\n    let strength = Float(cap\
    \ - sm)\n    if strength == Float(strongest_strength) {\n      continue\n    }\n\
    \    if strength > Float(strongest_strength) {\n      strongest = ext\n      strongest_strength\
    \ = cap - sm\n    }\n  }\n  return \"\\(class_name).\\(strongest)\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpbbzovtm0/tmpbbzovtm0.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04d69f3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04d66eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04d66ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04d66e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbbzovtm0                        0x000055fbae2dcf4c <unavailable> + 8012

    5    libc.so.6                          0x00002b04d6bdf460 __libc_start_main +
    245

    6    tmpbbzovtm0                        0x000055fbae2dc659 <unavailable> + 5721

    '
  stdout: ''
  timestamp: 1659820750
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongestExtension = \"\";\n    var\
    \ strongestStrength = 0;\n    for ext in extensions {\n        let letters = ext.characters;\n\
    \        var strength = 0;\n        for letter in letters {\n            if letter\
    \ >= \"A\" && letter <= \"Z\" {\n                strength += 1;\n            }\
    \ else if letter >= \"a\" && letter <= \"z\" {\n                strength -= 1;\n\
    \            }\n        }\n        if strength > strongestStrength {\n       \
    \     strongestStrength = strength;\n            strongestExtension = ext;\n \
    \       }\n    }\n    return \"\\(class_name).\\(strongestExtension)\";\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp4rvjgex5.swift:21:27: error: 'characters' is unavailable: Please\
    \ use String directly\n        let letters = ext.characters;\n               \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659820750
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    // The strength of the extension is as\
    \ follows:\n    // Let CAP be the number of the uppercase letters in the extension's\
    \ name,\n    // and let SM be the number of lowercase letters in the extension's\
    \ name,\n    // the strength is given by the fraction CAP - SM.\n    func strength_of_extension(extension_name:\
    \ String) -> Float {\n        var CAP = 0, SM = 0\n        for letter in extension_name\
    \ {\n            if letter.isUppercase {\n                CAP += 1\n         \
    \   } else {\n                SM += 1\n            }\n        }\n        return\
    \ Float(CAP) - Float(SM)\n    }\n    // Strongest extension's name\n    var strongest_extension_name\
    \ = \"\"\n    // Strongest extension's strength\n    var strongest_extension_strength\
    \ = 0.0\n    for extension_name in extensions {\n        let strength = strength_of_extension(extension_name:\
    \ extension_name)\n        if strength > strongest_extension_strength {\n    \
    \        strongest_extension_name = extension_name\n            strongest_extension_strength\
    \ = strength\n        }\n    }\n    return \"\\(class_name).\\(strongest_extension_name)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpftrj7gfd.swift:39:21: error: binary operator '>' cannot be applied\
    \ to operands of type 'Float' and 'Double'\n        if strength > strongest_extension_strength\
    \ {\n           ~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpftrj7gfd.swift:41:44:\
    \ error: cannot assign value of type 'Float' to type 'Double'\n            strongest_extension_strength\
    \ = strength\n                                           ^~~~~~~~\n          \
    \                                 Double( )\n"
  stdout: ''
  timestamp: 1659820750
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpk9i1zuij/tmpk9i1zuij.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84ff3bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84ff0b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84ff0b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84ff0b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk9i1zuij                        0x0000555a47e624fd <unavailable> + 5373

    5    libc.so.6                          0x00002b84ff5aa460 __libc_start_main +
    245

    6    tmpk9i1zuij                        0x0000555a47e62089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659820750
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n\tvar strongest_extension_name = \"\"\n\t\
    var strongest_extension_strength = 0.0\n\tfor (index,extension_name) in extensions.enumerated()\
    \ {\n\t\tvar upper_letters = 0\n\t\tvar lower_letters = 0\n\t\tfor letter in extension_name\
    \ {\n\t\t\tif letter.isUppercase {\n\t\t\t\tupper_letters += 1\n\t\t\t} else {\n\
    \t\t\t\tlower_letters += 1\n\t\t\t}\n\t\t}\n\t\tlet strength = Double(upper_letters)\
    \ - Double(lower_letters)\n\t\tif strength > strongest_extension_strength {\n\t\
    \t\tstrongest_extension_strength = strength\n\t\t\tstrongest_extension_name =\
    \ extension_name\n\t\t} else if strength == strongest_extension_strength {\n\t\
    \t\tif index < extensions.index(of: strongest_extension_name)! {\n\t\t\t\tstrongest_extension_name\
    \ = extension_name\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\\(class_name).\\(strongest_extension_name)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp4lw6i4fi/tmp4lw6i4fi.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4801966c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b480165db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b480165d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b480165c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4lw6i4fi                        0x000055f851539c6d <unavailable> + 7277

    5    libc.so.6                          0x00002b4801b52460 __libc_start_main +
    245

    6    tmp4lw6i4fi                        0x000055f8515397f9 <unavailable> + 6137

    '
  stdout: ''
  timestamp: 1659820750
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpk9i1zuij/tmpk9i1zuij.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84ff3bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84ff0b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84ff0b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84ff0b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk9i1zuij                        0x0000555a47e624fd <unavailable> + 5373

    5    libc.so.6                          0x00002b84ff5aa460 __libc_start_main +
    245

    6    tmpk9i1zuij                        0x0000555a47e62089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659820750
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n\treturn \"my_class.AA\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp7983h7m7/tmp7983h7m7.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b15d1f0ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b15d1c01b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b15d1c01988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b15d1c007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7983h7m7                        0x000055965696c4fd <unavailable> + 5373

    5    libc.so.6                          0x00002b15d20f6460 __libc_start_main +
    245

    6    tmp7983h7m7                        0x000055965696c089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659820750
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n\tvar strongestExt = \"\";\n\tvar strongestExtStrength\
    \ = 0;\n\tfor ext in extensions {\n\t\tlet cap = [Character](ext.uppercaseString);\n\
    \t\tlet sm = [Character](ext.lowercaseString);\n\t\tvar extStrength = 0;\n\t\t\
    for ch in cap {\n\t\t\tif let ascii = ch.asciiValue {\n\t\t\t\textStrength +=\
    \ Int(ascii);\n\t\t\t}\n\t\t}\n\t\tfor ch in sm {\n\t\t\tif let ascii = ch.asciiValue\
    \ {\n\t\t\t\textStrength -= Int(ascii);\n\t\t\t}\n\t\t}\n\t\tif extStrength >\
    \ strongestExtStrength {\n\t\t\tstrongestExtStrength = extStrength;\n\t\t\tstrongestExt\
    \ = ext;\n\t\t}\n\t}\n\treturn class_name + \".\" + strongestExt;\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpd9d0j0it.swift:21:29: error: value of type 'String' has no member\
    \ 'uppercaseString'\n                let cap = [Character](ext.uppercaseString);\n\
    \                                      ~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpd9d0j0it.swift:22:28:\
    \ error: value of type 'String' has no member 'lowercaseString'\n            \
    \    let sm = [Character](ext.lowercaseString);\n                            \
    \         ~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820750
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var str = \"\"\n    var strongest = 0\n\
    \    for i in 0..<extensions.count {\n        var cap = 0\n        var sm = 0\n\
    \        for j in 0..<extensions[i].count {\n            if extensions[i][extensions[i].index(extensions[i].startIndex,\
    \ offsetBy: j)].isUppercase {\n                cap += 1\n            } else {\n\
    \                sm += 1\n            }\n        }\n        if cap - sm > strongest\
    \ {\n            strongest = cap - sm\n            str = extensions[i]\n     \
    \   }\n    }\n    return class_name + \".\" + str\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpumjt2dym/tmpumjt2dym.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac7e6d32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac7e6a29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac7e6a29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac7e6a287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpumjt2dym                        0x0000556249d3593d <unavailable> + 6461

    5    libc.so.6                          0x00002ac7e6f1e460 __libc_start_main +
    245

    6    tmpumjt2dym                        0x0000556249d354c9 <unavailable> + 5321

    '
  stdout: ''
  timestamp: 1659820750
