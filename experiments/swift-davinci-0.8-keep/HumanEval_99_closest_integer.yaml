name: HumanEval_99_closest_integer
language: swift
prompt: "\n/// Create a function that takes a value (string) representing a number\n\
  /// and returns the closest integer to it. If the number is equidistant\n/// from\
  \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
  10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
  \ away from zero means that if the given number is equidistant\n/// from two integers,\
  \ the one you should return is the one that is the\n/// farthest from zero. For\
  \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
  -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\n\
  assert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value: \"\
  -15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
  \ \"0\") == 0)"
completions: ["    let doubleValue = Double(value)\n    let smallestInteger = Int(doubleValue!)\n\
    \    let largestInteger = smallestInteger + 1\n    let differenceSmallest = abs(smallestInteger\
    \ - doubleValue!)\n    let differenceLargest = abs(largestInteger - doubleValue!)\n\
    \    if differenceSmallest > differenceLargest {\n        return largestInteger\n\
    \    } else {\n        return smallestInteger\n    }", "    let floatValue = Float(value)\n\
    \    let doubleValue = Double(value)\n    if floatValue == nil && doubleValue\
    \ == nil {\n        return -1\n    }\n    let intValue = Int(value)\n    var decimalPart\
    \ = floatValue != nil ? fmodf(floatValue!, 1) : fmod(doubleValue!, 1)\n    if\
    \ decimalPart == 0 {\n        return intValue\n    }\n    decimalPart = decimalPart\
    \ < 0 ? decimalPart * -1 : decimalPart\n    let decimalPoint = decimalPart * 10\n\
    \    if decimalPoint == 5.0 {\n        return intValue + (intValue < 0 ? -1 :\
    \ 1)\n    }\n    let roundedDecimalPoint = Int(round(decimalPoint))\n    return\
    \ intValue + (roundedDecimalPoint > 5 ? 1 : 0)", '    return 0', "    // ...\n\
    \    return 0", '    return Int(value)!', "  let number = Double(value)!\n  let\
    \ rounded = number.rounded()\n  if rounded > number {\n    return Int(rounded\
    \ - 1)\n  }\n  return Int(rounded)", "    // Convert value to Double\n    let\
    \ doubleValue = (value as NSString).doubleValue\n    // Get the absolute value\n\
    \    let absValue = abs(doubleValue)\n    // Get the Int value from the double\n\
    \    let floorValue = floor(absValue)\n    // Check if the double value is already\
    \ an Int\n    if absValue == floorValue {\n        // Return the Int\n       \
    \ return Int(doubleValue)\n    }\n    // Get the fractional value\n    let fraction\
    \ = absValue - floorValue\n    // If the fractional value is greater than or equal\
    \ to 0.5, then increment the Int value\n    if fraction >= 0.5 {\n        return\
    \ Int(doubleValue) + 1\n    }\n    // Otherwise just return the Int value\n  \
    \  return Int(doubleValue)", "    var closest: Int = 0\n    let value_double:\
    \ Double = Double(value)!\n    if value_double > 0 {\n        closest = Int(value_double.rounded(.up))\n\
    \    } else {\n        closest = Int(value_double.rounded(.down))\n    }\n   \
    \ return closest", "    let val = Double(value)!\n    let integer = Int(val)\n\
    \    if val - Double(integer) >= 0.5 {\n        return integer + 1\n    } else\
    \ {\n        return integer\n    }", "    let valueDouble = Double(value)\n  \
    \  let lowerBound = floor(valueDouble!)\n    let upperBound = ceil(valueDouble!)\n\
    \    let half = lowerBound + ((upperBound - lowerBound) / 2)\n    return half\
    \ >= valueDouble! ? Int(lowerBound) : Int(upperBound)", "    if let number = Double(value)\
    \ {\n        let number = round(number)\n        return Int(number)\n    }\n \
    \   return 0", '    return Int(Double(value)!.rounded(.awayFromZero))', "    guard\
    \ let double = Double(value) else {\n        return 0\n    }\n    return Int(double.rounded(.awayFromZero))",
  "    if let inputDouble = Double(value) {\n        return Int(round(inputDouble))\n\
    \    }\n    return 0", '    return Int(value.floatValue.rounded())', "\tif let\
    \ number = Double(value) {\n\t\treturn Int(number.rounded(.awayFromZero))\n\t\
    }\n\treturn 0", "    guard !value.isEmpty else { return 0 }\n    guard let number\
    \ = Double(value) else { return 0 }\n    let left = Int(floor(number))\n    let\
    \ right = Int(ceil(number))\n    let distanceLeft = abs(number - Double(left))\n\
    \    let distanceRight = abs(number - Double(right))\n    return distanceLeft\
    \ > distanceRight ? right : left", "    let decimal = Double(value)!\n    let\
    \ rounded = round(decimal)\n    return Int(rounded)", "    let num = Double(value)!\n\
    \    return Int(num.rounded(.toNearestOrAwayFromZero))", "    var closest = Int(value)\
    \ ?? 0\n    if value.contains(\".\") {\n        let values = value.split(separator:\
    \ \".\")\n        let value1 = Double(values[0]) ?? 0\n        let value2 = Double(values[1])\
    \ ?? 0\n        if value2 > 0 {\n            closest = Int(value1 + 1)\n     \
    \   }\n    }\n    return closest"]
stop_tokens:
- "\n}"
