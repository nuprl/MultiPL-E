name: HumanEval_76_is_simple_power
language: swift
prompt: "\n/// Your task is to write a function that returns true if a number x is\
  \ a simple\n/// power of n and false in other cases.\n/// x is a simple power of\
  \ n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
  \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) => false\n\
  /// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\nfunc is_simple_power(x:\
  \ Int, n: Int) -> Bool {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(is_simple_power(x: 16, n: 2) == true)\n\
  assert(is_simple_power(x: 143214, n: 16) == false)\nassert(is_simple_power(x: 4,\
  \ n: 2) == true)\nassert(is_simple_power(x: 9, n: 3) == true)\nassert(is_simple_power(x:\
  \ 16, n: 4) == true)\nassert(is_simple_power(x: 24, n: 2) == false)\nassert(is_simple_power(x:\
  \ 128, n: 4) == false)\nassert(is_simple_power(x: 12, n: 6) == false)\nassert(is_simple_power(x:\
  \ 1, n: 1) == true)\nassert(is_simple_power(x: 1, n: 12) == true)"
completions: ["    if x == 0 {\n        return false\n    }\n    if n == 0 {\n   \
    \     return x == 1\n    }\n    var i = 1\n    while i < x {\n        i *= n\n\
    \    }\n    return i == x", "    if x <= 0 || n <= 0 {\n        return false\n\
    \    }\n    let divided = Double(x) / pow(Double(n), floor(log(Double(x)) / log(Double(n))))\n\
    \    return Int(divided) == Int(round(divided))", "    let root: Double = pow(Double(x),\
    \ 1 / Double(n))\n    return root - Double(Int(root)) == 0", "    if x == 0 {\n\
    \        return false\n    }\n    var k = 1\n    while k <= x {\n        if k\
    \ == x {\n            return true\n        }\n        k *= n\n    }\n    return\
    \ false", "  if n == 1 {\n    return x == 1\n  }\n  var pow = 1\n  while pow <\
    \ x {\n    pow *= n\n  }\n  return pow == x", "    guard x > 0, n > 0 else { return\
    \ false }\n    return Int(pow(Double(n), Double(Int(log(Double(x)) / log(Double(n))))))\
    \ == x", "    if n == 1 {\n        return false\n    }\n    if n == 0 {\n    \
    \    return x == 1\n    }\n    return (1..<30).reduce(false) { $0 || Int(pow(Double(n),\
    \ Double($1))) == x }", "    let logBaseN = log(Double(x)) / log(Double(n))\n\
    \    return logBaseN.truncatingRemainder(dividingBy: 1) == 0", '    return x.isMultiple(of:
    n) && (1..<sqrt(Double(x))).contains(where: { x.isMultiple(of: $0) })', "    if\
    \ x <= 0 || n <= 0 {\n        return false\n    }\n    for i in 0...(x / n) {\n\
    \        if x == n * n {\n            return true\n        }\n    }\n    return\
    \ false", '    return (n > 1 && x % n == 0 && x.isPow(of: n))', "    let a = log(Double(x))\
    \ / log(Double(n))\n    if a.truncatingRemainder(dividingBy: 1) == 0 {\n     \
    \   return true\n    }\n    return false", "    var num = x\n    if num == 1 {\n\
    \        return true\n    }\n    while num % n == 0 {\n        num /= n\n    }\n\
    \    return num == 1", "    if x < 1 || n < 1 {\n        return false\n    }\n\
    \    var m = x\n    var i = 1\n    while m > 1 {\n        m /= n\n        i +=\
    \ 1\n    }\n    return m == 1 && pow(n, i) == x", '    return pow(Decimal(n),
    Int(log(Decimal(x)) / log(Decimal(n)))) == Decimal(x)', "    guard n != 0 else\
    \ { return false }\n    guard n != 1 else { return true }\n    var temp = 1\n\
    \    while temp < x {\n        temp *= n\n    }\n    return temp == x", "    if\
    \ x % n == 0 && x / n % n == 0 {\n        return true\n    }\n    return false",
  "    if x == 0 {\n        return true\n    }\n    var x = x\n    var n = n\n   \
    \ while x % n == 0 {\n        x /= n\n    }\n    return x == 1", "    return Double(x).truncatingRemainder(dividingBy:\
    \ 1) == 0 &&\n        log(Double(x)) / log(Double(n)).truncatingRemainder(dividingBy:\
    \ 1) == 0", '    return (pow(Double(n), Double(x.log(base: n))) == Double(x))']
stop_tokens:
- "\n}"
