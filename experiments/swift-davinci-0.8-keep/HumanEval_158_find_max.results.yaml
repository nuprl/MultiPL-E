language: swift
name: HumanEval_158_find_max
results:
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var lexicographical = \"\"\n \
    \   var maximum = 0\n    for word in words {\n        if Set(word).count > maximum\
    \ {\n            maximum = Set(word).count\n            lexicographical = word\n\
    \        }\n    }\n    return lexicographical\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmpqsff9e94/tmpqsff9e94.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6071454c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607114bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607114b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607114a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqsff9e94                        0x0000558f6202e933 <unavailable> + 6451

    5    libc.so.6                          0x00002b6071640460 __libc_start_main +
    245

    6    tmpqsff9e94                        0x0000558f6202e359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013512
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxWord = \"\"\n    var maxUnique\
    \ = 0\n    for word in words {\n        let unique = Set(word.map { $0 }).count\n\
    \        if unique > maxUnique {\n            maxUnique = unique\n           \
    \ maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmp47s54ugm/tmp47s54ugm.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9876833c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b987652ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b987652a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b98765297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp47s54ugm                        0x00005611d1f2a9a3 <unavailable> + 6563

    5    libc.so.6                          0x00002b9876a1f460 __libc_start_main +
    245

    6    tmp47s54ugm                        0x00005611d1f2a3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660013512
- exit_code: 0
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var dict: [String: Int] = [:]\n\
    \    words.forEach { word in\n        dict[word] = Set(word).count\n    }\n  \
    \  dict = dict.filter { $0.value == dict.values.max() }\n    return dict.sorted\
    \ { $0.key < $1.key }.first!.key\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013512
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpx1huwk1e/tmpx1huwk1e.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab72f8c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab72f5bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab72f5ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab72f5b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx1huwk1e                        0x000055e0c8bac4ce <unavailable> + 5326

    5    libc.so.6                          0x00002ab72faaf460 __libc_start_main +
    245

    6    tmpx1huwk1e                        0x000055e0c8bac089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013512
- exit_code: 0
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    guard words.count > 0 else {\n\
    \        return \"\"\n    }\n    var max = words[0]\n    var max_set = Set(words[0])\n\
    \    var max_count = max_set.count\n    for word in words {\n        let set =\
    \ Set(word)\n        if set.count > max_count {\n            max = word\n    \
    \        max_set = set\n            max_count = max_set.count\n        } else\
    \ if set.count == max_count {\n            if word < max {\n                max\
    \ = word\n                max_set = set\n                max_count = max_set.count\n\
    \            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013512
- exit_code: 0
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = (word: \"\", count:\
    \ 0)\n    for word in words {\n        let count = Set(word).count\n        if\
    \ count > max.count {\n            max = (word, count)\n        } else if count\
    \ == max.count {\n            if word < max.word {\n                max = (word,\
    \ count)\n            }\n        }\n    }\n    return max.word\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013512
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    guard !words.isEmpty else { return\
    \ \"\" }\n    let set = words.map { $0.utf8.unique() }\n    let max = set.max\
    \ { $0.count < $1.count }\n    guard let index = set.firstIndex(of: max ?? [])\
    \ else { return \"\" }\n    return words[index]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmppnepu8dm.swift:11:35: error: value of type 'String.UTF8View' has\
    \ no member 'unique'\n    let set = words.map { $0.utf8.unique() }\n         \
    \                 ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013512
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var count = 0\n    var uniqueWord\
    \ = \"\"\n    for element in words {\n        let uniqueCount = Set(element).count\n\
    \        if uniqueCount > count {\n            count = uniqueCount\n         \
    \   uniqueWord = element\n        }\n    }\n    return uniqueWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpbh8743pr/tmpbh8743pr.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad8f2c70c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8f2967b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad8f2967988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8f29667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbh8743pr                        0x00005615618f5933 <unavailable> + 6451

    5    libc.so.6                          0x00002ad8f2e5c460 __libc_start_main +
    245

    6    tmpbh8743pr                        0x00005615618f5359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013512
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    let wordsWithUniqueChars: [(String,\
    \ Set<Character>)] = words.map { (word) -> (String, Set<Character>) in\n     \
    \   let chars = Set(word)\n        return (word, chars)\n    }\n    let sortedWords\
    \ = wordsWithUniqueChars.sorted { (lhs, rhs) -> Bool in\n        if lhs.1.count\
    \ > rhs.1.count {\n            return true\n        } else if lhs.1.count == rhs.1.count\
    \ {\n            return lhs.0 < rhs.0\n        } else {\n            return false\n\
    \        }\n    }\n    return sortedWords.last!.0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmpvne_gtxx/tmpvne_gtxx.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b134a241c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1349f38b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1349f38988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1349f377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvne_gtxx                        0x000055e93314a8de <unavailable> + 6366

    5    libc.so.6                          0x00002b134a42d460 __libc_start_main +
    245

    6    tmpvne_gtxx                        0x000055e93314a499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013512
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    if words.count == 0 {\n      \
    \  return \"\"\n    }\n    if words.count == 1 {\n        return words[0]\n  \
    \  }\n    var set = [String: Set<Character>]()\n    words.forEach { set[$0] =\
    \ Set($0.characters) }\n    let sorted = set.sorted(by: { $0.value.count < $1.value.count\
    \ })\n    let max = sorted.last!.value.count\n    var res = [String]()\n    for\
    \ (k, v) in sorted {\n        if v.count == max {\n            res.append(k)\n\
    \        }\n    }\n    let sortedByLex = res.sorted(by: { $0 < $1 })\n    return\
    \ sortedByLex.first!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpx9j085sf.swift:17:38: error: 'characters' is unavailable: Please\
    \ use String directly\n    words.forEach { set[$0] = Set($0.characters) }\n  \
    \                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013512
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var resultWord = words[0]\n  \
    \  var resultCount = 0\n    for word in words {\n        let wordSet = Set(word)\n\
    \        if wordSet.count > resultCount {\n            resultCount = wordSet.count\n\
    \            resultWord = word\n        }\n    }\n    return resultWord\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpe29s54kg/tmpe29s54kg.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afff9674c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afff936bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afff936b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afff936a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe29s54kg                        0x00005596d2a7a993 <unavailable> + 6547

    5    libc.so.6                          0x00002afff9860460 __libc_start_main +
    245

    6    tmpe29s54kg                        0x00005596d2a7a3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013512
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max: String = \"\"\n    var\
    \ maxLength: Int = 0\n    var index: Int = 0\n    var count: Int = 0\n    for\
    \ word in words {\n        count = 0\n        for index in 0..<word.count {\n\
    \            if word.index(of: word[index]) == word.endIndex {\n             \
    \   count += 1\n            }\n        }\n        if count > maxLength {\n   \
    \         maxLength = count\n            max = word\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpavl89nio.swift:17:21: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n            if word.index(of: word[index]) == word.endIndex\
    \ {\n                    ^\n/tmp/tmpavl89nio.swift:17:21: note: use 'firstIndex(of:)'\
    \ instead\n            if word.index(of: word[index]) == word.endIndex {\n   \
    \                 ^~~~~\n                    firstIndex\n/tmp/tmpavl89nio.swift:17:31:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if word.index(of: word[index]) == word.endIndex\
    \ {\n                              ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpavl89nio.swift:12:9: warning: variable\
    \ 'index' was never used; consider replacing with '_' or removing it\n    var\
    \ index: Int = 0\n        ^~~~~\n        _\n"
  stdout: ''
  timestamp: 1660013512
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    \n    var maxUniqueCharCount:\
    \ Int = 0\n    var maxUniqueChar: String = \"\"\n    \n    for word in words {\n\
    \        let wordArray = Array(word)\n        var tempWord = wordArray\n     \
    \   var uniqueCharCount = 0\n        \n        for (index, letter) in wordArray.enumerated()\
    \ {\n            let result = tempWord.removeFirst(index)\n            if !result.contains(letter)\
    \ {\n                uniqueCharCount += 1\n            }\n        }\n        \n\
    \        if uniqueCharCount > maxUniqueCharCount {\n            maxUniqueCharCount\
    \ = uniqueCharCount\n            maxUniqueChar = word\n        }\n    }\n    \n\
    \    return maxUniqueChar\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp8aw_f_81.swift:20:17: warning: constant 'result' inferred to have\
    \ type '()', which may be unexpected\n            let result = tempWord.removeFirst(index)\n\
    \                ^\n/tmp/tmp8aw_f_81.swift:20:17: note: add an explicit type annotation\
    \ to silence this warning\n            let result = tempWord.removeFirst(index)\n\
    \                ^\n                      : ()\n/tmp/tmp8aw_f_81.swift:21:24:\
    \ error: value of tuple type '()' has no member 'contains'\n            if !result.contains(letter)\
    \ {\n                ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013512
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    // Convert array to a tuple for\
    \ easier handling\n    let wordsTuple = words.enumerated().sorted{($0.1 < $1.1)}\n\
    \    var max = 0\n    var letterSet: Set<Character> = []\n    var maxIdx = 0\n\
    \    for (i, word) in wordsTuple {\n        letterSet = Set(word)\n        if\
    \ letterSet.count > max {\n            max = letterSet.count\n            maxIdx\
    \ = i\n        }\n    }\n    return wordsTuple[maxIdx].1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpwdigdvev/tmpwdigdvev.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4eb4a0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4eb4703b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4eb4703988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4eb47027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwdigdvev                        0x0000561e5e943bc3 <unavailable> + 7107

    5    libc.so.6                          0x00002b4eb4bf8460 __libc_start_main +
    245

    6    tmpwdigdvev                        0x0000561e5e9435e9 <unavailable> + 5609

    '
  stdout: ''
  timestamp: 1660013512
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var unique_chars_counts = [String:\
    \ Int]()\n    for word in words {\n        unique_chars_counts[word] = word.countUniqueCharacters()\n\
    \    }\n    let max_count = unique_chars_counts.values.max()\n    var unique_words\
    \ = [String]()\n    for word in unique_chars_counts.keys {\n        if unique_chars_counts[word]\
    \ == max_count {\n            unique_words.append(word)\n        }\n    }\n  \
    \  return unique_words.sorted()[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpohkj1upk.swift:12:42: error: value of type 'String' has no member\
    \ 'countUniqueCharacters'\n        unique_chars_counts[word] = word.countUniqueCharacters()\n\
    \                                    ~~~~ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013512
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    let uniqueCount = words.map {\n\
    \        return ($0, $0.unicodeScalars.count)\n    }\n    let maxCount = uniqueCount.map\
    \ {\n        return $0.1\n    }.max() ?? 0\n    let result = uniqueCount.filter\
    \ {\n        return $0.1 == maxCount\n    }.map {\n        return $0.0\n    }.sorted().first\
    \ ?? \"\"\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp_lcg_i03/tmp_lcg_i03.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2efb1d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2efaecbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2efaecb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2efaeca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_lcg_i03                        0x000055c664ea85ee <unavailable> + 9710

    5    libc.so.6                          0x00002b2efb3c0460 __libc_start_main +
    245

    6    tmp_lcg_i03                        0x000055c664ea74f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1660013512
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n  let map = words.map({(word: String)\
    \ -> (String, Int) in\n    let set = Set(word.characters)\n    return (word, set.count)\n\
    \  })\n  let sorted = map.sort({(a, b) -> Bool in\n    if a.1 == b.1 {\n     \
    \ return a.0 < b.0\n    }\n    return a.1 > b.1\n  })\n  return sorted[0].0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp51dtiu4m.swift:11:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    let set = Set(word.characters)\n                  \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp51dtiu4m.swift:14:20:\
    \ error: cannot use mutating member on immutable value: 'map' is a 'let' constant\n\
    \  let sorted = map.sort({(a, b) -> Bool in\n               ~~~ ^\n/tmp/tmp51dtiu4m.swift:10:3:\
    \ note: change 'let' to 'var' to make it mutable\n  let map = words.map({(word:\
    \ String) -> (String, Int) in\n  ^~~\n  var\n/tmp/tmp51dtiu4m.swift:14:25: error:\
    \ missing argument label 'by:' in call\n  let sorted = map.sort({(a, b) -> Bool\
    \ in\n                        ^\n                        by: \n"
  stdout: ''
  timestamp: 1660013512
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    guard words.count > 0 else { return\
    \ \"\" }\n    var result = words[0]\n    var largestSize = Set(result).count\n\
    \    for word in words[1...] {\n        let wordSize = Set(word).count\n     \
    \   if wordSize > largestSize {\n            largestSize = wordSize\n        \
    \    result = word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp0u7fojwk/tmp0u7fojwk.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af8e61fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af8e5ef1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af8e5ef1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8e5ef07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0u7fojwk                        0x0000556ac27b7b93 <unavailable> + 7059

    5    libc.so.6                          0x00002af8e63e6460 __libc_start_main +
    245

    6    tmp0u7fojwk                        0x0000556ac27b75b9 <unavailable> + 5561

    '
  stdout: ''
  timestamp: 1660013512
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    return words.max(by: {\n     \
    \   $0.count < $1.count\n    })!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp1iahaszs/tmp1iahaszs.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae918e17c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae918b0eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae918b0e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae918b0d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1iahaszs                        0x000055ab0fe8d7b3 <unavailable> + 6067

    5    libc.so.6                          0x00002ae919003460 __libc_start_main +
    245

    6    tmp1iahaszs                        0x000055ab0fe8d1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013512
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxStr = \"\"\n    var maxLen\
    \ = 0\n    var alphabets = [String:Int]()\n    for str in words {\n        for\
    \ c in str.characters {\n            alphabets[String(c)] = 1\n        }\n   \
    \     if alphabets.count > maxLen {\n            maxLen = alphabets.count\n  \
    \          maxStr = str\n        }\n        alphabets.removeAll()\n    }\n   \
    \ return maxStr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpqstk7lx7.swift:14:22: error: 'characters' is unavailable: Please\
    \ use String directly\n        for c in str.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013512
