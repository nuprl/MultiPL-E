language: swift
name: HumanEval_78_hex_key
results:
- exit_code: 0
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    let num = num.map {(c: Character) -> Int in\n        if let code\
    \ = Int(String(c), radix: 16) {\n            return code\n        }\n        return\
    \ 0\n    }\n    let digits = num.filter {(num: Int) -> Bool in\n        if num\
    \ == 2 || num == 3 || num == 5 || num == 7 || num == 11 || num == 13 {\n     \
    \       return true\n        }\n        return false\n    }\n    return digits.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014012
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    if num.count == 0 {\n        return 0\n    }\n    var hexes: [Character]\
    \ = [Character]()\n    var counter: Int = 0\n    for c in num {\n        if c\
    \ >= \"A\" && c <= \"F\" {\n            hexes.append(c)\n        }\n    }\n  \
    \  for hex in hexes {\n        if is_prime(n: Int(String(hex), radix: 16)!) {\n\
    \            counter += 1\n        }\n    }\n    return counter\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpdifvgt49.swift:30:12: error: cannot find 'is_prime' in scope\n\
    \        if is_prime(n: Int(String(hex), radix: 16)!) {\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014012
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n\tvar dict: [Character: Int] = [\"0\": 0, \"1\": 1, \"2\": 2, \"3\"\
    : 3, \"4\": 4, \"5\": 5, \"6\": 6, \"7\": 7, \"8\": 8, \"9\": 9, \"A\": 10, \"\
    B\": 11, \"C\": 12, \"D\": 13, \"E\": 14, \"F\": 15]\n\tvar res = 0\n\tvar num\
    \ = num\n\tfor key in dict.keys {\n\t\twhile num.contains(key) {\n\t\t\tres +=\
    \ isPrime(num: dict[key]!) ? 1 : 0\n\t\t\tnum = num.replacingOccurrences(of: \"\
    \\(key)\", with: \"\")\n\t\t}\n\t}\n\treturn res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpg9uu_gsi.swift:24:11: error: cannot find 'isPrime' in scope\n \
    \                       res += isPrime(num: dict[key]!) ? 1 : 0\n            \
    \                   ^~~~~~~\n/tmp/tmpg9uu_gsi.swift:25:14: error: value of type\
    \ 'String' has no member 'replacingOccurrences'\n                        num =\
    \ num.replacingOccurrences(of: \"\\(key)\", with: \"\")\n                    \
    \          ~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014012
- exit_code: 0
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    let hex = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"\
    8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n    let primes = [\"2\",\"3\"\
    ,\"5\",\"7\",\"B\",\"D\"]\n    var count = 0\n    for i in num {\n        if primes.contains(String(i))\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014012
- exit_code: 0
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    let num = num.uppercased()\n    let primes: Set<Character> = [\"\
    2\", \"3\", \"5\", \"7\", \"B\", \"D\"]\n    return num.filter { primes.contains($0)\
    \ }.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014012
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    let allowed = \"23456789ABD\".characters.map{ String($0) }\n \
    \   return allowed.filter{ num.characters.contains($0.characters.first!) }.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpxrm21mbu.swift:19:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    let allowed = \"23456789ABD\".characters.map{ String($0)\
    \ }\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpxrm21mbu.swift:20:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    return allowed.filter{ num.characters.contains($0.characters.first!)\
    \ }.count\n                               ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpxrm21mbu.swift:20:55: error: 'characters'\
    \ is unavailable: Please use String directly\n    return allowed.filter{ num.characters.contains($0.characters.first!)\
    \ }.count\n                                                      ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014012
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    let hex_primes = [0x2, 0x3, 0x5, 0x7, 0xb, 0xd]\n    let n = num.unicodeScalars.filter({(hex_primes.contains($0.value)\
    \ || (0xa...0xf).contains($0.value))}).count\n    return n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpbect67ic.swift:20:64: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'Int'\n    let n = num.unicodeScalars.filter({(hex_primes.contains($0.value)\
    \ || (0xa...0xf).contains($0.value))}).count\n                               \
    \                                ^\n                                         \
    \                   Int(    )\n"
  stdout: ''
  timestamp: 1660014012
- exit_code: 0
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    var arr = Array(num)\n    var count = 0\n    for i in 0..<arr.count\
    \ {\n        if arr[i] == \"2\" || arr[i] == \"3\" || arr[i] == \"5\" || arr[i]\
    \ == \"7\" || arr[i] == \"B\" || arr[i] == \"D\" {\n            count += 1\n \
    \       }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014012
- exit_code: 0
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    let primes = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"]\n    var\
    \ result = 0\n    for c in num {\n        if primes.contains(String(c)) {\n  \
    \          result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014012
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    let hex = \"0123456789ABCDEF\"\n    let primes = [2, 3, 5, 7,\
    \ 11, 13]\n    return num.filter { primes.contains(hex.firstIndex(of: $0)! + 1)\
    \ }.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpv8mgfjld.swift:21:63: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    return num.filter { primes.contains(hex.firstIndex(of:\
    \ $0)! + 1) }.count\n                                                        \
    \      ^\n"
  stdout: ''
  timestamp: 1660014012
- exit_code: 0
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    let hex_nums = [2, 3, 5, 7, 11, 13]\n    var total = 0\n    let\
    \ array = Array(num)\n    for i in array {\n        let char_to_int = Int(String(i),\
    \ radix: 16)\n        let hex_num = hex_nums.filter({$0 == char_to_int})\n   \
    \     if hex_num.count > 0 {\n            total += 1\n        }\n    }\n    return\
    \ total\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014012
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    let hexes = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"]\n    return\
    \ num.filter { hexes.contains($0) }.count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpl9u9tugp.swift:20:40: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n    return num.filter\
    \ { hexes.contains($0) }.count\n                                       ^\n"
  stdout: ''
  timestamp: 1660014012
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    var res = 0\n    for i in num {\n        if isHexPrime(i) {\n\
    \            res += 1\n        }\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp66iecrlf.swift:21:12: error: cannot find 'isHexPrime' in scope\n\
    \        if isHexPrime(i) {\n           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014012
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    let regex = try! NSRegularExpression(pattern: \"([2-7]|[B-D])\"\
    , options: [])\n    let matches = regex.matches(in: num, options: [], range: NSRange(location:\
    \ 0, length: num.count))\n    return matches.count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpa_kt13ip.swift:19:22: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = try! NSRegularExpression(pattern: \"([2-7]|[B-D])\"\
    , options: [])\n                     ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpa_kt13ip.swift:20:62:\
    \ error: cannot find 'NSRange' in scope\n    let matches = regex.matches(in: num,\
    \ options: [], range: NSRange(location: 0, length: num.count))\n             \
    \                                                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014012
- exit_code: 0
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    var primes = [2, 3, 5, 7, 11, 13]\n    var count = 0\n    for\
    \ c in num {\n        let ch = \"\\(c)\"\n        if let n = Int(ch, radix: 16)\
    \ {\n            if primes.contains(n) {\n                count += 1\n       \
    \     }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014012
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: Exception
  stderr: 'tmptyfn3uup/tmptyfn3uup.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3e2d0bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3e2a02b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3e2a02988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3e2a017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptyfn3uup                        0x0000562d694eb264 <unavailable> + 4708

    5    libc.so.6                          0x00002ac3e2ef7460 __libc_start_main +
    245

    6    tmptyfn3uup                        0x0000562d694eaee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014012
- exit_code: 0
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    var output = 0\n    let hexes = [\"0\", \"1\", \"2\", \"3\", \"\
    4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"\
    F\"]\n    let primes = [2, 3, 5, 7, 11, 13]\n    for digit in num {\n        if\
    \ primes.contains(hexes.firstIndex(of: String(digit))!) {\n            output\
    \ += 1\n        }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014012
- exit_code: 0
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    let hex_prime_digits = [\"2\", \"3\", \"5\", \"7\", \"B\", \"\
    D\"]\n    var result = 0\n    for digit in num {\n        if hex_prime_digits.contains(String(digit))\
    \ {\n            result += 1\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014012
- exit_code: 0
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    let prime = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"]\n    var\
    \ num_arr = [Character]()\n    for c in num {\n        num_arr.append(c)\n   \
    \ }\n    return num_arr.filter({prime.contains($0.description)}).count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014012
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfunc hex_key(num: String)\
    \ -> Int {\n    let hexDigits = \"0123456789ABCDEF\"\n    let hexPrimes = \"2357BDF\"\
    \n    let setPrimes = Set(hexPrimes.characters)\n    let setDigits = Set(hexDigits.characters)\n\
    \    let isValid = Array(num.characters).reduce(true) { (acc, ch) in acc && setDigits.contains(ch)\
    \ }\n    return isValid ? Array(num.characters).reduce(0) { (acc, ch) in acc +\
    \ (setPrimes.contains(ch) ? 1 : 0) } : 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpc18ayvu_.swift:21:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    let setPrimes = Set(hexPrimes.characters)\n       \
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpc18ayvu_.swift:22:35: error: 'characters' is unavailable:\
    \ Please use String directly\n    let setDigits = Set(hexDigits.characters)\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpc18ayvu_.swift:23:29: error: 'characters' is unavailable:\
    \ Please use String directly\n    let isValid = Array(num.characters).reduce(true)\
    \ { (acc, ch) in acc && setDigits.contains(ch) }\n                           \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpc18ayvu_.swift:24:32:\
    \ error: 'characters' is unavailable: Please use String directly\n    return isValid\
    \ ? Array(num.characters).reduce(0) { (acc, ch) in acc + (setPrimes.contains(ch)\
    \ ? 1 : 0) } : 0\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014012
