name: HumanEval_87_get_row
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n\
    \    {\n        foreach(j, col; row)\n        {\n            if(col == x)\n  \
    \          {\n                result ~= tuple(i, j);\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3t3b1o6k.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp3t3b1o6k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n\
    \    {\n        foreach(j, col; row)\n        {\n            if(col == x)\n  \
    \          {\n                result ~= tuple(i, j);\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpebhn66ob.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpebhn66ob.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n\
    \    {\n        foreach(j, col; row)\n        {\n            if(col == x)\n  \
    \          {\n                result ~= tuple(i, j);\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5tcho8ju.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp5tcho8ju.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n\
    \    {\n        foreach(j, col; row)\n        {\n            if(col == x)\n  \
    \          {\n                result ~= tuple(i, j);\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzk4mj2em.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpzk4mj2em.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n\
    \    {\n        foreach(j, item; row)\n        {\n            if(item == x)\n\
    \            {\n                result ~= tuple(i, j);\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptm323tn0.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmptm323tn0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n\
    \    {\n        foreach(j, col; row)\n        {\n            if(col == x)\n  \
    \          {\n                result ~= tuple(i, j);\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpii7fa33y.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpii7fa33y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    auto result = new Tuple!(long, long)[];\n    foreach(i,\
    \ row; lst)\n    {\n        foreach(j, item; row)\n        {\n            if(item\
    \ == x)\n            {\n                result ~= tuple(i, j);\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwvuwuli5.d(25): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `Tuple!(long, long)[]`\\'s\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpwvuwuli5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(row; 0 .. lst.length)\n\
    \    {\n        foreach(col; 0 .. lst[row].length)\n        {\n            if(lst[row][col]\
    \ == x)\n            {\n                result ~= tuple(row, col);\n         \
    \   }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpys_d4ti8.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpys_d4ti8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    auto result = new Tuple!(long, long)[];\n    foreach(i,\
    \ row; lst)\n    {\n        foreach(j, elem; row)\n        {\n            if(elem\
    \ == x)\n            {\n                result ~= tuple(i, j);\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy8qebh0f.d(25): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `Tuple!(long, long)[]`\\'s\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpy8qebh0f.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n\
    \    {\n        foreach(j, col; row)\n        {\n            if(col == x)\n  \
    \          {\n                result ~= tuple(i, j);\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq5o5wqu3.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpq5o5wqu3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n\
    \    {\n        foreach(j, item; row)\n        {\n            if(item == x)\n\
    \            {\n                result ~= tuple(i, j);\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaywoeu82.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpaywoeu82.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    auto res = [];\n    foreach(i, row; lst) \n    {\n   \
    \     foreach(j, col; row) \n        {\n            if(col == x) \n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res.sort!((a, b) => a[0] > b[0] || (a[0] == b[0] && a[1] < b[1]));\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyrnk2zjs.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `void[]`\\n/tmp/tmpyrnk2zjs.d(36): Error: no property `sort` for type\
    \ `void[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyrnk2zjs.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n\
    \    {\n        foreach(j, col; row)\n        {\n            if(col == x)\n  \
    \          {\n                res ~= tuple(i, j);\n            }\n        }\n\
    \    }\n    res.sort!((a, b) => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1n3p9ijl.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\n/tmp/tmp1n3p9ijl.d(36): Error: no property\
    \ `sort` for type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp1n3p9ijl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n\
    \    {\n        foreach(j, col; row)\n        {\n            if(col == x)\n  \
    \          {\n                res ~= tuple(i, j);\n            }\n        }\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp23sc9w5_.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp23sc9w5_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n\
    \    {\n        foreach(j, col; row)\n        {\n            if(col == x)\n  \
    \          {\n                result ~= tuple(i, j);\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuuptuf4s.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpuuptuf4s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n\
    \    {\n        foreach(j, item; row)\n        {\n            if(item == x)\n\
    \            {\n                result ~= tuple(i, j);\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_3q1pn51.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp_3q1pn51.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    auto res = [];\n    foreach(i, row; lst)\n    {\n    \
    \    foreach(j, col; row)\n        {\n            if(col == x)\n            {\n\
    \                res ~= tuple(i, j);\n            }\n        }\n    }\n    res.sort!((a,\
    \ b) => a[0] > b[0] || (a[0] == b[0] && a[1] < b[1]));\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy3qpzsm5.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `void[]`\\n/tmp/tmpy3qpzsm5.d(36): Error: no property `sort` for type\
    \ `void[]`\\n/tmp/tmpy3qpzsm5.d(37): Error: cannot implicitly convert expression\
    \ `res` of type `void[]` to `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpy3qpzsm5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\
    \ \n    {\n        foreach(j, col; row) \n        {\n            if(col == x)\
    \ \n            {\n                result ~= tuple(i, j);\n            }\n   \
    \     }\n    }\n    return result.sort!((a, b) => a[0] < b[0] || (a[0] == b[0]\
    \ && a[1] > b[1]));\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppd3cpxxy.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\n/tmp/tmppd3cpxxy.d(36): Error: no property\
    \ `sort` for type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmppd3cpxxy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    auto result = new Tuple!(long, long)[];\n    foreach(i,\
    \ row; lst)\n    {\n        foreach(j, col; row)\n        {\n            if(col\
    \ == x)\n            {\n                result ~= tuple(i, j);\n            }\n\
    \        }\n    }\n    return result.sort!((a, b) => a[0] < b[0] || (a[0] == b[0]\
    \ && a[1] > b[1]));\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptfn5k9dq.d(25): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `Tuple!(long, long)[]`\\'s\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmptfn5k9dq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n\
    \    {\n        foreach(j, col; row)\n        {\n            if(col == x)\n  \
    \          {\n                result ~= tuple(i, j);\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg9ajcte5.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpg9ajcte5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
