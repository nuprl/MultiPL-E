language: d
name: HumanEval_123_get_odd_collatz
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n > 1) {\n        if (n\
    \ % 2 == 1) {\n            result ~= n;\n        }\n        n = n % 2 == 0 ? n\
    \ / 2 : n * 3 + 1;\n    }\n    result ~= 1;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L,\
    \ 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp2qomn7w8.d(39): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp2qomn7w8.__unittest_L35_C1() [0x427f72]\n??:?
    void tmp2qomn7w8.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x8b137554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp37vemksn.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp37vemksn.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp37vemksn.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x4fa1f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpuplqtw7g.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpuplqtw7g.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpuplqtw7g.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x3043c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp46uzrro9.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp46uzrro9.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp46uzrro9.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xe4735554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : n * 3 + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpmr30g047.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpmr30g047.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpmr30g047.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x35e14554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long[] temp = new long[0];\n \
    \   long[] temp2 = new long[0];\n    long[] temp3 = new long[0];\n    long[] temp4\
    \ = new long[0];\n    long[] temp5 = new long[0];\n    long[] temp6 = new long[0];\n\
    \    long[] temp7 = new long[0];\n    long[] temp8 = new long[0];\n    long[]\
    \ temp9 = new long[0];\n    long[] temp10 = new long[0];\n    long[] temp11 =\
    \ new long[0];\n    long[] temp12 = new long[0];\n    long[] temp13 = new long[0];\n\
    \    long[] temp14 = new long[0];\n    long[] temp15 = new long[0];\n    long[]\
    \ temp16 = new long[0];\n    long[] temp17 = new long[0];\n    long[] temp18 =\
    \ new long[0];\n    long[] temp19 = new long[0];\n    long[] temp20 = new long[0];\n\
    \    long[] temp21 = new long[0];\n    long[] temp22 = new long[0];\n    long[]\
    \ temp23 = new long[0];\n    long[] temp24 = new long[0];\n    long[] temp25 =\
    \ new long[0];\n    long[] temp26 = new long[0];\n    long[] temp27 = new long[0];\n\
    \    long[] temp28 = new long[0];\n    long[] temp29 = new long[0];\n    long[]\
    \ temp30 = new long[0];\n    long[] temp31 = new long[0];\n    long[] temp32 =\
    \ new long[0];\n    long[] temp33 = new long[0];\n    long[] temp34 = new long[0];\n\
    \    long[] temp35 = new long[0];\n    long[] temp36 = new long[0];\n    long[]\
    \ temp37 = new long[0];\n    long[] temp38 = new long[0];\n    long[] temp39 =\
    \ new long[0];\n    long[] temp40 = new long[0];\n    long[] temp41 = new long[0];\n\
    \    long[] temp42 = new\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6liwwivb.d(68): Error: basic type expected, not `unittest`\n/tmp/tmp6liwwivb.d(68):
    Error: semicolon expected, not `unittest`\n/tmp/tmp6liwwivb.d(68): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6liwwivb.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    long[] temp = new long[0];\n\
    \    long[] result = new long[0];\n    long i = n;\n    while(i != 1)\n    {\n\
    \        if(i % 2 == 0)\n        {\n            i = i / 2;\n        }\n      \
    \  else\n        {\n            i = 3 * i + 1;\n        }\n        collatz ~=\
    \ i;\n    }\n    foreach(i; collatz)\n    {\n        if(i % 2 != 0)\n        {\n\
    \            temp ~= i;\n        }\n    }\n    result = temp.sort();\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptdxtm9l7.d(41): Error: variable `i` is shadowing variable `tmptdxtm9l7.get_odd_collatz.i`\n/tmp/tmptdxtm9l7.d(48):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmptdxtm9l7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[];\n    long num = n;\n    while (num !=\
    \ 1)\n    {\n        if (num % 2 == 1)\n        {\n            result ~= num;\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : 3 * num + 1;\n    }\n    result\
    \ ~= 1;\n    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpafjgedev.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpafjgedev.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    if (n == 1)\n    {\n        result\
    \ ~= 1;\n        return result;\n    }\n    while (n != 1)\n    {\n        if\
    \ (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n = n\
    \ % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpuep9m33o.d(46): unittest failure\n----------------\n??:?
    _d_unittestp [0x428405]\n??:? void tmpuep9m33o.__unittest_L42_C1() [0x427fb2]\n??:?
    void tmpuep9m33o.__modtest() [0x428188]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ce37]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bcca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430815]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4307a1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bca1]\n??:? runModuleUnitTests [0x42cc0d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428854]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287db]\n??:? _d_run_main [0x428746]\n??:? main [0x42819b]\n??:?
    __libc_start_main [0x825a5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = [n];\n    while (n != 1) \n    {\n        if (n\
    \ % 2 == 0) \n        {\n            n /= 2;\n        } \n        else \n    \
    \    {\n            n = 3 * n + 1;\n        }\n        collatz ~= n;\n    }\n\
    \    return collatz.filter!(a => a % 2 == 1).sort();\n}\nunittest\n{\n    alias\
    \ candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L, 7L, 11L,\
    \ 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxzql1_2q.d(38): Error: no property `filter` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxzql1_2q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 != 0)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp7zeph2r1.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp7zeph2r1.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp7zeph2r1.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xe10ef554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    // TODO: implement this function.\n    long[] result = new long[0];\n\
    \    long[] temp = new long[0];\n    long[] temp2 = new long[0];\n    long[] temp3\
    \ = new long[0];\n    long[] temp4 = new long[0];\n    long[] temp5 = new long[0];\n\
    \    long[] temp6 = new long[0];\n    long[] temp7 = new long[0];\n    long[]\
    \ temp8 = new long[0];\n    long[] temp9 = new long[0];\n    long[] temp10 = new\
    \ long[0];\n    long[] temp11 = new long[0];\n    long[] temp12 = new long[0];\n\
    \    long[] temp13 = new long[0];\n    long[] temp14 = new long[0];\n    long[]\
    \ temp15 = new long[0];\n    long[] temp16 = new long[0];\n    long[] temp17 =\
    \ new long[0];\n    long[] temp18 = new long[0];\n    long[] temp19 = new long[0];\n\
    \    long[] temp20 = new long[0];\n    long[] temp21 = new long[0];\n    long[]\
    \ temp22 = new long[0];\n    long[] temp23 = new long[0];\n    long[] temp24 =\
    \ new long[0];\n    long[] temp25 = new long[0];\n    long[] temp26 = new long[0];\n\
    \    long[] temp27 = new long[0];\n    long[] temp28 = new long[0];\n    long[]\
    \ temp29 = new long[0];\n    long[] temp30 = new long[0];\n    long[] temp31 =\
    \ new long[0];\n    long[] temp32 = new long[0];\n    long[] temp33 = new long[0];\n\
    \    long[] temp34 = new long[0];\n    long[] temp35 = new long[0];\n    long[]\
    \ temp36 = new long[0];\n    long[] temp37 = new long[0];\n    long[] temp38 =\
    \ new long[0];\n    long[] temp39 = new long[0];\n    long[] temp40 = new long[0];\n\
    \    long[] temp41 = new long[\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsv1pclvx.d(68): Error: expression expected, not `unittest`\n/tmp/tmpsv1pclvx.d(69):
    Error: found `{` when expecting `]`\n/tmp/tmpsv1pclvx.d(70): Error: semicolon
    expected, not `alias`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsv1pclvx.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n > 1)\n    {\n       \
    \ if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n =\
    \ n % 2 == 0 ? n / 2 : n * 3 + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpricjj8ne.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpricjj8ne.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpricjj8ne.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xe2543554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = [1L];\n    while (n != 1)\n    {\n        if (n\
    \ % 2 == 0)\n        {\n            n /= 2;\n        }\n        else\n       \
    \ {\n            n = 3 * n + 1;\n            result ~= n;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n\
    \    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpgjasg6m_.d(44): unittest failure\n----------------\n??:?
    _d_unittestp [0x42838d]\n??:? void tmpgjasg6m_.__unittest_L40_C1() [0x427f3a]\n??:?
    void tmpgjasg6m_.__modtest() [0x428110]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cd63]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bbf6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430649]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430af8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4305d5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bbcd]\n??:? runModuleUnitTests [0x42cb39]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287dc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428763]\n??:? _d_run_main [0x4286ce]\n??:? main [0x428123]\n??:?
    __libc_start_main [0xc9786554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    long i = n;\n    while (i !=\
    \ 1)\n    {\n        if (i % 2 == 1)\n        {\n            collatz ~= i;\n \
    \       }\n        i = i % 2 == 0 ? i / 2 : 3 * i + 1;\n    }\n    collatz ~=\
    \ 1;\n    return collatz;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmprfh1x9an.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmprfh1x9an.__unittest_L38_C1() [0x427f7a]\n??:?
    void tmprfh1x9an.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0x10dc2554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpoixjsobz.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpoixjsobz.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpoixjsobz.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x263a7554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmppm0duviz.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmppm0duviz.__unittest_L37_C1() [0x427f72]\n??:?
    void tmppm0duviz.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xf562d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[];\n    long current = n;\n    while (current\
    \ != 1)\n    {\n        if (current % 2 == 1)\n        {\n            result ~=\
    \ current;\n        }\n        current = (current % 2 == 0) ? current / 2 : current\
    \ * 3 + 1;\n    }\n    result ~= 1;\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L, 7L, 11L,\
    \ 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuqlnd15k.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpuqlnd15k.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : n * 3 + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpmr30g047.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpmr30g047.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpmr30g047.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x35e14554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long current = n;\n    while (current\
    \ != 1)\n    {\n        if (current % 2 == 1)\n        {\n            result ~=\
    \ current;\n        }\n        current = current % 2 == 0 ? current / 2 : current\
    \ * 3 + 1;\n    }\n    result ~= 1;\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L, 7L, 11L,\
    \ 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpvsqvqz3f.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmpvsqvqz3f.__unittest_L38_C1() [0x427f7a]\n??:?
    void tmpvsqvqz3f.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0x8202554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long num = n;\n    while (num\
    \ != 1)\n    {\n        if (num % 2 == 1)\n        {\n            result ~= num;\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1;\n    }\n    result\
    \ ~= 1;\n    return result.sort();\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3bm_88i4.d(36): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3bm_88i4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    if (n <= 0)\n        return [];\n    if (n == 1)\n        return\
    \ [1];\n    long[] result = [n];\n    while (n != 1)\n    {\n        if (n % 2\
    \ == 0)\n            n /= 2;\n        else\n            n = 3 * n + 1;\n     \
    \   if (n % 2 != 0)\n            result ~= n;\n    }\n    return result.sort();\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4c2ahzd6.d(39): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4c2ahzd6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1)\n    {\n     \
    \   if (n % 2 == 1)\n        {\n            collatz ~= n;\n        }\n       \
    \ n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return\
    \ collatz;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpfg03tudt.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpfg03tudt.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpfg03tudt.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xa5efd554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[];\n    long[] collatz = new long[];\n\
    \    while (n != 1)\n    {\n        if (n % 2 == 0)\n        {\n            n\
    \ = n / 2;\n        }\n        else\n        {\n            n = 3 * n + 1;\n \
    \       }\n        collatz ~= n;\n    }\n    foreach (i; collatz)\n    {\n   \
    \     if (i % 2 != 0)\n        {\n            result ~= i;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n\
    \    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmy2u25vk.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpmy2u25vk.d(26): Error: new
    can only create structs, dynamic arrays or class objects, not `long[]`\''s\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmy2u25vk.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = [1L];\n    while (n != 1)\n    {\n        if (n\
    \ % 2 == 0)\n        {\n            n /= 2;\n        }\n        else\n       \
    \ {\n            n = 3 * n + 1;\n            result ~= n;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n\
    \    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpgjasg6m_.d(44): unittest failure\n----------------\n??:?
    _d_unittestp [0x42838d]\n??:? void tmpgjasg6m_.__unittest_L40_C1() [0x427f3a]\n??:?
    void tmpgjasg6m_.__modtest() [0x428110]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cd63]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bbf6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430649]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430af8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4305d5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bbcd]\n??:? runModuleUnitTests [0x42cb39]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287dc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428763]\n??:? _d_run_main [0x4286ce]\n??:? main [0x428123]\n??:?
    __libc_start_main [0xc9786554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : n * 3 + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpmr30g047.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpmr30g047.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpmr30g047.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x35e14554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long[] collatz = new long[0];\n\
    \    long[] temp = new long[0];\n    long[] temp2 = new long[0];\n    long[] temp3\
    \ = new long[0];\n    long[] temp4 = new long[0];\n    long[] temp5 = new long[0];\n\
    \    long[] temp6 = new long[0];\n    long[] temp7 = new long[0];\n    long[]\
    \ temp8 = new long[0];\n    long[] temp9 = new long[0];\n    long[] temp10 = new\
    \ long[0];\n    long[] temp11 = new long[0];\n    long[] temp12 = new long[0];\n\
    \    long[] temp13 = new long[0];\n    long[] temp14 = new long[0];\n    long[]\
    \ temp15 = new long[0];\n    long[] temp16 = new long[0];\n    long[] temp17 =\
    \ new long[0];\n    long[] temp18 = new long[0];\n    long[] temp19 = new long[0];\n\
    \    long[] temp20 = new long[0];\n    long[] temp21 = new long[0];\n    long[]\
    \ temp22 = new long[0];\n    long[] temp23 = new long[0];\n    long[] temp24 =\
    \ new long[0];\n    long[] temp25 = new long[0];\n    long[] temp26 = new long[0];\n\
    \    long[] temp27 = new long[0];\n    long[] temp28 = new long[0];\n    long[]\
    \ temp29 = new long[0];\n    long[] temp30 = new long[0];\n    long[] temp31 =\
    \ new long[0];\n    long[] temp32 = new long[0];\n    long[] temp33 = new long[0];\n\
    \    long[] temp34 = new long[0];\n    long[] temp35 = new long[0];\n    long[]\
    \ temp36 = new long[0];\n    long[] temp37 = new long[0];\n    long[] temp38 =\
    \ new long[0];\n    long[] temp39 = new long[0];\n    long[] temp40 = new long[0];\n\
    \    long[] temp41 = new\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp57d18x4w.d(68): Error: basic type expected, not `unittest`\n/tmp/tmp57d18x4w.d(68):
    Error: semicolon expected, not `unittest`\n/tmp/tmp57d18x4w.d(68): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp57d18x4w.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long[] temp = new long[0];\n \
    \   long[] temp2 = new long[0];\n    long[] temp3 = new long[0];\n    long[] temp4\
    \ = new long[0];\n    long[] temp5 = new long[0];\n    long[] temp6 = new long[0];\n\
    \    long[] temp7 = new long[0];\n    long[] temp8 = new long[0];\n    long[]\
    \ temp9 = new long[0];\n    long[] temp10 = new long[0];\n    long[] temp11 =\
    \ new long[0];\n    long[] temp12 = new long[0];\n    long[] temp13 = new long[0];\n\
    \    long[] temp14 = new long[0];\n    long[] temp15 = new long[0];\n    long[]\
    \ temp16 = new long[0];\n    long[] temp17 = new long[0];\n    long[] temp18 =\
    \ new long[0];\n    long[] temp19 = new long[0];\n    long[] temp20 = new long[0];\n\
    \    long[] temp21 = new long[0];\n    long[] temp22 = new long[0];\n    long[]\
    \ temp23 = new long[0];\n    long[] temp24 = new long[0];\n    long[] temp25 =\
    \ new long[0];\n    long[] temp26 = new long[0];\n    long[] temp27 = new long[0];\n\
    \    long[] temp28 = new long[0];\n    long[] temp29 = new long[0];\n    long[]\
    \ temp30 = new long[0];\n    long[] temp31 = new long[0];\n    long[] temp32 =\
    \ new long[0];\n    long[] temp33 = new long[0];\n    long[] temp34 = new long[0];\n\
    \    long[] temp35 = new long[0];\n    long[] temp36 = new long[0];\n    long[]\
    \ temp37 = new long[0];\n    long[] temp38 = new long[0];\n    long[] temp39 =\
    \ new long[0];\n    long[] temp40 = new long[0];\n    long[] temp41 = new long[0];\n\
    \    long[] temp42 = new\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6liwwivb.d(68): Error: basic type expected, not `unittest`\n/tmp/tmp6liwwivb.d(68):
    Error: semicolon expected, not `unittest`\n/tmp/tmp6liwwivb.d(68): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6liwwivb.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = [];\n    while (n != 1) \n    {\n        if (n %\
    \ 2 == 1) \n        {\n            result ~= n;\n        }\n        n = n % 2\
    \ == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpggcp6bp8.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmpggcp6bp8.__unittest_L37_C1() [0x427f76]\n??:?
    void tmpggcp6bp8.__modtest() [0x42814c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cda3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc36]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430689]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b38]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430615]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc0d]\n??:? runModuleUnitTests [0x42cb79]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x42815f]\n??:?
    __libc_start_main [0x5bbc5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    if (n == 1) return [1];\n    long[] collatz = [n];\n    while (n\
    \ != 1) {\n        if (n % 2 == 0) n /= 2;\n        else n = n * 3 + 1;\n    \
    \    collatz ~= n;\n    }\n    return collatz.filter!(a => a % 2 == 1).array;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi7ewa4ap.d(32): Error: no property `filter` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi7ewa4ap.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[];\n    long i = n;\n    while (i != 1)\n\
    \    {\n        if (i % 2 == 0)\n        {\n            i /= 2;\n        }\n \
    \       else\n        {\n            i = 3 * i + 1;\n        }\n        if (i\
    \ % 2 != 0)\n        {\n            collatz ~= i;\n        }\n    }\n    collatz\
    \ ~= 1;\n    return collatz;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqsezxdda.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpqsezxdda.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = [1L];\n    while (n != 1) \n    {\n        if (n\
    \ % 2 == 0) \n        {\n            n /= 2;\n        } \n        else \n    \
    \    {\n            n = 3 * n + 1;\n            result ~= n;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n\
    \    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpr0i20x2u.d(44): unittest failure\n----------------\n??:?
    _d_unittestp [0x42838d]\n??:? void tmpr0i20x2u.__unittest_L40_C1() [0x427f3a]\n??:?
    void tmpr0i20x2u.__modtest() [0x428110]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cd63]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bbf6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430649]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430af8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4305d5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bbcd]\n??:? runModuleUnitTests [0x42cb39]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287dc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428763]\n??:? _d_run_main [0x4286ce]\n??:? main [0x428123]\n??:?
    __libc_start_main [0xf4859554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    long[] result = new long[0];\n\
    \    long[] temp = new long[0];\n    long[] temp2 = new long[0];\n    long[] temp3\
    \ = new long[0];\n    long[] temp4 = new long[0];\n    long[] temp5 = new long[0];\n\
    \    long[] temp6 = new long[0];\n    long[] temp7 = new long[0];\n    long[]\
    \ temp8 = new long[0];\n    long[] temp9 = new long[0];\n    long[] temp10 = new\
    \ long[0];\n    long[] temp11 = new long[0];\n    long[] temp12 = new long[0];\n\
    \    long[] temp13 = new long[0];\n    long[] temp14 = new long[0];\n    long[]\
    \ temp15 = new long[0];\n    long[] temp16 = new long[0];\n    long[] temp17 =\
    \ new long[0];\n    long[] temp18 = new long[0];\n    long[] temp19 = new long[0];\n\
    \    long[] temp20 = new long[0];\n    long[] temp21 = new long[0];\n    long[]\
    \ temp22 = new long[0];\n    long[] temp23 = new long[0];\n    long[] temp24 =\
    \ new long[0];\n    long[] temp25 = new long[0];\n    long[] temp26 = new long[0];\n\
    \    long[] temp27 = new long[0];\n    long[] temp28 = new long[0];\n    long[]\
    \ temp29 = new long[0];\n    long[] temp30 = new long[0];\n    long[] temp31 =\
    \ new long[0];\n    long[] temp32 = new long[0];\n    long[] temp33 = new long[0];\n\
    \    long[] temp34 = new long[0];\n    long[] temp35 = new long[0];\n    long[]\
    \ temp36 = new long[0];\n    long[] temp37 = new long[0];\n    long[] temp38 =\
    \ new long[0];\n    long[] temp39 = new long[0];\n    long[] temp40 = new long[0];\n\
    \    long[] temp41 = new\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjdy2odwg.d(68): Error: basic type expected, not `unittest`\n/tmp/tmpjdy2odwg.d(68):
    Error: semicolon expected, not `unittest`\n/tmp/tmpjdy2odwg.d(68): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjdy2odwg.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[1];\n    result[0] = 1;\n    if (n == 1)\n\
    \        return result;\n    else\n    {\n        long[] temp = new long[1];\n\
    \        temp[0] = n;\n        while (n != 1)\n        {\n            if (n %\
    \ 2 == 0)\n                n /= 2;\n            else\n            {\n        \
    \        n = 3 * n + 1;\n                temp ~= n;\n            }\n        }\n\
    \        result = temp.filter!(x => x % 2 != 0).sort();\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzx3h0pzd.d(43): Error: no property `filter` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzx3h0pzd.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1)\n    {\n     \
    \   if (n % 2 == 1)\n        {\n            collatz ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return collatz;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpldnq3fmn.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpldnq3fmn.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpldnq3fmn.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xa04d8554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[1];\n    collatz[0] = n;\n    long[] temp\
    \ = new long[1];\n    while(n != 1)\n    {\n        if(n % 2 == 0)\n        {\n\
    \            n = n / 2;\n        }\n        else\n        {\n            n = 3\
    \ * n + 1;\n        }\n        if(n % 2 != 0)\n        {\n            temp[0]\
    \ = n;\n            collatz = collatz ~ temp;\n        }\n    }\n    return collatz;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpb_9m8rxb.d(50): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283fd]\n??:? void tmpb_9m8rxb.__unittest_L46_C1() [0x427fa6]\n??:?
    void tmpb_9m8rxb.__modtest() [0x42817c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b492]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430a84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430561]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b469]\n??:? runModuleUnitTests [0x42c3d5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4288c0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428847]\n??:? _d_run_main [0x4287b2]\n??:? main [0x42818f]\n??:?
    __libc_start_main [0x709b6554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long num = n;\n    while (num\
    \ != 1)\n    {\n        if (num % 2 == 1)\n        {\n            result ~= num;\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1;\n    }\n    result\
    \ ~= 1;\n    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpqsg3sbsb.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmpqsg3sbsb.__unittest_L38_C1() [0x427f7a]\n??:?
    void tmpqsg3sbsb.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0xab2c3554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            collatz ~= n;\n        }\n      \
    \  n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return collatz;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg35b8hnr.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpg35b8hnr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 != 0)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp7zeph2r1.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp7zeph2r1.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp7zeph2r1.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xe10ef554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1)\n    {\n     \
    \   if (n % 2 == 1)\n        {\n            collatz ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return collatz;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpldnq3fmn.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpldnq3fmn.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpldnq3fmn.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xa04d8554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long num = n;\n    while (num\
    \ != 1) {\n        if (num % 2 == 1) {\n            result ~= num;\n        }\n\
    \        num = num % 2 == 0 ? num / 2 : num * 3 + 1;\n    }\n    result ~= 1;\n\
    \    return result.sort();\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfw7ksaw7.d(34): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfw7ksaw7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1)\n    {\n     \
    \   if (n % 2 == 1)\n        {\n            collatz ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return collatz;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpldnq3fmn.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpldnq3fmn.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpldnq3fmn.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xa04d8554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[1];\n    collatz[0] = n;\n    long[] odd_collatz\
    \ = new long[1];\n    odd_collatz[0] = n;\n    while(n != 1)\n    {\n        if(n\
    \ % 2 == 0)\n        {\n            n = n / 2;\n            collatz ~= n;\n  \
    \      }\n        else\n        {\n            n = 3 * n + 1;\n            collatz\
    \ ~= n;\n            odd_collatz ~= n;\n        }\n    }\n    return odd_collatz;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp6n65rgqz.d(49): unittest failure\n----------------\n??:?
    _d_unittestp [0x42843d]\n??:? void tmp6n65rgqz.__unittest_L45_C1() [0x427fe6]\n??:?
    void tmp6n65rgqz.__modtest() [0x4281bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cee3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bd76]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d70]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43084d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bd4d]\n??:? runModuleUnitTests [0x42ccb9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428900]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428887]\n??:? _d_run_main [0x4287f2]\n??:? main [0x4281cf]\n??:?
    __libc_start_main [0xb694a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    long num = n;\n    while (num\
    \ != 1)\n    {\n        if (num % 2 == 0)\n        {\n            num /= 2;\n\
    \        }\n        else\n        {\n            num = 3 * num + 1;\n        }\n\
    \        if (num % 2 != 0)\n        {\n            collatz ~= num;\n        }\n\
    \    }\n    return collatz;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpg60pskhi.d(48): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283a5]\n??:? void tmpg60pskhi.__unittest_L44_C1() [0x427f4e]\n??:?
    void tmpg60pskhi.__modtest() [0x428124]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdd7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc6a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c64]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430741]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc41]\n??:? runModuleUnitTests [0x42cbad]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287f4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42877b]\n??:? _d_run_main [0x4286e6]\n??:? main [0x428137]\n??:?
    __libc_start_main [0x3255f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = [1L];\n    while (n != 1) \n    {\n        if (n\
    \ % 2 == 0) \n        {\n            n /= 2;\n        } \n        else \n    \
    \    {\n            n = 3 * n + 1;\n            result ~= n;\n        }\n    }\n\
    \    return result.sort();\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe0050gkh.d(38): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe0050gkh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long[] temp = new long[0];\n \
    \   long[] temp2 = new long[0];\n    long i = n;\n    while(i != 1)\n    {\n \
    \       if(i % 2 == 0)\n        {\n            i = i / 2;\n        }\n       \
    \ else\n        {\n            i = 3 * i + 1;\n        }\n        temp = result;\n\
    \        temp2 = new long[temp.length + 1];\n        for(int j = 0; j < temp.length;\
    \ j++)\n        {\n            temp2[j] = temp[j];\n        }\n        temp2[temp2.length\
    \ - 1] = i;\n        result = temp2;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L,\
    \ 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpt203c81x.d(54): unittest failure\n----------------\n??:?
    _d_unittestp [0x428465]\n??:? void tmpt203c81x.__unittest_L50_C1() [0x42800e]\n??:?
    void tmpt203c81x.__modtest() [0x4281e4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c51f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43063d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430aec]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4305c9]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b389]\n??:? runModuleUnitTests [0x42c2f5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428928]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4288af]\n??:? _d_run_main [0x42881a]\n??:? main [0x4281f7]\n??:?
    __libc_start_main [0x28503554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    long num = n;\n    while(num\
    \ != 1)\n    {\n        if(num % 2 == 0)\n        {\n            num /= 2;\n \
    \       }\n        else\n        {\n            num = num * 3 + 1;\n        }\n\
    \        if(num % 2 != 0)\n        {\n            collatz ~= num;\n        }\n\
    \    }\n    collatz ~= 1;\n    return collatz;\n}\nunittest\n{\n    alias candidate\
    \ = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n\
    \    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L,\
    \ 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp8au7t_m3.d(49): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmp8au7t_m3.__unittest_L45_C1() [0x427f7a]\n??:?
    void tmp8au7t_m3.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0xc03b7554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long temp = n;\n    while(temp\
    \ != 1)\n    {\n        if(temp % 2 == 1)\n        {\n            result ~= temp;\n\
    \        }\n        temp = temp % 2 == 0 ? temp / 2 : 3 * temp + 1;\n    }\n \
    \   result ~= 1;\n    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpe_kbjl8y.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmpe_kbjl8y.__unittest_L38_C1() [0x427f7a]\n??:?
    void tmpe_kbjl8y.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0xedad5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1)\n    {\n     \
    \   if (n % 2 == 1)\n        {\n            collatz ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return collatz;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpldnq3fmn.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpldnq3fmn.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpldnq3fmn.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xa04d8554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long[] temp = new long[0];\n \
    \   long[] temp2 = new long[0];\n    long[] temp3 = new long[0];\n    long[] temp4\
    \ = new long[0];\n    long[] temp5 = new long[0];\n    long[] temp6 = new long[0];\n\
    \    long[] temp7 = new long[0];\n    long[] temp8 = new long[0];\n    long[]\
    \ temp9 = new long[0];\n    long[] temp10 = new long[0];\n    long[] temp11 =\
    \ new long[0];\n    long[] temp12 = new long[0];\n    long[] temp13 = new long[0];\n\
    \    long[] temp14 = new long[0];\n    long[] temp15 = new long[0];\n    long[]\
    \ temp16 = new long[0];\n    long[] temp17 = new long[0];\n    long[] temp18 =\
    \ new long[0];\n    long[] temp19 = new long[0];\n    long[] temp20 = new long[0];\n\
    \    long[] temp21 = new long[0];\n    long[] temp22 = new long[0];\n    long[]\
    \ temp23 = new long[0];\n    long[] temp24 = new long[0];\n    long[] temp25 =\
    \ new long[0];\n    long[] temp26 = new long[0];\n    long[] temp27 = new long[0];\n\
    \    long[] temp28 = new long[0];\n    long[] temp29 = new long[0];\n    long[]\
    \ temp30 = new long[0];\n    long[] temp31 = new long[0];\n    long[] temp32 =\
    \ new long[0];\n    long[] temp33 = new long[0];\n    long[] temp34 = new long[0];\n\
    \    long[] temp35 = new long[0];\n    long[] temp36 = new long[0];\n    long[]\
    \ temp37 = new long[0];\n    long[] temp38 = new long[0];\n    long[] temp39 =\
    \ new long[0];\n    long[] temp40 = new long[0];\n    long[] temp41 = new long[0];\n\
    \    long[] temp42 = new\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6liwwivb.d(68): Error: basic type expected, not `unittest`\n/tmp/tmp6liwwivb.d(68):
    Error: semicolon expected, not `unittest`\n/tmp/tmp6liwwivb.d(68): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6liwwivb.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1)\n    {\n     \
    \   if (n % 2 == 1)\n        {\n            collatz ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return collatz;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpldnq3fmn.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpldnq3fmn.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpldnq3fmn.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xa04d8554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[];\n    long num = n;\n    while(num !=\
    \ 1)\n    {\n        if(num % 2 == 0)\n        {\n            num /= 2;\n    \
    \    }\n        else\n        {\n            num = 3 * num + 1;\n        }\n \
    \       if(num % 2 != 0)\n        {\n            collatz ~= num;\n        }\n\
    \    }\n    collatz ~= 1;\n    return collatz;\n}\nunittest\n{\n    alias candidate\
    \ = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n\
    \    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L,\
    \ 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_28shzu5.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp_28shzu5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[1];\n    collatz[0] = n;\n    long[] collatz_odd\
    \ = new long[1];\n    collatz_odd[0] = n;\n    long[] collatz_even = new long[1];\n\
    \    collatz_even[0] = n;\n    long[] collatz_odd_temp = new long[1];\n    long[]\
    \ collatz_even_temp = new long[1];\n    long[] collatz_temp = new long[1];\n \
    \   long[] collatz_odd_temp2 = new long[1];\n    long[] collatz_even_temp2 = new\
    \ long[1];\n    long[] collatz_temp2 = new long[1];\n    long[] collatz_odd_temp3\
    \ = new long[1];\n    long[] collatz_even_temp3 = new long[1];\n    long[] collatz_temp3\
    \ = new long[1];\n    long[] collatz_odd_temp4 = new long[1];\n    long[] collatz_even_temp4\
    \ = new long[1];\n    long[] collatz_temp4 = new long[1];\n    long[] collatz_odd_temp5\
    \ = new long[1];\n    long[] collatz_even_temp5 = new long[1];\n    long[] collatz_temp5\
    \ = new long[1];\n    long[] collatz_odd_temp6 = new long[1];\n    long[] collatz_even_temp6\
    \ = new long[1];\n    long[] collatz_temp6 = new long[1];\n    long[] collatz_odd_temp7\
    \ = new long[1];\n    long[] collatz_even_temp7 = new long[1];\n    long[] collatz_temp7\
    \ = new long[1];\n    long[] collatz_odd_temp8 = new long[1];\n    long[] collatz_even_temp8\
    \ = new long[1];\n    long[] collatz_temp8 = new long[1];\n    long[] collatz_odd_temp9\
    \ = new long[1];\n    long[] collatz_even_temp9 = new long[1];\n    long[] collatz_temp9\
    \ = new long[\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpba9la3k4.d(58): Error: expression expected, not `unittest`\n/tmp/tmpba9la3k4.d(59):
    Error: found `{` when expecting `]`\n/tmp/tmpba9la3k4.d(60): Error: semicolon
    expected, not `alias`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpba9la3k4.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long[] collatz = new long[0];\n\
    \    long[] oddCollatz = new long[0];\n    long[] temp = new long[0];\n    long[]\
    \ temp2 = new long[0];\n    long[] temp3 = new long[0];\n    long[] temp4 = new\
    \ long[0];\n    long[] temp5 = new long[0];\n    long[] temp6 = new long[0];\n\
    \    long[] temp7 = new long[0];\n    long[] temp8 = new long[0];\n    long[]\
    \ temp9 = new long[0];\n    long[] temp10 = new long[0];\n    long[] temp11 =\
    \ new long[0];\n    long[] temp12 = new long[0];\n    long[] temp13 = new long[0];\n\
    \    long[] temp14 = new long[0];\n    long[] temp15 = new long[0];\n    long[]\
    \ temp16 = new long[0];\n    long[] temp17 = new long[0];\n    long[] temp18 =\
    \ new long[0];\n    long[] temp19 = new long[0];\n    long[] temp20 = new long[0];\n\
    \    long[] temp21 = new long[0];\n    long[] temp22 = new long[0];\n    long[]\
    \ temp23 = new long[0];\n    long[] temp24 = new long[0];\n    long[] temp25 =\
    \ new long[0];\n    long[] temp26 = new long[0];\n    long[] temp27 = new long[0];\n\
    \    long[] temp28 = new long[0];\n    long[] temp29 = new long[0];\n    long[]\
    \ temp30 = new long[0];\n    long[] temp31 = new long[0];\n    long[] temp32 =\
    \ new long[0];\n    long[] temp33 = new long[0];\n    long[] temp34 = new long[0];\n\
    \    long[] temp35 = new long[0];\n    long[] temp36 = new long[0];\n    long[]\
    \ temp37 = new long[0];\n    long[] temp38 = new long[0];\n    long[] temp39 =\
    \ new long[0];\n    long[] temp40 =\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdfx2jzm2.d(68): Error: expression expected, not `unittest`\n/tmp/tmpdfx2jzm2.d(69):
    Error: semicolon expected, not `{`\n/tmp/tmpdfx2jzm2.d(77): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpdfx2jzm2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result;\n    long[] collatz;\n    long[] odd_collatz;\n \
    \   long i;\n    long j;\n    long k;\n    long l;\n    long m;\n    long o;\n\
    \    long p;\n    long q;\n    long r;\n    long s;\n    long t;\n    long u;\n\
    \    long v;\n    long w;\n    long x;\n    long y;\n    long z;\n    long aa;\n\
    \    long bb;\n    long cc;\n    long dd;\n    long ee;\n    long ff;\n    long\
    \ gg;\n    long hh;\n    long ii;\n    long jj;\n    long kk;\n    long ll;\n\
    \    long mm;\n    long nn;\n    long oo;\n    long pp;\n    long qq;\n    long\
    \ rr;\n    long ss;\n    long tt;\n    long uu;\n    long vv;\n    long ww;\n\
    \    long xx;\n    long yy;\n    long zz;\n    long aaa;\n    long bbb;\n    long\
    \ ccc;\n    long ddd;\n    long eee;\n    long fff;\n    long ggg;\n    long hhh;\n\
    \    long iii;\n    long jjj;\n    long kkk;\n    long lll;\n    long mmm;\n \
    \   long nnn;\n    long ooo;\n    long ppp;\n    long qqq;\n    long rrr;\n  \
    \  long sss;\n    long ttt;\n    long uuu;\n    long vvv;\n    long www;\n   \
    \ long xxx;\n    long yyy;\n    long zzz;\n    long aaaa;\n    long bbbb;\n  \
    \  long cccc;\n    long dddd;\n    long eeee;\n    long ffff;\n    long gggg;\n\
    \    long hhhh;\n    long iiii;\n    long jjjj;\n    long kkkk;\n    long llll;\n\
    \    long mmmm;\n    long nnnn;\n    long oooo;\n    long p\nunittest\n{\n   \
    \ alias candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L,\
    \ 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2kv7_jx5.d(113): Error: semicolon expected, not `unittest`\n/tmp/tmp2kv7_jx5.d(113):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp2kv7_jx5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = [];\n    while (n > 1) \n    {\n        if (n %\
    \ 2 == 1) \n        {\n            result ~= n;\n        }\n        n = n % 2\
    \ == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp8e43xnf8.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmp8e43xnf8.__unittest_L37_C1() [0x427f76]\n??:?
    void tmp8e43xnf8.__modtest() [0x42814c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cda3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc36]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430689]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b38]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430615]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc0d]\n??:? runModuleUnitTests [0x42cb79]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x42815f]\n??:?
    __libc_start_main [0xd7dc1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : n * 3 + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmps0fih8xw.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmps0fih8xw.__unittest_L37_C1() [0x427f72]\n??:?
    void tmps0fih8xw.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xc3676554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : n * 3 + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmps0fih8xw.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmps0fih8xw.__unittest_L37_C1() [0x427f72]\n??:?
    void tmps0fih8xw.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xc3676554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[];\n    long[] collatz = new long[];\n\
    \    long[] odd = new long[];\n    long[] even = new long[];\n    long[] odd_collatz\
    \ = new long[];\n    long[] even_collatz = new long[];\n    long[] odd_collatz_even\
    \ = new long[];\n    long[] even_collatz_odd = new long[];\n    long[] odd_collatz_even_odd\
    \ = new long[];\n    long[] even_collatz_odd_even = new long[];\n    long[] odd_collatz_even_odd_even\
    \ = new long[];\n    long[] even_collatz_odd_even_odd = new long[];\n    long[]\
    \ odd_collatz_even_odd_even_odd = new long[];\n    long[] even_collatz_odd_even_odd_even\
    \ = new long[];\n    long[] odd_collatz_even_odd_even_odd_even = new long[];\n\
    \    long[] even_collatz_odd_even_odd_even_odd = new long[];\n    long[] odd_collatz_even_odd_even_odd_even_odd\
    \ = new long[];\n    long[] even_collatz_odd_even_odd_even_odd_even = new long[];\n\
    \    long[] odd_collatz_even_odd_even_odd_even_odd_even = new long[];\n    long[]\
    \ even_collatz_odd_even_odd_even_odd_even_odd = new long[];\n    long[] odd_collatz_even_odd_even_odd_even_odd_even_odd\
    \ = new long[];\n    long[] even_collatz_odd_even_odd_even_odd_even_odd_even =\
    \ new long[];\n    long[] odd_collatz_even_odd_even_odd_even_odd_even_odd_even\
    \ = new long[];\n    long[] even_collatz_odd_even_odd_even_odd_even_odd_even_odd\
    \ = new long[];\n    long[] odd_collatz_even_odd_even_odd_even_odd_even_odd_even_odd\
    \ =\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwdgnp7s_.d(50): Error: expression expected, not `unittest`\n/tmp/tmpwdgnp7s_.d(51):
    Error: semicolon expected, not `{`\n/tmp/tmpwdgnp7s_.d(59): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpwdgnp7s_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    if (n == 1)\n    {\n        result\
    \ ~= 1;\n        return result;\n    }\n    long current = n;\n    while (current\
    \ != 1)\n    {\n        if (current % 2 == 1)\n        {\n            result ~=\
    \ current;\n        }\n        current = current % 2 == 0 ? current / 2 : current\
    \ * 3 + 1;\n    }\n    result ~= 1;\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L, 7L, 11L,\
    \ 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpzg1k_n54.d(47): unittest failure\n----------------\n??:?
    _d_unittestp [0x42840d]\n??:? void tmpzg1k_n54.__unittest_L43_C1() [0x427fba]\n??:?
    void tmpzg1k_n54.__modtest() [0x428190]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ce3f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bcd2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bca9]\n??:? runModuleUnitTests [0x42cc15]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42885c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287e3]\n??:? _d_run_main [0x42874e]\n??:? main [0x4281a3]\n??:?
    __libc_start_main [0x9163554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] odd_collatz = new long[0];\n    while (n != 1)\n    {\n \
    \       if (n % 2 == 1)\n        {\n            odd_collatz ~= n;\n        }\n\
    \        n = n % 2 == 0 ? n / 2 : n * 3 + 1;\n    }\n    odd_collatz ~= 1;\n \
    \   return odd_collatz;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpogx5nosx.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpogx5nosx.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpogx5nosx.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xb08ee554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    auto collatz = [](long n) {\n        long[] result;\n        while\
    \ (n != 1) {\n            result ~= n;\n            if (n % 2 == 0) {\n      \
    \          n /= 2;\n            } else {\n                n = 3 * n + 1;\n   \
    \         }\n        }\n        result ~= 1;\n        return result;\n    };\n\
    \    return collatz(n).filter!(a => a % 2 == 1).array;\n}\nunittest\n{\n    alias\
    \ candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L, 7L, 11L,\
    \ 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyjvngkvp.d(25): Error: found `n` when expecting `.` following
    long\n/tmp/tmpyjvngkvp.d(25): Error: found `)` when expecting identifier following
    `long`.\n/tmp/tmpyjvngkvp.d(25): Error: found `{` when expecting `,`\n/tmp/tmpyjvngkvp.d(26):
    Error: found `[` when expecting `.` following long\n/tmp/tmpyjvngkvp.d(26): Error:
    found `]` when expecting identifier following `long`.\n/tmp/tmpyjvngkvp.d(26):
    Error: found `result` when expecting `,`\n/tmp/tmpyjvngkvp.d(26): Error: expression
    expected, not `;`\n/tmp/tmpyjvngkvp.d(27): Error: found `while` when expecting
    `,`\n/tmp/tmpyjvngkvp.d(27): Error: found `!=` when expecting `)`\n/tmp/tmpyjvngkvp.d(27):
    Error: missing `{ ... }` for function literal\n/tmp/tmpyjvngkvp.d(27): Error:
    found `1` when expecting `,`\n/tmp/tmpyjvngkvp.d(27): Error: semicolon expected
    following auto declaration, not `{`\n/tmp/tmpyjvngkvp.d(38): Error: declaration
    expected, not `return`\n/tmp/tmpyjvngkvp.d(39): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyjvngkvp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : n * 3 + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmps0fih8xw.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmps0fih8xw.__unittest_L37_C1() [0x427f72]\n??:?
    void tmps0fih8xw.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xc3676554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    long[] collatz_odd = new long[0];\n\
    \    long[] collatz_even = new long[0];\n    long[] collatz_odd_even = new long[0];\n\
    \    long[] collatz_odd_even_sorted = new long[0];\n    long[] collatz_odd_even_sorted_unique\
    \ = new long[0];\n    long[] collatz_odd_even_sorted_unique_odd = new long[0];\n\
    \    long[] collatz_odd_even_sorted_unique_odd_sorted = new long[0];\n    long[]\
    \ collatz_odd_even_sorted_unique_odd_sorted_odd = new long[0];\n    long[] collatz_odd_even_sorted_unique_odd_sorted_odd_sorted\
    \ = new long[0];\n    long[] collatz_odd_even_sorted_unique_odd_sorted_odd_sorted_odd\
    \ = new long[0];\n    long[] collatz_odd_even_sorted_unique_odd_sorted_odd_sorted_odd_sorted\
    \ = new long[0];\n    long[] collatz_odd_even_sorted_unique_odd_sorted_odd_sorted_odd_sorted_odd\
    \ = new long[0];\n    long[] collatz_odd_even_sorted_unique_odd_sorted_odd_sorted_odd_sorted_odd_sorted\
    \ = new long[0];\n    long[] collatz_odd_even_sorted_unique_odd_sorted_odd_sorted_odd_sorted_odd_sorted_odd\
    \ = new long[0];\n    long[] collatz_odd_even_sorted_unique_odd_sorted_odd_sorted_odd_sorted_odd_sorted_odd_sorted\
    \ = new long[0];\n    long[] collatz_odd_even_sorted_unique_odd_sorted_odd_sorted_odd_sorted_odd_sorted_odd_sorted_odd\
    \ = new long[0];\n    long[] collatz_odd_even_sorted_unique_odd_sorted_\nunittest\n\
    {\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L,\
    \ 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl2574ms_.d(43): Error: semicolon expected, not `unittest`\n/tmp/tmpl2574ms_.d(43):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpl2574ms_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1)\n    {\n     \
    \   if (n % 2 == 1)\n        {\n            collatz ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return collatz.sort;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpraqqjlo2.d(35): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpraqqjlo2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] res = new long[0];\n    while (n != 1) \n    {\n        if\
    \ (n % 2 == 1) \n        {\n            res ~= n;\n        }\n        n = n %\
    \ 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    res ~= 1;\n    return res.sort();\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi3rd60in.d(35): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi3rd60in.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = [1];\n    long[] collatz = [n];\n    long[] temp\
    \ = [];\n    while(n != 1)\n    {\n        if(n % 2 == 0)\n        {\n       \
    \     n = n / 2;\n            temp ~= n;\n        }\n        else\n        {\n\
    \            n = 3 * n + 1;\n            temp ~= n;\n        }\n    }\n    foreach(i;\
    \ temp)\n    {\n        if(i % 2 != 0)\n        {\n            result ~= i;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp7fc37zqa.d(54): unittest failure\n----------------\n??:?
    _d_unittestp [0x428485]\n??:? void tmp7fc37zqa.__unittest_L50_C1() [0x42802e]\n??:?
    void tmp7fc37zqa.__modtest() [0x428204]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ce5b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bcee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430741]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430bf0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4306cd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bcc5]\n??:? runModuleUnitTests [0x42cc31]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4288d4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42885b]\n??:? _d_run_main [0x4287c6]\n??:? main [0x428217]\n??:?
    __libc_start_main [0xd4200554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    long[] collatz_odd = new long[0];\n\
    \    long[] collatz_even = new long[0];\n    long[] collatz_odd_sorted = new long[0];\n\
    \    long[] collatz_even_sorted = new long[0];\n    long[] collatz_sorted = new\
    \ long[0];\n    long[] collatz_odd_sorted_final = new long[0];\n    long[] collatz_even_sorted_final\
    \ = new long[0];\n    long[] collatz_sorted_final = new long[0];\n    long[] collatz_odd_sorted_final_final\
    \ = new long[0];\n    long[] collatz_even_sorted_final_final = new long[0];\n\
    \    long[] collatz_sorted_final_final = new long[0];\n    long[] collatz_odd_sorted_final_final_final\
    \ = new long[0];\n    long[] collatz_even_sorted_final_final_final = new long[0];\n\
    \    long[] collatz_sorted_final_final_final = new long[0];\n    long[] collatz_odd_sorted_final_final_final_final\
    \ = new long[0];\n    long[] collatz_even_sorted_final_final_final_final = new\
    \ long[0];\n    long[] collatz_sorted_final_final_final_final = new long[0];\n\
    \    long[] collatz_odd_sorted_final_final_final_final_final = new long[0];\n\
    \    long[] collatz_even_sorted_final_final_final_final_final = new long[0];\n\
    \    long[] collatz_sorted_final_final_final_final_final = new long[0];\n    long[]\
    \ collatz_odd_sorted_final_final_final_final_final_final = new long[0];\n    long[]\
    \ collatz_even_sorted_final_final_final_final_final_final = new long[0];\n   \
    \ long[] collatz_sorted_final_final_final_final_final_final = new long[0];\n\n\
    unittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdymvhbw6.d(50): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdymvhbw6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[1];\n    collatz[0] = n;\n    while (n\
    \ != 1)\n    {\n        if (n % 2 == 0)\n        {\n            n = n / 2;\n \
    \       }\n        else\n        {\n            n = 3 * n + 1;\n        }\n  \
    \      collatz ~= n;\n    }\n    return collatz.filter!(a => a % 2 == 1).sort;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvr8esjz3.d(39): Error: no property `filter` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvr8esjz3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    // TODO: Implement this function\n    long[] result = new long[0];\n\
    \    long[] temp = new long[0];\n    long[] temp2 = new long[0];\n    long[] temp3\
    \ = new long[0];\n    long[] temp4 = new long[0];\n    long[] temp5 = new long[0];\n\
    \    long[] temp6 = new long[0];\n    long[] temp7 = new long[0];\n    long[]\
    \ temp8 = new long[0];\n    long[] temp9 = new long[0];\n    long[] temp10 = new\
    \ long[0];\n    long[] temp11 = new long[0];\n    long[] temp12 = new long[0];\n\
    \    long[] temp13 = new long[0];\n    long[] temp14 = new long[0];\n    long[]\
    \ temp15 = new long[0];\n    long[] temp16 = new long[0];\n    long[] temp17 =\
    \ new long[0];\n    long[] temp18 = new long[0];\n    long[] temp19 = new long[0];\n\
    \    long[] temp20 = new long[0];\n    long[] temp21 = new long[0];\n    long[]\
    \ temp22 = new long[0];\n    long[] temp23 = new long[0];\n    long[] temp24 =\
    \ new long[0];\n    long[] temp25 = new long[0];\n    long[] temp26 = new long[0];\n\
    \    long[] temp27 = new long[0];\n    long[] temp28 = new long[0];\n    long[]\
    \ temp29 = new long[0];\n    long[] temp30 = new long[0];\n    long[] temp31 =\
    \ new long[0];\n    long[] temp32 = new long[0];\n    long[] temp33 = new long[0];\n\
    \    long[] temp34 = new long[0];\n    long[] temp35 = new long[0];\n    long[]\
    \ temp36 = new long[0];\n    long[] temp37 = new long[0];\n    long[] temp38 =\
    \ new long[0];\n    long[] temp39 = new long[0];\n    long[] temp40 = new long[0];\n\
    \    long[] temp41 = new long[0\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_yw0h1zv.d(68): Error: found `unittest` when expecting `]`\n/tmp/tmp_yw0h1zv.d(69):
    Error: semicolon expected, not `{`\n/tmp/tmp_yw0h1zv.d(77): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_yw0h1zv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    // Your code here\n    long[] result = new long[0];\n    while(n\
    \ != 1)\n    {\n        if(n % 2 == 0)\n        {\n            n /= 2;\n     \
    \   }\n        else\n        {\n            n = 3 * n + 1;\n            result\
    \ ~= n;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n\
    \    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L,\
    \ 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpkv_o0kmx.d(45): unittest failure\n----------------\n??:?
    _d_unittestp [0x42837d]\n??:? void tmpkv_o0kmx.__unittest_L41_C1() [0x427f26]\n??:?
    void tmpkv_o0kmx.__modtest() [0x4280fc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdaf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc42]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43078d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c3c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430719]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc19]\n??:? runModuleUnitTests [0x42cb85]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287cc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428753]\n??:? _d_run_main [0x4286be]\n??:? main [0x42810f]\n??:?
    __libc_start_main [0x6a038554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = [1L];\n    long temp = n;\n    while(temp != 1L)\n\
    \    {\n        if(temp % 2L == 0L)\n        {\n            temp /= 2L;\n    \
    \    }\n        else\n        {\n            temp = 3L * temp + 1L;\n        \
    \    result ~= temp;\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L,\
    \ 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpdxuab5mr.d(45): unittest failure\n----------------\n??:?
    _d_unittestp [0x428395]\n??:? void tmpdxuab5mr.__unittest_L41_C1() [0x427f42]\n??:?
    void tmpdxuab5mr.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cd6b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bbfe]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430651]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b00]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4305dd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bbd5]\n??:? runModuleUnitTests [0x42cb41]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287e4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42876b]\n??:? _d_run_main [0x4286d6]\n??:? main [0x42812b]\n??:?
    __libc_start_main [0x2d8f7554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long num = n;\n    while (num\
    \ != 1)\n    {\n        if (num % 2 == 1)\n        {\n            result ~= num;\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1;\n    }\n    result\
    \ ~= 1;\n    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpqsg3sbsb.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmpqsg3sbsb.__unittest_L38_C1() [0x427f7a]\n??:?
    void tmpqsg3sbsb.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0xab2c3554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long current = n;\n    while (current\
    \ != 1)\n    {\n        if (current % 2 == 1)\n        {\n            result ~=\
    \ current;\n        }\n        current = current % 2 == 0 ? current / 2 : current\
    \ * 3 + 1;\n    }\n    result ~= 1;\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L, 7L, 11L,\
    \ 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpvsqvqz3f.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmpvsqvqz3f.__unittest_L38_C1() [0x427f7a]\n??:?
    void tmpvsqvqz3f.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0x8202554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1)\n    {\n     \
    \   if (n % 2 == 1)\n        {\n            collatz ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return collatz;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpldnq3fmn.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpldnq3fmn.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpldnq3fmn.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xa04d8554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long num = n;\n    while (num\
    \ != 1)\n    {\n        if (num % 2 == 1)\n        {\n            result ~= num;\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : 3 * num + 1;\n    }\n    result\
    \ ~= 1;\n    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmphhb047lw.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmphhb047lw.__unittest_L38_C1() [0x427f7a]\n??:?
    void tmphhb047lw.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0xfa986554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    long[] collatz_odd = new long[0];\n\
    \    long[] collatz_even = new long[0];\n    long[] collatz_odd_sorted = new long[0];\n\
    \    long[] collatz_even_sorted = new long[0];\n    long[] collatz_sorted = new\
    \ long[0];\n    long[] collatz_odd_sorted_final = new long[0];\n    long[] collatz_even_sorted_final\
    \ = new long[0];\n    long[] collatz_sorted_final = new long[0];\n    long[] collatz_odd_final\
    \ = new long[0];\n    long[] collatz_even_final = new long[0];\n    long[] collatz_final\
    \ = new long[0];\n    long[] collatz_odd_final_sorted = new long[0];\n    long[]\
    \ collatz_even_final_sorted = new long[0];\n    long[] collatz_final_sorted =\
    \ new long[0];\n    long[] collatz_odd_final_sorted_final = new long[0];\n   \
    \ long[] collatz_even_final_sorted_final = new long[0];\n    long[] collatz_final_sorted_final\
    \ = new long[0];\n    long[] collatz_odd_final_sorted_final_final = new long[0];\n\
    \    long[] collatz_even_final_sorted_final_final = new long[0];\n    long[] collatz_final_sorted_final_final\
    \ = new long[0];\n    long[] collatz_odd_final_sorted_final_final_final = new\
    \ long[0];\n    long[] collatz_even_final_sorted_final_final_final = new long[0];\n\
    \    long[] collatz_final_sorted_final_final_final = new long[0];\n    long[]\
    \ collatz_odd_final_sorted_final_final_final_final = new long[0];\n    long[]\
    \ collatz_even_final_sorted_final_final_final_final = new long[0];\n    long[]\
    \ collatz_final_s\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n   \
    \ assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0sjg_l2s.d(52): Error: semicolon expected, not `unittest`\n/tmp/tmp0sjg_l2s.d(52):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0sjg_l2s.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[];\n    long current = n;\n    while (current\
    \ != 1)\n    {\n        if (current % 2 == 1)\n        {\n            collatz\
    \ ~= current;\n        }\n        current = current % 2 == 0 ? current / 2 : 3\
    \ * current + 1;\n    }\n    collatz ~= 1;\n    return collatz;\n}\nunittest\n\
    {\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L,\
    \ 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvu2ars0r.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpvu2ars0r.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1) \n    {\n    \
    \    if (n % 2 == 1) \n        {\n            collatz ~= n;\n        }\n     \
    \   n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return\
    \ collatz;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpm_hzqlev.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpm_hzqlev.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpm_hzqlev.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x91c2a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long i = n;\n    while (i != 1)\n\
    \    {\n        if (i % 2 == 1)\n        {\n            result ~= i;\n       \
    \ }\n        i = i % 2 == 0 ? i / 2 : 3 * i + 1;\n    }\n    result ~= 1;\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n\
    \    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpkl_akzb0.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmpkl_akzb0.__unittest_L38_C1() [0x427f7a]\n??:?
    void tmpkl_akzb0.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0x2ccc6554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    long[] temp = new long[0];\n\
    \    long[] result = new long[0];\n    long i = n;\n    while(i != 1)\n    {\n\
    \        if(i % 2 == 0)\n        {\n            i = i / 2;\n        }\n      \
    \  else\n        {\n            i = 3 * i + 1;\n        }\n        temp = collatz;\n\
    \        collatz = new long[temp.length + 1];\n        for(int j = 0; j < temp.length;\
    \ j++)\n        {\n            collatz[j] = temp[j];\n        }\n        collatz[collatz.length\
    \ - 1] = i;\n    }\n    for(int j = 0; j < collatz.length; j++)\n    {\n     \
    \   if(collatz[j] % 2 != 0)\n        {\n            temp = result;\n         \
    \   result = new long[temp.length + 1];\n            for(int k = 0; k < temp.length;\
    \ k++)\n            {\n                result[k] = temp[k];\n            }\n \
    \           result[result.length - 1] = collatz[j];\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpk422zetp.d(66): unittest failure\n----------------\n??:?
    _d_unittestp [0x4285ad]\n??:? void tmpk422zetp.__unittest_L62_C1() [0x428156]\n??:?
    void tmpk422zetp.__modtest() [0x42832c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c667]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b4fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c34]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430711]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b4d1]\n??:? runModuleUnitTests [0x42c43d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a70]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4289f7]\n??:? _d_run_main [0x428962]\n??:? main [0x42833f]\n??:?
    __libc_start_main [0xa6cd4554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long[] temp = new long[0];\n \
    \   long[] temp2 = new long[0];\n    long[] temp3 = new long[0];\n    long[] temp4\
    \ = new long[0];\n    long[] temp5 = new long[0];\n    long[] temp6 = new long[0];\n\
    \    long[] temp7 = new long[0];\n    long[] temp8 = new long[0];\n    long[]\
    \ temp9 = new long[0];\n    long[] temp10 = new long[0];\n    long[] temp11 =\
    \ new long[0];\n    long[] temp12 = new long[0];\n    long[] temp13 = new long[0];\n\
    \    long[] temp14 = new long[0];\n    long[] temp15 = new long[0];\n    long[]\
    \ temp16 = new long[0];\n    long[] temp17 = new long[0];\n    long[] temp18 =\
    \ new long[0];\n    long[] temp19 = new long[0];\n    long[] temp20 = new long[0];\n\
    \    long[] temp21 = new long[0];\n    long[] temp22 = new long[0];\n    long[]\
    \ temp23 = new long[0];\n    long[] temp24 = new long[0];\n    long[] temp25 =\
    \ new long[0];\n    long[] temp26 = new long[0];\n    long[] temp27 = new long[0];\n\
    \    long[] temp28 = new long[0];\n    long[] temp29 = new long[0];\n    long[]\
    \ temp30 = new long[0];\n    long[] temp31 = new long[0];\n    long[] temp32 =\
    \ new long[0];\n    long[] temp33 = new long[0];\n    long[] temp34 = new long[0];\n\
    \    long[] temp35 = new long[0];\n    long[] temp36 = new long[0];\n    long[]\
    \ temp37 = new long[0];\n    long[] temp38 = new long[0];\n    long[] temp39 =\
    \ new long[0];\n    long[] temp40 = new long[0];\n    long[] temp41 = new long[0];\n\
    \    long[] temp42 = new\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6liwwivb.d(68): Error: basic type expected, not `unittest`\n/tmp/tmp6liwwivb.d(68):
    Error: semicolon expected, not `unittest`\n/tmp/tmp6liwwivb.d(68): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6liwwivb.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long num = n;\n    while (num\
    \ != 1) {\n        if (num % 2 == 1) {\n            result ~= num;\n        }\n\
    \        num = num % 2 == 0 ? num / 2 : num * 3 + 1;\n    }\n    result ~= 1;\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n\
    \    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpen6_49k5.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmpen6_49k5.__unittest_L36_C1() [0x427f7a]\n??:?
    void tmpen6_49k5.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0xfb40c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1)\n    {\n     \
    \   if (n % 2 == 1)\n        {\n            collatz ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    return collatz;\n}\nunittest\n\
    {\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L,\
    \ 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpf00ggwz4.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x42839d]\n??:? void tmpf00ggwz4.__unittest_L36_C1() [0x427f46]\n??:?
    void tmpf00ggwz4.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdcf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc62]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c5c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430739]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc39]\n??:? runModuleUnitTests [0x42cba5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287ec]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428773]\n??:? _d_run_main [0x4286de]\n??:? main [0x42812f]\n??:?
    __libc_start_main [0x5d021554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = [];\n    long i = n;\n    while (i != 1)\n    {\n\
    \        if (i % 2 == 1)\n        {\n            result ~= i;\n        }\n   \
    \     i = i % 2 == 0 ? i / 2 : 3 * i + 1;\n    }\n    result ~= 1;\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp8_svhyd1.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283d5]\n??:? void tmp8_svhyd1.__unittest_L38_C1() [0x427f7e]\n??:?
    void tmp8_svhyd1.__modtest() [0x428154]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc3e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430691]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b40]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43061d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc15]\n??:? runModuleUnitTests [0x42cb81]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428824]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287ab]\n??:? _d_run_main [0x428716]\n??:? main [0x428167]\n??:?
    __libc_start_main [0x9b59a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[];\n    long num = n;\n    while(num !=\
    \ 1)\n    {\n        if(num % 2 == 0)\n        {\n            num /= 2;\n    \
    \    }\n        else\n        {\n            num = 3 * num + 1;\n        }\n \
    \       if(num % 2 != 0)\n        {\n            collatz ~= num;\n        }\n\
    \    }\n    return collatz;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa458to7i.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpa458to7i.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    long[] temp = new long[0];\n\
    \    long[] result = new long[0];\n    long i = n;\n    while(i != 1)\n    {\n\
    \        temp = new long[collatz.length + 1];\n        temp[0] = i;\n        for(int\
    \ j = 0; j < collatz.length; j++)\n        {\n            temp[j + 1] = collatz[j];\n\
    \        }\n        collatz = temp;\n        if(i % 2 == 0)\n        {\n     \
    \       i = i / 2;\n        }\n        else\n        {\n            i = 3 * i\
    \ + 1;\n        }\n    }\n    temp = new long[collatz.length + 1];\n    temp[0]\
    \ = i;\n    for(int j = 0; j < collatz.length; j++)\n    {\n        temp[j + 1]\
    \ = collatz[j];\n    }\n    collatz = temp;\n    for(int j = 0; j < collatz.length;\
    \ j++)\n    {\n        if(collatz[j] % 2 != 0)\n        {\n            temp =\
    \ new long[result.length + 1];\n            temp[0] = collatz[j];\n          \
    \  for(int k = 0; k < result.length; k++)\n            {\n                temp[k\
    \ + 1] = result[k];\n            }\n            result = temp;\n        }\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmphheqwba3.d(73): unittest failure\n----------------\n??:?
    _d_unittestp [0x42862d]\n??:? void tmphheqwba3.__unittest_L69_C1() [0x4281d6]\n??:?
    void tmphheqwba3.__modtest() [0x4283ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6e7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b57a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430805]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430cb4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430791]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b551]\n??:? runModuleUnitTests [0x42c4bd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428af0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428a77]\n??:? _d_run_main [0x4289e2]\n??:? main [0x4283bf]\n??:?
    __libc_start_main [0xee88c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long i = n;\n    while (i != 1)\n\
    \    {\n        if (i % 2 == 1)\n        {\n            result ~= i;\n       \
    \ }\n        i = i % 2 == 0 ? i / 2 : 3 * i + 1;\n    }\n    result ~= 1;\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n\
    \    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpkl_akzb0.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmpkl_akzb0.__unittest_L38_C1() [0x427f7a]\n??:?
    void tmpkl_akzb0.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0x2ccc6554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n > 1)\n    {\n       \
    \ if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n =\
    \ n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpgqk6p61g.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpgqk6p61g.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpgqk6p61g.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x87b4f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    long num = n;\n    while(num\
    \ != 1)\n    {\n        if(num % 2 == 0)\n        {\n            num /= 2;\n \
    \       }\n        else\n        {\n            num = 3 * num + 1;\n        }\n\
    \        if(num % 2 != 0)\n        {\n            collatz ~= num;\n        }\n\
    \    }\n    collatz ~= 1;\n    return collatz;\n}\nunittest\n{\n    alias candidate\
    \ = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n\
    \    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L,\
    \ 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpf_mxmazc.d(49): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmpf_mxmazc.__unittest_L45_C1() [0x427f7a]\n??:?
    void tmpf_mxmazc.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0x1ba95554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long[] temp = new long[0];\n \
    \   long[] temp2 = new long[0];\n    long[] temp3 = new long[0];\n    long[] temp4\
    \ = new long[0];\n    long[] temp5 = new long[0];\n    long[] temp6 = new long[0];\n\
    \    long[] temp7 = new long[0];\n    long[] temp8 = new long[0];\n    long[]\
    \ temp9 = new long[0];\n    long[] temp10 = new long[0];\n    long[] temp11 =\
    \ new long[0];\n    long[] temp12 = new long[0];\n    long[] temp13 = new long[0];\n\
    \    long[] temp14 = new long[0];\n    long[] temp15 = new long[0];\n    long[]\
    \ temp16 = new long[0];\n    long[] temp17 = new long[0];\n    long[] temp18 =\
    \ new long[0];\n    long[] temp19 = new long[0];\n    long[] temp20 = new long[0];\n\
    \    long[] temp21 = new long[0];\n    long[] temp22 = new long[0];\n    long[]\
    \ temp23 = new long[0];\n    long[] temp24 = new long[0];\n    long[] temp25 =\
    \ new long[0];\n    long[] temp26 = new long[0];\n    long[] temp27 = new long[0];\n\
    \    long[] temp28 = new long[0];\n    long[] temp29 = new long[0];\n    long[]\
    \ temp30 = new long[0];\n    long[] temp31 = new long[0];\n    long[] temp32 =\
    \ new long[0];\n    long[] temp33 = new long[0];\n    long[] temp34 = new long[0];\n\
    \    long[] temp35 = new long[0];\n    long[] temp36 = new long[0];\n    long[]\
    \ temp37 = new long[0];\n    long[] temp38 = new long[0];\n    long[] temp39 =\
    \ new long[0];\n    long[] temp40 = new long[0];\n    long[] temp41 = new long[0];\n\
    \    long[] temp42 = new\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6liwwivb.d(68): Error: basic type expected, not `unittest`\n/tmp/tmp6liwwivb.d(68):
    Error: semicolon expected, not `unittest`\n/tmp/tmp6liwwivb.d(68): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6liwwivb.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] res = new long[0];\n    while (n > 1)\n    {\n        if\
    \ (n % 2 == 1)\n            res ~= n;\n        n = n % 2 == 0 ? n / 2 : 3 * n\
    \ + 1;\n    }\n    res ~= 1;\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n\
    \    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L,\
    \ 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpgf158ode.d(39): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpgf158ode.__unittest_L35_C1() [0x427f72]\n??:?
    void tmpgf158ode.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x680d9554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1)\n    {\n     \
    \   if (n % 2 == 1)\n        {\n            collatz ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return collatz;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpldnq3fmn.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpldnq3fmn.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpldnq3fmn.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xa04d8554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    long[] collatz_odd = new long[0];\n\
    \    long[] collatz_even = new long[0];\n    long[] collatz_odd_sorted = new long[0];\n\
    \    long[] collatz_even_sorted = new long[0];\n    long[] collatz_sorted = new\
    \ long[0];\n    long[] collatz_odd_sorted_final = new long[0];\n    long[] collatz_even_sorted_final\
    \ = new long[0];\n    long[] collatz_sorted_final = new long[0];\n    long[] collatz_odd_sorted_final_final\
    \ = new long[0];\n    long[] collatz_even_sorted_final_final = new long[0];\n\
    \    long[] collatz_sorted_final_final = new long[0];\n    long[] collatz_odd_sorted_final_final_final\
    \ = new long[0];\n    long[] collatz_even_sorted_final_final_final = new long[0];\n\
    \    long[] collatz_sorted_final_final_final = new long[0];\n    long[] collatz_odd_sorted_final_final_final_final\
    \ = new long[0];\n    long[] collatz_even_sorted_final_final_final_final = new\
    \ long[0];\n    long[] collatz_sorted_final_final_final_final = new long[0];\n\
    \    long[] collatz_odd_sorted_final_final_final_final_final = new long[0];\n\
    \    long[] collatz_even_sorted_final_final_final_final_final = new long[0];\n\
    \    long[] collatz_sorted_final_final_final_final_final = new long[0];\n    long[]\
    \ collatz_odd_sorted_final_final_final_final_final_final = new long[0];\n    long[]\
    \ collatz_even_sorted_final_final_final_final_final_final = new long[0];\n   \
    \ long[] collatz_sorted_final_final_final_final_final_final = new long[0];\n\n\
    unittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdymvhbw6.d(50): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdymvhbw6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1)\n    {\n     \
    \   if (n % 2 == 1)\n        {\n            collatz ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return collatz;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpldnq3fmn.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpldnq3fmn.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpldnq3fmn.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xa04d8554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[];\n    long num = n;\n    while (num !=\
    \ 1)\n    {\n        if (num % 2 == 1)\n        {\n            result ~= num;\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1;\n    }\n    result\
    \ ~= 1;\n    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2s0dujpm.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp2s0dujpm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] odd_collatz = new long[0];\n    long[] collatz = new long[0];\n\
    \    long[] temp = new long[0];\n    long[] temp2 = new long[0];\n    long[] temp3\
    \ = new long[0];\n    long[] temp4 = new long[0];\n    long[] temp5 = new long[0];\n\
    \    long[] temp6 = new long[0];\n    long[] temp7 = new long[0];\n    long[]\
    \ temp8 = new long[0];\n    long[] temp9 = new long[0];\n    long[] temp10 = new\
    \ long[0];\n    long[] temp11 = new long[0];\n    long[] temp12 = new long[0];\n\
    \    long[] temp13 = new long[0];\n    long[] temp14 = new long[0];\n    long[]\
    \ temp15 = new long[0];\n    long[] temp16 = new long[0];\n    long[] temp17 =\
    \ new long[0];\n    long[] temp18 = new long[0];\n    long[] temp19 = new long[0];\n\
    \    long[] temp20 = new long[0];\n    long[] temp21 = new long[0];\n    long[]\
    \ temp22 = new long[0];\n    long[] temp23 = new long[0];\n    long[] temp24 =\
    \ new long[0];\n    long[] temp25 = new long[0];\n    long[] temp26 = new long[0];\n\
    \    long[] temp27 = new long[0];\n    long[] temp28 = new long[0];\n    long[]\
    \ temp29 = new long[0];\n    long[] temp30 = new long[0];\n    long[] temp31 =\
    \ new long[0];\n    long[] temp32 = new long[0];\n    long[] temp33 = new long[0];\n\
    \    long[] temp34 = new long[0];\n    long[] temp35 = new long[0];\n    long[]\
    \ temp36 = new long[0];\n    long[] temp37 = new long[0];\n    long[] temp38 =\
    \ new long[0];\n    long[] temp39 = new long[0];\n    long[] temp40 = new long[0];\n\
    \    long[] temp\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppxr_qixy.d(68): Error: semicolon expected, not `unittest`\n/tmp/tmppxr_qixy.d(68):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmppxr_qixy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[];\n    while (n != 1)\n    {\n       \
    \ if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n =\
    \ n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3dsktg8e.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp3dsktg8e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : n * 3 + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmps0fih8xw.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmps0fih8xw.__unittest_L37_C1() [0x427f72]\n??:?
    void tmps0fih8xw.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xc3676554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[100];\n    long[] odd_collatz = new long[100];\n\
    \    long[] odd_collatz_sorted = new long[100];\n    int i = 0;\n    int j = 0;\n\
    \    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n\
    \    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n\
    \    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n\
    \    int z = 0;\n    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad\
    \ = 0;\n    int ae = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n \
    \   int ai = 0;\n    int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am\
    \ = 0;\n    int an = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n \
    \   int ar = 0;\n    int as = 0;\n    int at = 0;\n    int au = 0;\n    int av\
    \ = 0;\n    int aw = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n \
    \   int ba = 0;\n    int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be\
    \ = 0;\n    int bf = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n \
    \   int bj = 0;\n    int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn\
    \ = 0;\n    int bo = 0;\n    int bp = 0;\n    int bq = 0;\n    int br = 0;\n \
    \   int bs = 0;\n    int bt = 0;\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuspt24rl.d(92): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuspt24rl.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = [1L];\n    while (n != 1)\n    {\n        if (n\
    \ % 2 == 0)\n        {\n            n /= 2;\n        }\n        else\n       \
    \ {\n            n = 3 * n + 1;\n            result ~= n;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n\
    \    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpgjasg6m_.d(44): unittest failure\n----------------\n??:?
    _d_unittestp [0x42838d]\n??:? void tmpgjasg6m_.__unittest_L40_C1() [0x427f3a]\n??:?
    void tmpgjasg6m_.__modtest() [0x428110]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cd63]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bbf6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430649]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430af8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4305d5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bbcd]\n??:? runModuleUnitTests [0x42cb39]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287dc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428763]\n??:? _d_run_main [0x4286ce]\n??:? main [0x428123]\n??:?
    __libc_start_main [0xc9786554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long num = n;\n    while (num\
    \ != 1)\n    {\n        if (num % 2 == 1)\n        {\n            result ~= num;\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : 3 * num + 1;\n    }\n    result\
    \ ~= 1;\n    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmphhb047lw.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmphhb047lw.__unittest_L38_C1() [0x427f7a]\n??:?
    void tmphhb047lw.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0xfa986554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    // TODO: Implement this function\n    long[] result = new long[0];\n\
    \    long[] temp = new long[0];\n    long[] temp2 = new long[0];\n    long[] temp3\
    \ = new long[0];\n    long[] temp4 = new long[0];\n    long[] temp5 = new long[0];\n\
    \    long[] temp6 = new long[0];\n    long[] temp7 = new long[0];\n    long[]\
    \ temp8 = new long[0];\n    long[] temp9 = new long[0];\n    long[] temp10 = new\
    \ long[0];\n    long[] temp11 = new long[0];\n    long[] temp12 = new long[0];\n\
    \    long[] temp13 = new long[0];\n    long[] temp14 = new long[0];\n    long[]\
    \ temp15 = new long[0];\n    long[] temp16 = new long[0];\n    long[] temp17 =\
    \ new long[0];\n    long[] temp18 = new long[0];\n    long[] temp19 = new long[0];\n\
    \    long[] temp20 = new long[0];\n    long[] temp21 = new long[0];\n    long[]\
    \ temp22 = new long[0];\n    long[] temp23 = new long[0];\n    long[] temp24 =\
    \ new long[0];\n    long[] temp25 = new long[0];\n    long[] temp26 = new long[0];\n\
    \    long[] temp27 = new long[0];\n    long[] temp28 = new long[0];\n    long[]\
    \ temp29 = new long[0];\n    long[] temp30 = new long[0];\n    long[] temp31 =\
    \ new long[0];\n    long[] temp32 = new long[0];\n    long[] temp33 = new long[0];\n\
    \    long[] temp34 = new long[0];\n    long[] temp35 = new long[0];\n    long[]\
    \ temp36 = new long[0];\n    long[] temp37 = new long[0];\n    long[] temp38 =\
    \ new long[0];\n    long[] temp39 = new long[0];\n    long[] temp40 = new long[0];\n\
    \    long[] temp41 = new long[0\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_yw0h1zv.d(68): Error: found `unittest` when expecting `]`\n/tmp/tmp_yw0h1zv.d(69):
    Error: semicolon expected, not `{`\n/tmp/tmp_yw0h1zv.d(77): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_yw0h1zv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n > 1)\n    {\n       \
    \ if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n =\
    \ n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpgqk6p61g.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpgqk6p61g.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpgqk6p61g.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x87b4f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] res = new long[0];\n    while (n != 1)\n    {\n        if\
    \ (n % 2 == 1)\n        {\n            res ~= n;\n        }\n        n = n % 2\
    \ == 0 ? n / 2 : 3 * n + 1;\n    }\n    res ~= 1;\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L,\
    \ 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp18fvyi7o.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp18fvyi7o.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp18fvyi7o.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x62c6c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    auto result = new long[];\n    while (n != 1)\n    {\n        if\
    \ (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n = n\
    \ % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjprtakzh.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpjprtakzh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result;\n    long[] collatz;\n    long[] temp;\n    long[]\
    \ temp2;\n    long[] temp3;\n    long[] temp4;\n    long[] temp5;\n    long[]\
    \ temp6;\n    long[] temp7;\n    long[] temp8;\n    long[] temp9;\n    long[]\
    \ temp10;\n    long[] temp11;\n    long[] temp12;\n    long[] temp13;\n    long[]\
    \ temp14;\n    long[] temp15;\n    long[] temp16;\n    long[] temp17;\n    long[]\
    \ temp18;\n    long[] temp19;\n    long[] temp20;\n    long[] temp21;\n    long[]\
    \ temp22;\n    long[] temp23;\n    long[] temp24;\n    long[] temp25;\n    long[]\
    \ temp26;\n    long[] temp27;\n    long[] temp28;\n    long[] temp29;\n    long[]\
    \ temp30;\n    long[] temp31;\n    long[] temp32;\n    long[] temp33;\n    long[]\
    \ temp34;\n    long[] temp35;\n    long[] temp36;\n    long[] temp37;\n    long[]\
    \ temp38;\n    long[] temp39;\n    long[] temp40;\n    long[] temp41;\n    long[]\
    \ temp42;\n    long[] temp43;\n    long[] temp44;\n    long[] temp45;\n    long[]\
    \ temp46;\n    long[] temp47;\n    long[] temp48;\n    long[] temp49;\n    long[]\
    \ temp50;\n    long[] temp51;\n    long[] temp52;\n    long[] temp53;\n    long[]\
    \ temp54;\n    long[] temp55;\n    long[] temp56;\n    long[] temp57;\n    long[]\
    \ temp58;\n    long[] temp59;\n    long[] temp60;\n    long[] temp61;\n    long[]\
    \ temp62;\n    long[] temp63;\n    long[] temp64;\n    long[] temp65;\n    long[]\
    \ temp66;\n    long[] temp67;\n    long[] temp68;\n    long[] temp69;\n    long[]\
    \ temp70;\n    long[] temp71;\n\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpftjaricv.d(99): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpftjaricv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1)\n    {\n     \
    \   if (n % 2 == 1)\n        {\n            collatz ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return collatz;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpldnq3fmn.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpldnq3fmn.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpldnq3fmn.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xa04d8554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long i = n;\n    while (i != 1)\n\
    \    {\n        if (i % 2 == 1)\n        {\n            result ~= i;\n       \
    \ }\n        i = i % 2 == 0 ? i / 2 : 3 * i + 1;\n    }\n    result ~= 1;\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n\
    \    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpkl_akzb0.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmpkl_akzb0.__unittest_L38_C1() [0x427f7a]\n??:?
    void tmpkl_akzb0.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0x2ccc6554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    // your code here\n    long[] collatz = new long[0];\n    long[]\
    \ temp = new long[0];\n    long[] result = new long[0];\n    long[] temp2 = new\
    \ long[0];\n    long[] temp3 = new long[0];\n    long[] temp4 = new long[0];\n\
    \    long[] temp5 = new long[0];\n    long[] temp6 = new long[0];\n    long[]\
    \ temp7 = new long[0];\n    long[] temp8 = new long[0];\n    long[] temp9 = new\
    \ long[0];\n    long[] temp10 = new long[0];\n    long[] temp11 = new long[0];\n\
    \    long[] temp12 = new long[0];\n    long[] temp13 = new long[0];\n    long[]\
    \ temp14 = new long[0];\n    long[] temp15 = new long[0];\n    long[] temp16 =\
    \ new long[0];\n    long[] temp17 = new long[0];\n    long[] temp18 = new long[0];\n\
    \    long[] temp19 = new long[0];\n    long[] temp20 = new long[0];\n    long[]\
    \ temp21 = new long[0];\n    long[] temp22 = new long[0];\n    long[] temp23 =\
    \ new long[0];\n    long[] temp24 = new long[0];\n    long[] temp25 = new long[0];\n\
    \    long[] temp26 = new long[0];\n    long[] temp27 = new long[0];\n    long[]\
    \ temp28 = new long[0];\n    long[] temp29 = new long[0];\n    long[] temp30 =\
    \ new long[0];\n    long[] temp31 = new long[0];\n    long[] temp32 = new long[0];\n\
    \    long[] temp33 = new long[0];\n    long[] temp34 = new long[0];\n    long[]\
    \ temp35 = new long[0];\n    long[] temp36 = new long[0];\n    long[] temp37 =\
    \ new long[0];\n    long[] temp38 = new long[0];\n    long[] temp39 = new long[0];\n\
    \    long[] temp40 = new long[0];\n   \nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu2g4jli4.d(69): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu2g4jli4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    long[] collatz_odd = new long[0];\n\
    \    long[] collatz_even = new long[0];\n    long[] collatz_odd_sorted = new long[0];\n\
    \    long[] collatz_even_sorted = new long[0];\n    long[] collatz_sorted = new\
    \ long[0];\n    long[] collatz_odd_sorted_final = new long[0];\n    long[] collatz_even_sorted_final\
    \ = new long[0];\n    long[] collatz_sorted_final = new long[0];\n    long[] collatz_odd_sorted_final_final\
    \ = new long[0];\n    long[] collatz_even_sorted_final_final = new long[0];\n\
    \    long[] collatz_sorted_final_final = new long[0];\n    long[] collatz_odd_sorted_final_final_final\
    \ = new long[0];\n    long[] collatz_even_sorted_final_final_final = new long[0];\n\
    \    long[] collatz_sorted_final_final_final = new long[0];\n    long[] collatz_odd_sorted_final_final_final_final\
    \ = new long[0];\n    long[] collatz_even_sorted_final_final_final_final = new\
    \ long[0];\n    long[] collatz_sorted_final_final_final_final = new long[0];\n\
    \    long[] collatz_odd_sorted_final_final_final_final_final = new long[0];\n\
    \    long[] collatz_even_sorted_final_final_final_final_final = new long[0];\n\
    \    long[] collatz_sorted_final_final_final_final_final = new long[0];\n    long[]\
    \ collatz_odd_sorted_final_final_final_final_final_final = new long[0];\n    long[]\
    \ collatz_even_sorted_final_final_final_final_final_final = new long[0];\n   \
    \ long[] collatz_sorted_final_final_final_final_final_final = new long[0];\n\n\
    unittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdymvhbw6.d(50): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdymvhbw6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[1];\n    collatz[0] = n;\n    long i =\
    \ n;\n    while (i != 1)\n    {\n        if (i % 2 == 0)\n        {\n        \
    \    i = i / 2;\n        }\n        else\n        {\n            i = 3 * i + 1;\n\
    \        }\n        collatz ~= i;\n    }\n    long[] result = new long[0];\n \
    \   foreach (i; collatz)\n    {\n        if (i % 2 != 0)\n        {\n        \
    \    result ~= i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L, 7L, 11L,\
    \ 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpco9uz8m7.d(41): Error: variable `i` is shadowing variable `tmpco9uz8m7.get_odd_collatz.i`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpco9uz8m7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[];\n    long i = n;\n    while (i != 1)\n\
    \    {\n        if (i % 2 == 1)\n        {\n            result ~= i;\n       \
    \ }\n        i = i % 2 == 0 ? i / 2 : 3 * i + 1;\n    }\n    result ~= 1;\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n\
    \    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbl1vvyss.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpbl1vvyss.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjmd12hnl.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpjmd12hnl.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpjmd12hnl.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x34131554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[];\n    while (n != 1)\n    {\n       \
    \ if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n =\
    \ n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3dsktg8e.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp3dsktg8e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result;\n    long[] temp;\n    long i;\n    long j;\n   \
    \ long k;\n    long l;\n    long m;\n    long o;\n    long p;\n    long q;\n \
    \   long r;\n    long s;\n    long t;\n    long u;\n    long v;\n    long w;\n\
    \    long x;\n    long y;\n    long z;\n    long aa;\n    long bb;\n    long cc;\n\
    \    long dd;\n    long ee;\n    long ff;\n    long gg;\n    long hh;\n    long\
    \ ii;\n    long jj;\n    long kk;\n    long ll;\n    long mm;\n    long nn;\n\
    \    long oo;\n    long pp;\n    long qq;\n    long rr;\n    long ss;\n    long\
    \ tt;\n    long uu;\n    long vv;\n    long ww;\n    long xx;\n    long yy;\n\
    \    long zz;\n    long aaa;\n    long bbb;\n    long ccc;\n    long ddd;\n  \
    \  long eee;\n    long fff;\n    long ggg;\n    long hhh;\n    long iii;\n   \
    \ long jjj;\n    long kkk;\n    long lll;\n    long mmm;\n    long nnn;\n    long\
    \ ooo;\n    long ppp;\n    long qqq;\n    long rrr;\n    long sss;\n    long ttt;\n\
    \    long uuu;\n    long vvv;\n    long www;\n    long xxx;\n    long yyy;\n \
    \   long zzz;\n    long aaaa;\n    long bbbb;\n    long cccc;\n    long dddd;\n\
    \    long eeee;\n    long ffff;\n    long gggg;\n    long hhhh;\n    long iiii;\n\
    \    long jjjj;\n    long kkkk;\n    long llll;\n    long mmmm;\n    long nnnn;\n\
    \    long oooo;\n    long pppp;\n    long qqqq;\nunittest\n{\n    alias candidate\
    \ = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n\
    \    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L,\
    \ 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjkqs8m_g.d(113): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjkqs8m_g.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1)\n    {\n     \
    \   if (n % 2 == 1)\n        {\n            collatz ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return collatz;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpldnq3fmn.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpldnq3fmn.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpldnq3fmn.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xa04d8554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result;\n    long[] collatz;\n    long i;\n    long j;\n\
    \    long k;\n    long l;\n    long m;\n    long n;\n    long o;\n    long p;\n\
    \    long q;\n    long r;\n    long s;\n    long t;\n    long u;\n    long v;\n\
    \    long w;\n    long x;\n    long y;\n    long z;\n    long aa;\n    long ab;\n\
    \    long ac;\n    long ad;\n    long ae;\n    long af;\n    long ag;\n    long\
    \ ah;\n    long ai;\n    long aj;\n    long ak;\n    long al;\n    long am;\n\
    \    long an;\n    long ao;\n    long ap;\n    long aq;\n    long ar;\n    long\
    \ as;\n    long at;\n    long au;\n    long av;\n    long aw;\n    long ax;\n\
    \    long ay;\n    long az;\n    long ba;\n    long bb;\n    long bc;\n    long\
    \ bd;\n    long be;\n    long bf;\n    long bg;\n    long bh;\n    long bi;\n\
    \    long bj;\n    long bk;\n    long bl;\n    long bm;\n    long bn;\n    long\
    \ bo;\n    long bp;\n    long bq;\n    long br;\n    long bs;\n    long bt;\n\
    \    long bu;\n    long bv;\n    long bw;\n    long bx;\n    long by;\n    long\
    \ bz;\n    long ca;\n    long cb;\n    long cc;\n    long cd;\n    long ce;\n\
    \    long cf;\n    long cg;\n    long ch;\n    long ci;\n    long cj;\n    long\
    \ ck;\n    long cl;\n    long cm;\n    long cn;\n    long co;\n    long cp;\n\
    \    long cq;\n    long cr;\n    long cs;\n    long ct;\n    long cu;\n    long\
    \ cv;\n    long cw\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n  \
    \  assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjlnux06v.d(120): Error: semicolon expected, not `unittest`\n/tmp/tmpjlnux06v.d(120):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpjlnux06v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long i = n;\n    while (i > 1)\n\
    \    {\n        if (i % 2 == 1)\n        {\n            result ~= i;\n       \
    \ }\n        i = i % 2 == 0 ? i / 2 : i * 3 + 1;\n    }\n    result ~= 1;\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n\
    \    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmprm4l9p_8.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmprm4l9p_8.__unittest_L38_C1() [0x427f7a]\n??:?
    void tmprm4l9p_8.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0xfce0e554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = [];\n    while (n != 1) \n    {\n        if (n %\
    \ 2 == 1) \n        {\n            result ~= n;\n        }\n        n = n % 2\
    \ == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpggcp6bp8.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmpggcp6bp8.__unittest_L37_C1() [0x427f76]\n??:?
    void tmpggcp6bp8.__modtest() [0x42814c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cda3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc36]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430689]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b38]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430615]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc0d]\n??:? runModuleUnitTests [0x42cb79]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x42815f]\n??:?
    __libc_start_main [0x5bbc5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1)\n    {\n     \
    \   if (n % 2 == 1)\n        {\n            collatz ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return collatz;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpldnq3fmn.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpldnq3fmn.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpldnq3fmn.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xa04d8554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    long num = n;\n    while (num\
    \ != 1)\n    {\n        if (num % 2 == 0)\n        {\n            num /= 2;\n\
    \        }\n        else\n        {\n            num = 3 * num + 1;\n        }\n\
    \        if (num % 2 != 0)\n        {\n            collatz ~= num;\n        }\n\
    \    }\n    collatz ~= 1;\n    return collatz;\n}\nunittest\n{\n    alias candidate\
    \ = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n\
    \    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L,\
    \ 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpcyi85aqx.d(49): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmpcyi85aqx.__unittest_L45_C1() [0x427f7a]\n??:?
    void tmpcyi85aqx.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0xf4280554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : n * 3 + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmps0fih8xw.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmps0fih8xw.__unittest_L37_C1() [0x427f72]\n??:?
    void tmps0fih8xw.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xc3676554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long[] collatz = new long[0];\n\
    \    long[] odd = new long[0];\n    long[] even = new long[0];\n    long[] temp\
    \ = new long[0];\n    long[] temp1 = new long[0];\n    long[] temp2 = new long[0];\n\
    \    long[] temp3 = new long[0];\n    long[] temp4 = new long[0];\n    long[]\
    \ temp5 = new long[0];\n    long[] temp6 = new long[0];\n    long[] temp7 = new\
    \ long[0];\n    long[] temp8 = new long[0];\n    long[] temp9 = new long[0];\n\
    \    long[] temp10 = new long[0];\n    long[] temp11 = new long[0];\n    long[]\
    \ temp12 = new long[0];\n    long[] temp13 = new long[0];\n    long[] temp14 =\
    \ new long[0];\n    long[] temp15 = new long[0];\n    long[] temp16 = new long[0];\n\
    \    long[] temp17 = new long[0];\n    long[] temp18 = new long[0];\n    long[]\
    \ temp19 = new long[0];\n    long[] temp20 = new long[0];\n    long[] temp21 =\
    \ new long[0];\n    long[] temp22 = new long[0];\n    long[] temp23 = new long[0];\n\
    \    long[] temp24 = new long[0];\n    long[] temp25 = new long[0];\n    long[]\
    \ temp26 = new long[0];\n    long[] temp27 = new long[0];\n    long[] temp28 =\
    \ new long[0];\n    long[] temp29 = new long[0];\n    long[] temp30 = new long[0];\n\
    \    long[] temp31 = new long[0];\n    long[] temp32 = new long[0];\n    long[]\
    \ temp33 = new long[0];\n    long[] temp34 = new long[0];\n    long[] temp35 =\
    \ new long[0];\n    long[] temp36 = new long[0];\n    long[] temp37 = new long[0];\n\
    \    long[] temp38 = new long[\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpay2foo49.d(68): Error: expression expected, not `unittest`\n/tmp/tmpay2foo49.d(69):
    Error: found `{` when expecting `]`\n/tmp/tmpay2foo49.d(70): Error: semicolon
    expected, not `alias`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpay2foo49.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    if (n == 1)\n    {\n        result\
    \ ~= 1;\n        return result;\n    }\n    while (n != 1)\n    {\n        if\
    \ (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n = n\
    \ % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpuep9m33o.d(46): unittest failure\n----------------\n??:?
    _d_unittestp [0x428405]\n??:? void tmpuep9m33o.__unittest_L42_C1() [0x427fb2]\n??:?
    void tmpuep9m33o.__modtest() [0x428188]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ce37]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bcca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430815]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4307a1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bca1]\n??:? runModuleUnitTests [0x42cc0d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428854]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287db]\n??:? _d_run_main [0x428746]\n??:? main [0x42819b]\n??:?
    __libc_start_main [0x825a5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    if (n == 1)\n    {\n        result\
    \ ~= 1;\n        return result;\n    }\n    while (n != 1)\n    {\n        if\
    \ (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n = (n\
    \ % 2 == 0) ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpf1pzi6e0.d(46): unittest failure\n----------------\n??:?
    _d_unittestp [0x428405]\n??:? void tmpf1pzi6e0.__unittest_L42_C1() [0x427fb2]\n??:?
    void tmpf1pzi6e0.__modtest() [0x428188]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ce37]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bcca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430815]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4307a1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bca1]\n??:? runModuleUnitTests [0x42cc0d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428854]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287db]\n??:? _d_run_main [0x428746]\n??:? main [0x42819b]\n??:?
    __libc_start_main [0xbd17b554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long[] collatz = new long[0];\n\
    \    long[] temp = new long[0];\n    long[] odd = new long[0];\n    long[] even\
    \ = new long[0];\n    long[] odd_collatz = new long[0];\n    long[] even_collatz\
    \ = new long[0];\n    long[] odd_collatz_temp = new long[0];\n    long[] even_collatz_temp\
    \ = new long[0];\n    long[] odd_collatz_temp2 = new long[0];\n    long[] even_collatz_temp2\
    \ = new long[0];\n    long[] odd_collatz_temp3 = new long[0];\n    long[] even_collatz_temp3\
    \ = new long[0];\n    long[] odd_collatz_temp4 = new long[0];\n    long[] even_collatz_temp4\
    \ = new long[0];\n    long[] odd_collatz_temp5 = new long[0];\n    long[] even_collatz_temp5\
    \ = new long[0];\n    long[] odd_collatz_temp6 = new long[0];\n    long[] even_collatz_temp6\
    \ = new long[0];\n    long[] odd_collatz_temp7 = new long[0];\n    long[] even_collatz_temp7\
    \ = new long[0];\n    long[] odd_collatz_temp8 = new long[0];\n    long[] even_collatz_temp8\
    \ = new long[0];\n    long[] odd_collatz_temp9 = new long[0];\n    long[] even_collatz_temp9\
    \ = new long[0];\n    long[] odd_collatz_temp10 = new long[0];\n    long[] even_collatz_temp10\
    \ = new long[0];\n    long[] odd_collatz_temp11 = new long[0];\n    long[] even_collatz_temp11\
    \ = new long[0];\n    long[] odd_collatz_temp12 = new long[0];\n    long[] even_collatz_temp12\
    \ = new long[0];\n    long[] odd_collatz_temp13 = new long[0];\n    long\nunittest\n\
    {\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L) == [1L,\
    \ 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L)\
    \ == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplqr9e17s.d(58): Error: no identifier for declarator `long`\n/tmp/tmplqr9e17s.d(58):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmplqr9e17s.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = [1];\n    while (n != 1)\n    {\n        if (n %\
    \ 2 == 0)\n        {\n            n /= 2;\n        }\n        else\n        {\n\
    \            n = 3 * n + 1;\n            result ~= n;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmprr5z2dhk.d(44): unittest failure\n----------------\n??:?
    _d_unittestp [0x42838d]\n??:? void tmprr5z2dhk.__unittest_L40_C1() [0x427f3a]\n??:?
    void tmprr5z2dhk.__modtest() [0x428110]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cd63]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bbf6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430649]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430af8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4305d5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bbcd]\n??:? runModuleUnitTests [0x42cb39]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287dc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428763]\n??:? _d_run_main [0x4286ce]\n??:? main [0x428123]\n??:?
    __libc_start_main [0xe971d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long[] temp = new long[0];\n \
    \   long[] temp2 = new long[0];\n    long[] temp3 = new long[0];\n    long[] temp4\
    \ = new long[0];\n    long[] temp5 = new long[0];\n    long[] temp6 = new long[0];\n\
    \    long[] temp7 = new long[0];\n    long[] temp8 = new long[0];\n    long[]\
    \ temp9 = new long[0];\n    long[] temp10 = new long[0];\n    long[] temp11 =\
    \ new long[0];\n    long[] temp12 = new long[0];\n    long[] temp13 = new long[0];\n\
    \    long[] temp14 = new long[0];\n    long[] temp15 = new long[0];\n    long[]\
    \ temp16 = new long[0];\n    long[] temp17 = new long[0];\n    long[] temp18 =\
    \ new long[0];\n    long[] temp19 = new long[0];\n    long[] temp20 = new long[0];\n\
    \    long[] temp21 = new long[0];\n    long[] temp22 = new long[0];\n    long[]\
    \ temp23 = new long[0];\n    long[] temp24 = new long[0];\n    long[] temp25 =\
    \ new long[0];\n    long[] temp26 = new long[0];\n    long[] temp27 = new long[0];\n\
    \    long[] temp28 = new long[0];\n    long[] temp29 = new long[0];\n    long[]\
    \ temp30 = new long[0];\n    long[] temp31 = new long[0];\n    long[] temp32 =\
    \ new long[0];\n    long[] temp33 = new long[0];\n    long[] temp34 = new long[0];\n\
    \    long[] temp35 = new long[0];\n    long[] temp36 = new long[0];\n    long[]\
    \ temp37 = new long[0];\n    long[] temp38 = new long[0];\n    long[] temp39 =\
    \ new long[0];\n    long[] temp40 = new long[0];\n    long[] temp41 = new long[0];\n\
    \    long[] temp42 = new\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6liwwivb.d(68): Error: basic type expected, not `unittest`\n/tmp/tmp6liwwivb.d(68):
    Error: semicolon expected, not `unittest`\n/tmp/tmp6liwwivb.d(68): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6liwwivb.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] odd_collatz = new long[0];\n    long[] collatz = new long[0];\n\
    \    long[] temp = new long[0];\n    long[] temp2 = new long[0];\n    long[] temp3\
    \ = new long[0];\n    long[] temp4 = new long[0];\n    long[] temp5 = new long[0];\n\
    \    long[] temp6 = new long[0];\n    long[] temp7 = new long[0];\n    long[]\
    \ temp8 = new long[0];\n    long[] temp9 = new long[0];\n    long[] temp10 = new\
    \ long[0];\n    long[] temp11 = new long[0];\n    long[] temp12 = new long[0];\n\
    \    long[] temp13 = new long[0];\n    long[] temp14 = new long[0];\n    long[]\
    \ temp15 = new long[0];\n    long[] temp16 = new long[0];\n    long[] temp17 =\
    \ new long[0];\n    long[] temp18 = new long[0];\n    long[] temp19 = new long[0];\n\
    \    long[] temp20 = new long[0];\n    long[] temp21 = new long[0];\n    long[]\
    \ temp22 = new long[0];\n    long[] temp23 = new long[0];\n    long[] temp24 =\
    \ new long[0];\n    long[] temp25 = new long[0];\n    long[] temp26 = new long[0];\n\
    \    long[] temp27 = new long[0];\n    long[] temp28 = new long[0];\n    long[]\
    \ temp29 = new long[0];\n    long[] temp30 = new long[0];\n    long[] temp31 =\
    \ new long[0];\n    long[] temp32 = new long[0];\n    long[] temp33 = new long[0];\n\
    \    long[] temp34 = new long[0];\n    long[] temp35 = new long[0];\n    long[]\
    \ temp36 = new long[0];\n    long[] temp37 = new long[0];\n    long[] temp38 =\
    \ new long[0];\n    long[] temp39 = new long[0];\n    long[] temp40 = new long[0];\n\
    \    long[] temp\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppxr_qixy.d(68): Error: semicolon expected, not `unittest`\n/tmp/tmppxr_qixy.d(68):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmppxr_qixy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    long[] oddCollatz = new long[0];\n\
    \    long[] temp = new long[0];\n    long[] temp2 = new long[0];\n    long[] temp3\
    \ = new long[0];\n    long[] temp4 = new long[0];\n    long[] temp5 = new long[0];\n\
    \    long[] temp6 = new long[0];\n    long[] temp7 = new long[0];\n    long[]\
    \ temp8 = new long[0];\n    long[] temp9 = new long[0];\n    long[] temp10 = new\
    \ long[0];\n    long[] temp11 = new long[0];\n    long[] temp12 = new long[0];\n\
    \    long[] temp13 = new long[0];\n    long[] temp14 = new long[0];\n    long[]\
    \ temp15 = new long[0];\n    long[] temp16 = new long[0];\n    long[] temp17 =\
    \ new long[0];\n    long[] temp18 = new long[0];\n    long[] temp19 = new long[0];\n\
    \    long[] temp20 = new long[0];\n    long[] temp21 = new long[0];\n    long[]\
    \ temp22 = new long[0];\n    long[] temp23 = new long[0];\n    long[] temp24 =\
    \ new long[0];\n    long[] temp25 = new long[0];\n    long[] temp26 = new long[0];\n\
    \    long[] temp27 = new long[0];\n    long[] temp28 = new long[0];\n    long[]\
    \ temp29 = new long[0];\n    long[] temp30 = new long[0];\n    long[] temp31 =\
    \ new long[0];\n    long[] temp32 = new long[0];\n    long[] temp33 = new long[0];\n\
    \    long[] temp34 = new long[0];\n    long[] temp35 = new long[0];\n    long[]\
    \ temp36 = new long[0];\n    long[] temp37 = new long[0];\n    long[] temp38 =\
    \ new long[0];\n    long[] temp39 = new long[0];\n    long[] temp40 = new long[0];\n\
    \    long[] temp41\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n  \
    \  assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwa7b0asr.d(68): Error: semicolon expected, not `unittest`\n/tmp/tmpwa7b0asr.d(68):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpwa7b0asr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long[] temp = new long[0];\n \
    \   long[] temp2 = new long[0];\n    long[] temp3 = new long[0];\n    long[] temp4\
    \ = new long[0];\n    long[] temp5 = new long[0];\n    long[] temp6 = new long[0];\n\
    \    long[] temp7 = new long[0];\n    long[] temp8 = new long[0];\n    long[]\
    \ temp9 = new long[0];\n    long[] temp10 = new long[0];\n    long[] temp11 =\
    \ new long[0];\n    long[] temp12 = new long[0];\n    long[] temp13 = new long[0];\n\
    \    long[] temp14 = new long[0];\n    long[] temp15 = new long[0];\n    long[]\
    \ temp16 = new long[0];\n    long[] temp17 = new long[0];\n    long[] temp18 =\
    \ new long[0];\n    long[] temp19 = new long[0];\n    long[] temp20 = new long[0];\n\
    \    long[] temp21 = new long[0];\n    long[] temp22 = new long[0];\n    long[]\
    \ temp23 = new long[0];\n    long[] temp24 = new long[0];\n    long[] temp25 =\
    \ new long[0];\n    long[] temp26 = new long[0];\n    long[] temp27 = new long[0];\n\
    \    long[] temp28 = new long[0];\n    long[] temp29 = new long[0];\n    long[]\
    \ temp30 = new long[0];\n    long[] temp31 = new long[0];\n    long[] temp32 =\
    \ new long[0];\n    long[] temp33 = new long[0];\n    long[] temp34 = new long[0];\n\
    \    long[] temp35 = new long[0];\n    long[] temp36 = new long[0];\n    long[]\
    \ temp37 = new long[0];\n    long[] temp38 = new long[0];\n    long[] temp39 =\
    \ new long[0];\n    long[] temp40 = new long[0];\n    long[] temp41 = new long[0];\n\
    \    long[] temp42 = new\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6liwwivb.d(68): Error: basic type expected, not `unittest`\n/tmp/tmp6liwwivb.d(68):
    Error: semicolon expected, not `unittest`\n/tmp/tmp6liwwivb.d(68): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6liwwivb.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long[] collatz = new long[0];\n\
    \    long num = n;\n    while (num != 1)\n    {\n        if (num % 2 == 0)\n \
    \       {\n            num /= 2;\n        }\n        else\n        {\n       \
    \     num = 3 * num + 1;\n        }\n        collatz ~= num;\n    }\n    foreach\
    \ (i; collatz)\n    {\n        if (i % 2 != 0)\n        {\n            result\
    \ ~= i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_odd_collatz;\n\n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n\
    \    assert(candidate(5L) == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L,\
    \ 5L]);\n    assert(candidate(1L) == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmph7j9992r.d(53): unittest failure\n----------------\n??:?
    _d_unittestp [0x428425]\n??:? void tmph7j9992r.__unittest_L49_C1() [0x427fce]\n??:?
    void tmph7j9992r.__modtest() [0x4281a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ce57]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bcea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430835]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430ce4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4307c1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bcc1]\n??:? runModuleUnitTests [0x42cc2d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428874]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287fb]\n??:? _d_run_main [0x428766]\n??:? main [0x4281b7]\n??:?
    __libc_start_main [0xb93db554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    if (n == 1)\n    {\n        result\
    \ ~= 1;\n        return result;\n    }\n    while (n != 1)\n    {\n        if\
    \ (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n = n\
    \ % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpuep9m33o.d(46): unittest failure\n----------------\n??:?
    _d_unittestp [0x428405]\n??:? void tmpuep9m33o.__unittest_L42_C1() [0x427fb2]\n??:?
    void tmpuep9m33o.__modtest() [0x428188]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ce37]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bcca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430815]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4307a1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bca1]\n??:? runModuleUnitTests [0x42cc0d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428854]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287db]\n??:? _d_run_main [0x428746]\n??:? main [0x42819b]\n??:?
    __libc_start_main [0x825a5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long i = n;\n    while (i != 1)\n\
    \    {\n        if (i % 2 == 1)\n        {\n            result ~= i;\n       \
    \ }\n        i = (i % 2 == 0) ? i / 2 : 3 * i + 1;\n    }\n    result ~= 1;\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n\
    \    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpg__ljzds.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmpg__ljzds.__unittest_L38_C1() [0x427f7a]\n??:?
    void tmpg__ljzds.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0xb81d7554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n > 1)\n    {\n       \
    \ if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n =\
    \ n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpgqk6p61g.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpgqk6p61g.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpgqk6p61g.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x87b4f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result;\n    long[] collatz;\n    long[] odd_collatz;\n \
    \   long i;\n    long j;\n    long k;\n    long l;\n    long m;\n    long temp;\n\
    \    long temp2;\n    long temp3;\n    long temp4;\n    long temp5;\n    long\
    \ temp6;\n    long temp7;\n    long temp8;\n    long temp9;\n    long temp10;\n\
    \    long temp11;\n    long temp12;\n    long temp13;\n    long temp14;\n    long\
    \ temp15;\n    long temp16;\n    long temp17;\n    long temp18;\n    long temp19;\n\
    \    long temp20;\n    long temp21;\n    long temp22;\n    long temp23;\n    long\
    \ temp24;\n    long temp25;\n    long temp26;\n    long temp27;\n    long temp28;\n\
    \    long temp29;\n    long temp30;\n    long temp31;\n    long temp32;\n    long\
    \ temp33;\n    long temp34;\n    long temp35;\n    long temp36;\n    long temp37;\n\
    \    long temp38;\n    long temp39;\n    long temp40;\n    long temp41;\n    long\
    \ temp42;\n    long temp43;\n    long temp44;\n    long temp45;\n    long temp46;\n\
    \    long temp47;\n    long temp48;\n    long temp49;\n    long temp50;\n    long\
    \ temp51;\n    long temp52;\n    long temp53;\n    long temp54;\n    long temp55;\n\
    \    long temp56;\n    long temp57;\n    long temp58;\n    long temp59;\n    long\
    \ temp60;\n    long temp61;\n    long temp62;\n    long temp63;\n    long temp64;\n\
    \    long temp65;\n    long temp66;\n    long temp67;\n    long temp68;\n    long\
    \ temp69;\n    long temp70;\n    long temp71;\n    long temp72;\n    long temp73;\n\
    \    long temp74;\n    long temp75;\n    long temp76;\n    long temp77;\n   \n\
    unittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1eozpvtj.d(111): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1eozpvtj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    if (n == 1)\n        return [1];\n    auto result = [1];\n    while\
    \ (n != 1)\n    {\n        if (n % 2 == 0)\n            n /= 2;\n        else\n\
    \        {\n            n = 3 * n + 1;\n            result ~= n;\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2ehc8qun.d(35): Error: cannot append type `long` to type `int[]`\n/tmp/tmp2ehc8qun.d(38):
    Error: cannot implicitly convert expression `result` of type `int[]` to `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ehc8qun.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz = new long[0];\n    while (n != 1)\n    {\n     \
    \   if (n % 2 == 1)\n        {\n            collatz ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    collatz ~= 1;\n    return collatz;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpldnq3fmn.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpldnq3fmn.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpldnq3fmn.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0xa04d8554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1) \n    {\n     \
    \   if (n % 2 == 1) \n        {\n            result ~= n;\n        }\n       \
    \ n = n % 2 == 0 ? n / 2 : n * 3 + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpmr30g047.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmpmr30g047.__unittest_L37_C1() [0x427f72]\n??:?
    void tmpmr30g047.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x35e14554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long num = n;\n    while (num\
    \ != 1)\n    {\n        if (num % 2 == 1)\n        {\n            result ~= num;\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1;\n    }\n    result\
    \ ~= 1;\n    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpqsg3sbsb.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmpqsg3sbsb.__unittest_L38_C1() [0x427f7a]\n??:?
    void tmpqsg3sbsb.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0xab2c3554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    long num = n;\n    while (num\
    \ != 1)\n    {\n        if (num % 2 == 1)\n        {\n            result ~= num;\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : 3 * num + 1;\n    }\n    result\
    \ ~= 1;\n    return result;\n}\nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmphhb047lw.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283cd]\n??:? void tmphhb047lw.__unittest_L38_C1() [0x427f7a]\n??:?
    void tmphhb047lw.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc92]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c8c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430769]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc69]\n??:? runModuleUnitTests [0x42cbd5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287a3]\n??:? _d_run_main [0x42870e]\n??:? main [0x428163]\n??:?
    __libc_start_main [0xfa986554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] result = new long[0];\n    while (n != 1)\n    {\n      \
    \  if (n % 2 == 1)\n        {\n            result ~= n;\n        }\n        n\
    \ = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result ~= 1;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_odd_collatz;\n\n    assert(candidate(14L)\
    \ == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L) == [1L, 5L]);\n \
    \   assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L) == [1L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5xhekd8i.d(41): unittest failure\n----------------\n??:?
    _d_unittestp [0x4283c5]\n??:? void tmp5xhekd8i.__unittest_L37_C1() [0x427f72]\n??:?
    void tmp5xhekd8i.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cdf7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc8a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430761]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42bc61]\n??:? runModuleUnitTests [0x42cbcd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428814]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42879b]\n??:? _d_run_main [0x428706]\n??:? main [0x42815b]\n??:?
    __libc_start_main [0x5eda1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
    \ n, return a sorted array that has the odd numbers in collatz sequence.\n\n \
    \   The Collatz conjecture is a conjecture in mathematics that concerns a sequence\
    \ defined\n    as follows: start with any positive integer n. Then each term is\
    \ obtained from the \n    previous term as follows: if the previous term is even,\
    \ the next term is one half of \n    the previous term. If the previous term is\
    \ odd, the next term is 3 times the previous\n    term plus 1. The conjecture\
    \ is that no matter what value of n, the sequence will always reach 1.\n\n   \
    \ Note: \n        1. Collatz(1) is [1].\n        2. returned array sorted in increasing\
    \ order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz\
    \ sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\
    \    >>> get_odd_collatz(5L)\n    [1L, 5L]\n    \n*/\nlong[] get_odd_collatz(long\
    \ n) \n{\n    long[] collatz_seq = new long[0];\n    long[] odd_collatz_seq =\
    \ new long[0];\n    long[] result = new long[0];\n    long[] temp = new long[0];\n\
    \    long[] temp2 = new long[0];\n    long[] temp3 = new long[0];\n    long[]\
    \ temp4 = new long[0];\n    long[] temp5 = new long[0];\n    long[] temp6 = new\
    \ long[0];\n    long[] temp7 = new long[0];\n    long[] temp8 = new long[0];\n\
    \    long[] temp9 = new long[0];\n    long[] temp10 = new long[0];\n    long[]\
    \ temp11 = new long[0];\n    long[] temp12 = new long[0];\n    long[] temp13 =\
    \ new long[0];\n    long[] temp14 = new long[0];\n    long[] temp15 = new long[0];\n\
    \    long[] temp16 = new long[0];\n    long[] temp17 = new long[0];\n    long[]\
    \ temp18 = new long[0];\n    long[] temp19 = new long[0];\n    long[] temp20 =\
    \ new long[0];\n    long[] temp21 = new long[0];\n    long[] temp22 = new long[0];\n\
    \    long[] temp23 = new long[0];\n    long[] temp24 = new long[0];\n    long[]\
    \ temp25 = new long[0];\n    long[] temp26 = new long[0];\n    long[] temp27 =\
    \ new long[0];\n    long[] temp28 = new long[0];\n    long[] temp29 = new long[0];\n\
    \    long[] temp30 = new long[0];\n    long[] temp31 = new long[0];\n    long[]\
    \ temp32 = new long[0];\n    long[] temp33 = new long[0];\n    long[] temp34 =\
    \ new long[0];\n    long[] temp35 = new long[0];\n    long[] temp36 = new long[0];\n\
    \    long[] temp37 = new long[0];\n    long[] temp38 = new long[0];\n    long[]\
    \ temp39 = new long[0];\n   \nunittest\n{\n    alias candidate = get_odd_collatz;\n\
    \n    assert(candidate(14L) == [1L, 5L, 7L, 11L, 13L, 17L]);\n    assert(candidate(5L)\
    \ == [1L, 5L]);\n    assert(candidate(12L) == [1L, 3L, 5L]);\n    assert(candidate(1L)\
    \ == [1L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8kdxr_7a.d(68): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8kdxr_7a.d", "-I/tmp"]\n'''
  stdout: b''
