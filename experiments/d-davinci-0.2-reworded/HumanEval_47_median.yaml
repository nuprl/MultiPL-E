name: HumanEval_47_median
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nReturn median of elements in\
  \ the array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L,\
  \ 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\nfloat median(long[] l) \n"
tests: "unittest\n{\n    alias candidate = median;\n\n    assert(candidate([3L, 1L,\
  \ 2L, 4L, 5L]) == 3L);\n    assert(candidate([-10L, 4L, 6L, 1000L, 10L, 20L]) ==\
  \ 8.0);\n    assert(candidate([5L]) == 5L);\n    assert(candidate([6L, 5L]) == 5.5);\n\
  \    assert(candidate([8L, 1L, 3L, 9L, 9L, 2L, 7L]) == 7L);\n}\nvoid main(){}"
completions: ["{\n    if (l.length == 0) \n    {\n        return 0.0;\n    }\n   \
    \ else if (l.length == 1) \n    {\n        return l[0];\n    }\n    else \n  \
    \  {\n        long[] sorted = l.dup;\n        sorted.sort;\n        if (sorted.length\
    \ % 2 == 0) \n        {\n            return (sorted[sorted.length / 2 - 1] + sorted[sorted.length\
    \ / 2]) / 2.0;\n        }\n        else \n        {\n            return sorted[sorted.length\
    \ / 2];\n        }\n    }\n}", "{\n    if (l.length == 0) \n    {\n        return\
    \ 0.0;\n    }\n    else \n    {\n        long[] sorted = l.dup.sort();\n     \
    \   if (sorted.length % 2 == 1) \n        {\n            return sorted[sorted.length\
    \ / 2];\n        }\n        else \n        {\n            return (sorted[sorted.length\
    \ / 2 - 1] + sorted[sorted.length / 2]) / 2.0;\n        }\n    }\n}\n/*\nReturn\
    \ the mean of elements in the array l.\n    >>> mean([3L, 1L, 2L, 4L, 5L])\n \
    \   3.0\n    >>> mean([-10L, 4L, 6L, 1000L, 10L, 20L])\n    190.0\n*/\nfloat mean(long[]\
    \ l) \n{\n    if (l.length == 0) \n    {\n        return 0.0;\n    }\n    else\
    \ \n    {\n        return l.sum / l.length;\n    }\n}\n/*\nReturn the standard\
    \ deviation of elements in the array l.\n    >>> stddev([3L, 1L, 2L, 4L, 5L])\n\
    \    1.5811388300841898\n    >>> stddev([-10L, 4L, 6L, 1000L, 10L, 20L])\n   \
    \ 528.9795918367347\n*/\nfloat stddev(long[] l) \n{\n    if (l.length == 0) \n\
    \    {\n        return 0.0;\n    }\n    else \n    {\n        float m = mean(l);\n\
    \        float sum = 0.0;\n        foreach (x; l) \n        {\n            sum\
    \ += (x - m) * (x - m);\n        }\n        return sqrt(sum / l.length);\n   \
    \ }\n}\n/*\nReturn the variance of elements in the array l.\n    >>> variance([3L,\
    \ 1L, 2L, 4L, 5L])\n    2.5\n    >>> variance([-10L, 4L, 6L, 1000L, 10L, 20L])\n\
    \   ", "{\n    if (l.length == 0)\n    {\n        return 0;\n    }\n    else\n\
    \    {\n        long[] sorted = l.dup.sort;\n        if (sorted.length % 2 ==\
    \ 1)\n        {\n            return sorted[sorted.length / 2];\n        }\n  \
    \      else\n        {\n            return (sorted[sorted.length / 2 - 1] + sorted[sorted.length\
    \ / 2]) / 2.0;\n        }\n    }\n}", "{\n    if (l.length == 0) \n    {\n   \
    \     return 0.0;\n    }\n    else \n    {\n        long[] sorted = l.dup.sort;\n\
    \        if (sorted.length % 2 == 1) \n        {\n            return sorted[sorted.length\
    \ / 2];\n        }\n        else \n        {\n            return (sorted[sorted.length\
    \ / 2 - 1] + sorted[sorted.length / 2]) / 2.0;\n        }\n    }\n}", "{\n   \
    \ if (l.length == 0) \n    {\n        return 0.0;\n    }\n    else \n    {\n \
    \       long[] sorted = l.dup.sort;\n        int mid = l.length / 2;\n       \
    \ if (l.length % 2 == 0) \n        {\n            return (sorted[mid] + sorted[mid\
    \ - 1]) / 2.0;\n        }\n        else \n        {\n            return sorted[mid];\n\
    \        }\n    }\n}\n/*\nReturn the mode of elements in the array l.\n    >>>\
    \ mode([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L])\n    1L\n    >>> mode([1L, 1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L])\n    1L\n    >>> mode([1L, 2L, 3L, 4L,\
    \ 5L, 6L, 7L, 8L, 9L, 10L, 10L])\n    10L\n    >>> mode([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L, 9L, 10L, 10L, 10L])\n    10L\n    >>> mode([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L, 9L, 10L, 10L, 10L, 10L])\n    10L\n    >>> mode([1L, 2L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L, 10L, 10L, 10L, 10L, 10L])\n    10L\n    >>> mode([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 10L, 10L, 10L, 10L, 10L])\n    10L\n    >>> mode([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 10L, 10L, 10L, 10L, 10L, 10L])\n    10L\n\
    \   ", "{\n    long[] temp = l.dup;\n    temp.sort;\n    if (temp.length % 2 ==\
    \ 0)\n    {\n        return (temp[temp.length / 2 - 1] + temp[temp.length / 2])\
    \ / 2.0;\n    }\n    else\n    {\n        return temp[temp.length / 2];\n    }\n\
    }", "{\n    if (l.length == 0) \n    {\n        return 0;\n    }\n    else \n\
    \    {\n        long[] sorted = l.dup.sort;\n        int mid = l.length / 2;\n\
    \        if (l.length % 2 == 0) \n        {\n            return (sorted[mid -\
    \ 1] + sorted[mid]) / 2.0;\n        }\n        else \n        {\n            return\
    \ sorted[mid];\n        }\n    }\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n\
    \    int n = l2.length;\n    if (n % 2 == 1)\n        return l2[n / 2];\n    else\n\
    \        return (l2[n / 2 - 1] + l2[n / 2]) / 2.0;\n}\n/*\nReturn the mode of\
    \ elements in the array l.\n    >>> mode([3L, 1L, 2L, 4L, 5L])\n    1L\n    >>>\
    \ mode([-10L, 4L, 6L, 1000L, 10L, 20L])\n    10L\n    >>> mode([1L, 2L, 3L, 4L,\
    \ 5L, 6L, 7L, 8L, 9L, 10L])\n    1L\n*/\nlong mode(long[] l) \n{\n    long[] l2\
    \ = l.dup;\n    l2.sort;\n    long max = 0;\n    long max_count = 0;\n    long\
    \ last = 0;\n    long count = 0;\n    foreach (e; l2) \n    {\n        if (e ==\
    \ last)\n            count++;\n        else \n        {\n            if (count\
    \ > max_count) \n            {\n                max = last;\n                max_count\
    \ = count;\n            }\n            last = e;\n            count = 1;\n   \
    \     }\n    }\n    if (count > max_count) \n    {\n        max = last;\n    \
    \    max_count = count;\n    }\n    return max;\n}\n/*\nReturn the standard deviation\
    \ of elements in the array l.\n    >>> stddev([3L, 1L, 2L, 4L, 5L])\n    1.5811388300841898\n\
    \    >>> stddev([-10L, 4L, 6L, 1000L, 10L, 20L])\n    515.9778079291882\n*/\n\
    float stddev(long[] l) \n{\n    long[] l2 = l.dup;\n    l2.sort;\n    float m\
    \ = median(l2);\n    float sum = 0.0;\n    foreach (", "{\n    if (l.length ==\
    \ 0) \n    {\n        return 0.0;\n    }\n    else \n    {\n        long[] sorted\
    \ = l.dup.sort;\n        if (sorted.length % 2 == 1) \n        {\n           \
    \ return sorted[sorted.length / 2];\n        }\n        else \n        {\n   \
    \         return (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) /\
    \ 2.0;\n        }\n    }\n}", "{\n    if (l.length == 0)\n    {\n        return\
    \ 0.0;\n    }\n    else\n    {\n        long[] sorted = l.dup.sort;\n        long\
    \ mid = l.length / 2;\n        if (l.length % 2 == 0)\n        {\n           \
    \ return (sorted[mid] + sorted[mid - 1]) / 2.0;\n        }\n        else\n   \
    \     {\n            return sorted[mid];\n        }\n    }\n}\n/*\nReturn the\
    \ mode of elements in the array l.\n    >>> mode([3L, 1L, 2L, 4L, 5L])\n    [1L,\
    \ 2L, 3L, 4L, 5L]\n    >>> mode([-10L, 4L, 6L, 1000L, 10L, 20L])\n    [4L, 6L,\
    \ 10L, 20L, 1000L]\n*/\nlong[] mode(long[] l) \n{\n    if (l.length == 0)\n  \
    \  {\n        return new long[0];\n    }\n    else\n    {\n        long[] sorted\
    \ = l.dup.sort;\n        long[] result = new long[0];\n        long maxCount =\
    \ 0;\n        long currentCount = 0;\n        long currentNum = sorted[0];\n \
    \       foreach (long num; sorted)\n        {\n            if (num == currentNum)\n\
    \            {\n                currentCount++;\n            }\n            else\n\
    \            {\n                if (currentCount > maxCount)\n               \
    \ {\n                    maxCount = currentCount;\n                    result\
    \ = new long[0];\n                    result ~= currentNum;\n                }\n\
    \                else if (currentCount == maxCount)\n                {\n     \
    \               result ~= currentNum;\n                }\n                currentCount\
    \ = 1;\n                currentNum = num;\n            }\n        }\n        if\
    \ (currentCount > maxCount)\n        {\n            result = new long[0];\n  \
    \          result ~= currentNum;\n        }\n        else if (currentCount ==\
    \ maxCount)\n        {\n            result ~= currentNum;\n        }\n       \
    \ return result;\n    }\n}\n/*\nReturn the range of elements in the array l.\n\
    \    >>> range", "{\n    if (l.length == 0) \n    {\n        return 0.0;\n   \
    \ }\n    else \n    {\n        long[] sorted = l.dup;\n        sorted.sort;\n\
    \        if (sorted.length % 2 == 1) \n        {\n            return sorted[sorted.length\
    \ / 2];\n        }\n        else \n        {\n            return (sorted[sorted.length\
    \ / 2 - 1] + sorted[sorted.length / 2]) / 2.0;\n        }\n    }\n}\n/*\nReturn\
    \ the mean of elements in the array l.\n    >>> mean([3L, 1L, 2L, 4L, 5L])\n \
    \   3.0\n    >>> mean([-10L, 4L, 6L, 1000L, 10L, 20L])\n    155.0\n*/\nfloat mean(long[]\
    \ l) \n{\n    if (l.length == 0) \n    {\n        return 0.0;\n    }\n    else\
    \ \n    {\n        return l.sum / l.length;\n    }\n}\n/*\nReturn the standard\
    \ deviation of elements in the array l.\n    >>> stddev([3L, 1L, 2L, 4L, 5L])\n\
    \    1.5811388300841898\n    >>> stddev([-10L, 4L, 6L, 1000L, 10L, 20L])\n   \
    \ 590.9290780141844\n*/\nfloat stddev(long[] l) \n{\n    if (l.length == 0) \n\
    \    {\n        return 0.0;\n    }\n    else \n    {\n        float m = mean(l);\n\
    \        return sqrt(l.map!(x => (x - m) * (x - m)).sum / l.length);\n    }\n\
    }\n/*\nReturn the variance of elements in the array l.\n    >>> variance([3L,\
    \ 1L, 2L, 4L, 5L])\n    2.5\n    >>> variance([-10L, 4L, 6L, 1000L, 10L, 20L])\n\
    \    350166.6666666667\n*/\nfloat variance(long[] l) ", "{\n    long[] l2 = l.dup;\n\
    \    l2.sort;\n    if (l2.length % 2 == 1)\n        return l2[l2.length / 2];\n\
    \    else\n        return (l2[l2.length / 2 - 1] + l2[l2.length / 2]) / 2.0;\n\
    }", "{\n    if (l.length == 0) \n    {\n        return 0;\n    }\n    else \n\
    \    {\n        long[] sorted = l.dup.sort;\n        if (sorted.length % 2 ==\
    \ 1) \n        {\n            return sorted[sorted.length / 2];\n        }\n \
    \       else \n        {\n            return (sorted[sorted.length / 2 - 1] +\
    \ sorted[sorted.length / 2]) / 2.0;\n        }\n    }\n}\n/*\nReturn the mode\
    \ of elements in the array l.\n    >>> mode([3L, 1L, 2L, 4L, 5L])\n    1L\n  \
    \  >>> mode([-10L, 4L, 6L, 1000L, 10L, 20L])\n    4L\n*/\nlong mode(long[] l)\
    \ \n{\n    if (l.length == 0) \n    {\n        return 0;\n    }\n    else \n \
    \   {\n        long[] sorted = l.dup.sort;\n        long max_count = 0;\n    \
    \    long max_element = 0;\n        long current_count = 0;\n        long current_element\
    \ = 0;\n        foreach (e; sorted) \n        {\n            if (e != current_element)\
    \ \n            {\n                current_element = e;\n                current_count\
    \ = 1;\n            }\n            else \n            {\n                current_count++;\n\
    \            }\n            if (current_count > max_count) \n            {\n \
    \               max_count = current_count;\n                max_element = e;\n\
    \            }\n        }\n        return max_element;\n    }\n}\n/*\nReturn the\
    \ standard deviation of elements in the array l.\n    >>> stddev([3L, 1L, 2L,\
    \ 4L, 5L])\n    1.5811388300841898\n    >>> stddev([-10L, 4L, 6L, 1000L, 10L,\
    \ 20L])\n    558.8671328671328\n*/\nfloat stddev(long[] l) \n{\n    if (l.length\
    \ == 0) \n    {\n        return 0;", "{\n    long[] l2 = l.dup;\n    l2.sort;\n\
    \    int n = l2.length;\n    if (n % 2 == 1)\n        return l2[n / 2];\n    else\n\
    \        return (l2[n / 2 - 1] + l2[n / 2]) / 2.0;\n}", "{\n    if (l.length ==\
    \ 0) \n    {\n        return 0.0;\n    }\n    else \n    {\n        long[] sorted\
    \ = l.dup.sort;\n        if (sorted.length % 2 == 1) \n        {\n           \
    \ return sorted[sorted.length / 2];\n        }\n        else \n        {\n   \
    \         return (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) /\
    \ 2.0;\n        }\n    }\n}\n/*\nReturn the mode of elements in the array l.\n\
    \    >>> mode([3L, 1L, 2L, 4L, 5L])\n    1L\n    >>> mode([-10L, 4L, 6L, 1000L,\
    \ 10L, 20L])\n    4L\n*/\nlong mode(long[] l) \n{\n    if (l.length == 0) \n \
    \   {\n        return 0L;\n    }\n    else \n    {\n        long[] sorted = l.dup.sort;\n\
    \        long max_count = 0L;\n        long max_value = sorted[0];\n        long\
    \ current_count = 0L;\n        long current_value = sorted[0];\n        foreach\
    \ (long i; sorted) \n        {\n            if (i == current_value) \n       \
    \     {\n                current_count++;\n            }\n            else \n\
    \            {\n                if (current_count > max_count) \n            \
    \    {\n                    max_count = current_count;\n                    max_value\
    \ = current_value;\n                }\n                current_value = i;\n  \
    \              current_count = 1L;\n            }\n        }\n        if (current_count\
    \ > max_count) \n        {\n            max_count = current_count;\n         \
    \   max_value = current_value;\n        }\n        return max_value;\n    }\n\
    }\n/*\nReturn the range of elements in the array l.\n    >>> range([3L, 1L, 2L,\
    \ 4L, 5L])\n    4L\n    >>> range([-10L, 4L, 6L, 1000L, 10L, 20L])\n    1010L\n\
    */", "{\n    long[] sorted = l.dup.sort;\n    int len = sorted.length;\n    if\
    \ (len % 2 == 1)\n        return sorted[len / 2];\n    else\n        return (sorted[len\
    \ / 2 - 1] + sorted[len / 2]) / 2.0;\n}\n/*\nReturn the mode of elements in the\
    \ array l.\n    >>> mode([3L, 1L, 2L, 4L, 5L])\n    [1L, 2L, 3L, 4L, 5L]\n   \
    \ >>> mode([-10L, 4L, 6L, 1000L, 10L, 20L])\n    [4L, 6L, 10L, 20L, 1000L]\n*/\n\
    long[] mode(long[] l) \n{\n    long[] sorted = l.dup.sort;\n    long[] modes =\
    \ [];\n    long[] counts = [];\n    long maxCount = 0L;\n    long currentValue\
    \ = sorted[0];\n    long currentCount = 0L;\n    foreach (long value; sorted)\
    \ \n    {\n        if (value != currentValue) \n        {\n            if (currentCount\
    \ > maxCount) \n            {\n                modes = [currentValue];\n     \
    \           counts = [currentCount];\n                maxCount = currentCount;\n\
    \            }\n            else if (currentCount == maxCount) \n            {\n\
    \                modes ~= currentValue;\n                counts ~= currentCount;\n\
    \            }\n            currentValue = value;\n            currentCount =\
    \ 0L;\n        }\n        currentCount++;\n    }\n    if (currentCount > maxCount)\
    \ \n    {\n        modes = [currentValue];\n        counts = [currentCount];\n\
    \        maxCount = currentCount;\n    }\n    else if (currentCount == maxCount)\
    \ \n    {\n        modes ~= currentValue;\n        counts ~= currentCount;\n \
    \   }\n    return modes;\n}\n/*\nReturn the standard deviation of elements in\
    \ the array l.\n    >>> stddev([3L, 1L, 2L, 4L, 5L])\n    1.5811388300841898\n\
    \    >>> stddev([-10L, 4L, 6L, 1000L", "{\n    int n = l.length;\n    if (n ==\
    \ 0) \n    {\n        return 0.0;\n    }\n    else \n    {\n        long[] sorted\
    \ = l.dup;\n        sorted.sort;\n        if (n % 2 == 1) \n        {\n      \
    \      return sorted[n / 2];\n        }\n        else \n        {\n          \
    \  return (sorted[n / 2 - 1] + sorted[n / 2]) / 2.0;\n        }\n    }\n}\n/*\n\
    Return the mode of elements in the array l.\n    >>> mode([3L, 1L, 2L, 4L, 5L])\n\
    \    1L\n    >>> mode([-10L, 4L, 6L, 1000L, 10L, 20L])\n    4L\n*/\nlong mode(long[]\
    \ l) \n{\n    int n = l.length;\n    if (n == 0) \n    {\n        return 0L;\n\
    \    }\n    else \n    {\n        long[] sorted = l.dup;\n        sorted.sort;\n\
    \        long max_count = 1L;\n        long max_value = sorted[0];\n        long\
    \ current_count = 1L;\n        long current_value = sorted[0];\n        for (int\
    \ i = 1; i < n; i++) \n        {\n            if (sorted[i] == current_value)\
    \ \n            {\n                current_count++;\n            }\n         \
    \   else \n            {\n                if (current_count > max_count) \n  \
    \              {\n                    max_count = current_count;\n           \
    \         max_value = current_value;\n                }\n                current_count\
    \ = 1L;\n                current_value = sorted[i];\n            }\n        }\n\
    \        if (current_count > max_count) \n        {\n            max_count = current_count;\n\
    \            max_value = current_value;\n        }\n        return max_value;\n\
    \    }\n}\n/*\nReturn the range of elements in the array l.\n    >>> range([3L,\
    \ 1L, 2L, 4L, 5L])\n    4L\n    >>> range([-10L, 4", "{\n    if (l.length == 0)\
    \ \n    {\n        return 0;\n    }\n    else \n    {\n        long[] sorted =\
    \ l.dup;\n        sorted.sort;\n        if (sorted.length % 2 == 1) \n       \
    \ {\n            return sorted[sorted.length / 2];\n        }\n        else \n\
    \        {\n            return (sorted[sorted.length / 2 - 1] + sorted[sorted.length\
    \ / 2]) / 2.0;\n        }\n    }\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n\
    \    if (l2.length % 2 == 1)\n    {\n        return l2[l2.length / 2];\n    }\n\
    \    else\n    {\n        return (l2[l2.length / 2 - 1] + l2[l2.length / 2]) /\
    \ 2.0;\n    }\n}", "{\n    if (l.length == 0) \n    {\n        return 0.0;\n \
    \   }\n    else \n    {\n        long[] sorted = l.dup;\n        sorted.sort;\n\
    \        if (sorted.length % 2 == 1) \n        {\n            return sorted[sorted.length\
    \ / 2];\n        }\n        else \n        {\n            return (sorted[sorted.length\
    \ / 2 - 1] + sorted[sorted.length / 2]) / 2.0;\n        }\n    }\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
