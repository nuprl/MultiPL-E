name: HumanEval_141_file_name_check
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] parts = split(file_name, \".\"\
    );\n    if (parts.length != 2)\n        return \"No\";\n    if (parts[0].length\
    \ == 0)\n        return \"No\";\n    if (parts[0][0] < 'a' || parts[0][0] > 'z')\n\
    \        return \"No\";\n    if (parts[1] !in valid_extensions)\n        return\
    \ \"No\";\n    if (parts[0].count!(c => c >= '0' && c <= '9') > 3)\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1zxg8blm.d(23): Error: undefined identifier `split`\\n/tmp/tmp1zxg8blm.d(30):\
    \ Error: incompatible types for `(parts[1]) in (valid_extensions)`: `string` and\
    \ `string[]`\\n/tmp/tmp1zxg8blm.d(32): Error: no property `count` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1zxg8blm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count\
    \ = 0;\n    int digit_count = 0;\n    int dot_index = 0;\n    bool is_valid =\
    \ true;\n    foreach(i, c; file_name)\n    {\n        if(c == '.')\n        {\n\
    \            dot_count++;\n            dot_index = i;\n        }\n        if(c\
    \ >= '0' && c <= '9')\n        {\n            digit_count++;\n        }\n    }\n\
    \    if(dot_count != 1 || digit_count > 3)\n    {\n        is_valid = false;\n\
    \    }\n    else\n    {\n        string prefix = file_name[0..dot_index];\n  \
    \      string suffix = file_name[dot_index+1..$];\n        if(prefix.length ==\
    \ 0 || !(prefix[0] >= 'a' && prefix[0] <= 'z' || prefix[0] >= 'A' && prefix[0]\
    \ <= 'Z'))\n        {\n            is_valid = false;\n        }\n        else\
    \ if(suffix != \"txt\" && suffix != \"exe\" && suffix != \"dll\")\n        {\n\
    \            is_valid = false;\n        }\n    }\n    return is_valid ? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo4ad3i3g.d(31): Error: cannot implicitly convert expression `i`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpo4ad3i3g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index +\
    \ 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n\
    \    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n\
    \    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\"\
    \ && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n \
    \   if(name.length == 0)\n        return \"No\";\n    if(name[0] < 'a' || name[0]\
    \ > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg3w19a4j.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpg3w19a4j.d(23): Error: no property `substr` for type `string`\\n/tmp/tmpg3w19a4j.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpg3w19a4j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[]\
    \ file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length !=\
    \ 2)\n        return \"No\";\n    foreach (char c; file_name_parts[0])\n    {\n\
    \        if (c >= '0' && c <= '9')\n            count++;\n    }\n    if (count\
    \ > 3)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n    \
    \    return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z' &&\n        file_name_parts[0][0] < 'A' || file_name_parts[0][0] > 'Z')\n\
    \        return \"No\";\n    if (valid_extensions.find(file_name_parts[1]) ==\
    \ -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmporimeo_i.d(24): Error: no property `split` for type `string`\\\
    n/tmp/tmporimeo_i.d(39): Error: no property `find` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmporimeo_i.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index +\
    \ 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n\
    \    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n\
    \    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\"\
    \ && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n \
    \   if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0]\
    \ <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n  \
    \  return \"Yes\";\n}\n/*\nCreate a function which takes a string representing\
    \ a file's name, and returns\n    'Yes' if the the file's name is valid, and returns\
    \ 'No' otherwise.\n    A file's name is considered to be valid if and only if\
    \ all the following conditions \n    are met:\n    - There should not be more\
    \ than three digits ('0'-'9') in the file's name.\n    - The file's name contains\
    \ exactly one dot '.'\n    - The substring before the dot should not be empty,\
    \ and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n\
    \    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n\
    \    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>>\
    \ file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check2(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension\
    \ = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n\
    \    int digits = 0;\n    foreach(c; name)\n    {\n\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp02_36jpc.d(67): Error: found `unittest` instead of statement\\\
    n/tmp/tmp02_36jpc.d(98): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp02_36jpc.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n \
    \   string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0,\
    \ dot_index);\n    int digits_count = 0;\n    foreach(char c; name)\n    {\n \
    \       if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count\
    \ > 3 || dot_index == -1 || name.length == 0 || name[0] < 'A' || name[0] > 'z'\
    \ || !valid_extensions.count(extension))\n        return \"No\";\n    return \"\
    Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp71rg69c3.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmp71rg69c3.d(24): Error: no property `substr` for type `string`\\n/tmp/tmp71rg69c3.d(25):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmp71rg69c3.d(32): Error:\
    \ no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp71rg69c3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    string extension = \"\
    \";\n    string name = \"\";\n    foreach(i, c; file_name)\n    {\n        if(c\
    \ == '.')\n        {\n            dot_count++;\n            dot_index = i;\n \
    \       }\n        if(c >= '0' && c <= '9')\n        {\n            count++;\n\
    \        }\n    }\n    if(count > 3 || dot_count != 1)\n    {\n        return\
    \ \"No\";\n    }\n    name = file_name[0..dot_index];\n    extension = file_name[dot_index+1..$];\n\
    \    if(name.length == 0 || !(name[0] >= 'a' && name[0] <= 'z' || name[0] >= 'A'\
    \ && name[0] <= 'Z'))\n    {\n        return \"No\";\n    }\n    if(extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\")\n    {\n       \
    \ return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcx6aslfz.d(32): Error: cannot implicitly convert expression `i`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpcx6aslfz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find(\".\");\n    if (dot_index == -1)\n        return \"No\";\n\
    \    string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n\
    \    if (before_dot.length == 0)\n        return \"No\";\n    if (after_dot !=\
    \ \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"\
    No\";\n    int digit_count = 0;\n    foreach (c; before_dot)\n    {\n        if\
    \ (c >= '0' && c <= '9')\n            digit_count++;\n    }\n    if (digit_count\
    \ > 3)\n        return \"No\";\n    if (before_dot[0] < 'a' || before_dot[0] >\
    \ 'z')\n        return \"No\";\n    return \"Yes\";\n}\n/*\nCreate a function\
    \ which takes a string representing a file's name, and returns\n    'Yes' if the\
    \ the file's name is valid, and returns 'No' otherwise.\n    A file's name is\
    \ considered to be valid if and only if all the following conditions \n    are\
    \ met:\n    - There should not be more than three digits ('0'-'9') in the file's\
    \ name.\n    - The file's name contains exactly one dot '.'\n    - The substring\
    \ before the dot should not be empty, and it starts with a letter from \n    the\
    \ latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should\
    \ be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find(\".\");\n    if (dot_index == -1)\n        return \"No\";\n\
    \    string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpco40gtmj.d(67): Error: expression expected, not `unittest`\\\
    n/tmp/tmpco40gtmj.d(68): Error: found `{` when expecting `,`\\n/tmp/tmpco40gtmj.d(69):\
    \ Error: expression expected, not `alias`\\n/tmp/tmpco40gtmj.d(69): Error: found\
    \ `candidate` when expecting `,`\\n/tmp/tmpco40gtmj.d(69): Error: expression expected,\
    \ not `=`\\n/tmp/tmpco40gtmj.d(69): Error: found `file_name_check` when expecting\
    \ `,`\\n/tmp/tmpco40gtmj.d(69): Error: expression expected, not `;`\\n/tmp/tmpco40gtmj.d(71):\
    \ Error: found `assert` when expecting `,`\\n/tmp/tmpco40gtmj.d(71): Error: found\
    \ `;` when expecting `,`\\n/tmp/tmpco40gtmj.d(72): Error: found `;` when expecting\
    \ `,`\\n/tmp/tmpco40gtmj.d(73): Error: found `;` when expecting `,`\\n/tmp/tmpco40gtmj.d(74):\
    \ Error: found `;` when expecting `,`\\n/tmp/tmpco40gtmj.d(75): Error: found `;`\
    \ when expecting `,`\\n/tmp/tmpco40gtmj.d(76): Error: found `;` when expecting\
    \ `,`\\n/tmp/tmpco40gtmj.d(77): Error: found `;` when expecting `,`\\n/tmp/tmpco40gtmj.d(78):\
    \ Error: found `;` when expecting `,`\\n/tmp/tmpco40gtmj.d(79): Error: found `;`\
    \ when expecting `,`\\n/tmp/tmpco40gtmj.d(80): Error: found `;` when expecting\
    \ `,`\\n/tmp/tmpco40gtmj.d(81): Error: found `;` when expecting `,`\\n/tmp/tmpco40gtmj.d(82):\
    \ Error: found `;` when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpco40gtmj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n   \
    \ string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n\
    \    if (before_dot.length == 0)\n        return \"No\";\n    if (before_dot.count('0','9')\
    \ > 3)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"\
    exe\" && after_dot != \"dll\")\n        return \"No\";\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcem4v50p.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpcem4v50p.d(29): Error: no property `count` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcem4v50p.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    string extension = \"\";\n    string file_name_without_extension\
    \ = \"\";\n    foreach(char c; file_name)\n    {\n        if(c == '.')\n     \
    \   {\n            dot_count++;\n            continue;\n        }\n        if(dot_count\
    \ == 0)\n        {\n            file_name_without_extension ~= c;\n        }\n\
    \        else\n        {\n            extension ~= c;\n        }\n        if(c\
    \ >= '0' && c <= '9')\n        {\n            count++;\n        }\n    }\n   \
    \ if(count > 3 || dot_count != 1 || file_name_without_extension.length == 0 ||\
    \ !(file_name_without_extension[0] >= 'a' && file_name_without_extension[0] <=\
    \ 'z') || !(file_name_without_extension[0] >= 'A' && file_name_without_extension[0]\
    \ <= 'Z') || extension != \"txt\" && extension != \"exe\" && extension != \"dll\"\
    )\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n\
    \    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpp4ks35ps.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428855]\\n??:? void tmpp4ks35ps.__unittest_L52_C1()\
    \ [0x427d5d]\\n??:? void tmpp4ks35ps.__modtest() [0x4285d4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cf5f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42be6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430845]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430cf4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4307d1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42be45]\\n??:? runModuleUnitTests [0x42cd35]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428d18]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428c9f]\\n??:? _d_run_main [0x428c0a]\\n??:? main [0x4285e7]\\\
    n??:? __libc_start_main [0xfb30f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find('.');\n    string ext = file_name.substr(dot_pos+1);\n    string\
    \ name = file_name.substr(0, dot_pos);\n    int digits = 0;\n    foreach(c; name)\n\
    \    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits\
    \ > 3)\n        return \"No\";\n    if(ext != \"txt\" && ext != \"exe\" && ext\
    \ != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return\
    \ \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0]\
    \ <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6odrcw7l.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmp6odrcw7l.d(23): Error: no property `substr` for type `string`\\n/tmp/tmp6odrcw7l.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp6odrcw7l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // TODO: implement\
    \ this function\n    //return \"Yes\";\n    int dot_pos = file_name.find('.');\n\
    \    if (dot_pos == -1)\n        return \"No\";\n    string pre_dot = file_name[0..dot_pos];\n\
    \    string post_dot = file_name[dot_pos+1..$];\n    if (pre_dot.length == 0 ||\
    \ post_dot.length == 0)\n        return \"No\";\n    if (pre_dot.count('0'..'9')\
    \ > 3)\n        return \"No\";\n    if (post_dot != \"txt\" && post_dot != \"\
    exe\" && post_dot != \"dll\")\n        return \"No\";\n    if (pre_dot[0] < 'a'\
    \ || pre_dot[0] > 'z')\n        if (pre_dot[0] < 'A' || pre_dot[0] > 'Z')\n  \
    \          return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3m6ch43l.d(31): Error: found `..` when expecting `,`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3m6ch43l.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int dot_index_start\
    \ = 0;\n    int dot_index_end = 0;\n    int dot_index_start_end = 0;\n    int\
    \ dot_index_end_end = 0;\n    int dot_index_start_start = 0;\n    int dot_index_end_start\
    \ = 0;\n    int dot_index_start_start_end = 0;\n    int dot_index_end_start_end\
    \ = 0;\n    int dot_index_start_end_end = 0;\n    int dot_index_end_end_end =\
    \ 0;\n    int dot_index_start_start_start = 0;\n    int dot_index_end_start_start\
    \ = 0;\n    int dot_index_start_start_start_end = 0;\n    int dot_index_end_start_start_end\
    \ = 0;\n    int dot_index_start_start_end_end = 0;\n    int dot_index_end_start_end_end\
    \ = 0;\n    int dot_index_start_end_end_end = 0;\n    int dot_index_end_end_end_end\
    \ = 0;\n    int dot_index_start_start_start_start = 0;\n    int dot_index_end_start_start_start\
    \ = 0;\n    int dot_index_start_start_start_start_end = 0;\n    int dot_index_end_start_start_start_end\
    \ = 0;\n    int dot_index_start_start_start_end_end = 0;\n    int dot_index_end_start_start_end_end\
    \ = 0;\n    int dot_index_start_start_end_end_end = 0;\n    int dot_index_end_start_end_end_end\
    \ = 0;\n    int dot_index_start_end_end_end_end = 0;\n    int dot_index_end_end_end_end_end\
    \ = 0;\n    int dot_index_start_start_start_start_start = 0;\n    int dot_index_end_start_start_start\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpic7bvspq.d(55): Error: semicolon expected, not `unittest`\\n/tmp/tmpic7bvspq.d(55):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpic7bvspq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (file_name_parts[1] !in valid_extensions)\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpotawm7a3.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmpotawm7a3.d(28): Error: no property `count` for type `string`\\n/tmp/tmpotawm7a3.d(32):\
    \ Error: incompatible types for `(file_name_parts[1]) in (valid_extensions)`:\
    \ `string` and `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpotawm7a3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_pos\
    \ = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n   \
    \ auto ext = file_name.substr(dot_pos + 1);\n    if (ext != \"txt\" && ext !=\
    \ \"exe\" && ext != \"dll\")\n        return \"No\";\n    auto name = file_name.substr(0,\
    \ dot_pos);\n    if (name.length == 0)\n        return \"No\";\n    if (name[0]\
    \ < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"\
    No\";\n    if (name.count!(char)(\"0123456789\") > 3)\n        return \"No\";\n\
    \    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprgxbv3gi.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmprgxbv3gi.d(25): Error: no property `substr` for type `string`\\n/tmp/tmprgxbv3gi.d(28):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmprgxbv3gi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n \
    \   string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n\
    \    if (before_dot.length == 0 || !isalpha(before_dot[0]))\n        return \"\
    No\";\n    int digits_count = 0;\n    foreach (c; before_dot)\n    {\n       \
    \ if (isdigit(c))\n            digits_count++;\n    }\n    if (digits_count >\
    \ 3)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"\
    exe\" && after_dot != \"dll\")\n        return \"No\";\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxm5o8yc9.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpxm5o8yc9.d(27): Error: undefined identifier `isalpha`\\n/tmp/tmpxm5o8yc9.d(32):\
    \ Error: undefined identifier `isdigit`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpxm5o8yc9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    string file_extension = file_name[dot_index+1..$];\n    string file_name_without_extension\
    \ = file_name[0..dot_index-1];\n    int digits_count = 0;\n    foreach(char c;\
    \ file_name_without_extension)\n    {\n        if(c >= '0' && c <= '9')\n    \
    \    {\n            digits_count++;\n        }\n    }\n    if(digits_count > 3)\n\
    \    {\n        return \"No\";\n    }\n    if(file_name.count(\".\") != 1)\n \
    \   {\n        return \"No\";\n    }\n    if(file_name_without_extension.length\
    \ == 0)\n    {\n        return \"No\";\n    }\n    if(file_name_without_extension[0]\
    \ < 'a' || file_name_without_extension[0] > 'z')\n    {\n        return \"No\"\
    ;\n    }\n    if(!valid_extensions.canFind(file_extension))\n    {\n        return\
    \ \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpikamlvf_.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpikamlvf_.d(38): Error: no property `count` for type `string`\\n/tmp/tmpikamlvf_.d(50):\
    \ Error: no property `canFind` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpikamlvf_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    import std.regex;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.conv;\n    import\
    \ std.range;\n    import std.string;\n    import std.typecons;\n    import std.math;\n\
    \    import std.stdio;\n    import std.exception;\n    import std.traits;\n  \
    \  import std.typecons;\n    import std.math;\n    import std.algorithm;\n   \
    \ import std.array;\n    import std.conv;\n    import std.range;\n    import std.string;\n\
    \    import std.typecons;\n    import std.math;\n    import std.algorithm;\n \
    \   import std.array;\n    import std.conv;\n    import std.range;\n    import\
    \ std.string;\n    import std.typecons;\n    import std.math;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std.range;\n    import\
    \ std.string;\n    import std.typecons;\n    import std.math;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std.range;\n    import\
    \ std.string;\n    import std.typecons;\n    import std.math;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std.range;\n    import\
    \ std.string;\n    import std.typecons;\n    import std.math;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std.range;\n    import\
    \ std.string;\n    import std.typecons;\n    import std.math;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std.range;\n    import\
    \ std.string;\n    import std.typecons;\n    import std.math;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std.range;\n    import\
    \ std.string;\n    import std.typecons;\n    import std.math;\n    import std\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpol06vqk5.d(92): Error: `;` expected\\n/tmp/tmpol06vqk5.d(123):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpol06vqk5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n \
    \   string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n\
    \    if (before_dot.length == 0 || before_dot.length > 8)\n        return \"No\"\
    ;\n    if (after_dot.length == 0 || after_dot.length > 3)\n        return \"No\"\
    ;\n    if (before_dot.count!(a => a >= '0' && a <= '9') > 3)\n        return \"\
    No\";\n    if (before_dot[0] < 'a' || before_dot[0] > 'z')\n        return \"\
    No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"\
    dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplwg5mp9k.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmplwg5mp9k.d(31): Error: no property `count` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplwg5mp9k.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_split = file_name.split(\"\
    .\");\n    if (file_name_split.length != 2)\n        return \"No\";\n    string\
    \ file_name_without_extension = file_name_split[0];\n    string file_extension\
    \ = file_name_split[1];\n    if (file_name_without_extension.length == 0)\n  \
    \      return \"No\";\n    if (file_name_without_extension.count(\"0\") + file_name_without_extension.count(\"\
    1\") + file_name_without_extension.count(\"2\") + file_name_without_extension.count(\"\
    3\") + file_name_without_extension.count(\"4\") + file_name_without_extension.count(\"\
    5\") + file_name_without_extension.count(\"6\") + file_name_without_extension.count(\"\
    7\") + file_name_without_extension.count(\"8\") + file_name_without_extension.count(\"\
    9\") > 3)\n        return \"No\";\n    if (file_name_without_extension[0] < 'a'\
    \ || file_name_without_extension[0] > 'z')\n        return \"No\";\n    if (file_name_without_extension[0]\
    \ < 'A' || file_name_without_extension[0] > 'Z')\n        return \"No\";\n   \
    \ if (valid_extensions.count(file_extension) == 0)\n        return \"No\";\n \
    \   return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_395o_2v.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmp_395o_2v.d(30): Error: no property `count` for type `string`\\n/tmp/tmp_395o_2v.d(30):\
    \ Error: no property `count` for type `string`\\n/tmp/tmp_395o_2v.d(30): Error:\
    \ no property `count` for type `string`\\n/tmp/tmp_395o_2v.d(30): Error: no property\
    \ `count` for type `string`\\n/tmp/tmp_395o_2v.d(30): Error: no property `count`\
    \ for type `string`\\n/tmp/tmp_395o_2v.d(30): Error: no property `count` for type\
    \ `string`\\n/tmp/tmp_395o_2v.d(30): Error: no property `count` for type `string`\\\
    n/tmp/tmp_395o_2v.d(30): Error: no property `count` for type `string`\\n/tmp/tmp_395o_2v.d(30):\
    \ Error: no property `count` for type `string`\\n/tmp/tmp_395o_2v.d(30): Error:\
    \ no property `count` for type `string`\\n/tmp/tmp_395o_2v.d(36): Error: no property\
    \ `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp_395o_2v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find(\".\");\n    string extension = file_name.substr(dot_index\
    \ + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n\
    \    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n        \
    \    digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return\
    \ \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0]\
    \ >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplfy05vgk.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmplfy05vgk.d(23): Error: no property `substr` for type `string`\\n/tmp/tmplfy05vgk.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmplfy05vgk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_split = file_name.split(\"\
    .\");\n    if (file_name_split.length != 2)\n        return \"No\";\n    string\
    \ file_name_without_extension = file_name_split[0];\n    string file_extension\
    \ = file_name_split[1];\n    if (file_name_without_extension.length == 0)\n  \
    \      return \"No\";\n    if (file_name_without_extension.count(\"0\") + file_name_without_extension.count(\"\
    1\") + file_name_without_extension.count(\"2\") + file_name_without_extension.count(\"\
    3\") + file_name_without_extension.count(\"4\") + file_name_without_extension.count(\"\
    5\") + file_name_without_extension.count(\"6\") + file_name_without_extension.count(\"\
    7\") + file_name_without_extension.count(\"8\") + file_name_without_extension.count(\"\
    9\") > 3)\n        return \"No\";\n    if (file_name_without_extension[0] < 'a'\
    \ || file_name_without_extension[0] > 'z')\n        return \"No\";\n    if (file_name_without_extension[0]\
    \ < 'A' || file_name_without_extension[0] > 'Z')\n        return \"No\";\n   \
    \ if (valid_extensions.count(file_extension) == 0)\n        return \"No\";\n \
    \   return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp72h3vrh0.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmp72h3vrh0.d(30): Error: no property `count` for type `string`\\n/tmp/tmp72h3vrh0.d(30):\
    \ Error: no property `count` for type `string`\\n/tmp/tmp72h3vrh0.d(30): Error:\
    \ no property `count` for type `string`\\n/tmp/tmp72h3vrh0.d(30): Error: no property\
    \ `count` for type `string`\\n/tmp/tmp72h3vrh0.d(30): Error: no property `count`\
    \ for type `string`\\n/tmp/tmp72h3vrh0.d(30): Error: no property `count` for type\
    \ `string`\\n/tmp/tmp72h3vrh0.d(30): Error: no property `count` for type `string`\\\
    n/tmp/tmp72h3vrh0.d(30): Error: no property `count` for type `string`\\n/tmp/tmp72h3vrh0.d(30):\
    \ Error: no property `count` for type `string`\\n/tmp/tmp72h3vrh0.d(30): Error:\
    \ no property `count` for type `string`\\n/tmp/tmp72h3vrh0.d(36): Error: no property\
    \ `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp72h3vrh0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    string extension = \"\
    \";\n    string name = \"\";\n    foreach(i, c; file_name)\n    {\n        if(c\
    \ == '.')\n        {\n            dot_count++;\n            dot_index = i;\n \
    \       }\n        if(c >= '0' && c <= '9')\n        {\n            count++;\n\
    \        }\n    }\n    if(count > 3 || dot_count != 1)\n    {\n        return\
    \ \"No\";\n    }\n    extension = file_name[dot_index+1..$];\n    name = file_name[0..dot_index-1];\n\
    \    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n\
    \    {\n        return \"No\";\n    }\n    if(name == \"\" || (name[0] < 'a' ||\
    \ name[0] > 'z') && (name[0] < 'A' || name[0] > 'Z'))\n    {\n        return \"\
    No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcbilbs4w.d(32): Error: cannot implicitly convert expression `i`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpcbilbs4w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index +\
    \ 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n\
    \    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n\
    \    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\"\
    \ && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n \
    \   if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0]\
    \ <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n  \
    \  return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5axhustq.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmp5axhustq.d(23): Error: no property `substr` for type `string`\\n/tmp/tmp5axhustq.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp5axhustq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // TODO: Implement\
    \ this function\n    //return \"Yes\";\n    int count = 0;\n    int dot_count\
    \ = 0;\n    int dot_index = 0;\n    int start_index = 0;\n    int end_index =\
    \ 0;\n    string sub_string = \"\";\n    string sub_string_1 = \"\";\n    string\
    \ sub_string_2 = \"\";\n    string sub_string_3 = \"\";\n    string sub_string_4\
    \ = \"\";\n    string sub_string_5 = \"\";\n    string sub_string_6 = \"\";\n\
    \    string sub_string_7 = \"\";\n    string sub_string_8 = \"\";\n    string\
    \ sub_string_9 = \"\";\n    string sub_string_10 = \"\";\n    string sub_string_11\
    \ = \"\";\n    string sub_string_12 = \"\";\n    string sub_string_13 = \"\";\n\
    \    string sub_string_14 = \"\";\n    string sub_string_15 = \"\";\n    string\
    \ sub_string_16 = \"\";\n    string sub_string_17 = \"\";\n    string sub_string_18\
    \ = \"\";\n    string sub_string_19 = \"\";\n    string sub_string_20 = \"\";\n\
    \    string sub_string_21 = \"\";\n    string sub_string_22 = \"\";\n    string\
    \ sub_string_23 = \"\";\n    string sub_string_24 = \"\";\n    string sub_string_25\
    \ = \"\";\n    string sub_string_26 = \"\";\n    string sub_string_27 = \"\";\n\
    \    string sub_string_28 = \"\";\n    string sub_string_29 = \"\";\n    string\
    \ sub_string_30 = \"\";\n    string sub_string_31 = \"\";\n    string sub_string_32\
    \ = \"\";\n    string sub_string_33 = \"\";\n    string sub_string_34 = \"\";\n\
    \    string sub_string_35 = \"\";\n    string sub_string_36 = \"\";\n    string\
    \ sub_string_37 = \"\";\n    string sub_string_38 = \"\";\n    string sub_string_39\
    \ = \"\";\n    string sub_string_40 = \"\";\n   \nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmooe2zv0.d(71): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmooe2zv0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find('.');\n    string ext = file_name.substr(dot_pos+1);\n    string\
    \ name = file_name.substr(0, dot_pos);\n    if(name.length == 0 || ext.length\
    \ == 0)\n        return \"No\";\n    if(ext != \"txt\" && ext != \"exe\" && ext\
    \ != \"dll\")\n        return \"No\";\n    if(name.count('0') + name.count('1')\
    \ + name.count('2') + name.count('3') + name.count('4') + name.count('5') + name.count('6')\
    \ + name.count('7') + name.count('8') + name.count('9') > 3)\n        return \"\
    No\";\n    if(name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppusyewac.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmppusyewac.d(23): Error: no property `substr` for type `string`\\n/tmp/tmppusyewac.d(24):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmppusyewac.d(29): Error:\
    \ no property `count` for type `string`\\n/tmp/tmppusyewac.d(29): Error: no property\
    \ `count` for type `string`\\n/tmp/tmppusyewac.d(29): Error: no property `count`\
    \ for type `string`\\n/tmp/tmppusyewac.d(29): Error: no property `count` for type\
    \ `string`\\n/tmp/tmppusyewac.d(29): Error: no property `count` for type `string`\\\
    n/tmp/tmppusyewac.d(29): Error: no property `count` for type `string`\\n/tmp/tmppusyewac.d(29):\
    \ Error: no property `count` for type `string`\\n/tmp/tmppusyewac.d(29): Error:\
    \ no property `count` for type `string`\\n/tmp/tmppusyewac.d(29): Error: no property\
    \ `count` for type `string`\\n/tmp/tmppusyewac.d(29): Error: no property `count`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppusyewac.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    import std.array;\n\
    \    import std.algorithm;\n    import std.conv;\n    import std.range;\n    import\
    \ std.string;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n\
    \    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n\
    \    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import\
    \ std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n\
    \    import std.math;\n    import std.regex;\n    import std.stdio;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n\
    \    import std.typecons;\n    import std.math;\n    import std.regex;\n    import\
    \ std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n\
    \    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n\
    \    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import\
    \ std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n\
    \    import std.math;\n    import std.regex;\n    import std.stdio;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n\
    \    import std.typecons;\n    import std.math;\n    import std.regex;\n    import\
    \ std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n\
    \    import std.stdio;\n    import std.typecons;\n\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpejq_nmf9.d(89): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpejq_nmf9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = split(file_name,\
    \ \".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if\
    \ (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count!(c\
    \ => '0' <= c && c <= '9') > 3)\n        return \"No\";\n    if (file_name_parts[0][0]\
    \ < 'a' || 'z' < file_name_parts[0][0])\n        return \"No\";\n    if (file_name_parts[0][0]\
    \ < 'A' || 'Z' < file_name_parts[0][0])\n        return \"No\";\n    if (!valid_extensions.canFind(file_name_parts[1]))\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp37vlssbl.d(23): Error: undefined identifier `split`\\n/tmp/tmp37vlssbl.d(28):\
    \ Error: no property `count` for type `string`\\n/tmp/tmp37vlssbl.d(34): Error:\
    \ no property `canFind` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp37vlssbl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find('.');\n    string ext = file_name.substr(dot_pos + 1);\n  \
    \  if (ext == \"txt\" || ext == \"exe\" || ext == \"dll\")\n    {\n        string\
    \ name = file_name.substr(0, dot_pos);\n        if (name.length > 0)\n       \
    \ {\n            int count = 0;\n            foreach (c; name)\n            {\n\
    \                if (c >= '0' && c <= '9')\n                    count++;\n   \
    \         }\n            if (count <= 3)\n            {\n                if (name[0]\
    \ >= 'a' && name[0] <= 'z' || name[0] >= 'A' && name[0] <= 'Z')\n            \
    \        return \"Yes\";\n            }\n        }\n    }\n    return \"No\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp30doa6wv.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmp30doa6wv.d(23): Error: no property `substr` for type `string`\\n/tmp/tmp30doa6wv.d(26):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp30doa6wv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // Your code\
    \ here\n    int dot_count = 0;\n    int digit_count = 0;\n    int first_letter\
    \ = 0;\n    int last_letter = 0;\n    string extension = \"\";\n    foreach(i,\
    \ c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n\
    \            last_letter = i;\n        }\n        if(c >= '0' && c <= '9')\n \
    \       {\n            digit_count++;\n        }\n        if(i == 0 && (c >= 'a'\
    \ && c <= 'z' || c >= 'A' && c <= 'Z'))\n        {\n            first_letter =\
    \ 1;\n        }\n    }\n    extension = file_name[last_letter + 1 .. $];\n   \
    \ if(dot_count != 1 || digit_count > 3 || first_letter == 0 || \n        (extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\"))\n    {\n      \
    \  return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphrytgzrw.d(33): Error: cannot implicitly convert expression `i`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmphrytgzrw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    if (dot_index == -1) return \"No\";\n    string extension = file_name[dot_index+1..$];\n\
    \    if (!valid_extensions.find(extension)) return \"No\";\n    string name =\
    \ file_name[0..dot_index-1];\n    if (name.length == 0) return \"No\";\n    if\
    \ (name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z') return \"\
    No\";\n    int digits_count = 0;\n    foreach (c; name)\n    {\n        if (c\
    \ >= '0' && c <= '9')\n        {\n            digits_count++;\n            if\
    \ (digits_count > 3) return \"No\";\n        }\n    }\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl2zfftcf.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpl2zfftcf.d(26): Error: no property `find` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl2zfftcf.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    import std.algorithm\
    \ : count;\n    import std.conv : to;\n    import std.range : take, drop;\n  \
    \  import std.string : startsWith;\n    import std.array : array;\n    import\
    \ std.ascii : isAlpha;\n    import std.math : isNaN;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tupleof;\n\
    \    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import\
    \ std.typecons : tupleof;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : Tuple;\n    import std.typecons : tupleof;\n    import std.typecons : tuple;\n\
    \    import std.typecons : Tuple;\n    import std.typecons : tupleof;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons\
    \ : tupleof;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tupleof;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : Tuple;\n    import std.typecons : tupleof;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tupleof;\n\
    \    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import\
    \ std.typecons : tupleof;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : Tuple;\n    import std.typecons : tupleof;\n    import std.typecons : tuple;\n\
    \    import std.typecons : Tuple;\n    import std.typecons : tupleof;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons\
    \ : tupleof;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tupleof;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : Tuple;\n\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqz3i1vih.d(71): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqz3i1vih.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n\
    \    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(c.isDigit)\n\
    \            digits_count++;\n    }\n    if(digits_count > 3)\n        return\
    \ \"No\";\n    if(!name.length || !name[0].isLetter)\n        return \"No\";\n\
    \    if(!extension.length || !valid_extensions.canFind(extension))\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwvn765k3.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpwvn765k3.d(29): Error: no property `isDigit` for type `immutable(char)`\\\
    n/tmp/tmpwvn765k3.d(34): Error: no property `isLetter` for type `immutable(char)`\\\
    n/tmp/tmpwvn765k3.d(36): Error: no property `canFind` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwvn765k3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (file_name_parts[1] !in valid_extensions)\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpou0cm7y4.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmpou0cm7y4.d(28): Error: no property `count` for type `string`\\n/tmp/tmpou0cm7y4.d(32):\
    \ Error: incompatible types for `(file_name_parts[1]) in (valid_extensions)`:\
    \ `string` and `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpou0cm7y4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0\", \"9\"\
    ) > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp947jjvcn.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmp947jjvcn.d(28): Error: no property `count` for type `string`\\n/tmp/tmp947jjvcn.d(32):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp947jjvcn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0123456789\"\
    ) > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy87i2a49.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmpy87i2a49.d(28): Error: no property `count` for type `string`\\n/tmp/tmpy87i2a49.d(32):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpy87i2a49.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].filter!(a\
    \ => a.isDigit).length > 3)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0 || !file_name_parts[0][0].isLetter)\n        return \"No\";\n    if (!valid_extensions.any!(a\
    \ => a == file_name_parts[1]))\n        return \"No\";\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9b380ach.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmp9b380ach.d(26): Error: no property `filter` for type `string`\\n/tmp/tmp9b380ach.d(28):\
    \ Error: no property `isLetter` for type `immutable(char)`\\n/tmp/tmp9b380ach.d(30):\
    \ Error: no property `any` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp9b380ach.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count\
    \ = 0;\n    int digit_count = 0;\n    int dot_position = 0;\n    string extension;\n\
    \    foreach(i, c; file_name)\n    {\n        if(c == '.')\n        {\n      \
    \      dot_count++;\n            dot_position = i;\n        }\n        if(c >=\
    \ '0' && c <= '9')\n            digit_count++;\n    }\n    if(dot_count != 1 ||\
    \ digit_count > 3)\n        return \"No\";\n    extension = file_name[dot_position\
    \ + 1 .. $];\n    if(extension != \"txt\" && extension != \"exe\" && extension\
    \ != \"dll\")\n        return \"No\";\n    if(file_name[0] < 'a' || file_name[0]\
    \ > 'z' && file_name[0] < 'A' || file_name[0] > 'Z')\n        return \"No\";\n\
    \    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz0311a2o.d(31): Error: cannot implicitly convert expression `i`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpz0311a2o.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    auto dot_index = file_name.find(\".\");\n\
    \    if (dot_index == -1)\n        return \"No\";\n    auto extension = file_name[dot_index\
    \ + 1 .. $];\n    if (extension.count(\"0\" .. \"9\") > 3)\n        return \"\
    No\";\n    if (valid_extensions.find(extension) == -1)\n        return \"No\"\
    ;\n    auto name = file_name[0 .. dot_index];\n    if (name.empty || !name[0].isAlpha)\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9m6kzwa9.d(27): Error: found `..` when expecting `,`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9m6kzwa9.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index +\
    \ 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n\
    \    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n        \
    \    digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return\
    \ \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(name[0] <\
    \ 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\"\
    ;\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt_i9bl9s.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpt_i9bl9s.d(23): Error: no property `substr` for type `string`\\n/tmp/tmpt_i9bl9s.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpt_i9bl9s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int len = file_name.length;\n    foreach(i;\
    \ 0..len)\n    {\n        if(file_name[i] == '.')\n        {\n            dot_count++;\n\
    \        }\n        if(file_name[i] >= '0' && file_name[i] <= '9')\n        {\n\
    \            count++;\n        }\n    }\n    if(count > 3 || dot_count != 1)\n\
    \    {\n        return \"No\";\n    }\n    else\n    {\n        string[] arr =\
    \ file_name.split(\".\");\n        if(arr[0].length == 0 || (arr[0][0] < 'a' ||\
    \ arr[0][0] > 'z') && (arr[0][0] < 'A' || arr[0][0] > 'Z'))\n        {\n     \
    \       return \"No\";\n        }\n        else\n        {\n            if(arr[1]\
    \ == \"txt\" || arr[1] == \"exe\" || arr[1] == \"dll\")\n            {\n     \
    \           return \"Yes\";\n            }\n            else\n            {\n\
    \                return \"No\";\n            }\n        }\n    }\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5hb5w_n4.d(24): Error: cannot implicitly convert expression `file_name.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp5hb5w_n4.d(42): Error: no property `split`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5hb5w_n4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_split = file_name.split(\"\
    .\");\n    if (file_name_split.length != 2)\n        return \"No\";\n    if (file_name_split[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_split[0].filter!(x => x.isDigit).length\
    \ > 3)\n        return \"No\";\n    if (file_name_split[0].filter!(x => x.isLetter).length\
    \ == 0)\n        return \"No\";\n    if (valid_extensions.filter!(x => x == file_name_split[1]).length\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4vn4ngog.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmp4vn4ngog.d(28): Error: no property `filter` for type `string`\\n/tmp/tmp4vn4ngog.d(30):\
    \ Error: no property `filter` for type `string`\\n/tmp/tmp4vn4ngog.d(32): Error:\
    \ no property `filter` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmp4vn4ngog.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n \
    \   string prefix = file_name[0..dot_index];\n    string suffix = file_name[dot_index+1..$];\n\
    \    if (prefix.length == 0 || !isAlpha(prefix[0]))\n        return \"No\";\n\
    \    if (suffix != \"txt\" && suffix != \"exe\" && suffix != \"dll\")\n      \
    \  return \"No\";\n    int digit_count = 0;\n    foreach (c; prefix)\n    {\n\
    \        if (isDigit(c))\n            digit_count++;\n    }\n    if (digit_count\
    \ > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6_b6yemu.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmp6_b6yemu.d(27): Error: undefined identifier `isAlpha`\\n/tmp/tmp6_b6yemu.d(34):\
    \ Error: undefined identifier `isDigit`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp6_b6yemu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.indexOf(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3x_ok42j.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmp3x_ok42j.d(28): Error: no property `count` for type `string`\\n/tmp/tmp3x_ok42j.d(32):\
    \ Error: no property `indexOf` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp3x_ok42j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index+1..$];\n\
    \    if (!valid_extensions.canFind(extension))\n        return \"No\";\n    string\
    \ name = file_name[0..dot_index-1];\n    if (name.length == 0)\n        return\
    \ \"No\";\n    if (!isAlpha(name[0]))\n        return \"No\";\n    int count =\
    \ 0;\n    foreach (c; name)\n    {\n        if (isDigit(c))\n            count++;\n\
    \    }\n    if (count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr8_k4zr7.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpr8_k4zr7.d(27): Error: no property `canFind` for type `string[]`\\n/tmp/tmpr8_k4zr7.d(32):\
    \ Error: undefined identifier `isAlpha`\\n/tmp/tmpr8_k4zr7.d(37): Error: undefined\
    \ identifier `isDigit`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpr8_k4zr7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int count_after_dot\
    \ = 0;\n    int count_before_dot = 0;\n    int count_digits = 0;\n    string str_after_dot\
    \ = \"\";\n    string str_before_dot = \"\";\n    string result = \"\";\n    foreach(char\
    \ c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n\
    \            dot_index = count;\n        }\n        if(c >= '0' && c <= '9')\n\
    \        {\n            count_digits++;\n        }\n        count++;\n    }\n\
    \    if(dot_count != 1 || count_digits > 3)\n    {\n        result = \"No\";\n\
    \    }\n    else\n    {\n        str_after_dot = file_name[dot_index+1..$];\n\
    \        str_before_dot = file_name[0..dot_index-1];\n        foreach(char c;\
    \ str_after_dot)\n        {\n            count_after_dot++;\n        }\n     \
    \   foreach(char c; str_before_dot)\n        {\n            count_before_dot++;\n\
    \        }\n        if(count_after_dot == 3 && count_before_dot > 0 && \n    \
    \        (str_after_dot == \"txt\" || str_after_dot == \"exe\" || str_after_dot\
    \ == \"dll\") &&\n            (str_before_dot[0] >= 'a' && str_before_dot[0] <=\
    \ 'z' || str_before_dot[0] >= 'A' && str_before_dot[0] <= 'Z'))\n        {\n \
    \           result = \"Yes\";\n        }\n        else\n        {\n          \
    \  result = \"No\";\n        }\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqlpb50iv.d(80): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42893d]\\n??:? void tmpqlpb50iv.__unittest_L73_C1()\
    \ [0x427f4e]\\n??:? void tmpqlpb50iv.__modtest() [0x4286c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c65b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b56a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430681]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b30]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43060d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b541]\\n??:? runModuleUnitTests [0x42c431]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428e00]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428d87]\\n??:? _d_run_main [0x428cf2]\\n??:? main [0x4286d3]\\\
    n??:? __libc_start_main [0x9c90554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp67z24_f7.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmp67z24_f7.d(28): Error: no property `count` for type `string`\\n/tmp/tmp67z24_f7.d(32):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp67z24_f7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index +\
    \ 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n\
    \    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n        \
    \    digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return\
    \ \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0]\
    \ >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxy1hdz1v.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpxy1hdz1v.d(23): Error: no property `substr` for type `string`\\n/tmp/tmpxy1hdz1v.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpxy1hdz1v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n\
    \    int digits_count = 0;\n    foreach(char c; name)\n    {\n        if(isdigit(c))\n\
    \            digits_count++;\n    }\n    if(digits_count > 3)\n        return\
    \ \"No\";\n    if(!(extension in valid_extensions))\n        return \"No\";\n\
    \    if(!isalpha(name[0]))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpftwomc1a.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpftwomc1a.d(29): Error: undefined identifier `isdigit`\\n/tmp/tmpftwomc1a.d(34):\
    \ Error: incompatible types for `(extension) in (valid_extensions)`: `string`\
    \ and `string[]`\\n/tmp/tmpftwomc1a.d(36): Error: undefined identifier `isalpha`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpftwomc1a.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index +\
    \ 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n\
    \    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n\
    \    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\"\
    \ && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n \
    \   if(name.length == 0)\n        return \"No\";\n    if(name[0] < 'a' || name[0]\
    \ > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvbvpf6un.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpvbvpf6un.d(23): Error: no property `substr` for type `string`\\n/tmp/tmpvbvpf6un.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpvbvpf6un.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_pos\
    \ = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n   \
    \ auto ext = file_name.substr(dot_pos + 1);\n    if (ext != \"txt\" && ext !=\
    \ \"exe\" && ext != \"dll\")\n        return \"No\";\n    auto name = file_name.substr(0,\
    \ dot_pos);\n    if (name.length == 0)\n        return \"No\";\n    if (name[0]\
    \ < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"\
    No\";\n    int count = 0;\n    for (auto c : name)\n        if (c >= '0' && c\
    \ <= '9')\n            count++;\n    if (count > 3)\n        return \"No\";\n\
    \    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplnpwh8vy.d(34): Error: no identifier for declarator `c`\\n/tmp/tmplnpwh8vy.d(34):\
    \ Error: expression expected, not `:`\\n/tmp/tmplnpwh8vy.d(34): Error: found `name`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmplnpwh8vy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n\
    \    int digits_count = 0;\n    foreach(char c; name)\n    {\n        if(c >=\
    \ '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count >\
    \ 3)\n        return \"No\";\n    if(extension.length == 0)\n        return \"\
    No\";\n    if(!valid_extensions.canFind(extension))\n        return \"No\";\n\
    \    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' &&\
    \ name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\"\
    ;\n    return \"Yes\";\n}\n/*\nCreate a function which takes a string representing\
    \ a file's name, and returns\n    'Yes' if the the file's name is valid, and returns\
    \ 'No' otherwise.\n    A file's name is considered to be valid if and only if\
    \ all the following conditions \n    are met:\n    - There should not be more\
    \ than three digits ('0'-'9') in the file's name.\n    - The file's name contains\
    \ exactly one dot '.'\n    - The substring before the dot should not be empty,\
    \ and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n\
    \    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n\
    \    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>>\
    \ file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    int dot_index = file_name.find(\".\");\n    string\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpesk6cva5.d(66): Error: found `unittest` when expecting `;` following\
    \ statement\\n/tmp/tmpesk6cva5.d(97): Error: found `End of File` when expecting\
    \ `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpesk6cva5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n \
    \   string file_name_before_dot = file_name[0..dot_index];\n    string file_name_after_dot\
    \ = file_name[dot_index+1..$];\n    if (file_name_before_dot.length == 0 || file_name_after_dot.length\
    \ == 0)\n        return \"No\";\n    if (file_name_before_dot.count('0','9') >\
    \ 3)\n        return \"No\";\n    if (file_name_before_dot[0] < 'a' || file_name_before_dot[0]\
    \ > 'z')\n        return \"No\";\n    if (file_name_after_dot != \"txt\" && file_name_after_dot\
    \ != \"exe\" && file_name_after_dot != \"dll\")\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzjlwto_y.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpzjlwto_y.d(29): Error: no property `count` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzjlwto_y.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find('.');\n    if (dot_pos == -1) return \"No\";\n    string before_dot\
    \ = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n\
    \    if (before_dot.length == 0) return \"No\";\n    if (before_dot.count('0','9')\
    \ > 3) return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" &&\
    \ after_dot != \"dll\") return \"No\";\n    if (before_dot[0] < 'a' || before_dot[0]\
    \ > 'z') return \"No\";\n    return \"Yes\";\n}\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    the file's extension.\n\
    \    A file's extension is the substring after the last dot '.' in the file's\
    \ name.\n    If the file's name does not contain a dot, the function should return\
    \ an empty string.\n    Examples:\n    >>> file_extension(\"example.txt\")\n \
    \   \"txt\"\n    >>> file_extension(\"example\")\n    \"\"\n*/\nstring file_extension(string\
    \ file_name) \n{\n    int dot_pos = file_name.rfind('.');\n    if (dot_pos ==\
    \ -1) return \"\";\n    return file_name[dot_pos+1..$];\n}\n/*\nCreate a function\
    \ which takes a string representing a file's name, and returns\n    the file's\
    \ name without the extension.\n    A file's extension is the substring after the\
    \ last dot '.' in the file's name.\n    If the file's name does not contain a\
    \ dot, the function should return the file's name.\n    Examples:\n    >>> file_name_without_extension(\"\
    example.txt\")\n    \"example\"\n    >>> file_name_without_extension(\"example\"\
    )\n    \"example\"\n*/\nstring file_name_without_extension(string file_name) \n\
    {\n    int dot_pos = file_name.rfind('.');\n    if (dot_pos == -1) return file_name;\n\
    \    return file\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyqhog_80.d(65): Error: found `unittest` when expecting `;` following\
    \ `return` statement\\n/tmp/tmpyqhog_80.d(96): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpyqhog_80.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n   \
    \ string extension = file_name.substr(dot_pos + 1);\n    if (extension != \"txt\"\
    \ && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n \
    \   string name = file_name.substr(0, dot_pos);\n    if (name.length == 0)\n \
    \       return \"No\";\n    int digits = 0;\n    foreach (c; name)\n    {\n  \
    \      if (c >= '0' && c <= '9')\n            digits++;\n        else if (!(c\
    \ >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z'))\n            return \"No\";\n\
    \    }\n    if (digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6h9bpn65.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmp6h9bpn65.d(25): Error: no property `substr` for type `string`\\n/tmp/tmp6h9bpn65.d(28):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp6h9bpn65.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find(\".\");\n    string extension = file_name.substr(dot_index\
    \ + 1);\n    string name = file_name.substr(0, dot_index);\n    if (extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return\
    \ \"No\";\n    if (name.length == 0)\n        return \"No\";\n    if (name[0]\
    \ < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"\
    No\";\n    int digits = 0;\n    foreach (c; name)\n    {\n        if (c >= '0'\
    \ && c <= '9')\n            digits++;\n    }\n    if (digits > 3)\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkz2_iaz6.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpkz2_iaz6.d(23): Error: no property `substr` for type `string`\\n/tmp/tmpkz2_iaz6.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpkz2_iaz6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_index = 0;\n    int dot_count = 0;\n    int i = 0;\n    string\
    \ extension;\n    string first_part;\n    string[] valid_extensions = [\"txt\"\
    , \"exe\", \"dll\"];\n    foreach(char c; file_name)\n    {\n        if(c == '.')\n\
    \        {\n            dot_index = i;\n            dot_count++;\n        }\n\
    \        if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n\
    \        i++;\n    }\n    if(count > 3 || dot_count != 1)\n    {\n        return\
    \ \"No\";\n    }\n    first_part = file_name[0..dot_index];\n    extension = file_name[dot_index+1..$];\n\
    \    if(first_part.length == 0 || (first_part[0] < 'a' || first_part[0] > 'z')\
    \ && (first_part[0] < 'A' || first_part[0] > 'Z'))\n    {\n        return \"No\"\
    ;\n    }\n    if(extension !in valid_extensions)\n    {\n        return \"No\"\
    ;\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv_0qewgt.d(52): Error: incompatible types for `(extension) in\
    \ (valid_extensions)`: `string` and `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpv_0qewgt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int i = 0;\n    int\
    \ j = 0;\n    string sub_string_1;\n    string sub_string_2;\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    foreach(in char c; file_name)\n    {\n \
    \       if(c == '.')\n        {\n            dot_count++;\n            dot_index\
    \ = i;\n        }\n        if(c >= '0' && c <= '9')\n        {\n            count++;\n\
    \        }\n        i++;\n    }\n    if(count > 3 || dot_count != 1)\n    {\n\
    \        return \"No\";\n    }\n    sub_string_1 = file_name[0..dot_index];\n\
    \    sub_string_2 = file_name[dot_index+1..$];\n    if(sub_string_1.length ==\
    \ 0 || (sub_string_1[0] < 'a' || sub_string_1[0] > 'z') && (sub_string_1[0] <\
    \ 'A' || sub_string_1[0] > 'Z'))\n    {\n        return \"No\";\n    }\n    foreach(in\
    \ string s; valid_extensions)\n    {\n        if(s == sub_string_2)\n        {\n\
    \            return \"Yes\";\n        }\n    }\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqgnmqlk7.d(30): Error: basic type expected, not `in`\\n/tmp/tmpqgnmqlk7.d(30):\
    \ Error: no identifier for declarator `_error_`\\n/tmp/tmpqgnmqlk7.d(30): Error:\
    \ found `in` when expecting `;`\\n/tmp/tmpqgnmqlk7.d(30): Error: found `c` when\
    \ expecting `.` following char\\n/tmp/tmpqgnmqlk7.d(30): Error: found `;` when\
    \ expecting identifier following `char`.\\n/tmp/tmpqgnmqlk7.d(30): Error: found\
    \ `file_name` when expecting `)`\\n/tmp/tmpqgnmqlk7.d(30): Error: found `)` instead\
    \ of statement\\n/tmp/tmpqgnmqlk7.d(37): Error: declaration expected, not `if`\\\
    n/tmp/tmpqgnmqlk7.d(40): Error: unrecognized declaration\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpqgnmqlk7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    string result = \"Yes\";\n    foreach(char c;\
    \ file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n\
    \        }\n        if(c >= '0' && c <= '9')\n        {\n            count++;\n\
    \        }\n    }\n    if(count > 3 || dot_count != 1)\n    {\n        result\
    \ = \"No\";\n    }\n    else\n    {\n        string[] parts = file_name.split(\"\
    .\");\n        if(parts[0].length == 0 || parts[0][0] < 'a' || parts[0][0] > 'z')\n\
    \        {\n            result = \"No\";\n        }\n        else\n        {\n\
    \            if(parts[1] != \"txt\" && parts[1] != \"exe\" && parts[1] != \"dll\"\
    )\n            {\n                result = \"No\";\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpajff20gk.d(42): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpajff20gk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.indexOf('.');\n\
    \    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name.substr(dot_index\
    \ + 1);\n    if (extension.length == 0 || valid_extensions.indexOf(extension)\
    \ == -1)\n        return \"No\";\n    string name = file_name.substr(0, dot_index);\n\
    \    if (name.length == 0)\n        return \"No\";\n    if (name[0] < 'a' || name[0]\
    \ > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    int digits_count\
    \ = 0;\n    foreach (c; name)\n    {\n        if (c >= '0' && c <= '9')\n    \
    \        digits_count++;\n    }\n    if (digits_count > 3)\n        return \"\
    No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl3teij3l.d(23): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmpl3teij3l.d(26): Error: no property `substr` for type `string`\\n/tmp/tmpl3teij3l.d(27):\
    \ Error: no property `indexOf` for type `string[]`\\n/tmp/tmpl3teij3l.d(29): Error:\
    \ no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpl3teij3l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int len = file_name.length;\n    string extension\
    \ = \"\";\n    string name = \"\";\n    string[] valid_extensions = [\"txt\",\
    \ \"exe\", \"dll\"];\n    for (int i = 0; i < len; i++)\n    {\n        if (file_name[i]\
    \ == '.')\n        {\n            dot_count++;\n            if (dot_count > 1)\n\
    \            {\n                return \"No\";\n            }\n            else\n\
    \            {\n                extension = file_name[i+1..$];\n             \
    \   name = file_name[0..i-1];\n            }\n        }\n        else if (file_name[i]\
    \ >= '0' && file_name[i] <= '9')\n        {\n            count++;\n          \
    \  if (count > 3)\n            {\n                return \"No\";\n           \
    \ }\n        }\n    }\n    if (name.length == 0)\n    {\n        return \"No\"\
    ;\n    }\n    else if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0]\
    \ > 'Z')\n    {\n        return \"No\";\n    }\n    else if (extension.length\
    \ == 0)\n    {\n        return \"No\";\n    }\n    else if (extension !in valid_extensions)\n\
    \    {\n        return \"No\";\n    }\n    else\n    {\n        return \"Yes\"\
    ;\n    }\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjn6l2cd7.d(24): Error: cannot implicitly convert expression `file_name.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpjn6l2cd7.d(64): Error: incompatible types\
    \ for `(extension) in (valid_extensions)`: `string` and `string[]`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjn6l2cd7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n \
    \   string name = file_name[0..dot_index];\n    string ext = file_name[dot_index+1..$];\n\
    \    if (name.length == 0 || !(name[0] in ['a'..'z', 'A'..'Z']))\n        return\
    \ \"No\";\n    if (ext !in [\"txt\", \"exe\", \"dll\"])\n        return \"No\"\
    ;\n    int count = 0;\n    foreach (c; name)\n        if (c in ['0'..'9'])\n \
    \           count++;\n    if (count > 3)\n        return \"No\";\n    return \"\
    Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp93mm9o39.d(27): Error: found `..` when expecting `,`\\n/tmp/tmp93mm9o39.d(27):\
    \ Error: found `..` when expecting `,`\\n/tmp/tmp93mm9o39.d(33): Error: found\
    \ `..` when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp93mm9o39.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_pos\
    \ = file_name.find(\".\");\n    if (dot_pos == -1)\n        return \"No\";\n \
    \   auto dot_pos_end = file_name.find(\".\", dot_pos + 1);\n    if (dot_pos_end\
    \ != -1)\n        return \"No\";\n    if (dot_pos == 0)\n        return \"No\"\
    ;\n    if (file_name[dot_pos + 1] == '.')\n        return \"No\";\n    auto file_name_without_ext\
    \ = file_name[0..dot_pos];\n    auto file_name_ext = file_name[dot_pos + 1..$];\n\
    \    if (file_name_ext != \"txt\" && file_name_ext != \"exe\" && file_name_ext\
    \ != \"dll\")\n        return \"No\";\n    if (file_name_without_ext.count('0')\
    \ + file_name_without_ext.count('1') + \n        file_name_without_ext.count('2')\
    \ + file_name_without_ext.count('3') + \n        file_name_without_ext.count('4')\
    \ + file_name_without_ext.count('5') + \n        file_name_without_ext.count('6')\
    \ + file_name_without_ext.count('7') + \n        file_name_without_ext.count('8')\
    \ + file_name_without_ext.count('9') > 3)\n        return \"No\";\n    if (file_name_without_ext.count('0')\
    \ + file_name_without_ext.count('1') + \n        file_name_without_ext.count('2')\
    \ + file_name_without_ext.count('3') + \n        file_name_without_ext.count('4')\
    \ + file_name_without_ext.count('5') + \n        file_name_without_ext.count('6')\
    \ + file_name_without_ext.count('7') + \n        file_name_without_ext.count('8')\
    \ + file_name_without_ext.count('9') == file_name_without_ext.length)\n      \
    \  return \"No\";\nunittest\n{\n    alias candidate = file_name_check;\n\n   \
    \ assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbl94y450.d(48): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbl94y450.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n \
    \   string extension = file_name.substr(dot_index + 1);\n    if (extension !=\
    \ \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"\
    No\";\n    string name = file_name.substr(0, dot_index);\n    if (name.length\
    \ == 0)\n        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0]\
    \ < 'A' || name[0] > 'Z')\n        return \"No\";\n    int digits = 0;\n    foreach\
    \ (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            digits++;\n\
    \    }\n    if (digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj72jcr54.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpj72jcr54.d(25): Error: no property `substr` for type `string`\\n/tmp/tmpj72jcr54.d(28):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpj72jcr54.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmtxgyjfg.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmpmtxgyjfg.d(28): Error: no property `count` for type `string`\\n/tmp/tmpmtxgyjfg.d(32):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpmtxgyjfg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string result\
    \ = \"No\";\n    int dot_index = file_name.find(\".\");\n    if (dot_index !=\
    \ -1)\n    {\n        string before_dot = file_name[0..dot_index];\n        string\
    \ after_dot = file_name[dot_index+1..$];\n        if (before_dot.length > 0 &&\
    \ before_dot[0] >= 'a' && before_dot[0] <= 'z' ||\n            before_dot[0] >=\
    \ 'A' && before_dot[0] <= 'Z')\n        {\n            if (after_dot == \"txt\"\
    \ || after_dot == \"exe\" || after_dot == \"dll\")\n            {\n          \
    \      int count = 0;\n                foreach (c; before_dot)\n             \
    \   {\n                    if (c >= '0' && c <= '9')\n                    {\n\
    \                        count++;\n                    }\n                }\n\
    \                if (count <= 3)\n                {\n                    result\
    \ = \"Yes\";\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu29nwh5n.d(23): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu29nwh5n.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // TODO: implement\
    \ this function\n    //return \"Yes\";\n    int dot_pos = file_name.find('.');\n\
    \    if (dot_pos == -1)\n        return \"No\";\n    string pre_dot = file_name[0..dot_pos];\n\
    \    string post_dot = file_name[dot_pos+1..$];\n    if (pre_dot.length == 0 ||\
    \ !isAlpha(pre_dot[0]))\n        return \"No\";\n    if (post_dot != \"txt\" &&\
    \ post_dot != \"exe\" && post_dot != \"dll\")\n        return \"No\";\n    int\
    \ num_digits = 0;\n    foreach (c; pre_dot)\n    {\n        if (isDigit(c))\n\
    \            num_digits++;\n    }\n    if (num_digits > 3)\n        return \"\
    No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdthd47n8.d(24): Error: no property `find` for type `string`\\\
    n/tmp/tmpdthd47n8.d(29): Error: undefined identifier `isAlpha`\\n/tmp/tmpdthd47n8.d(36):\
    \ Error: undefined identifier `isDigit`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpdthd47n8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int len = file_name.length;\n\
    \    string sub_string;\n    string sub_string2;\n    foreach(i; 0..len)\n   \
    \ {\n        if(file_name[i] == '.')\n        {\n            dot_count++;\n  \
    \          dot_index = i;\n        }\n        if(file_name[i] >= '0' && file_name[i]\
    \ <= '9')\n        {\n            count++;\n        }\n    }\n    if(count > 3)\n\
    \    {\n        return \"No\";\n    }\n    if(dot_count != 1)\n    {\n       \
    \ return \"No\";\n    }\n    sub_string = file_name[0..dot_index];\n    sub_string2\
    \ = file_name[dot_index+1..len];\n    if(sub_string.length == 0)\n    {\n    \
    \    return \"No\";\n    }\n    if(sub_string[0] < 'a' || sub_string[0] > 'z')\n\
    \    {\n        if(sub_string[0] < 'A' || sub_string[0] > 'Z')\n        {\n  \
    \          return \"No\";\n        }\n    }\n    if(sub_string2 != \"txt\" &&\
    \ sub_string2 != \"exe\" && sub_string2 != \"dll\")\n    {\n        return \"\
    No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq8r50xrh.d(25): Error: cannot implicitly convert expression `file_name.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpq8r50xrh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index +\
    \ 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n\
    \    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n        \
    \    digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return\
    \ \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(name[0] <\
    \ 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\"\
    ;\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpia3j9mml.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpia3j9mml.d(23): Error: no property `substr` for type `string`\\n/tmp/tmpia3j9mml.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpia3j9mml.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index +\
    \ 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n\
    \    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n        \
    \    digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return\
    \ \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(name[0] <\
    \ 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\"\
    ;\n    return \"Yes\";\n}\n/*\nCreate a function which takes a string representing\
    \ a file's name, and returns\n    'Yes' if the the file's name is valid, and returns\
    \ 'No' otherwise.\n    A file's name is considered to be valid if and only if\
    \ all the following conditions \n    are met:\n    - There should not be more\
    \ than three digits ('0'-'9') in the file's name.\n    - The file's name contains\
    \ exactly one dot '.'\n    - The substring before the dot should not be empty,\
    \ and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n\
    \    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n\
    \    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>>\
    \ file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension\
    \ = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n\
    \    int digits = 0;\n    foreach(char c; name)\n    {\n        if(c\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpihdt0kwq.d(67): Error: found `unittest` when expecting `)`\\\
    n/tmp/tmpihdt0kwq.d(98): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmpihdt0kwq.d(98): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpihdt0kwq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    bool valid = true;\n    foreach(char c; file_name)\n\
    \    {\n        if(c == '.')\n        {\n            dot_count++;\n        }\n\
    \        if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n\
    \    }\n    if(count > 3 || dot_count != 1)\n    {\n        valid = false;\n \
    \   }\n    else\n    {\n        string[] parts = file_name.split(\".\");\n   \
    \     if(parts[0].length == 0 || !(parts[0][0] >= 'a' && parts[0][0] <= 'z') ||\
    \ !(parts[0][0] >= 'A' && parts[0][0] <= 'Z'))\n        {\n            valid =\
    \ false;\n        }\n        else\n        {\n            if(parts[1] != \"txt\"\
    \ && parts[1] != \"exe\" && parts[1] != \"dll\")\n            {\n            \
    \    valid = false;\n            }\n        }\n    }\n    if(valid)\n    {\n \
    \       return \"Yes\";\n    }\n    else\n    {\n        return \"No\";\n    }\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_cl0_fwo.d(42): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_cl0_fwo.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    if (dot_index == -1)\n        return \"No\";\n    string file_name_without_extension\
    \ = file_name[0..dot_index];\n    string file_extension = file_name[dot_index+1..$];\n\
    \    if (file_name_without_extension.length == 0 ||\n        file_name_without_extension[0]\
    \ < 'a' ||\n        file_name_without_extension[0] > 'z' &&\n        file_name_without_extension[0]\
    \ < 'A' ||\n        file_name_without_extension[0] > 'Z')\n        return \"No\"\
    ;\n    if (count(file_name_without_extension.filter!(c => c >= '0' && c <= '9'))\
    \ > 3)\n        return \"No\";\n    if (valid_extensions.find(file_extension)\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4g50nngx.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmp4g50nngx.d(34): Error: undefined identifier `count`\\n/tmp/tmp4g50nngx.d(36):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp4g50nngx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    string\
    \ extension = file_name_parts[1];\n    if (valid_extensions.count(extension) ==\
    \ 0)\n        return \"No\";\n    string name = file_name_parts[0];\n    int digits_count\
    \ = 0;\n    foreach (c; name)\n    {\n        if (c >= '0' && c <= '9')\n    \
    \        digits_count++;\n    }\n    if (digits_count > 3)\n        return \"\
    No\";\n    if (name.length == 0)\n        return \"No\";\n    if (name[0] < 'a'\
    \ || name[0] > 'z')\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3p3mcy_x.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmp3p3mcy_x.d(27): Error: no property `count` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3p3mcy_x.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int dot_index_before\
    \ = 0;\n    int dot_index_after = 0;\n    string before_dot = \"\";\n    string\
    \ after_dot = \"\";\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"\
    ];\n    foreach(char c; file_name)\n    {\n        if (c == '.')\n        {\n\
    \            dot_count++;\n            dot_index = count;\n        }\n       \
    \ count++;\n    }\n    if (dot_count != 1)\n    {\n        return \"No\";\n  \
    \  }\n    dot_index_before = dot_index;\n    dot_index_after = count - dot_index\
    \ - 1;\n    before_dot = file_name[0..dot_index_before];\n    after_dot = file_name[dot_index\
    \ + 1..$];\n    if (before_dot.length == 0 || !isAlpha(before_dot[0]))\n    {\n\
    \        return \"No\";\n    }\n    if (after_dot.length == 0 || !after_dot.in(valid_extensions))\n\
    \    {\n        return \"No\";\n    }\n    foreach(char c; before_dot)\n    {\n\
    \        if (isDigit(c))\n        {\n            return \"No\";\n        }\n \
    \   }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp923b5omc.d(51): Error: identifier expected following `.`, not\
    \ `in`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp923b5omc.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_pos\
    \ = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n   \
    \ auto ext = file_name.slice(dot_pos + 1);\n    if (ext != \"txt\" && ext != \"\
    exe\" && ext != \"dll\")\n        return \"No\";\n    auto name = file_name.slice(0,\
    \ dot_pos);\n    if (name.length == 0)\n        return \"No\";\n    if (name[0]\
    \ < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"\
    No\";\n    int count = 0;\n    foreach (c; name)\n    {\n        if (c >= '0'\
    \ && c <= '9')\n            count++;\n    }\n    if (count > 3)\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjl9nc8te.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpjl9nc8te.d(25): Error: no property `slice` for type `string`\\n/tmp/tmpjl9nc8te.d(28):\
    \ Error: no property `slice` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpjl9nc8te.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n \
    \   string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n\
    \    if (before_dot.length == 0 || after_dot.length == 0)\n        return \"No\"\
    ;\n    if (before_dot.count('0'..'9') > 3)\n        return \"No\";\n    if (before_dot[0]\
    \ < 'a' || before_dot[0] > 'z')\n        return \"No\";\n    if (after_dot !=\
    \ \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"\
    No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyh7y7h3f.d(29): Error: found `..` when expecting `,`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyh7y7h3f.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int i = 0;\n    string\
    \ extension = \"\";\n    string name = \"\";\n    string[] valid_extensions =\
    \ [\"txt\", \"exe\", \"dll\"];\n    foreach(char c; file_name)\n    {\n      \
    \  if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n    \
    \    if(c == '.')\n        {\n            dot_count++;\n            dot_index\
    \ = i;\n        }\n        i++;\n    }\n    if(count > 3 || dot_count != 1)\n\
    \    {\n        return \"No\";\n    }\n    extension = file_name[dot_index+1..$];\n\
    \    name = file_name[0..dot_index-1];\n    if(name.length == 0 || !(name[0] >=\
    \ 'a' && name[0] <= 'z' || name[0] >= 'A' && name[0] <= 'Z'))\n    {\n       \
    \ return \"No\";\n    }\n    if(!valid_extensions.find(extension))\n    {\n  \
    \      return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5kazk2hv.d(52): Error: no property `find` for type `string[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5kazk2hv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int i = 0;\n    int\
    \ j = 0;\n    string sub_str;\n    string sub_str2;\n    string result = \"No\"\
    ;\n    string[] valid_ext = [\"txt\", \"exe\", \"dll\"];\n    foreach(char c;\
    \ file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n\
    \            dot_index = i;\n        }\n        if(c >= '0' && c <= '9')\n   \
    \     {\n            count++;\n        }\n        i++;\n    }\n    if(count <=\
    \ 3 && dot_count == 1)\n    {\n        sub_str = file_name[0..dot_index];\n  \
    \      sub_str2 = file_name[dot_index+1..$];\n        if(sub_str.length > 0 &&\
    \ (sub_str[0] >= 'a' && sub_str[0] <= 'z' || sub_str[0] >= 'A' && sub_str[0] <=\
    \ 'Z'))\n        {\n            foreach(string s; valid_ext)\n            {\n\
    \                if(s == sub_str2)\n                {\n                    result\
    \ = \"Yes\";\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n   \
    \ string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n\
    \    if (before_dot.length == 0 || before_dot.count!(a => a >= '0' && a <= '9')\
    \ > 3)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"\
    exe\" && after_dot != \"dll\")\n        return \"No\";\n    if (before_dot[0]\
    \ < 'a' || before_dot[0] > 'z' && before_dot[0] < 'A' || before_dot[0] > 'Z')\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwj3q15q2.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpwj3q15q2.d(27): Error: no property `count` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwj3q15q2.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int i = 0;\n    string\
    \ sub_string_before_dot = \"\";\n    string sub_string_after_dot = \"\";\n   \
    \ string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    bool is_valid\
    \ = true;\n    foreach(char c; file_name)\n    {\n        if(c == '.')\n     \
    \   {\n            dot_count++;\n            dot_index = i;\n        }\n     \
    \   if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n   \
    \     i++;\n    }\n    if(dot_count != 1)\n    {\n        is_valid = false;\n\
    \    }\n    if(count > 3)\n    {\n        is_valid = false;\n    }\n    if(dot_index\
    \ == 0)\n    {\n        is_valid = false;\n    }\n    if(file_name[0] >= '0' &&\
    \ file_name[0] <= '9')\n    {\n        is_valid = false;\n    }\n    sub_string_before_dot\
    \ = file_name[0..dot_index];\n    sub_string_after_dot = file_name[dot_index+1..$];\n\
    \    if(sub_string_before_dot.length == 0)\n    {\n        is_valid = false;\n\
    \    }\n    if(!valid_extensions.contains(sub_string_after_dot))\n    {\n    \
    \    is_valid = false;\n    }\n    if(is_valid)\n    {\n        return \"Yes\"\
    ;\n    }\n    else\n    {\n        return \"No\";\n    }\n}\nunittest\n{\n   \
    \ alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\")\
    \ == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpusito76l.d(65): Error: no property `contains` for type `string[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpusito76l.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // write your\
    \ code here\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n\
    \        return \"No\";\n    string prefix = file_name[0..dot_pos];\n    string\
    \ suffix = file_name[dot_pos+1..$];\n    if (prefix.length == 0 || suffix.length\
    \ == 0)\n        return \"No\";\n    if (prefix.count('0','9') > 3)\n        return\
    \ \"No\";\n    if (prefix.count('a','z') == 0 && prefix.count('A','Z') == 0)\n\
    \        return \"No\";\n    if (suffix != \"txt\" && suffix != \"exe\" && suffix\
    \ != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n \
    \   alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfbaz08o6.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpfbaz08o6.d(30): Error: no property `count` for type `string`\\n/tmp/tmpfbaz08o6.d(32):\
    \ Error: no property `count` for type `string`\\n/tmp/tmpfbaz08o6.d(32): Error:\
    \ no property `count` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpfbaz08o6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].filter!(c\
    \ => c.isDigit).length > 3)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0 || !file_name_parts[0][0].isLetter)\n        return \"No\";\n    if (!valid_extensions.canFind(file_name_parts[1]))\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfrqrzub_.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmpfrqrzub_.d(26): Error: no property `filter` for type `string`\\n/tmp/tmpfrqrzub_.d(28):\
    \ Error: no property `isLetter` for type `immutable(char)`\\n/tmp/tmpfrqrzub_.d(30):\
    \ Error: no property `canFind` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpfrqrzub_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    bool is_valid = true;\n    foreach(char c; file_name)\n\
    \    {\n        if(c == '.')\n        {\n            dot_count++;\n        }\n\
    \        if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n\
    \    }\n    if(count > 3 || dot_count != 1)\n    {\n        is_valid = false;\n\
    \    }\n    else\n    {\n        string[] file_name_parts = file_name.split(\"\
    .\");\n        if(file_name_parts[0].length == 0 || \n            (file_name_parts[0][0]\
    \ < 'a' || file_name_parts[0][0] > 'z') && \n            (file_name_parts[0][0]\
    \ < 'A' || file_name_parts[0][0] > 'Z'))\n        {\n            is_valid = false;\n\
    \        }\n        else\n        {\n            if(file_name_parts[1] != \"txt\"\
    \ && file_name_parts[1] != \"exe\" && file_name_parts[1] != \"dll\")\n       \
    \     {\n                is_valid = false;\n            }\n        }\n    }\n\
    \    return is_valid ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeffgs9s9.d(42): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeffgs9s9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find('.');\n    string ext = file_name.substr(dot_pos + 1);\n  \
    \  string name = file_name.substr(0, dot_pos);\n    int digits = 0;\n    foreach(c;\
    \ name)\n    {\n        if(isdigit(c))\n            digits++;\n    }\n    if(digits\
    \ > 3)\n        return \"No\";\n    if(ext != \"txt\" && ext != \"exe\" && ext\
    \ != \"dll\")\n        return \"No\";\n    if(!isalpha(name[0]))\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqy9552zi.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpqy9552zi.d(23): Error: no property `substr` for type `string`\\n/tmp/tmpqy9552zi.d(24):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmpqy9552zi.d(28): Error:\
    \ undefined identifier `isdigit`\\n/tmp/tmpqy9552zi.d(35): Error: undefined identifier\
    \ `isalpha`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqy9552zi.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n \
    \   if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index\
    \ + 1 .. $];\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n\
    \        return \"No\";\n    string name = file_name[0 .. dot_index];\n    if\
    \ (name.length == 0 || !isAlpha(name[0]))\n        return \"No\";\n    int digit_count\
    \ = 0;\n    foreach (c; name)\n        if (isDigit(c))\n            digit_count++;\n\
    \    if (digit_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn13ikxf0.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpn13ikxf0.d(27): Error: no property `canFind` for type `string[]`\\n/tmp/tmpn13ikxf0.d(30):\
    \ Error: undefined identifier `isAlpha`\\n/tmp/tmpn13ikxf0.d(34): Error: undefined\
    \ identifier `isDigit`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpn13ikxf0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int i = 0;\n    string\
    \ sub_string_before_dot;\n    string sub_string_after_dot;\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    bool valid_extension = false;\n    foreach(char\
    \ c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n\
    \            dot_index = i;\n        }\n        else if(c >= '0' && c <= '9')\n\
    \        {\n            count++;\n        }\n        i++;\n    }\n    if(count\
    \ > 3 || dot_count != 1)\n    {\n        return \"No\";\n    }\n    sub_string_before_dot\
    \ = file_name[0..dot_index];\n    sub_string_after_dot = file_name[dot_index+1..$];\n\
    \    if(sub_string_before_dot.length == 0 || \n        (sub_string_before_dot[0]\
    \ < 'a' || sub_string_before_dot[0] > 'z') && \n        (sub_string_before_dot[0]\
    \ < 'A' || sub_string_before_dot[0] > 'Z'))\n    {\n        return \"No\";\n \
    \   }\n    foreach(string s; valid_extensions)\n    {\n        if(s == sub_string_after_dot)\n\
    \        {\n            valid_extension = true;\n            break;\n        }\n\
    \    }\n    if(valid_extension)\n    {\n        return \"Yes\";\n    }\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_pos\
    \ = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n   \
    \ auto ext = file_name.slice(dot_pos + 1);\n    if (ext != \"txt\" && ext != \"\
    exe\" && ext != \"dll\")\n        return \"No\";\n    auto name = file_name.slice(0,\
    \ dot_pos);\n    if (name.length == 0)\n        return \"No\";\n    if (name[0]\
    \ < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"\
    No\";\n    auto digits = 0;\n    foreach (c; name)\n    {\n        if (c >= '0'\
    \ && c <= '9')\n            digits++;\n    }\n    if (digits > 3)\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9d6q3_ha.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmp9d6q3_ha.d(25): Error: no property `slice` for type `string`\\n/tmp/tmp9d6q3_ha.d(28):\
    \ Error: no property `slice` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp9d6q3_ha.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n \
    \   string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0,\
    \ dot_index);\n    int digits_count = 0;\n    foreach(char c; name)\n    {\n \
    \       if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count\
    \ > 3 || dot_index == -1 || name.length == 0 || !(name[0] >= 'a' && name[0] <=\
    \ 'z' || name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    foreach(string\
    \ s; valid_extensions)\n    {\n        if(s == extension)\n            return\
    \ \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppjl7imd1.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmppjl7imd1.d(24): Error: no property `substr` for type `string`\\n/tmp/tmppjl7imd1.d(25):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppjl7imd1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpanfk9qlx.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmpanfk9qlx.d(28): Error: no property `count` for type `string`\\n/tmp/tmpanfk9qlx.d(32):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpanfk9qlx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count\
    \ = 0;\n    int digit_count = 0;\n    foreach(c; file_name)\n    {\n        if(c\
    \ == '.')\n        {\n            dot_count++;\n        }\n        else if(c >=\
    \ '0' && c <= '9')\n        {\n            digit_count++;\n        }\n    }\n\
    \    if(dot_count != 1 || digit_count > 3)\n    {\n        return \"No\";\n  \
    \  }\n    string[] parts = file_name.split(\".\");\n    if(parts.length != 2)\n\
    \    {\n        return \"No\";\n    }\n    if(parts[0].length == 0 || !(parts[0][0]\
    \ >= 'a' && parts[0][0] <= 'z') && !(parts[0][0] >= 'A' && parts[0][0] <= 'Z'))\n\
    \    {\n        return \"No\";\n    }\n    if(parts[1] != \"txt\" && parts[1]\
    \ != \"exe\" && parts[1] != \"dll\")\n    {\n        return \"No\";\n    }\n \
    \   return \"Yes\";\n}\n/*\nCreate a function which takes a string representing\
    \ a file's name, and returns\n    the file's extension.\n    Examples:\n    >>>\
    \ file_extension(\"example.txt\")\n    \"txt\"\n    >>> file_extension(\"1example.dll\"\
    )\n    \"dll\"\n*/\nstring file_extension(string file_name) \n{\n    string[]\
    \ parts = file_name.split(\".\");\n    return parts[1];\n}\n/*\nCreate a function\
    \ which takes a string representing a file's name, and returns\n    the file's\
    \ name without the extension.\n    Examples:\n    >>> file_name_without_extension(\"\
    example.txt\")\n    \"example\"\n    >>> file_name_without_extension(\"1example.dll\"\
    )\n    \"1example\"\n*/\nstring file_name_without_extension(string file_name)\
    \ \n{\n    string[] parts = file_name.split(\".\");\n    return parts[0];\n}\n\
    /*\nCreate a function which takes a string representing a file's name,\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8vbhv3uw.d(82): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8vbhv3uw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_index = 0;\n    int dot_count = 0;\n    int dot_index_after\
    \ = 0;\n    string sub_before_dot = \"\";\n    string sub_after_dot = \"\";\n\
    \    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    foreach(i,\
    \ c; file_name)\n    {\n        if(c >= '0' && c <= '9')\n        {\n        \
    \    count++;\n        }\n        if(c == '.')\n        {\n            dot_index\
    \ = i;\n            dot_count++;\n        }\n    }\n    if(count > 3 || dot_count\
    \ != 1)\n    {\n        return \"No\";\n    }\n    sub_before_dot = file_name[0..dot_index];\n\
    \    sub_after_dot = file_name[dot_index + 1..$];\n    if(sub_before_dot.length\
    \ == 0 || (sub_before_dot[0] < 'a' || sub_before_dot[0] > 'z') && (sub_before_dot[0]\
    \ < 'A' || sub_before_dot[0] > 'Z'))\n    {\n        return \"No\";\n    }\n \
    \   foreach(ext; valid_extensions)\n    {\n        if(ext == sub_after_dot)\n\
    \        {\n            return \"Yes\";\n        }\n    }\n    return \"No\";\n\
    }\n/*\nCreate a function which takes a string representing a file's name, and\
    \ returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    \    A file's name is considered to be valid if and only if all the following\
    \ conditions \n    are met:\n    - There should not be more than three digits\
    \ ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot\
    \ '.'\n    - The substring before the dot should not be empty, and it starts with\
    \ a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring\
    \ after the dot should be one of these: ['txt', 'exe', '\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpufo7_gu1.d(60): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpufo7_gu1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n \
    \   if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index\
    \ + 1 .. $];\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n\
    \        return \"No\";\n    string name = file_name[0 .. dot_index];\n    if\
    \ (name.length == 0 || !isAlpha(name[0]))\n        return \"No\";\n    int digits_count\
    \ = 0;\n    foreach (c; name)\n        if (isDigit(c))\n            digits_count++;\n\
    \    if (digits_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvei4fw6j.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpvei4fw6j.d(27): Error: no property `canFind` for type `string[]`\\n/tmp/tmpvei4fw6j.d(30):\
    \ Error: undefined identifier `isAlpha`\\n/tmp/tmpvei4fw6j.d(34): Error: undefined\
    \ identifier `isDigit`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpvei4fw6j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n   \
    \ string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n\
    \    if (before_dot.length == 0 || before_dot.length == dot_pos)\n        return\
    \ \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot !=\
    \ \"dll\")\n        return \"No\";\n    int num_digits = 0;\n    foreach (c; before_dot)\n\
    \    {\n        if (c >= '0' && c <= '9')\n            num_digits++;\n    }\n\
    \    if (num_digits > 3)\n        return \"No\";\n    if (before_dot[0] < 'a'\
    \ || before_dot[0] > 'z')\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv66e0t4m.d(22): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv66e0t4m.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    string extension;\n\
    \    string name;\n    foreach(i, ch; file_name)\n    {\n        if(ch >= '0'\
    \ && ch <= '9')\n        {\n            count++;\n        }\n        if(ch ==\
    \ '.')\n        {\n            dot_count++;\n            dot_index = i;\n    \
    \    }\n    }\n    if(count > 3 || dot_count != 1)\n    {\n        return \"No\"\
    ;\n    }\n    extension = file_name[dot_index + 1 .. $];\n    if(extension !=\
    \ \"txt\" && extension != \"exe\" && extension != \"dll\")\n    {\n        return\
    \ \"No\";\n    }\n    name = file_name[0 .. dot_index];\n    if(name.length ==\
    \ 0)\n    {\n        return \"No\";\n    }\n    if(name[0] < 'a' || name[0] >\
    \ 'z' && name[0] < 'A' || name[0] > 'Z')\n    {\n        return \"No\";\n    }\n\
    \    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5y7wkqzh.d(36): Error: cannot implicitly convert expression `i`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp5y7wkqzh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqcl0pezg.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmpqcl0pezg.d(28): Error: no property `count` for type `string`\\n/tmp/tmpqcl0pezg.d(32):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpqcl0pezg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n\
    \        return \"No\";\n    if (!file_name_parts[0][0].isAlpha)\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnzrh5fa3.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmpnzrh5fa3.d(28): Error: no property `count` for type `string`\\n/tmp/tmpnzrh5fa3.d(30):\
    \ Error: no property `contains` for type `string[]`\\n/tmp/tmpnzrh5fa3.d(32):\
    \ Error: no property `isAlpha` for type `immutable(char)`\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnzrh5fa3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    string extension = file_name[dot_index + 1 .. $];\n    string name = file_name[0\
    \ .. dot_index - 1];\n    int digits_count = 0;\n    foreach(char c; name)\n \
    \   {\n        if(c >= '0' && c <= '9')\n        {\n            digits_count++;\n\
    \        }\n    }\n    if(digits_count > 3)\n    {\n        return \"No\";\n \
    \   }\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0]\
    \ <= 'Z'))\n    {\n        return \"No\";\n    }\n    if(!valid_extensions.find(extension))\n\
    \    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n \
    \   alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplafo41p5.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmplafo41p5.d(42): Error: no property `find` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplafo41p5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // your code\
    \ here\n    int dot_index = file_name.find('.');\n    if (dot_index == -1) return\
    \ \"No\";\n    string before_dot = file_name[0..dot_index];\n    string after_dot\
    \ = file_name[dot_index+1..$];\n    if (before_dot.count('0'..'9') > 3) return\
    \ \"No\";\n    if (before_dot.empty) return \"No\";\n    if (!(before_dot[0] in\
    \ 'a'..'z' || before_dot[0] in 'A'..'Z')) return \"No\";\n    if (!(after_dot\
    \ in [\"txt\", \"exe\", \"dll\"])) return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcytwcijp.d(27): Error: found `..` when expecting `,`\\n/tmp/tmpcytwcijp.d(29):\
    \ Error: found `..` when expecting `)`\\n/tmp/tmpcytwcijp.d(29): Error: found\
    \ `122U` when expecting `)`\\n/tmp/tmpcytwcijp.d(29): Error: found `||` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcytwcijp.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // Write your\
    \ code here\n    int dot_count = 0;\n    int digit_count = 0;\n    int i = 0;\n\
    \    int len = file_name.length;\n    if (len < 5)\n        return \"No\";\n \
    \   if (file_name[i] >= '0' && file_name[i] <= '9')\n        return \"No\";\n\
    \    for (i = 0; i < len; i++)\n    {\n        if (file_name[i] == '.')\n    \
    \        dot_count++;\n        if (file_name[i] >= '0' && file_name[i] <= '9')\n\
    \            digit_count++;\n    }\n    if (dot_count != 1 || digit_count > 3)\n\
    \        return \"No\";\n    string ext = file_name.split('.')[1];\n    if (ext\
    \ == \"txt\" || ext == \"exe\" || ext == \"dll\")\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr7p6ljld.d(26): Error: cannot implicitly convert expression `file_name.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpr7p6ljld.d(40): Error: no property `split`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr7p6ljld.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n \
    \   if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index+1..$];\n\
    \    if (valid_extensions.find(extension) == -1)\n        return \"No\";\n   \
    \ string name = file_name[0..dot_index-1];\n    if (name.length == 0)\n      \
    \  return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A' ||\
    \ name[0] > 'Z')\n        return \"No\";\n    int digits_count = 0;\n    foreach\
    \ (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            digits_count++;\n\
    \    }\n    if (digits_count > 3)\n        return \"No\";\n    return \"Yes\"\
    ;\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphaond_nh.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmphaond_nh.d(27): Error: no property `find` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphaond_nh.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find(\".\");\n    if (dot_index == -1)\n        return \"No\";\n\
    \    string extension = file_name.substr(dot_index+1);\n    if (extension != \"\
    txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\"\
    ;\n    string name = file_name.substr(0, dot_index);\n    if (name.length == 0)\n\
    \        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A'\
    \ || name[0] > 'Z')\n        return \"No\";\n    int count = 0;\n    foreach (c;\
    \ name)\n    {\n        if (c >= '0' && c <= '9')\n            count++;\n    }\n\
    \    if (count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpntw1f_0t.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpntw1f_0t.d(25): Error: no property `substr` for type `string`\\n/tmp/tmpntw1f_0t.d(28):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpntw1f_0t.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_index = 0;\n    int dot_count = 0;\n    int i = 0;\n    int\
    \ j = 0;\n    string sub_str = \"\";\n    string sub_str2 = \"\";\n    string[]\
    \ valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] valid_extensions2\
    \ = [\"TXT\", \"EXE\", \"DLL\"];\n    string[] valid_extensions3 = [\"Txt\", \"\
    Exe\", \"Dll\"];\n    string[] valid_extensions4 = [\"tXt\", \"eXe\", \"dXl\"\
    ];\n    string[] valid_extensions5 = [\"txT\", \"exE\", \"dlL\"];\n    string[]\
    \ valid_extensions6 = [\"tXT\", \"eXE\", \"dXL\"];\n    string[] valid_extensions7\
    \ = [\"TxT\", \"ExE\", \"DlL\"];\n    string[] valid_extensions8 = [\"TXt\", \"\
    EXe\", \"DLl\"];\n    string[] valid_extensions9 = [\"tXt\", \"eXe\", \"dXl\"\
    ];\n    string[] valid_extensions10 = [\"txT\", \"exE\", \"dlL\"];\n    string[]\
    \ valid_extensions11 = [\"tXT\", \"eXE\", \"dXL\"];\n    string[] valid_extensions12\
    \ = [\"TxT\", \"ExE\", \"DlL\"];\n    string[] valid_extensions13 = [\"TXt\",\
    \ \"EXe\", \"DLl\"];\n    string[] valid_extensions14 = [\"tXt\", \"eXe\", \"\
    dXl\"];\n    string[] valid_extensions15 = [\"txT\", \"exE\", \"dlL\"];\n    string[]\
    \ valid_extensions16 = [\"tXT\", \"eXE\", \"dXL\"];\n    string[] valid_extensions17\
    \ = [\"TxT\", \"ExE\", \"DlL\"];\n    string[] valid_extensions18 = [\"TXt\",\
    \ \"EXe\", \"DLl\"];\n    string[] valid_extensions19 = [\"tXt\", \"eXe\", \"\
    dXl\"];\n\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd3so5y4n.d(49): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd3so5y4n.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.indexOf('.');\n\
    \    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0,\
    \ dot_index);\n    int digits_count = 0;\n    foreach(char c; name)\n    {\n \
    \       if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count\
    \ > 3 || dot_index == -1 || name.length == 0 || name[0] < 'A' || name[0] > 'z'\
    \ || !valid_extensions.canFind(extension))\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxi818zb9.d(23): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmpxi818zb9.d(24): Error: no property `substr` for type `string`\\n/tmp/tmpxi818zb9.d(25):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmpxi818zb9.d(32): Error:\
    \ no property `canFind` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpxi818zb9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_pos\
    \ = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n   \
    \ auto dot_pos_2 = file_name.find('.', dot_pos + 1);\n    if (dot_pos_2 != -1)\n\
    \        return \"No\";\n    auto ext = file_name.substr(dot_pos + 1);\n    if\
    \ (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\"\
    ;\n    auto name = file_name.substr(0, dot_pos);\n    if (name.length == 0)\n\
    \        return \"No\";\n    if (!isAlpha(name[0]))\n        return \"No\";\n\
    \    auto digits = 0;\n    for (auto c : name)\n    {\n        if (isDigit(c))\n\
    \            digits++;\n    }\n    if (digits > 3)\n        return \"No\";\n \
    \   return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi0mp6lya.d(37): Error: no identifier for declarator `c`\\n/tmp/tmpi0mp6lya.d(37):\
    \ Error: expression expected, not `:`\\n/tmp/tmpi0mp6lya.d(37): Error: found `name`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpi0mp6lya.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n\
    \        return \"No\";\n    if (!file_name_parts[0][0].isLetter)\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_l_jev12.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmp_l_jev12.d(28): Error: no property `count` for type `string`\\n/tmp/tmp_l_jev12.d(30):\
    \ Error: no property `contains` for type `string[]`\\n/tmp/tmp_l_jev12.d(32):\
    \ Error: no property `isLetter` for type `immutable(char)`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_l_jev12.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index +\
    \ 1);\n    string name = file_name.substr(0, dot_index);\n    int digit_count\
    \ = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n \
    \           digit_count++;\n    }\n    if(digit_count > 3)\n        return \"\
    No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"\
    dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\"\
    ;\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <=\
    \ 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp89k2qw1e.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmp89k2qw1e.d(23): Error: no property `substr` for type `string`\\n/tmp/tmp89k2qw1e.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp89k2qw1e.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    string extension = file_name[dot_index + 1 .. $];\n    string name = file_name[0\
    \ .. dot_index - 1];\n    int digits_count = 0;\n    foreach(c; name)\n    {\n\
    \        if(c >= '0' && c <= '9')\n        {\n            digits_count++;\n  \
    \      }\n    }\n    if(digits_count > 3)\n    {\n        return \"No\";\n   \
    \ }\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0]\
    \ <= 'Z'))\n    {\n        return \"No\";\n    }\n    if(!valid_extensions.canFind(extension))\n\
    \    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n \
    \   alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp02yjvo12.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmp02yjvo12.d(42): Error: no property `canFind` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp02yjvo12.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n\
    \    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' &&\
    \ c <= '9')\n            digits_count++;\n    }\n    if(digits_count > 3)\n  \
    \      return \"No\";\n    if(dot_index == -1)\n        return \"No\";\n    if(name.length\
    \ == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') &&\
    \ !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    if(!valid_extensions.canFind(extension))\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph25fhz5_.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmph25fhz5_.d(40): Error: no property `canFind` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph25fhz5_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n\
    \    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(c.isDigit)\n\
    \            digits_count++;\n    }\n    if(digits_count > 3)\n        return\
    \ \"No\";\n    if(!name.length)\n        return \"No\";\n    if(!name[0].isLetter)\n\
    \        return \"No\";\n    if(!valid_extensions.canFind(extension))\n      \
    \  return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate =\
    \ file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n   \
    \ assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvuwda2_4.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpvuwda2_4.d(29): Error: no property `isDigit` for type `immutable(char)`\\\
    n/tmp/tmpvuwda2_4.d(36): Error: no property `isLetter` for type `immutable(char)`\\\
    n/tmp/tmpvuwda2_4.d(38): Error: no property `canFind` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvuwda2_4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].count(\"\
    0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n\
    \        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprzz7r2dq.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmprzz7r2dq.d(26): Error: no property `count` for type `string`\\n/tmp/tmprzz7r2dq.d(32):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmprzz7r2dq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot = 0;\n    int dot_pos = 0;\n    int num_pos = 0;\n    int num_count\
    \ = 0;\n    int num_count_after = 0;\n    int num_count_before = 0;\n    int num_count_after_dot\
    \ = 0;\n    int num_count_before_dot = 0;\n    int num_count_after_dot_pos = 0;\n\
    \    int num_count_before_dot_pos = 0;\n    int num_count_after_dot_pos_end =\
    \ 0;\n    int num_count_before_dot_pos_end = 0;\n    int num_count_after_dot_pos_end_pos\
    \ = 0;\n    int num_count_before_dot_pos_end_pos = 0;\n    int num_count_after_dot_pos_end_pos_end\
    \ = 0;\n    int num_count_before_dot_pos_end_pos_end = 0;\n    int num_count_after_dot_pos_end_pos_end_pos\
    \ = 0;\n    int num_count_before_dot_pos_end_pos_end_pos = 0;\n    int num_count_after_dot_pos_end_pos_end_pos_end\
    \ = 0;\n    int num_count_before_dot_pos_end_pos_end_pos_end = 0;\n    int num_count_after_dot_pos_end_pos_end_pos_end_pos\
    \ = 0;\n    int num_count_before_dot_pos_end_pos_end_pos_end_pos = 0;\n    int\
    \ num_count_after_dot_pos_end_pos_end_pos_end_pos_end = 0;\n    int num_count_before_dot_pos_end_pos_end_pos_end_pos_end\
    \ = 0;\n    int num_count_after_dot_pos_end_pos_end_pos_end_pos_end_pos = 0;\n\
    \    int num_count_before_dot_pos_end_pos_end_pos_end_pos_end_pos = 0;\n    int\
    \ num_count_\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv_zqkvrv.d(50): Error: semicolon expected, not `unittest`\\n/tmp/tmpv_zqkvrv.d(50):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpv_zqkvrv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n   \
    \ string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n\
    \    if (before_dot.length == 0)\n        return \"No\";\n    if (after_dot !=\
    \ \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"\
    No\";\n    int count = 0;\n    foreach (c; before_dot)\n    {\n        if (c >=\
    \ '0' && c <= '9')\n            count++;\n    }\n    if (count > 3)\n        return\
    \ \"No\";\n    if (before_dot[0] < 'a' || before_dot[0] > 'z')\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwmchx_qz.d(22): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwmchx_qz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count\
    \ = 0;\n    int digit_count = 0;\n    bool is_valid = true;\n    foreach(c; file_name)\n\
    \    {\n        if(c == '.')\n        {\n            dot_count++;\n        }\n\
    \        else if(c >= '0' && c <= '9')\n        {\n            digit_count++;\n\
    \        }\n    }\n    if(dot_count != 1 || digit_count > 3)\n    {\n        is_valid\
    \ = false;\n    }\n    else\n    {\n        auto parts = file_name.split(\".\"\
    );\n        if(parts.length != 2)\n        {\n            is_valid = false;\n\
    \        }\n        else\n        {\n            if(parts[0].length == 0 || !(parts[0][0]\
    \ >= 'a' && parts[0][0] <= 'z') && !(parts[0][0] >= 'A' && parts[0][0] <= 'Z'))\n\
    \            {\n                is_valid = false;\n            }\n           \
    \ else\n            {\n                if(parts[1] != \"txt\" && parts[1] != \"\
    exe\" && parts[1] != \"dll\")\n                {\n                    is_valid\
    \ = false;\n                }\n            }\n        }\n    }\n    return is_valid\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq_whj9fu.d(42): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq_whj9fu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n \
    \   string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n\
    \    if (before_dot.length == 0 || after_dot.length == 0)\n        return \"No\"\
    ;\n    if (before_dot.count('0', '9') > 3)\n        return \"No\";\n    if (before_dot[0]\
    \ < 'a' || before_dot[0] > 'z')\n        return \"No\";\n    if (after_dot !=\
    \ \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"\
    No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv2_lsfgm.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpv2_lsfgm.d(29): Error: no property `count` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv2_lsfgm.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3n3777rq.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmp3n3777rq.d(28): Error: no property `count` for type `string`\\n/tmp/tmp3n3777rq.d(32):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp3n3777rq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    string sub_string;\n\
    \    string sub_string_after_dot;\n    foreach(i; 0..file_name.length)\n    {\n\
    \        if(file_name[i] == '.')\n        {\n            dot_count++;\n      \
    \      dot_index = i;\n        }\n        if(file_name[i] >= '0' && file_name[i]\
    \ <= '9')\n        {\n            count++;\n        }\n    }\n    if(count > 3\
    \ || dot_count != 1)\n    {\n        return \"No\";\n    }\n    sub_string = file_name[0..dot_index];\n\
    \    sub_string_after_dot = file_name[dot_index+1..$];\n    if(sub_string.length\
    \ == 0 || (sub_string[0] < 'a' || sub_string[0] > 'z') && (sub_string[0] < 'A'\
    \ || sub_string[0] > 'Z'))\n    {\n        return \"No\";\n    }\n    if(sub_string_after_dot\
    \ != \"txt\" && sub_string_after_dot != \"exe\" && sub_string_after_dot != \"\
    dll\")\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo97a31c9.d(32): Error: cannot implicitly convert expression `i`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpo97a31c9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.indexOf('.');\n    string extension = file_name.substring(dot_index\
    \ + 1);\n    string name = file_name.substring(0, dot_index);\n    int digits\
    \ = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n      \
    \      digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return\
    \ \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(name[0] <\
    \ 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\"\
    ;\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqcudhigg.d(22): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmpqcudhigg.d(23): Error: no property `substring` for type `string`\\n/tmp/tmpqcudhigg.d(24):\
    \ Error: no property `substring` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpqcudhigg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int i = 0;\n    int dot_index = 0;\n    string\
    \ extension = \"\";\n    string name = \"\";\n    foreach(char c; file_name)\n\
    \    {\n        if(c == '.')\n        {\n            dot_count++;\n          \
    \  dot_index = i;\n        }\n        i++;\n    }\n    if(dot_count != 1)\n  \
    \  {\n        return \"No\";\n    }\n    extension = file_name[dot_index+1..$];\n\
    \    name = file_name[0..dot_index-1];\n    if(extension != \"txt\" && extension\
    \ != \"exe\" && extension != \"dll\")\n    {\n        return \"No\";\n    }\n\
    \    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n        {\n\
    \            count++;\n        }\n    }\n    if(count > 3)\n    {\n        return\
    \ \"No\";\n    }\n    if(name[0] < 'a' || name[0] > 'z')\n    {\n        if(name[0]\
    \ < 'A' || name[0] > 'Z')\n        {\n            return \"No\";\n        }\n\
    \    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpk_fkf1gg.d(58): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x428946]\\n??:? immutable(char)[] tmpk_fkf1gg.file_name_check(immutable(char)[])\
    \ [0x427c93]\\n??:? void tmpk_fkf1gg.__unittest_L67_C1() [0x427e63]\\n??:? void\
    \ tmpk_fkf1gg.__modtest() [0x428614]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5b3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b4c2]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4305d9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430a88]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430565]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b499]\\n??:? runModuleUnitTests [0x42c389]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428d58]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428cdf]\\n??:? _d_run_main [0x428c4a]\\n??:? main [0x428627]\\\
    n??:? __libc_start_main [0xcbb74554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n \
    \   string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0,\
    \ dot_index);\n    int digits_count = 0;\n    foreach(char c; name)\n    {\n \
    \       if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count\
    \ > 3 || dot_index == -1 || name.length == 0 || \n        !(name[0] >= 'a' &&\
    \ name[0] <= 'z' || name[0] >= 'A' && name[0] <= 'Z') || \n        !valid_extensions.canFind(extension))\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppn0_gom_.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmppn0_gom_.d(24): Error: no property `substr` for type `string`\\n/tmp/tmppn0_gom_.d(25):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmppn0_gom_.d(34): Error:\
    \ no property `canFind` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppn0_gom_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] parts = split(file_name, \".\"\
    );\n    if (parts.length != 2)\n        return \"No\";\n    if (parts[0].length\
    \ == 0)\n        return \"No\";\n    if (parts[0][0] < 'a' || parts[0][0] > 'z')\n\
    \        return \"No\";\n    if (valid_extensions.count(parts[1]) == 0)\n    \
    \    return \"No\";\n    int digits = 0;\n    foreach (c; parts[0])\n    {\n \
    \       if (c >= '0' && c <= '9')\n            digits++;\n    }\n    if (digits\
    \ > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw2o05o3q.d(23): Error: undefined identifier `split`\\n/tmp/tmpw2o05o3q.d(30):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpw2o05o3q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (valid_extensions.indexOf(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\n/*\nCreate a function\
    \ which takes a string representing a file's name, and returns\n    'Yes' if the\
    \ the file's name is valid, and returns 'No' otherwise.\n    A file's name is\
    \ considered to be valid if and only if all the following conditions \n    are\
    \ met:\n    - There should not be more than three digits ('0'-'9') in the file's\
    \ name.\n    - The file's name contains exactly one dot '.'\n    - The substring\
    \ before the dot should not be empty, and it starts with a letter from \n    the\
    \ latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should\
    \ be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (valid_extensions.indexOf(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxkhynkkg.d(64): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxkhynkkg.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find('.');\n    string ext = file_name.substr(dot_pos+1);\n    string\
    \ name = file_name.substr(0, dot_pos);\n    if (ext != \"txt\" && ext != \"exe\"\
    \ && ext != \"dll\")\n        return \"No\";\n    if (name.length == 0)\n    \
    \    return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A' ||\
    \ name[0] > 'Z')\n        return \"No\";\n    int count = 0;\n    foreach (c;\
    \ name)\n    {\n        if (c >= '0' && c <= '9')\n            count++;\n    }\n\
    \    if (count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp54jiu_59.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmp54jiu_59.d(23): Error: no property `substr` for type `string`\\n/tmp/tmp54jiu_59.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp54jiu_59.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] parts = file_name.split(\".\");\n\
    \    if (parts.length != 2)\n        return \"No\";\n    if (parts[0].length ==\
    \ 0)\n        return \"No\";\n    if (parts[0].count('0', '9') > 3)\n        return\
    \ \"No\";\n    if (parts[0].count('a', 'z') == 0 && parts[0].count('A', 'Z') ==\
    \ 0)\n        return \"No\";\n    if (valid_extensions.count(parts[1]) == 0)\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptxbzlrki.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmptxbzlrki.d(28): Error: no property `count` for type `string`\\n/tmp/tmptxbzlrki.d(30):\
    \ Error: no property `count` for type `string`\\n/tmp/tmptxbzlrki.d(30): Error:\
    \ no property `count` for type `string`\\n/tmp/tmptxbzlrki.d(32): Error: no property\
    \ `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmptxbzlrki.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count\
    \ = 0;\n    int digit_count = 0;\n    bool valid_extension = false;\n    string\
    \ extension;\n    string name;\n    foreach(char c; file_name)\n    {\n      \
    \  if(c == '.')\n        {\n            dot_count++;\n            if(dot_count\
    \ > 1)\n                return \"No\";\n            valid_extension = true;\n\
    \            continue;\n        }\n        if(dot_count == 0)\n        {\n   \
    \         if(!isAlpha(c))\n                return \"No\";\n            name ~=\
    \ c;\n        }\n        else\n        {\n            if(!isAlpha(c))\n      \
    \          return \"No\";\n            extension ~= c;\n        }\n    }\n   \
    \ if(name.length == 0)\n        return \"No\";\n    if(extension.length == 0)\n\
    \        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" &&\
    \ extension != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6r71t8bs.d(39): Error: undefined identifier `isAlpha`\\n/tmp/tmp6r71t8bs.d(45):\
    \ Error: undefined identifier `isAlpha`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp6r71t8bs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    if (dot_index == -1) return \"No\";\n    string\
    \ before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n\
    \    if (before_dot.length == 0) return \"No\";\n    if (before_dot.length ==\
    \ 1 && !isAlpha(before_dot[0])) return \"No\";\n    if (before_dot.length > 1\
    \ && !isAlpha(before_dot[0])) return \"No\";\n    if (before_dot.length > 1 &&\
    \ !isAlpha(before_dot[1])) return \"No\";\n    if (after_dot != \"txt\" && after_dot\
    \ != \"exe\" && after_dot != \"dll\") return \"No\";\n    int num_digits = 0;\n\
    \    foreach (c; before_dot) {\n        if (isDigit(c)) num_digits++;\n    }\n\
    \    if (num_digits > 3) return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n\
    \    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpof_hz4h6.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpof_hz4h6.d(27): Error: undefined identifier `isAlpha`\\n/tmp/tmpof_hz4h6.d(28):\
    \ Error: undefined identifier `isAlpha`\\n/tmp/tmpof_hz4h6.d(29): Error: undefined\
    \ identifier `isAlpha`\\n/tmp/tmpof_hz4h6.d(33): Error: undefined identifier `isDigit`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpof_hz4h6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n \
    \   string extension = file_name.slice(dot_index + 1);\n    string name = file_name.slice(0,\
    \ dot_index);\n    int digits_count = 0;\n    foreach(char c; name)\n    {\n \
    \       if(c >= '0' && c <= '9')\n        {\n            digits_count++;\n   \
    \     }\n    }\n    if(digits_count > 3)\n    {\n        return \"No\";\n    }\n\
    \    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <=\
    \ 'Z'))\n    {\n        return \"No\";\n    }\n    if(!(extension in valid_extensions))\n\
    \    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n \
    \   alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwz9zwgqn.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpwz9zwgqn.d(24): Error: no property `slice` for type `string`\\n/tmp/tmpwz9zwgqn.d(25):\
    \ Error: no property `slice` for type `string`\\n/tmp/tmpwz9zwgqn.d(42): Error:\
    \ incompatible types for `(extension) in (valid_extensions)`: `string` and `string[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwz9zwgqn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find('.');\n    string ext = file_name.substr(dot_pos + 1);\n  \
    \  string name = file_name.substr(0, dot_pos);\n    int digits = 0;\n    foreach(c;\
    \ name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n\
    \    if(digits > 3)\n        return \"No\";\n    if(ext != \"txt\" && ext != \"\
    exe\" && ext != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n \
    \       return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0]\
    \ >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp342d74xd.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmp342d74xd.d(23): Error: no property `substr` for type `string`\\n/tmp/tmp342d74xd.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp342d74xd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = split(file_name,\
    \ \".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if\
    \ (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ != count(file_name_parts[0], ch => ch.isLetter))\n        return \"No\";\n \
    \   if (file_name_parts[0].length != count(file_name_parts[0], ch => ch.isDigit))\n\
    \        return \"No\";\n    if (file_name_parts[0].length > 3)\n        return\
    \ \"No\";\n    if (valid_extensions.indexOf(file_name_parts[1]) == -1)\n     \
    \   return \"No\";\n    return \"Yes\";\n}\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = split(file_name,\
    \ \".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if\
    \ (file_name_\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvteevd7y.d(62): Error: found `unittest` when expecting `)`\\\
    n/tmp/tmpvteevd7y.d(93): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvteevd7y.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    string ext = \"\";\n    string ext_list[] =\
    \ [\"txt\", \"exe\", \"dll\"];\n    foreach(c; file_name)\n    {\n        if(c.isDigit)\n\
    \        {\n            count++;\n        }\n        if(c == '.')\n        {\n\
    \            dot_count++;\n        }\n    }\n    if(count > 3 || dot_count !=\
    \ 1)\n    {\n        return \"No\";\n    }\n    else\n    {\n        ext = file_name.split('.')[1];\n\
    \        if(ext in ext_list)\n        {\n            return \"Yes\";\n       \
    \ }\n        else\n        {\n            return \"No\";\n        }\n    }\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgc0yohtl.d(25): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `string[] ext_list`\\n/tmp/tmpgc0yohtl.d(28): Error: no property `isDigit`\
    \ for type `immutable(char)`\\n/tmp/tmpgc0yohtl.d(43): Error: no property `split`\
    \ for type `string`\\n/tmp/tmpgc0yohtl.d(44): Error: incompatible types for `(ext)\
    \ in (ext_list)`: `string` and `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpgc0yohtl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n \
    \   if (dot_index == -1)\n        return \"No\";\n    string name = file_name[0..dot_index];\n\
    \    string extension = file_name[dot_index+1..$];\n    if (name.count('0'..'9')\
    \ > 3)\n        return \"No\";\n    if (name.length == 0)\n        return \"No\"\
    ;\n    if (!(name[0] in 'a'..'z' || name[0] in 'A'..'Z'))\n        return \"No\"\
    ;\n    if (!(extension in valid_extensions))\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfxpzt5u9.d(28): Error: found `..` when expecting `,`\\n/tmp/tmpfxpzt5u9.d(32):\
    \ Error: found `..` when expecting `)`\\n/tmp/tmpfxpzt5u9.d(32): Error: found\
    \ `122U` when expecting `)`\\n/tmp/tmpfxpzt5u9.d(32): Error: found `||` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfxpzt5u9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // your code\
    \ here\n    int dot_count = 0;\n    int digit_count = 0;\n    foreach(c; file_name)\n\
    \    {\n        if(c == '.')\n            dot_count++;\n        if(c >= '0' &&\
    \ c <= '9')\n            digit_count++;\n    }\n    if(dot_count != 1 || digit_count\
    \ > 3)\n        return \"No\";\n    string[] parts = file_name.split(\".\");\n\
    \    if(parts[0].length == 0 || parts[0][0] < 'a' || parts[0][0] > 'z')\n    \
    \    return \"No\";\n    if(parts[1] != \"txt\" && parts[1] != \"exe\" && parts[1]\
    \ != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n \
    \   alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdsc8mytg.d(34): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdsc8mytg.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index+1);\n\
    \    string name = file_name.substr(0, dot_index);\n    int digit_count = 0;\n\
    \    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n        \
    \    digit_count++;\n    }\n    if(digit_count > 3)\n        return \"No\";\n\
    \    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n\
    \        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n  \
    \  if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi6pa4uvn.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpi6pa4uvn.d(23): Error: no property `substr` for type `string`\\n/tmp/tmpi6pa4uvn.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpi6pa4uvn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index +\
    \ 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n\
    \    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n        \
    \    digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return\
    \ \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0]\
    \ >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return\
    \ \"No\";\n    return \"Yes\";\n}\n/*\nCreate a function which takes a string\
    \ representing a file's name, and returns\n    the file's extension.\n    A file's\
    \ extension is the substring after the last dot '.' in the file's name.\n    If\
    \ the file's name does not contain a dot, return an empty string.\n    Examples:\n\
    \    >>> file_extension(\"example.txt\")\n    \"txt\"\n    >>> file_extension(\"\
    example\")\n    \"\"\n*/\nstring file_extension(string file_name) \n{\n    int\
    \ dot_index = file_name.find('.');\n    if(dot_index == -1)\n        return \"\
    \";\n    return file_name.substr(dot_index + 1);\n}\n/*\nCreate a function which\
    \ takes a string representing a file's name, and returns\n    the file's name\
    \ without its extension.\n    A file's extension is the substring after the last\
    \ dot '.' in the file's name.\n    If the file's name does not contain a dot,\
    \ return the file's name unchanged.\n    Examples:\n    >>> file_name_without_extension(\"\
    example.txt\")\n    \"example\"\n    >>> file_name_without_extension(\"example\"\
    )\n    \"example\"\n*/\nstring file_name_without_extension(string file_name) \n\
    {\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpimisx6q8.d(72): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpimisx6q8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // check if\
    \ there are more than 3 digits\n    int count = 0;\n    foreach(c; file_name)\n\
    \    {\n        if(c >= '0' && c <= '9')\n            count++;\n    }\n    if(count\
    \ > 3)\n        return \"No\";\n    // check if there is exactly one dot\n   \
    \ int dot_count = 0;\n    foreach(c; file_name)\n    {\n        if(c == '.')\n\
    \            dot_count++;\n    }\n    if(dot_count != 1)\n        return \"No\"\
    ;\n    // check if the substring before the dot starts with a letter\n    // and\
    \ if the substring after the dot is one of the valid extensions\n    string[]\
    \ valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_split\
    \ = file_name.split(\".\");\n    if(file_name_split[0].length == 0)\n        return\
    \ \"No\";\n    if(file_name_split[0][0] < 'a' || file_name_split[0][0] > 'z' &&\n\
    \       file_name_split[0][0] < 'A' || file_name_split[0][0] > 'Z')\n        return\
    \ \"No\";\n    if(!valid_extensions.contains(file_name_split[1]))\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq7iare7k.d(43): Error: no property `split` for type `string`\\\
    n/tmp/tmpq7iare7k.d(49): Error: no property `contains` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq7iare7k.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n \
    \   string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n\
    \    if (before_dot.length == 0 || !isAlpha(before_dot[0]))\n        return \"\
    No\";\n    int digits_count = 0;\n    foreach (c; before_dot)\n    {\n       \
    \ if (isDigit(c))\n            digits_count++;\n    }\n    if (digits_count >\
    \ 3)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"\
    exe\" && after_dot != \"dll\")\n        return \"No\";\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmbyxm0uj.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpmbyxm0uj.d(27): Error: undefined identifier `isAlpha`\\n/tmp/tmpmbyxm0uj.d(32):\
    \ Error: undefined identifier `isDigit`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpmbyxm0uj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n \
    \   string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n\
    \    if (before_dot.length == 0)\n        return \"No\";\n    if (after_dot !=\
    \ \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"\
    No\";\n    int digits_count = 0;\n    foreach (c; before_dot)\n    {\n       \
    \ if ('0' <= c && c <= '9')\n            digits_count++;\n    }\n    if (digits_count\
    \ > 3)\n        return \"No\";\n    if ('a' <= before_dot[0] && before_dot[0]\
    \ <= 'z')\n        return \"Yes\";\n    if ('A' <= before_dot[0] && before_dot[0]\
    \ <= 'Z')\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6pyyk5m3.d(22): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6pyyk5m3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n \
    \   string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0,\
    \ dot_index);\n    int digits_count = 0;\n    foreach(c; name)\n    {\n      \
    \  if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count\
    \ > 3 || dot_index == -1 || name.length == 0 || !(name[0] >= 'a' && name[0] <=\
    \ 'z' || name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    foreach(ext;\
    \ valid_extensions)\n    {\n        if(ext == extension)\n            return \"\
    Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfpjm_zgq.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpfpjm_zgq.d(24): Error: no property `substr` for type `string`\\n/tmp/tmpfpjm_zgq.d(25):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpfpjm_zgq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int dot_index_2 = 0;\n\
    \    int dot_index_3 = 0;\n    int dot_index_4 = 0;\n    int dot_index_5 = 0;\n\
    \    int dot_index_6 = 0;\n    int dot_index_7 = 0;\n    int dot_index_8 = 0;\n\
    \    int dot_index_9 = 0;\n    int dot_index_10 = 0;\n    int dot_index_11 = 0;\n\
    \    int dot_index_12 = 0;\n    int dot_index_13 = 0;\n    int dot_index_14 =\
    \ 0;\n    int dot_index_15 = 0;\n    int dot_index_16 = 0;\n    int dot_index_17\
    \ = 0;\n    int dot_index_18 = 0;\n    int dot_index_19 = 0;\n    int dot_index_20\
    \ = 0;\n    int dot_index_21 = 0;\n    int dot_index_22 = 0;\n    int dot_index_23\
    \ = 0;\n    int dot_index_24 = 0;\n    int dot_index_25 = 0;\n    int dot_index_26\
    \ = 0;\n    int dot_index_27 = 0;\n    int dot_index_28 = 0;\n    int dot_index_29\
    \ = 0;\n    int dot_index_30 = 0;\n    int dot_index_31 = 0;\n    int dot_index_32\
    \ = 0;\n    int dot_index_33 = 0;\n    int dot_index_34 = 0;\n    int dot_index_35\
    \ = 0;\n    int dot_index_36 = 0;\n    int dot_index_37 = 0;\n    int dot_index_38\
    \ = 0;\n    int dot_index_39 = 0;\n    int dot_index_40 = 0;\n    int dot_index_41\
    \ = 0;\n    int dot_index_42 = 0;\n    int dot_index_43 = 0;\n    int dot_index_44\
    \ = 0;\n    int dot_index_45 = 0;\n\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvf6ymik7.d(70): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvf6ymik7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.indexOf('.');\n\
    \    if (dot_index == -1) return \"No\";\n    string name = file_name[0..dot_index];\n\
    \    string extension = file_name[dot_index+1..$];\n    if (name.length == 0 ||\
    \ !isAlpha(name[0])) return \"No\";\n    if (extension.length == 0 || valid_extensions.indexOf(extension)\
    \ == -1) return \"No\";\n    int digits_count = 0;\n    foreach (c; name)\n  \
    \  {\n        if (isDigit(c)) digits_count++;\n    }\n    if (digits_count > 3)\
    \ return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqzoywyz5.d(23): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmpqzoywyz5.d(27): Error: undefined identifier `isAlpha`\\n/tmp/tmpqzoywyz5.d(28):\
    \ Error: no property `indexOf` for type `string[]`\\n/tmp/tmpqzoywyz5.d(32): Error:\
    \ undefined identifier `isDigit`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpqzoywyz5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_pos = 0;\n    int len = file_name.length;\n\
    \    string file_name_substr;\n    string file_name_substr_after_dot;\n    string\
    \ file_name_substr_before_dot;\n    string[] file_name_substr_after_dot_array\
    \ = [\"txt\", \"exe\", \"dll\"];\n    foreach(i; 0..len)\n    {\n        if(file_name[i]\
    \ == '.')\n        {\n            dot_count++;\n            dot_pos = i;\n   \
    \     }\n        if(file_name[i] >= '0' && file_name[i] <= '9')\n        {\n \
    \           count++;\n        }\n    }\n    if(count > 3 || dot_count != 1)\n\
    \    {\n        return \"No\";\n    }\n    file_name_substr = file_name[0..dot_pos-1];\n\
    \    file_name_substr_after_dot = file_name[dot_pos+1..len];\n    if(file_name_substr.length\
    \ == 0 || !(file_name_substr[0] >= 'a' && file_name_substr[0] <= 'z' || file_name_substr[0]\
    \ >= 'A' && file_name_substr[0] <= 'Z'))\n    {\n        return \"No\";\n    }\n\
    \    if(!(file_name_substr_after_dot == file_name_substr_after_dot_array[0] ||\
    \ file_name_substr_after_dot == file_name_substr_after_dot_array[1] || file_name_substr_after_dot\
    \ == file_name_substr_after_dot_array[2]))\n    {\n        return \"No\";\n  \
    \  }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt8yofi1m.d(25): Error: cannot implicitly convert expression `file_name.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpt8yofi1m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot = 0;\n    int dot_index = 0;\n    int len = file_name.length;\n\
    \    int i = 0;\n    string sub_str = \"\";\n    string sub_str2 = \"\";\n   \
    \ string sub_str3 = \"\";\n    string sub_str4 = \"\";\n    string sub_str5 =\
    \ \"\";\n    string sub_str6 = \"\";\n    string sub_str7 = \"\";\n    string\
    \ sub_str8 = \"\";\n    string sub_str9 = \"\";\n    string sub_str10 = \"\";\n\
    \    string sub_str11 = \"\";\n    string sub_str12 = \"\";\n    string sub_str13\
    \ = \"\";\n    string sub_str14 = \"\";\n    string sub_str15 = \"\";\n    string\
    \ sub_str16 = \"\";\n    string sub_str17 = \"\";\n    string sub_str18 = \"\"\
    ;\n    string sub_str19 = \"\";\n    string sub_str20 = \"\";\n    string sub_str21\
    \ = \"\";\n    string sub_str22 = \"\";\n    string sub_str23 = \"\";\n    string\
    \ sub_str24 = \"\";\n    string sub_str25 = \"\";\n    string sub_str26 = \"\"\
    ;\n    string sub_str27 = \"\";\n    string sub_str28 = \"\";\n    string sub_str29\
    \ = \"\";\n    string sub_str30 = \"\";\n    string sub_str31 = \"\";\n    string\
    \ sub_str32 = \"\";\n    string sub_str33 = \"\";\n    string sub_str34 = \"\"\
    ;\n    string sub_str35 = \"\";\n    string sub_str36 = \"\";\n    string sub_str37\
    \ = \"\";\n    string sub_str38 = \"\";\n    string sub_str39 = \"\";\n    string\
    \ sub_str40 = \"\";\n    string sub_str41 = \"\";\n    string sub_str42 = \"\"\
    ;\n    string sub_str43 = \"\";\n    string sub_str44 = \"\";\n    string sub_str45\
    \ = \"\";\n    string sub_str46 = \"\";\n    string sub_str47 = \"\";\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7_yx96na.d(74): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7_yx96na.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    foreach(char c; file_name)\n    {\n        if(c\
    \ == '.')\n        {\n            dot_count++;\n        }\n        if(c >= '0'\
    \ && c <= '9')\n        {\n            count++;\n        }\n    }\n    if(count\
    \ > 3 || dot_count != 1)\n    {\n        return \"No\";\n    }\n    string[] parts\
    \ = file_name.split(\".\");\n    if(parts[0].length == 0 || (parts[0][0] < 'a'\
    \ || parts[0][0] > 'z') && (parts[0][0] < 'A' || parts[0][0] > 'Z'))\n    {\n\
    \        return \"No\";\n    }\n    if(parts[1] != \"txt\" && parts[1] != \"exe\"\
    \ && parts[1] != \"dll\")\n    {\n        return \"No\";\n    }\n    return \"\
    Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv7dpylbo.d(39): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv7dpylbo.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqfn9srnk.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmpqfn9srnk.d(28): Error: no property `count` for type `string`\\n/tmp/tmpqfn9srnk.d(32):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpqfn9srnk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find('.');\n    string before_dot = file_name[0..dot_pos];\n   \
    \ string after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0\
    \ || before_dot.length == dot_pos)\n        return \"No\";\n    if (after_dot.length\
    \ == 0)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot !=\
    \ \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    int count = 0;\n\
    \    foreach (c; before_dot)\n    {\n        if (c >= '0' && c <= '9')\n     \
    \       count++;\n    }\n    if (count > 3)\n        return \"No\";\n    if (before_dot[0]\
    \ < 'a' || before_dot[0] > 'z')\n        if (before_dot[0] < 'A' || before_dot[0]\
    \ > 'Z')\n            return \"No\";\n    return \"Yes\";\n}\n/*\nCreate a function\
    \ which takes a string representing a file's name, and returns\n    the file's\
    \ extension.\n    Examples:\n    >>> file_extension(\"example.txt\")\n    \"txt\"\
    \n    >>> file_extension(\"example.exe\")\n    \"exe\"\n*/\nstring file_extension(string\
    \ file_name) \n{\n    int dot_pos = file_name.find('.');\n    return file_name[dot_pos+1..$];\n\
    }\n/*\nCreate a function which takes a string representing a file's name, and\
    \ returns\n    the file's name without the extension.\n    Examples:\n    >>>\
    \ file_name_without_extension(\"example.txt\")\n    \"example\"\n    >>> file_name_without_extension(\"\
    example.exe\")\n    \"example\"\n*/\nstring file_name_without_extension(string\
    \ file_name) \n{\n    int dot_pos = file_name.find('.');\n    return file_name[0..dot_pos-1];\n\
    }\n/*\nCreate a function which takes a string representing a file's name, and\
    \ returns\n   \nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2tih5x46.d(72): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2tih5x46.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = split(file_name,\
    \ \".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    string\
    \ file_name_without_extension = file_name_parts[0];\n    string file_extension\
    \ = file_name_parts[1];\n    if (file_name_without_extension.length == 0)\n  \
    \      return \"No\";\n    if (file_name_without_extension.length == 1)\n    {\n\
    \        if (file_name_without_extension[0] >= 'a' && file_name_without_extension[0]\
    \ <= 'z')\n            return \"Yes\";\n        if (file_name_without_extension[0]\
    \ >= 'A' && file_name_without_extension[0] <= 'Z')\n            return \"Yes\"\
    ;\n        return \"No\";\n    }\n    if (file_name_without_extension.length ==\
    \ 2)\n    {\n        if (file_name_without_extension[0] >= 'a' && file_name_without_extension[0]\
    \ <= 'z')\n            return \"Yes\";\n        if (file_name_without_extension[0]\
    \ >= 'A' && file_name_without_extension[0] <= 'Z')\n            return \"Yes\"\
    ;\n        return \"No\";\n    }\n    if (file_name_without_extension.length ==\
    \ 3)\n    {\n        if (file_name_without_extension[0] >= 'a' && file_name_without_extension[0]\
    \ <= 'z')\n            return \"Yes\";\n        if (file_name_without_extension[0]\
    \ >= 'A' && file_name_without_extension[0] <= 'Z')\n            return \"Yes\"\
    ;\n        return \"No\";\n    }\n    if (file_name_without_extension.length >\
    \ 3)\n        return \"No\";\n    if (file_extension != \"txt\" && file_extension\
    \ != \"exe\" && file_extension != \"dll\")\n        return \"No\";\n\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphjp8226z.d(59): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphjp8226z.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count\
    \ = 0;\n    int digit_count = 0;\n    int dot_index = 0;\n    int file_name_length\
    \ = file_name.length;\n    string file_extension = \"\";\n    string file_name_without_extension\
    \ = \"\";\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    bool\
    \ is_valid_extension = false;\n    bool is_valid_file_name = false;\n    for (int\
    \ i = 0; i < file_name_length; i++)\n    {\n        if (file_name[i] == '.')\n\
    \        {\n            dot_count++;\n            dot_index = i;\n        }\n\
    \        if (file_name[i] >= '0' && file_name[i] <= '9')\n        {\n        \
    \    digit_count++;\n        }\n    }\n    if (dot_count == 1 && digit_count <=\
    \ 3)\n    {\n        file_extension = file_name[dot_index+1..$];\n        file_name_without_extension\
    \ = file_name[0..dot_index-1];\n        foreach (extension; valid_extensions)\n\
    \        {\n            if (extension == file_extension)\n            {\n    \
    \            is_valid_extension = true;\n            }\n        }\n        if\
    \ (file_name_without_extension != \"\" && (file_name_without_extension[0] >= 'a'\
    \ && file_name_without_extension[0] <= 'z' || file_name_without_extension[0] >=\
    \ 'A' && file_name_without_extension[0] <= 'Z'))\n        {\n            is_valid_file_name\
    \ = true;\n        }\n    }\n    if (is_valid_file_name && is_valid_extension)\n\
    \    {\n        return \"Yes\";\n    }\n    else\n    {\n        return \"No\"\
    ;\n    }\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpza9pe9xc.d(25): Error: cannot implicitly convert expression `file_name.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpza9pe9xc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n \
    \   string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n\
    \    if (before_dot.length == 0 || after_dot.length == 0)\n        return \"No\"\
    ;\n    if (before_dot.length - before_dot.count!(c => c >= '0' && c <= '9') >\
    \ 3)\n        return \"No\";\n    if (before_dot[0] < 'A' || before_dot[0] > 'z'\
    \ || (before_dot[0] > 'Z' && before_dot[0] < 'a'))\n        return \"No\";\n \
    \   if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp67xwnzko.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmp67xwnzko.d(29): Error: no property `count` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp67xwnzko.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n \
    \   string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0,\
    \ dot_index);\n    int digits_count = 0;\n    foreach(char c; name)\n    {\n \
    \       if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count\
    \ > 3 || dot_index == -1 || name.length == 0 || \n        !(name[0] >= 'a' &&\
    \ name[0] <= 'z' || name[0] >= 'A' && name[0] <= 'Z') || \n        !valid_extensions.canFind(extension))\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3kk5rtyz.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmp3kk5rtyz.d(24): Error: no property `substr` for type `string`\\n/tmp/tmp3kk5rtyz.d(25):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmp3kk5rtyz.d(34): Error:\
    \ no property `canFind` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp3kk5rtyz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count\
    \ = 0;\n    int digit_count = 0;\n    bool is_valid = true;\n    foreach(c; file_name)\n\
    \    {\n        if(c == '.')\n        {\n            dot_count++;\n        }\n\
    \        else if(c >= '0' && c <= '9')\n        {\n            digit_count++;\n\
    \        }\n    }\n    if(dot_count != 1 || digit_count > 3)\n    {\n        is_valid\
    \ = false;\n    }\n    else\n    {\n        auto parts = file_name.split(\".\"\
    );\n        if(parts.length != 2)\n        {\n            is_valid = false;\n\
    \        }\n        else\n        {\n            auto extension = parts[1];\n\
    \            if(extension != \"txt\" && extension != \"exe\" && extension != \"\
    dll\")\n            {\n                is_valid = false;\n            }\n    \
    \        else\n            {\n                auto name = parts[0];\n        \
    \        if(name.length == 0)\n                {\n                    is_valid\
    \ = false;\n                }\n                else\n                {\n     \
    \               auto first_char = name[0];\n                    if(!(first_char\
    \ >= 'a' && first_char <= 'z') && !(first_char >= 'A' && first_char <= 'Z'))\n\
    \                    {\n                        is_valid = false;\n          \
    \          }\n                }\n            }\n        }\n    }\n    return is_valid\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj_y2h3b2.d(42): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj_y2h3b2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // Your code\
    \ goes here\n    int dot_count = 0;\n    int digit_count = 0;\n    bool is_valid\
    \ = true;\n    foreach(c; file_name)\n    {\n        if(c == '.')\n        {\n\
    \            dot_count++;\n        }\n        else if(c >= '0' && c <= '9')\n\
    \        {\n            digit_count++;\n        }\n    }\n    if(dot_count !=\
    \ 1 || digit_count > 3)\n    {\n        is_valid = false;\n    }\n    else\n \
    \   {\n        string[] parts = file_name.split(\".\");\n        if(parts.length\
    \ != 2)\n        {\n            is_valid = false;\n        }\n        else\n \
    \       {\n            if(parts[0].length == 0 || parts[0][0] < 'a' || parts[0][0]\
    \ > 'z')\n            {\n                is_valid = false;\n            }\n  \
    \          else\n            {\n                string[] valid_extensions = [\"\
    txt\", \"exe\", \"dll\"];\n                if(!valid_extensions.canFind(parts[1]))\n\
    \                {\n                    is_valid = false;\n                }\n\
    \            }\n        }\n    }\n    return is_valid ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprac09keq.d(43): Error: no property `split` for type `string`\\\
    n/tmp/tmprac09keq.d(57): Error: no property `canFind` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprac09keq.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n   \
    \ string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n\
    \    if (before_dot.length == 0 || before_dot.length > 8)\n        return \"No\"\
    ;\n    if (after_dot.length == 0 || after_dot.length > 3)\n        return \"No\"\
    ;\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\"\
    )\n        return \"No\";\n    int num_digits = 0;\n    foreach (c; before_dot)\n\
    \    {\n        if (c >= '0' && c <= '9')\n            num_digits++;\n       \
    \ else if (!(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z'))\n            return\
    \ \"No\";\n    }\n    if (num_digits > 3)\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjs8t0j6r.d(22): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjs8t0j6r.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int i = 0;\n    int len = file_name.length;\n\
    \    string extension = \"\";\n    string name = \"\";\n    while(i < len)\n \
    \   {\n        if(file_name[i] == '.')\n        {\n            dot_count++;\n\
    \            if(dot_count > 1)\n            {\n                return \"No\";\n\
    \            }\n            if(i == 0)\n            {\n                return\
    \ \"No\";\n            }\n            if(i == len - 1)\n            {\n      \
    \          return \"No\";\n            }\n            extension = file_name[i+1..$];\n\
    \            name = file_name[0..i-1];\n        }\n        else if(file_name[i]\
    \ >= '0' && file_name[i] <= '9')\n        {\n            count++;\n          \
    \  if(count > 3)\n            {\n                return \"No\";\n            }\n\
    \        }\n        else if(file_name[i] < 'a' || file_name[i] > 'z')\n      \
    \  {\n            if(file_name[i] < 'A' || file_name[i] > 'Z')\n            {\n\
    \                return \"No\";\n            }\n        }\n        i++;\n    }\n\
    \    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n\
    \    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n \
    \   alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8nud0wk4.d(25): Error: cannot implicitly convert expression `file_name.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp8nud0wk4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n\
    \    int digits_count = 0;\n    foreach(char c; name)\n    {\n        if(c >=\
    \ '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count >\
    \ 3)\n        return \"No\";\n    if(dot_index == -1)\n        return \"No\";\n\
    \    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' &&\
    \ name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\"\
    ;\n    if(!valid_extensions.canFind(extension))\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd8gzrny_.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpd8gzrny_.d(40): Error: no property `canFind` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd8gzrny_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index\
    \ + 1 .. $];\n    if (!valid_extensions.canFind(extension))\n        return \"\
    No\";\n    string name = file_name[0 .. dot_index];\n    if (name.length == 0)\n\
    \        return \"No\";\n    int digits_count = 0;\n    foreach (c; name)\n  \
    \  {\n        if (c >= '0' && c <= '9')\n            digits_count++;\n    }\n\
    \    if (digits_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpznl22anw.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpznl22anw.d(27): Error: no property `canFind` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpznl22anw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n \
    \   string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0,\
    \ dot_index);\n    int digits_count = 0;\n    foreach(char c; name)\n    {\n \
    \       if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    return\
    \ (digits_count <= 3 && dot_index != -1 && name.length > 0 && \n            name[0]\
    \ >= 'a' && name[0] <= 'z' && valid_extensions.find(extension) != -1) ? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp424guto7.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmp424guto7.d(24): Error: no property `substr` for type `string`\\n/tmp/tmp424guto7.d(25):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmp424guto7.d(33): Error:\
    \ no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp424guto7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    string extension = file_name[dot_index + 1 .. $];\n    string name = file_name[0\
    \ .. dot_index - 1];\n    int digits_count = 0;\n    foreach(c; name)\n    {\n\
    \        if(isdigit(c))\n        {\n            digits_count++;\n        }\n \
    \   }\n    if(digits_count > 3)\n    {\n        return \"No\";\n    }\n    if(!isalpha(name[0]))\n\
    \    {\n        return \"No\";\n    }\n    if(!valid_extensions.count(extension))\n\
    \    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n \
    \   alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyp6gszf_.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpyp6gszf_.d(29): Error: undefined identifier `isdigit`\\n/tmp/tmpyp6gszf_.d(38):\
    \ Error: undefined identifier `isalpha`\\n/tmp/tmpyp6gszf_.d(42): Error: no property\
    \ `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpyp6gszf_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_pos = 0;\n    int len = file_name.length;\n\
    \    string sub1 = \"\";\n    string sub2 = \"\";\n    string result = \"\";\n\
    \    for (int i = 0; i < len; i++)\n    {\n        if (file_name[i] >= '0' &&\
    \ file_name[i] <= '9')\n        {\n            count++;\n        }\n        if\
    \ (file_name[i] == '.')\n        {\n            dot_count++;\n            dot_pos\
    \ = i;\n        }\n    }\n    if (count > 3 || dot_count != 1)\n    {\n      \
    \  result = \"No\";\n    }\n    else\n    {\n        sub1 = file_name[0..dot_pos];\n\
    \        sub2 = file_name[dot_pos + 1..$];\n        if (sub1.length == 0 || (sub1[0]\
    \ < 'a' || sub1[0] > 'z') && (sub1[0] < 'A' || sub1[0] > 'Z'))\n        {\n  \
    \          result = \"No\";\n        }\n        else\n        {\n            if\
    \ (sub2 != \"txt\" && sub2 != \"exe\" && sub2 != \"dll\")\n            {\n   \
    \             result = \"No\";\n            }\n            else\n            {\n\
    \                result = \"Yes\";\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr9ctryr8.d(25): Error: cannot implicitly convert expression `file_name.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpr9ctryr8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n \
    \   string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n\
    \    if (before_dot.length == 0 || !(before_dot[0] >= 'a' && before_dot[0] <=\
    \ 'z' || before_dot[0] >= 'A' && before_dot[0] <= 'Z'))\n        return \"No\"\
    ;\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\"\
    )\n        return \"No\";\n    int digit_count = 0;\n    foreach (c; before_dot)\n\
    \    {\n        if (c >= '0' && c <= '9')\n            digit_count++;\n    }\n\
    \    if (digit_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphxvy8x4c.d(22): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphxvy8x4c.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_split = file_name.split(\"\
    .\");\n    if (file_name_split.length != 2)\n        return \"No\";\n    if (file_name_split[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_split[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (!valid_extensions.contains(file_name_split[1]))\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3nyjcotx.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmp3nyjcotx.d(28): Error: no property `count` for type `string`\\n/tmp/tmp3nyjcotx.d(30):\
    \ Error: no property `contains` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp3nyjcotx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // your code\
    \ here\n    int dot_index = file_name.find(\".\");\n    if (dot_index == -1)\n\
    \        return \"No\";\n    string prefix = file_name[0..dot_index];\n    string\
    \ suffix = file_name[dot_index + 1..$];\n    if (prefix.length == 0 || !(prefix[0]\
    \ >= 'a' && prefix[0] <= 'z' || prefix[0] >= 'A' && prefix[0] <= 'Z'))\n     \
    \   return \"No\";\n    if (suffix != \"txt\" && suffix != \"exe\" && suffix !=\
    \ \"dll\")\n        return \"No\";\n    int count = 0;\n    foreach (c; prefix)\n\
    \    {\n        if (c >= '0' && c <= '9')\n            count++;\n    }\n    if\
    \ (count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n \
    \   alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqruef6v4.d(23): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqruef6v4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find(\".\");\n    string extension = file_name.substr(dot_index\
    \ + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n\
    \    foreach(char c; name)\n    {\n        if(isdigit(c))\n            digits++;\n\
    \    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\"\
    \ && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n \
    \   if(!isalpha(name[0]))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0k7ofv_d.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmp0k7ofv_d.d(23): Error: no property `substr` for type `string`\\n/tmp/tmp0k7ofv_d.d(24):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmp0k7ofv_d.d(28): Error:\
    \ undefined identifier `isdigit`\\n/tmp/tmp0k7ofv_d.d(35): Error: undefined identifier\
    \ `isalpha`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0k7ofv_d.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count\
    \ = 0;\n    int digit_count = 0;\n    bool is_valid = true;\n    foreach(char\
    \ c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n\
    \        }\n        else if(c >= '0' && c <= '9')\n        {\n            digit_count++;\n\
    \        }\n    }\n    if(dot_count != 1 || digit_count > 3)\n    {\n        is_valid\
    \ = false;\n    }\n    else\n    {\n        string[] file_name_parts = file_name.split(\"\
    .\");\n        if(file_name_parts.length != 2)\n        {\n            is_valid\
    \ = false;\n        }\n        else\n        {\n            string file_name_part\
    \ = file_name_parts[0];\n            string file_extension = file_name_parts[1];\n\
    \            if(file_name_part.length == 0 || !(file_name_part[0] >= 'a' && file_name_part[0]\
    \ <= 'z') && !(file_name_part[0] >= 'A' && file_name_part[0] <= 'Z'))\n      \
    \      {\n                is_valid = false;\n            }\n            else if(file_extension\
    \ != \"txt\" && file_extension != \"exe\" && file_extension != \"dll\")\n    \
    \        {\n                is_valid = false;\n            }\n        }\n    }\n\
    \    return is_valid ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpftywq5gk.d(42): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpftywq5gk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index+1);\n\
    \    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    for\
    \ (int i = 0; i < name.length; i++)\n    {\n        if (isdigit(name[i]))\n  \
    \          digits++;\n    }\n    if (digits > 3)\n        return \"No\";\n   \
    \ if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n\
    \        return \"No\";\n    if (name.length == 0)\n        return \"No\";\n \
    \   if (!isalpha(name[0]))\n        return \"No\";\n    return \"Yes\";\n}\n/*\n\
    Create a function which takes a string representing a file's name, and returns\n\
    \    the file's extension.\n    A file's extension is the substring after the\
    \ last dot '.' in the file's name.\n    If the file's name doesn't contain a dot,\
    \ the file's extension is an empty string.\n    Examples:\n    >>> file_extension(\"\
    example.txt\")\n    \"txt\"\n    >>> file_extension(\"example\")\n    \"\"\n*/\n\
    string file_extension(string file_name) \n{\n    int dot_index = file_name.find('.');\n\
    \    if (dot_index == -1)\n        return \"\";\n    return file_name.substr(dot_index+1);\n\
    }\n/*\nCreate a function which takes a string representing a file's name, and\
    \ returns\n    the file's name without its extension.\n    A file's extension\
    \ is the substring after the last dot '.' in the file's name.\n    If the file's\
    \ name doesn't contain a dot, the file's extension is an empty string.\n    Examples:\n\
    \    >>> file_name_without_extension(\"example.txt\")\n    \"example\"\n    >>>\
    \ file_name_without_extension(\"example\")\n    \"example\"\n*/\nstring file_name_without_extension(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn1nzy_db.d(74): Error: found `unittest` when expecting `)`\\\
    n/tmp/tmpn1nzy_db.d(105): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn1nzy_db.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    string extension = file_name[dot_index + 1 .. $];\n    string file_name_without_extension\
    \ = file_name[0 .. dot_index - 1];\n    int digits_count = 0;\n    foreach(char\
    \ c; file_name_without_extension)\n    {\n        if(c >= '0' && c <= '9')\n \
    \       {\n            digits_count++;\n        }\n    }\n    if(digits_count\
    \ > 3)\n    {\n        return \"No\";\n    }\n    if(file_name.count(\".\") !=\
    \ 1)\n    {\n        return \"No\";\n    }\n    if(file_name_without_extension.length\
    \ == 0)\n    {\n        return \"No\";\n    }\n    if(!(file_name_without_extension[0]\
    \ >= 'a' && file_name_without_extension[0] <= 'z') &&\n        !(file_name_without_extension[0]\
    \ >= 'A' && file_name_without_extension[0] <= 'Z'))\n    {\n        return \"\
    No\";\n    }\n    if(!valid_extensions.contains(extension))\n    {\n        return\
    \ \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0az9gt44.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmp0az9gt44.d(38): Error: no property `count` for type `string`\\n/tmp/tmp0az9gt44.d(51):\
    \ Error: no property `contains` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp0az9gt44.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_pos\
    \ = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n   \
    \ auto ext = file_name.substr(dot_pos + 1);\n    if (ext != \"txt\" && ext !=\
    \ \"exe\" && ext != \"dll\")\n        return \"No\";\n    auto name = file_name.substr(0,\
    \ dot_pos);\n    if (name.length == 0)\n        return \"No\";\n    if (name[0]\
    \ < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"\
    No\";\n    int count = 0;\n    for (auto c : name)\n        if (c >= '0' && c\
    \ <= '9')\n            count++;\n    if (count > 3)\n        return \"No\";\n\
    \    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppj0h22io.d(34): Error: no identifier for declarator `c`\\n/tmp/tmppj0h22io.d(34):\
    \ Error: expression expected, not `:`\\n/tmp/tmppj0h22io.d(34): Error: found `name`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppj0h22io.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbxgp34if.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmpbxgp34if.d(28): Error: no property `count` for type `string`\\n/tmp/tmpbxgp34if.d(30):\
    \ Error: no property `contains` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpbxgp34if.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_index = -1;\n    int dot_count = 0;\n    foreach(i, c; file_name)\n\
    \    {\n        if(c >= '0' && c <= '9')\n        {\n            count++;\n  \
    \      }\n        if(c == '.')\n        {\n            dot_index = i;\n      \
    \      dot_count++;\n        }\n    }\n    if(count > 3 || dot_count != 1)\n \
    \   {\n        return \"No\";\n    }\n    string sub_string = file_name[0..dot_index];\n\
    \    if(sub_string.length == 0 || !(sub_string[0] >= 'a' && sub_string[0] <= 'z'\
    \ || sub_string[0] >= 'A' && sub_string[0] <= 'Z'))\n    {\n        return \"\
    No\";\n    }\n    sub_string = file_name[dot_index+1..$];\n    if(sub_string !=\
    \ \"txt\" && sub_string != \"exe\" && sub_string != \"dll\")\n    {\n        return\
    \ \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzk8bf4ak.d(33): Error: cannot implicitly convert expression `i`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpzk8bf4ak.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_pos\
    \ = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n   \
    \ auto ext = file_name.substr(dot_pos + 1);\n    if (ext != \"txt\" && ext !=\
    \ \"exe\" && ext != \"dll\")\n        return \"No\";\n    auto name = file_name.substr(0,\
    \ dot_pos);\n    if (name.length == 0)\n        return \"No\";\n    if (!isAlpha(name[0]))\n\
    \        return \"No\";\n    if (name.count!(isDigit) > 3)\n        return \"\
    No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiatr5htl.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpiatr5htl.d(25): Error: no property `substr` for type `string`\\n/tmp/tmpiatr5htl.d(28):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmpiatr5htl.d(31): Error:\
    \ undefined identifier `isAlpha`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpiatr5htl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = split(file_name,\
    \ \".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if\
    \ (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"\
    0\", \"9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a'\
    \ || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (file_name_parts[1]\
    \ !in valid_extensions)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptk8izxuy.d(23): Error: undefined identifier `split`\\n/tmp/tmptk8izxuy.d(28):\
    \ Error: no property `count` for type `string`\\n/tmp/tmptk8izxuy.d(32): Error:\
    \ incompatible types for `(file_name_parts[1]) in (valid_extensions)`: `string`\
    \ and `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptk8izxuy.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find(\".\");\n    string ext = file_name.substr(dot_pos+1);\n  \
    \  string name = file_name.substr(0, dot_pos);\n    int count = 0;\n    foreach(char\
    \ c; name)\n    {\n        if(c >= '0' && c <= '9')\n            count++;\n  \
    \  }\n    if(count > 3)\n        return \"No\";\n    if(ext != \"txt\" && ext\
    \ != \"exe\" && ext != \"dll\")\n        return \"No\";\n    if(name.length ==\
    \ 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0]\
    \ >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjpa8yh4g.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpjpa8yh4g.d(23): Error: no property `substr` for type `string`\\n/tmp/tmpjpa8yh4g.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpjpa8yh4g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int len = file_name.length;\n\
    \    string sub_string_before_dot = \"\";\n    string sub_string_after_dot = \"\
    \";\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    for (int\
    \ i = 0; i < len; i++)\n    {\n        if (file_name[i] >= '0' && file_name[i]\
    \ <= '9')\n        {\n            count++;\n        }\n        if (file_name[i]\
    \ == '.')\n        {\n            dot_count++;\n            dot_index = i;\n \
    \       }\n    }\n    if (count > 3 || dot_count != 1)\n    {\n        return\
    \ \"No\";\n    }\n    sub_string_before_dot = file_name[0..dot_index];\n    sub_string_after_dot\
    \ = file_name[dot_index+1..$];\n    if (sub_string_before_dot == \"\" || (sub_string_before_dot[0]\
    \ < 'a' || sub_string_before_dot[0] > 'z') && (sub_string_before_dot[0] < 'A'\
    \ || sub_string_before_dot[0] > 'Z'))\n    {\n        return \"No\";\n    }\n\
    \    if (valid_extensions.find(sub_string_after_dot) == -1)\n    {\n        return\
    \ \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_cwcfjfr.d(25): Error: cannot implicitly convert expression `file_name.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp_cwcfjfr.d(51): Error: no property `find`\
    \ for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_cwcfjfr.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index +\
    \ 1);\n    string name = file_name.substr(0, dot_index);\n    int count = 0;\n\
    \    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n        \
    \    count++;\n    }\n    if(count > 3)\n        return \"No\";\n    if(extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return\
    \ \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(name[0] <\
    \ 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\"\
    ;\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkqrood38.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpkqrood38.d(23): Error: no property `substr` for type `string`\\n/tmp/tmpkqrood38.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpkqrood38.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index +\
    \ 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n\
    \    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n        \
    \    digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return\
    \ \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(name[0] <\
    \ 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\"\
    ;\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjfjz4vpc.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpjfjz4vpc.d(23): Error: no property `substr` for type `string`\\n/tmp/tmpjfjz4vpc.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpjfjz4vpc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n \
    \   string ext = file_name.substr(dot_index + 1);\n    if (ext != \"txt\" && ext\
    \ != \"exe\" && ext != \"dll\")\n        return \"No\";\n    string name = file_name.substr(0,\
    \ dot_index);\n    if (name.length == 0)\n        return \"No\";\n    int digits\
    \ = 0;\n    foreach (c; name)\n    {\n        if (c >= '0' && c <= '9')\n    \
    \        digits++;\n        else if (!(c >= 'a' && c <= 'z') && !(c >= 'A' &&\
    \ c <= 'Z'))\n            return \"No\";\n    }\n    if (digits > 3)\n       \
    \ return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps6yymooc.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmps6yymooc.d(25): Error: no property `substr` for type `string`\\n/tmp/tmps6yymooc.d(28):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmps6yymooc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (file_name_parts[1] !in valid_extensions)\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpahe7c1pj.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmpahe7c1pj.d(28): Error: no property `count` for type `string`\\n/tmp/tmpahe7c1pj.d(32):\
    \ Error: incompatible types for `(file_name_parts[1]) in (valid_extensions)`:\
    \ `string` and `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpahe7c1pj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int dot_index_2 = 0;\n\
    \    int dot_index_3 = 0;\n    int dot_index_4 = 0;\n    int dot_index_5 = 0;\n\
    \    int dot_index_6 = 0;\n    int dot_index_7 = 0;\n    int dot_index_8 = 0;\n\
    \    int dot_index_9 = 0;\n    int dot_index_10 = 0;\n    int dot_index_11 = 0;\n\
    \    int dot_index_12 = 0;\n    int dot_index_13 = 0;\n    int dot_index_14 =\
    \ 0;\n    int dot_index_15 = 0;\n    int dot_index_16 = 0;\n    int dot_index_17\
    \ = 0;\n    int dot_index_18 = 0;\n    int dot_index_19 = 0;\n    int dot_index_20\
    \ = 0;\n    int dot_index_21 = 0;\n    int dot_index_22 = 0;\n    int dot_index_23\
    \ = 0;\n    int dot_index_24 = 0;\n    int dot_index_25 = 0;\n    int dot_index_26\
    \ = 0;\n    int dot_index_27 = 0;\n    int dot_index_28 = 0;\n    int dot_index_29\
    \ = 0;\n    int dot_index_30 = 0;\n    int dot_index_31 = 0;\n    int dot_index_32\
    \ = 0;\n    int dot_index_33 = 0;\n    int dot_index_34 = 0;\n    int dot_index_35\
    \ = 0;\n    int dot_index_36 = 0;\n    int dot_index_37 = 0;\n    int dot_index_38\
    \ = 0;\n    int dot_index_39 = 0;\n    int dot_index_40 = 0;\n    int dot_index_41\
    \ = 0;\n    int dot_index_42 = 0;\n    int dot_index_43 = 0;\n    int dot_index_44\
    \ = 0;\n    int dot_index_45 = 0;\n\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp271nyjzd.d(70): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp271nyjzd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index+1);\n\
    \    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(char\
    \ c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n \
    \   }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\"\
    \ && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n \
    \   if(name.length == 0)\n        return \"No\";\n    if(name[0] < 'a' || name[0]\
    \ > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp77jyh4h8.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmp77jyh4h8.d(23): Error: no property `substr` for type `string`\\n/tmp/tmp77jyh4h8.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp77jyh4h8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count\
    \ = 0;\n    int digit_count = 0;\n    int dot_index = 0;\n    int file_name_length\
    \ = file_name.length;\n    int i = 0;\n    string extension = \"\";\n    string\
    \ valid_extensions[] = [\"txt\", \"exe\", \"dll\"];\n    string valid_extensions_length\
    \ = valid_extensions.length;\n    string valid_extensions_index = 0;\n    string\
    \ valid_extension = \"\";\n    string valid_extension_length = 0;\n    string\
    \ valid_extension_index = 0;\n    string valid_extension_found = \"No\";\n   \
    \ string valid_extension_found_index = 0;\n    string valid_extension_found_length\
    \ = 0;\n    string valid_extension_found_char = \"\";\n    string valid_extension_found_char_index\
    \ = 0;\n    string valid_extension_found_char_length = 0;\n    string valid_extension_found_char_found\
    \ = \"No\";\n    string valid_extension_found_char_found_index = 0;\n    string\
    \ valid_extension_found_char_found_length = 0;\n    string valid_extension_found_char_found_char\
    \ = \"\";\n    string valid_extension_found_char_found_char_index = 0;\n    string\
    \ valid_extension_found_char_found_char_length = 0;\n    string valid_extension_found_char_found_char_found\
    \ = \"No\";\n    string valid_extension_found_char_found_char_found_index = 0;\n\
    \    string valid_extension_found_char_found_char_found_length = 0;\n    string\
    \ valid_extension_found_char_found_char_found_char = \"\";\n    string valid_extension_found_char_found_char_found_char_index\
    \ = 0;\n    string valid_extension_found_char_found_char_found_char_length = 0;\n\
    \    string valid_extension_found_char_found_char_found_char_found = \"No\";\n\
    \    string valid_extension_found_char_found_\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp963_oy27.d(28): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `string[] valid_extensions`\\n/tmp/tmp963_oy27.d(53): Error: found `valid_extension_found_char_found_`\
    \ when expecting `;` following statement\\n/tmp/tmp963_oy27.d(54): Error: found\
    \ `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp963_oy27.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    bool valid = true;\n    if (file_name.length < 5)\n        return \"\
    No\";\n    foreach(c; file_name)\n    {\n        if (c == '.')\n            count++;\n\
    \        if (count > 1)\n            return \"No\";\n    }\n    if (count == 0)\n\
    \        return \"No\";\n    int dot_index = file_name.indexOf('.');\n    string\
    \ sub_str = file_name[0..dot_index];\n    if (sub_str.length == 0)\n        return\
    \ \"No\";\n    foreach(c; sub_str)\n    {\n        if (c >= '0' && c <= '9')\n\
    \            valid = false;\n    }\n    if (!valid)\n        return \"No\";\n\
    \    sub_str = file_name[dot_index+1..$];\n    if (sub_str != \"txt\" && sub_str\
    \ != \"exe\" && sub_str != \"dll\")\n        return \"No\";\n    return \"Yes\"\
    ;\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyta0rdju.d(35): Error: no property `indexOf` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyta0rdju.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n\
    \    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(c.isDigit)\n\
    \            digits_count++;\n    }\n    if(digits_count > 3)\n        return\
    \ \"No\";\n    if(extension !in valid_extensions)\n        return \"No\";\n  \
    \  if(name.length == 0)\n        return \"No\";\n    if(!name[0].isLetter)\n \
    \       return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv5txyzti.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpv5txyzti.d(29): Error: no property `isDigit` for type `immutable(char)`\\\
    n/tmp/tmpv5txyzti.d(34): Error: incompatible types for `(extension) in (valid_extensions)`:\
    \ `string` and `string[]`\\n/tmp/tmpv5txyzti.d(38): Error: no property `isLetter`\
    \ for type `immutable(char)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpv5txyzti.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index +\
    \ 1);\n    string name = file_name.substr(0, dot_index);\n    int count = 0;\n\
    \    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n        \
    \    count++;\n    }\n    if(count > 3)\n        return \"No\";\n    if(name.length\
    \ == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') &&\
    \ !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    if(extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7gsnjvk4.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmp7gsnjvk4.d(23): Error: no property `substr` for type `string`\\n/tmp/tmp7gsnjvk4.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp7gsnjvk4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos\
    \ = file_name.find('.');\n    string ext = file_name.substr(dot_pos + 1);\n  \
    \  string name = file_name.substr(0, dot_pos);\n    if (ext != \"txt\" && ext\
    \ != \"exe\" && ext != \"dll\")\n        return \"No\";\n    if (name.length ==\
    \ 0)\n        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0]\
    \ < 'A' || name[0] > 'Z')\n        return \"No\";\n    int digits = 0;\n    foreach\
    \ (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            digits++;\n\
    \    }\n    if (digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7rqbbtj0.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmp7rqbbtj0.d(23): Error: no property `substr` for type `string`\\n/tmp/tmp7rqbbtj0.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp7rqbbtj0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_split = file_name.split(\"\
    .\");\n    string file_name_extension = file_name_split[1];\n    string file_name_no_extension\
    \ = file_name_split[0];\n    int digits_count = 0;\n    foreach(char c; file_name_no_extension)\n\
    \    {\n        if(c >= '0' && c <= '9')\n        {\n            digits_count++;\n\
    \        }\n    }\n    if(digits_count > 3)\n    {\n        return \"No\";\n \
    \   }\n    if(!(file_name_no_extension[0] >= 'a' && file_name_no_extension[0]\
    \ <= 'z') && !(file_name_no_extension[0] >= 'A' && file_name_no_extension[0] <=\
    \ 'Z'))\n    {\n        return \"No\";\n    }\n    if(file_name_extension != valid_extensions[0]\
    \ && file_name_extension != valid_extensions[1] && file_name_extension != valid_extensions[2])\n\
    \    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n \
    \   alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe7dh8b2y.d(23): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe7dh8b2y.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // Your code\
    \ here\n    //return \"Yes\";\n    int dot_count = 0;\n    int digit_count = 0;\n\
    \    int file_name_length = file_name.length;\n    foreach(i; 0..file_name_length)\n\
    \    {\n        if(file_name[i] == '.')\n        {\n            dot_count++;\n\
    \        }\n        if(file_name[i] >= '0' && file_name[i] <= '9')\n        {\n\
    \            digit_count++;\n        }\n    }\n    if(digit_count > 3)\n    {\n\
    \        return \"No\";\n    }\n    if(dot_count != 1)\n    {\n        return\
    \ \"No\";\n    }\n    int dot_index = file_name.indexOf('.');\n    string file_name_before_dot\
    \ = file_name[0..dot_index];\n    string file_name_after_dot = file_name[dot_index+1..$];\n\
    \    if(file_name_before_dot.length == 0)\n    {\n        return \"No\";\n   \
    \ }\n    if(file_name_before_dot[0] < 'a' || file_name_before_dot[0] > 'z')\n\
    \    {\n        if(file_name_before_dot[0] < 'A' || file_name_before_dot[0] >\
    \ 'Z')\n        {\n            return \"No\";\n        }\n    }\n    if(file_name_after_dot\
    \ != \"txt\" && file_name_after_dot != \"exe\" && file_name_after_dot != \"dll\"\
    )\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n\
    \    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpocakah1a.d(26): Error: cannot implicitly convert expression `file_name.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpocakah1a.d(46): Error: no property `indexOf`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpocakah1a.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\"\
    .\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n\
    \        return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmply92agzb.d(23): Error: no property `split` for type `string`\\\
    n/tmp/tmply92agzb.d(28): Error: no property `count` for type `string`\\n/tmp/tmply92agzb.d(30):\
    \ Error: no property `contains` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmply92agzb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // Your code\
    \ goes here\n    int count = 0;\n    int dot_count = 0;\n    int dot_index = 0;\n\
    \    int i = 0;\n    int j = 0;\n    string sub_string = \"\";\n    string sub_string2\
    \ = \"\";\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    foreach(char\
    \ c; file_name)\n    {\n        if(c >= '0' && c <= '9')\n        {\n        \
    \    count++;\n        }\n        if(c == '.')\n        {\n            dot_count++;\n\
    \            dot_index = i;\n        }\n        i++;\n    }\n    if(count > 3\
    \ || dot_count != 1)\n    {\n        return \"No\";\n    }\n    sub_string = file_name[0..dot_index];\n\
    \    sub_string2 = file_name[dot_index+1..$];\n    if(sub_string.length == 0 ||\
    \ (sub_string[0] < 'a' || sub_string[0] > 'z') && (sub_string[0] < 'A' || sub_string[0]\
    \ > 'Z'))\n    {\n        return \"No\";\n    }\n    foreach(string s; valid_extensions)\n\
    \    {\n        if(s == sub_string2)\n        {\n            return \"Yes\";\n\
    \        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // TODO: Implement\
    \ this function\n    //return \"No\";\n    //return \"Yes\";\n    //return \"\"\
    ;\n    //return \"example.txt\";\n    //return \"1example.dll\";\n    //return\
    \ \"example.txt\";\n    //return \"example.txt\";\n    //return \"example.txt\"\
    ;\n    //return \"example.txt\";\n    //return \"example.txt\";\n    //return\
    \ \"example.txt\";\n    //return \"example.txt\";\n    //return \"example.txt\"\
    ;\n    //return \"example.txt\";\n    //return \"example.txt\";\n    //return\
    \ \"example.txt\";\n    //return \"example.txt\";\n    //return \"example.txt\"\
    ;\n    //return \"example.txt\";\n    //return \"example.txt\";\n    //return\
    \ \"example.txt\";\n    //return \"example.txt\";\n    //return \"example.txt\"\
    ;\n    //return \"example.txt\";\n    //return \"example.txt\";\n    //return\
    \ \"example.txt\";\n    //return \"example.txt\";\n    //return \"example.txt\"\
    ;\n    //return \"example.txt\";\n    //return \"example.txt\";\n    //return\
    \ \"example.txt\";\n    //return \"example.txt\";\n    //return \"example.txt\"\
    ;\n    //return \"example.txt\";\n    //return \"example.txt\";\n    //return\
    \ \"example.txt\";\n    //return \"example.txt\";\n    //return \"example.txt\"\
    ;\n    //return \"example.txt\";\n    //return \"example.txt\";\n    //return\
    \ \"example.txt\";\n    //return \"example.txt\";\n    //return \"example.txt\"\
    ;\n    //return \"example.txt\";\n    //return \"example.txt\";\n    //return\
    \ \"example.txt\";\n    //return \"example.txt\";\n    //return \"example.txt\"\
    ;\n    //return \"example.txt\";\n    //return \"example.txt\";\n    //return\
    \ \"example.txt\";\n    //return \"example.txt\";\n    //return \"example.txt\"\
    ;\n    //return \"example.txt\";\n    //return \"example.txt\";\n    //return\
    \ \"example.txt\";\n    //\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuys7gg81.d(80): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuys7gg81.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.indexOf('.');\n\
    \    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name.substr(dot_index\
    \ + 1);\n    if (valid_extensions.indexOf(extension) == -1)\n        return \"\
    No\";\n    string name = file_name.substr(0, dot_index);\n    if (name.length\
    \ == 0)\n        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0]\
    \ < 'A' || name[0] > 'Z')\n        return \"No\";\n    int digits_count = 0;\n\
    \    foreach (c; name)\n    {\n        if (c >= '0' && c <= '9')\n           \
    \ digits_count++;\n    }\n    if (digits_count > 3)\n        return \"No\";\n\
    \    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpodt7u9hr.d(23): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmpodt7u9hr.d(26): Error: no property `substr` for type `string`\\n/tmp/tmpodt7u9hr.d(27):\
    \ Error: no property `indexOf` for type `string[]`\\n/tmp/tmpodt7u9hr.d(29): Error:\
    \ no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpodt7u9hr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index\
    \ + 1 .. $];\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n\
    \        return \"No\";\n    string name = file_name[0 .. dot_index];\n    if\
    \ (name.length == 0)\n        return \"No\";\n    int count = 0;\n    foreach\
    \ (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            count++;\n\
    \    }\n    if (count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp87owo0q3.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmp87owo0q3.d(27): Error: no property `canFind` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp87owo0q3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = split(file_name,\
    \ \".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if\
    \ (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"\
    0\", \"9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a'\
    \ || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.indexOf(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0h64wvkn.d(23): Error: undefined identifier `split`\\n/tmp/tmp0h64wvkn.d(28):\
    \ Error: no property `count` for type `string`\\n/tmp/tmp0h64wvkn.d(32): Error:\
    \ no property `indexOf` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp0h64wvkn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n\
    \    string extension = file_name[dot_index + 1 .. $];\n    string name = file_name[0\
    \ .. dot_index - 1];\n    int digit_count = 0;\n    foreach(c; name)\n    {\n\
    \        if(c >= '0' && c <= '9')\n        {\n            digit_count++;\n   \
    \     }\n    }\n    if(digit_count > 3)\n    {\n        return \"No\";\n    }\n\
    \    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <=\
    \ 'Z'))\n    {\n        return \"No\";\n    }\n    if(!valid_extensions.canFind(extension))\n\
    \    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n \
    \   alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfktnup1t.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpfktnup1t.d(42): Error: no property `canFind` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfktnup1t.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count\
    \ = 0;\n    int digit_count = 0;\n    int dot_index = 0;\n    int file_name_length\
    \ = file_name.length;\n    string file_extension = \"\";\n    string valid_extensions[]\
    \ = [\"txt\", \"exe\", \"dll\"];\n    bool is_valid = true;\n    for (int i =\
    \ 0; i < file_name_length; i++)\n    {\n        if (file_name[i] == '.')\n   \
    \     {\n            dot_count++;\n            dot_index = i;\n        }\n   \
    \     else if (file_name[i] >= '0' && file_name[i] <= '9')\n        {\n      \
    \      digit_count++;\n        }\n    }\n    if (dot_count != 1 || digit_count\
    \ > 3)\n    {\n        is_valid = false;\n    }\n    else\n    {\n        file_extension\
    \ = file_name[dot_index+1..file_name_length];\n        if (file_extension.length\
    \ == 0 || !(file_name[0] >= 'a' && file_name[0] <= 'z' || file_name[0] >= 'A'\
    \ && file_name[0] <= 'Z'))\n        {\n            is_valid = false;\n       \
    \ }\n        else\n        {\n            for (int i = 0; i < valid_extensions.length;\
    \ i++)\n            {\n                if (file_extension == valid_extensions[i])\n\
    \                {\n                    is_valid = true;\n                   \
    \ break;\n                }\n                else\n                {\n       \
    \             is_valid = false;\n                }\n            }\n        }\n\
    \    }\n    if (is_valid)\n    {\n        return \"Yes\";\n    }\n    else\n \
    \   {\n        return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmi8ugaaf.d(27): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `string[] valid_extensions`\\n/tmp/tmpmi8ugaaf.d(25): Error: cannot implicitly\
    \ convert expression `file_name.length` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmi8ugaaf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    bool valid = true;\n    foreach(char c; file_name)\n\
    \    {\n        if(c == '.')\n        {\n            dot_count++;\n        }\n\
    \        if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n\
    \    }\n    if(count > 3 || dot_count != 1)\n    {\n        valid = false;\n \
    \   }\n    else\n    {\n        int dot_index = file_name.indexOf('.');\n    \
    \    string sub_string = file_name[0..dot_index];\n        if(sub_string.length\
    \ == 0 || !(sub_string[0] >= 'a' && sub_string[0] <= 'z') && !(sub_string[0] >=\
    \ 'A' && sub_string[0] <= 'Z'))\n        {\n            valid = false;\n     \
    \   }\n        else\n        {\n            sub_string = file_name[dot_index+1..$];\n\
    \            if(sub_string != \"txt\" && sub_string != \"exe\" && sub_string !=\
    \ \"dll\")\n            {\n                valid = false;\n            }\n   \
    \     }\n    }\n    if(valid)\n    {\n        return \"Yes\";\n    }\n    else\n\
    \    {\n        return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3alk03vk.d(42): Error: no property `indexOf` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3alk03vk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find(\".\");\n    string extension = file_name.substr(dot_index+1);\n\
    \    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(c;\
    \ name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n\
    \    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension\
    \ != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length\
    \ == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') &&\
    \ !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"\
    Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptom7qz51.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmptom7qz51.d(23): Error: no property `substr` for type `string`\\n/tmp/tmptom7qz51.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmptom7qz51.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = split(file_name,\
    \ \".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if\
    \ (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ - count(file_name_parts[0], \"0\", \"9\") > 3)\n        return \"No\";\n   \
    \ if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z' && file_name_parts[0][0]\
    \ < 'A' || file_name_parts[0][0] > 'Z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5880u5c7.d(23): Error: undefined identifier `split`\\n/tmp/tmp5880u5c7.d(28):\
    \ Error: undefined identifier `count`\\n/tmp/tmp5880u5c7.d(32): Error: no property\
    \ `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp5880u5c7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count\
    \ = 0;\n    int digit_count = 0;\n    bool is_valid = true;\n    foreach(c; file_name)\n\
    \    {\n        if(c == '.')\n        {\n            dot_count++;\n        }\n\
    \        else if(c >= '0' && c <= '9')\n        {\n            digit_count++;\n\
    \        }\n    }\n    if(dot_count != 1 || digit_count > 3)\n    {\n        is_valid\
    \ = false;\n    }\n    else\n    {\n        auto dot_index = file_name.indexOf('.');\n\
    \        auto prefix = file_name[0..dot_index];\n        auto suffix = file_name[dot_index+1..$];\n\
    \        if(prefix.length == 0 || !(prefix[0] >= 'a' && prefix[0] <= 'z' || prefix[0]\
    \ >= 'A' && prefix[0] <= 'Z'))\n        {\n            is_valid = false;\n   \
    \     }\n        else if(suffix != \"txt\" && suffix != \"exe\" && suffix != \"\
    dll\")\n        {\n            is_valid = false;\n        }\n    }\n    return\
    \ is_valid ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxatj50gb.d(42): Error: no property `indexOf` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxatj50gb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n \
    \   if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index+1..$];\n\
    \    if (!valid_extensions.canFind(extension))\n        return \"No\";\n    string\
    \ name = file_name[0..dot_index-1];\n    if (name.length == 0)\n        return\
    \ \"No\";\n    if (!isAlpha(name[0]))\n        return \"No\";\n    int count =\
    \ 0;\n    foreach (c; name)\n    {\n        if (isDigit(c))\n            count++;\n\
    \    }\n    if (count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpria8rfws.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmpria8rfws.d(27): Error: no property `canFind` for type `string[]`\\n/tmp/tmpria8rfws.d(32):\
    \ Error: undefined identifier `isAlpha`\\n/tmp/tmpria8rfws.d(37): Error: undefined\
    \ identifier `isDigit`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpria8rfws.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_index +\
    \ 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n\
    \    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n\
    \    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\"\
    \ && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n \
    \   if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0]\
    \ <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n  \
    \  return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpapx6ezm2.d(22): Error: no property `find` for type `string`\\\
    n/tmp/tmpapx6ezm2.d(23): Error: no property `substr` for type `string`\\n/tmp/tmpapx6ezm2.d(24):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpapx6ezm2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.indexOf('.');\n\
    \    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0,\
    \ dot_index);\n    int digits_count = 0;\n    foreach(char c; name)\n    {\n \
    \       if (c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if\
    \ (digits_count > 3 || dot_index == -1 || name.length == 0 || !(name[0] >= 'a'\
    \ && name[0] <= 'z' || name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\"\
    ;\n    foreach(string ext; valid_extensions)\n    {\n        if (ext == extension)\n\
    \            return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn2sn0do8.d(23): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmpn2sn0do8.d(24): Error: no property `substr` for type `string`\\n/tmp/tmpn2sn0do8.d(25):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpn2sn0do8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_pos\
    \ = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n   \
    \ auto before_dot = file_name[0..dot_pos];\n    auto after_dot = file_name[dot_pos+1..$];\n\
    \    if (before_dot.length == 0 || before_dot.length > 8)\n        return \"No\"\
    ;\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\"\
    )\n        return \"No\";\n    if (before_dot.count!(c => c >= '0' && c <= '9')\
    \ > 3)\n        return \"No\";\n    if (!(before_dot[0] >= 'a' && before_dot[0]\
    \ <= 'z' || before_dot[0] >= 'A' && before_dot[0] <= 'Z'))\n        return \"\
    No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxzzk1krs.d(22): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxzzk1krs.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
