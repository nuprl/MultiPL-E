name: HumanEval_11_string_xor
language: d
results:
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_h6j2jos.d(16): Error: slice `result` is not mutable\\n/tmp/tmp_h6j2jos.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp_h6j2jos.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    foreach(i, c;\
    \ a)\n    {\n        res ~= (c ^ b[i]);\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpo86jm68m.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpo86jm68m.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpo86jm68m.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0xc2d14554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb1ai_ixt.d(16): Error: slice `result` is not mutable\\n/tmp/tmpb1ai_ixt.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpb1ai_ixt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i])\n            result\
    \ += \"0\";\n        else\n            result += \"1\";\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnrowq5ge.d(15): Error: slice `result` is not mutable\\n/tmp/tmpnrowq5ge.d(17):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpnrowq5ge.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        if(c == b[i])\n            result ~= \"0\";\n        else\n\
    \            result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb82xne8b.d(16): Error: slice `result` is not mutable\\n/tmp/tmpb82xne8b.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpb82xne8b.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa6isq__d.d(16): Error: slice `result` is not mutable\\n/tmp/tmpa6isq__d.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpa6isq__d.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm9drd8el.d(16): Error: slice `result` is not mutable\\n/tmp/tmpm9drd8el.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpm9drd8el.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp57w3ih84.d(16): Error: slice `result` is not mutable\\n/tmp/tmp57w3ih84.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp57w3ih84.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    foreach(i, c;\
    \ a)\n    {\n        res ~= (c ^ b[i]);\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprnc0x320.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmprnc0x320.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmprnc0x320.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0xd712a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6v5_nypq.d(16): Error: slice `result` is not mutable\\n/tmp/tmp6v5_nypq.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp6v5_nypq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkdg3tflv.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpkdg3tflv.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpkdg3tflv.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x25070554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    for (int i = 0;\
    \ i < a.length; i++)\n    {\n        result ~= (a[i] ^ b[i]);\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpeabf2c1y.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmpeabf2c1y.__unittest_L18_C1()\
    \ [0x427ba5]\\n??:? void tmpeabf2c1y.__modtest() [0x427d18]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d2b]\\\
    n??:? __libc_start_main [0x6800c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ char; a)\n    {\n        result ~= (a[i] ^ b[i]).to!string;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7i5vh5px.d(12): Error: no identifier for declarator `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7i5vh5px.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        if(c == b[i])\n            result ~= \"0\";\n        else\n  \
    \          result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp585skb3y.d(16): Error: slice `result` is not mutable\\n/tmp/tmp585skb3y.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp585skb3y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3xu_a2gb.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmp3xu_a2gb.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmp3xu_a2gb.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x995c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpie_noo36.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpie_noo36.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpie_noo36.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0xd8167554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    foreach(i, c;\
    \ a)\n    {\n        res ~= (c ^ b[i]);\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpv8mq6wbc.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpv8mq6wbc.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpv8mq6wbc.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0xd7508554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(int\
    \ i, char c; a)\n    {\n        result ~= (c == b[i]) ? '0' : '1';\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i])\n            result\
    \ += \"0\";\n        else\n            result += \"1\";\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpljiaejgz.d(15): Error: slice `result` is not mutable\\n/tmp/tmpljiaejgz.d(17):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpljiaejgz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5mymytnc.d(16): Error: slice `result` is not mutable\\n/tmp/tmp5mymytnc.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp5mymytnc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result += (a[i] == b[i]) ? \"0\" :\
    \ \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp92czbjzw.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp92czbjzw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n            res +=\
    \ \"0\";\n        else\n            res += \"1\";\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu9u81um1.d(15): Error: slice `res` is not mutable\\n/tmp/tmpu9u81um1.d(17):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpu9u81um1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnaics0wp.d(16): Error: slice `result` is not mutable\\n/tmp/tmpnaics0wp.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpnaics0wp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph73hu5a9.d(16): Error: slice `result` is not mutable\\n/tmp/tmph73hu5a9.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmph73hu5a9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzwshqf6z.d(16): Error: slice `result` is not mutable\\n/tmp/tmpzwshqf6z.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpzwshqf6z.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphe1t86s1.d(16): Error: slice `result` is not mutable\\n/tmp/tmphe1t86s1.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmphe1t86s1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result += (a[i] == b[i]) ? \"0\" :\
    \ \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp631hc7qs.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp631hc7qs.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl_2b7492.d(16): Error: slice `result` is not mutable\\n/tmp/tmpl_2b7492.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpl_2b7492.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        }\n        else \n        {\n          \
    \  result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp22la6huq.d(16): Error: slice `result` is not mutable\\n/tmp/tmp22la6huq.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp22la6huq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_tn2an26.d(16): Error: slice `result` is not mutable\\n/tmp/tmp_tn2an26.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp_tn2an26.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n            res +=\
    \ \"0\";\n        else\n            res += \"1\";\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu8knzs03.d(15): Error: slice `res` is not mutable\\n/tmp/tmpu8knzs03.d(17):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpu8knzs03.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp951rdzm9.d(16): Error: slice `result` is not mutable\\n/tmp/tmp951rdzm9.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp951rdzm9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a) \n    {\n        result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5gsdmez4.d(16): Error: slice `result` is not mutable\\n/tmp/tmp5gsdmez4.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp5gsdmez4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2z5zr9ad.d(16): Error: slice `result` is not mutable\\n/tmp/tmp2z5zr9ad.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp2z5zr9ad.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(int\
    \ i, char c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkek5h37r.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f9d]\\n??:? void tmpkek5h37r.__unittest_L18_C1()\
    \ [0x427ba9]\\n??:? void tmpkek5h37r.__modtest() [0x427d1c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c6a7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5b6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff8d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43043c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff19]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b58d]\\n??:? runModuleUnitTests [0x42c47d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428460]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283e7]\\n??:? _d_run_main [0x428352]\\n??:? main [0x427d2f]\\\
    n??:? __libc_start_main [0x12325554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpls60ab6p.d(16): Error: slice `result` is not mutable\\n/tmp/tmpls60ab6p.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpls60ab6p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(int\
    \ i, char c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpfi5zlebf.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f9d]\\n??:? void tmpfi5zlebf.__unittest_L18_C1()\
    \ [0x427ba9]\\n??:? void tmpfi5zlebf.__modtest() [0x427d1c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c6a7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5b6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff8d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43043c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff19]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b58d]\\n??:? runModuleUnitTests [0x42c47d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428460]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283e7]\\n??:? _d_run_main [0x428352]\\n??:? main [0x427d2f]\\\
    n??:? __libc_start_main [0xfd8c5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n            res +=\
    \ \"0\";\n        else\n            res += \"1\";\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsvs9sssh.d(15): Error: slice `res` is not mutable\\n/tmp/tmpsvs9sssh.d(17):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpsvs9sssh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp103ecl9p.d(16): Error: slice `result` is not mutable\\n/tmp/tmp103ecl9p.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp103ecl9p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        if(c == b[i])\n            result ~= \"0\";\n        else\n\
    \            result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqz71l_md.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmpqz71l_md.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmpqz71l_md.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0xc139f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmbqv8i11.d(16): Error: slice `result` is not mutable\\n/tmp/tmpmbqv8i11.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpmbqv8i11.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3gjaidgu.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmp3gjaidgu.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmp3gjaidgu.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x7b902554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result += (a[i] == b[i]) ? \"0\" :\
    \ \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptqh6mh_h.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptqh6mh_h.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++)\n    {\n        res += (a[i] == b[i]) ? \"0\" : \"1\"\
    ;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4bl34xdm.d(14): Error: slice `res` is not mutable\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4bl34xdm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphuokwxv4.d(16): Error: slice `result` is not mutable\\n/tmp/tmphuokwxv4.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmphuokwxv4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n            res +=\
    \ \"0\";\n        else\n            res += \"1\";\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2wtc4jor.d(15): Error: slice `res` is not mutable\\n/tmp/tmp2wtc4jor.d(17):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp2wtc4jor.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpptj2ptah.d(16): Error: slice `result` is not mutable\\n/tmp/tmpptj2ptah.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpptj2ptah.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa1d0nhug.d(16): Error: slice `result` is not mutable\\n/tmp/tmpa1d0nhug.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpa1d0nhug.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgi_b39d2.d(16): Error: slice `result` is not mutable\\n/tmp/tmpgi_b39d2.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpgi_b39d2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_9_va1ib.d(16): Error: slice `result` is not mutable\\n/tmp/tmp_9_va1ib.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp_9_va1ib.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdx4uwa08.d(16): Error: slice `result` is not mutable\\n/tmp/tmpdx4uwa08.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpdx4uwa08.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkgvtt_7_.d(16): Error: slice `result` is not mutable\\n/tmp/tmpkgvtt_7_.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpkgvtt_7_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    for (int i = 0;\
    \ i < a.length; i++)\n    {\n        if (a[i] == b[i])\n            result ~=\
    \ \"0\";\n        else\n            result ~= \"1\";\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n     \
    \       res += \"0\";\n        } \n        else \n        {\n            res +=\
    \ \"1\";\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2abxiimc.d(16): Error: slice `res` is not mutable\\n/tmp/tmp2abxiimc.d(20):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp2abxiimc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0odjlz8a.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmp0odjlz8a.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmp0odjlz8a.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x88344554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result ~= (a[i] ^ b[i]);\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n   \
    \ assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphr5dz9tb.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f8d]\\n??:? void tmphr5dz9tb.__unittest_L18_C1()\
    \ [0x427b99]\\n??:? void tmphr5dz9tb.__modtest() [0x427d0c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c697]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5a6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff7d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43042c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff09]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b57d]\\n??:? runModuleUnitTests [0x42c46d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428450]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283d7]\\n??:? _d_run_main [0x428342]\\n??:? main [0x427d1f]\\\
    n??:? __libc_start_main [0x80397554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppwxyvx07.d(16): Error: slice `result` is not mutable\\n/tmp/tmppwxyvx07.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmppwxyvx07.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpa6kh7jrg.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpa6kh7jrg.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpa6kh7jrg.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0xa27b8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        if(c == b[i])\n            result ~= \"0\";\n        else\n  \
    \          result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptebfceba.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmptebfceba.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmptebfceba.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0xa4a69554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5zaws0zt.d(16): Error: slice `result` is not mutable\\n/tmp/tmp5zaws0zt.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp5zaws0zt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        if(c == b[i])\n            result ~= \"0\";\n        else\n  \
    \          result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0gdhah54.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmp0gdhah54.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmp0gdhah54.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x2e444554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n            res +=\
    \ \"0\";\n        else\n            res += \"1\";\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi4p57cnx.d(15): Error: slice `res` is not mutable\\n/tmp/tmpi4p57cnx.d(17):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpi4p57cnx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result += (a[i] == b[i]) ? \"0\" :\
    \ \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu_ib3gvl.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu_ib3gvl.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp51sq38op.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmp51sq38op.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmp51sq38op.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x1141554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzw9ar3xf.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpzw9ar3xf.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpzw9ar3xf.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x59a12554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3kohljv4.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmp3kohljv4.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmp3kohljv4.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x5059b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    foreach(i, c;\
    \ a)\n    {\n        res ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        if(c == b[i])\n            result ~= \"0\";\n        else\n\
    \            result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiuig0uka.d(16): Error: slice `result` is not mutable\\n/tmp/tmpiuig0uka.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpiuig0uka.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    int i;\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnajlffmx.d(13): Error: variable `i` is shadowing variable `tmpnajlffmx.string_xor.i`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnajlffmx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjhgwb93k.d(16): Error: slice `result` is not mutable\\n/tmp/tmpjhgwb93k.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpjhgwb93k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjghzzlbh.d(16): Error: slice `result` is not mutable\\n/tmp/tmpjghzzlbh.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpjghzzlbh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n            res +=\
    \ \"0\";\n        else\n            res += \"1\";\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz1nt4vcp.d(15): Error: slice `res` is not mutable\\n/tmp/tmpz1nt4vcp.d(17):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpz1nt4vcp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqvn3ge40.d(16): Error: slice `result` is not mutable\\n/tmp/tmpqvn3ge40.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpqvn3ge40.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt8atu39x.d(16): Error: slice `result` is not mutable\\n/tmp/tmpt8atu39x.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpt8atu39x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        if(c == b[i])\n            result ~= \"0\";\n        else\n\
    \            result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp30t_a607.d(16): Error: slice `result` is not mutable\\n/tmp/tmp30t_a607.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp30t_a607.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    foreach(i, c;\
    \ a)\n    {\n        res ~= (c == b[i]) ? '0' : '1';\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplt56auoy.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmplt56auoy.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmplt56auoy.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x22d5a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        if(c == b[i])\n            result ~= \"0\";\n        else\n\
    \            result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjhmg_xcm.d(16): Error: slice `result` is not mutable\\n/tmp/tmpjhmg_xcm.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpjhmg_xcm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxkajv2y_.d(16): Error: slice `result` is not mutable\\n/tmp/tmpxkajv2y_.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpxkajv2y_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzhhxp6yc.d(16): Error: slice `result` is not mutable\\n/tmp/tmpzhhxp6yc.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpzhhxp6yc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    foreach(i, c;\
    \ a)\n    {\n        res ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n     \
    \       res += \"0\";\n        } \n        else \n        {\n            res +=\
    \ \"1\";\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4sqdzz55.d(16): Error: slice `res` is not mutable\\n/tmp/tmp4sqdzz55.d(20):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp4sqdzz55.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        result += (a[i] == b[i]) ? \"0\"\
    \ : \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_cu7w5dw.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_cu7w5dw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeg58yc1t.d(16): Error: slice `result` is not mutable\\n/tmp/tmpeg58yc1t.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpeg58yc1t.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        if(c == b[i])\n            result ~= \"0\";\n        else\n  \
    \          result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpj3yv4qsx.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmpj3yv4qsx.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmpj3yv4qsx.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0xa18a0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfk97uyvy.d(16): Error: slice `result` is not mutable\\n/tmp/tmpfk97uyvy.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpfk97uyvy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n            res +=\
    \ \"0\";\n        else\n            res += \"1\";\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9d761g_l.d(15): Error: slice `res` is not mutable\\n/tmp/tmp9d761g_l.d(17):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp9d761g_l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgzlh5dk9.d(16): Error: slice `result` is not mutable\\n/tmp/tmpgzlh5dk9.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpgzlh5dk9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2zwgrm3g.d(16): Error: slice `result` is not mutable\\n/tmp/tmp2zwgrm3g.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp2zwgrm3g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\n/*\n    Input is a string\
    \ of 1s and 0s.\n    Return the number of 1s in the string.\n    >>> count_ones(\"\
    10001\")\n    2\n*/\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxg7x6yfr.d(16): Error: slice `result` is not mutable\\n/tmp/tmpxg7x6yfr.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpxg7x6yfr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result ~= (a[i] ^ b[i]).to!string;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9xg3n7ya.d(14): Error: no property `to` for type `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9xg3n7ya.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    foreach(i, aa;\
    \ a)\n    {\n        res ~= (aa ^ b[i]) ? \"1\" : \"0\";\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result += (a[i] == b[i]) ? \"0\" :\
    \ \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplhgf9txu.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplhgf9txu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7bi6rajm.d(16): Error: slice `result` is not mutable\\n/tmp/tmp7bi6rajm.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp7bi6rajm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv71382c3.d(16): Error: slice `result` is not mutable\\n/tmp/tmpv71382c3.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpv71382c3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result += (a[i] == b[i]) ? \"0\" :\
    \ \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7w9dqnd0.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7w9dqnd0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7ju2ai1d.d(16): Error: slice `result` is not mutable\\n/tmp/tmp7ju2ai1d.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp7ju2ai1d.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++) \n    {\n        if (a[i] == b[i])\n            res +=\
    \ \"0\";\n        else\n            res += \"1\";\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3bv5r44h.d(15): Error: slice `res` is not mutable\\n/tmp/tmp3bv5r44h.d(17):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp3bv5r44h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c == b[i]) ? '0' : '1';\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwq9qspx1.d(16): Error: slice `result` is not mutable\\n/tmp/tmpwq9qspx1.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpwq9qspx1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpppzphs7v.d(16): Error: slice `result` is not mutable\\n/tmp/tmpppzphs7v.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpppzphs7v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp13p_ee_4.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmp13p_ee_4.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmp13p_ee_4.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0xefd53554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp526q43kb.d(16): Error: slice `result` is not mutable\\n/tmp/tmp526q43kb.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp526q43kb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n            res +=\
    \ \"0\";\n        else\n            res += \"1\";\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpanr6j_cx.d(15): Error: slice `res` is not mutable\\n/tmp/tmpanr6j_cx.d(17):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpanr6j_cx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        if(c == b[i])\n            result ~= \"0\";\n        else\n  \
    \          result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0o16bx44.d(16): Error: slice `result` is not mutable\\n/tmp/tmp0o16bx44.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp0o16bx44.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n            res +=\
    \ \"0\";\n        else\n            res += \"1\";\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz_b8y5v5.d(15): Error: slice `res` is not mutable\\n/tmp/tmpz_b8y5v5.d(17):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpz_b8y5v5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result += (a[i] == b[i]) ? \"0\" :\
    \ \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw8hf4odc.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw8hf4odc.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        result += (a[i] == b[i]) ? \"0\"\
    \ : \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxkfb4xb0.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxkfb4xb0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbl4uzmiu.d(16): Error: slice `result` is not mutable\\n/tmp/tmpbl4uzmiu.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpbl4uzmiu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        result += (a[i] == b[i]) ? \"0\"\
    \ : \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp97f17suy.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp97f17suy.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2l76pcwh.d(16): Error: slice `result` is not mutable\\n/tmp/tmp2l76pcwh.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp2l76pcwh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpadaauc_9.d(16): Error: slice `result` is not mutable\\n/tmp/tmpadaauc_9.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpadaauc_9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxeq_qjwv.d(16): Error: slice `result` is not mutable\\n/tmp/tmpxeq_qjwv.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpxeq_qjwv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    foreach(i, c;\
    \ a)\n    {\n        res ~= (c == b[i]) ? '0' : '1';\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpt_dqh2w3.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpt_dqh2w3.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpt_dqh2w3.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0xcd71b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(int\
    \ i; 0 .. a.length)\n    {\n        if(a[i] == b[i])\n        {\n            result\
    \ ~= \"0\";\n        }\n        else\n        {\n            result ~= \"1\";\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4pgxamuy.d(12): Error: cannot implicitly convert expression `a.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp4pgxamuy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7_d263rq.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmp7_d263rq.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmp7_d263rq.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0xba05c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplkbylg8t.d(16): Error: slice `result` is not mutable\\n/tmp/tmplkbylg8t.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmplkbylg8t.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    foreach(int\
    \ i, char c; a)\n    {\n        res ~= (c ^ b[i]);\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpshlzwvec.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f9d]\\n??:? void tmpshlzwvec.__unittest_L18_C1()\
    \ [0x427ba9]\\n??:? void tmpshlzwvec.__modtest() [0x427d1c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c6a7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5b6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff8d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43043c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff19]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b58d]\\n??:? runModuleUnitTests [0x42c47d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428460]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283e7]\\n??:? _d_run_main [0x428352]\\n??:? main [0x427d2f]\\\
    n??:? __libc_start_main [0x7b669554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ aa; a)\n    {\n        if(aa == b[i])\n            result ~= \"0\";\n      \
    \  else\n            result ~= \"1\";\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4uaf_bhn.d(16): Error: slice `result` is not mutable\\n/tmp/tmp4uaf_bhn.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp4uaf_bhn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        if(c == b[i])\n            result ~= \"0\";\n        else\n\
    \            result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n            res +=\
    \ \"0\";\n        else\n            res += \"1\";\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp99hico6m.d(15): Error: slice `res` is not mutable\\n/tmp/tmp99hico6m.d(17):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp99hico6m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result ~= (a[i] ^ b[i]);\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n   \
    \ assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcjp04kio.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f8d]\\n??:? void tmpcjp04kio.__unittest_L18_C1()\
    \ [0x427b99]\\n??:? void tmpcjp04kio.__modtest() [0x427d0c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c697]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5a6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff7d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43042c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff09]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b57d]\\n??:? runModuleUnitTests [0x42c46d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428450]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283d7]\\n??:? _d_run_main [0x428342]\\n??:? main [0x427d1f]\\\
    n??:? __libc_start_main [0x3c009554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp59e4s3gl.d(16): Error: slice `result` is not mutable\\n/tmp/tmp59e4s3gl.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp59e4s3gl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp90sz7g6f.d(16): Error: slice `result` is not mutable\\n/tmp/tmp90sz7g6f.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp90sz7g6f.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n            res +=\
    \ \"0\";\n        else\n            res += \"1\";\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_hq99im2.d(15): Error: slice `res` is not mutable\\n/tmp/tmp_hq99im2.d(17):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp_hq99im2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    foreach(i, c;\
    \ a)\n    {\n        res ~= (c ^ b[i]);\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwrleyrq8.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpwrleyrq8.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpwrleyrq8.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x70e4c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpivnbgykz.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmpivnbgykz.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmpivnbgykz.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x8f8a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        if(c == b[i])\n            result ~= \"0\";\n        else\n\
    \            result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result ~= ((a[i] == '1') ^ (b[i] ==\
    \ '1')) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpfcdzr_e2.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpfcdzr_e2.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpfcdzr_e2.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x8dc34554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsb00_wl0.d(16): Error: slice `result` is not mutable\\n/tmp/tmpsb00_wl0.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpsb00_wl0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpidpi392y.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmpidpi392y.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmpidpi392y.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x81018554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3wkw6m11.d(16): Error: slice `result` is not mutable\\n/tmp/tmp3wkw6m11.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp3wkw6m11.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbf6d4j7p.d(16): Error: slice `result` is not mutable\\n/tmp/tmpbf6d4j7p.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpbf6d4j7p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8zg8ruir.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmp8zg8ruir.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmp8zg8ruir.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x4b291554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp18lg78ux.d(16): Error: slice `result` is not mutable\\n/tmp/tmp18lg78ux.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp18lg78ux.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj48mlv88.d(16): Error: slice `result` is not mutable\\n/tmp/tmpj48mlv88.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpj48mlv88.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result ~= \"0\";\n        }\n        else\n        {\n            result\
    \ ~= \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp44t51bto.d(16): Error: slice `result` is not mutable\\n/tmp/tmp44t51bto.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp44t51bto.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6zw09a7r.d(16): Error: slice `result` is not mutable\\n/tmp/tmp6zw09a7r.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp6zw09a7r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ char; a)\n    {\n        if(a[i] == b[i])\n            result ~= \"0\";\n  \
    \      else\n            result ~= \"1\";\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2fxolzxw.d(12): Error: no identifier for declarator `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2fxolzxw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdme4sffh.d(16): Error: slice `result` is not mutable\\n/tmp/tmpdme4sffh.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpdme4sffh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        if(c == b[i])\n            result ~= \"0\";\n        else\n\
    \            result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    for (int i =\
    \ 0; i < a.length; i++) \n    {\n        res += (a[i] == b[i]) ? \"0\" : \"1\"\
    ;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_xi7k2v4.d(14): Error: slice `res` is not mutable\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_xi7k2v4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result ~= (a[i] ^ b[i]).to!string;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz3rqxyyr.d(14): Error: no property `to` for type `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz3rqxyyr.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsdtgco78.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpsdtgco78.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpsdtgco78.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x880a8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmppu3tm5dd.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmppu3tm5dd.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmppu3tm5dd.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0xe6952554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4epa6ltj.d(16): Error: slice `result` is not mutable\\n/tmp/tmp4epa6ltj.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp4epa6ltj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvt3tn6cg.d(16): Error: slice `result` is not mutable\\n/tmp/tmpvt3tn6cg.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpvt3tn6cg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        if(c == b[i])\n            result ~= \"0\";\n        else\n  \
    \          result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result ~= \"0\";\n        }\n        else\n        {\n            result\
    \ ~= \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ char; a)\n    {\n        if(a[i] == b[i])\n            result ~= \"0\";\n  \
    \      else\n            result ~= \"1\";\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4lv19lr2.d(12): Error: no identifier for declarator `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4lv19lr2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result += (a[i] == b[i]) ? \"0\" :\
    \ \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb7mnfbkx.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb7mnfbkx.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ char; a)\n    {\n        result ~= (a[i] ^ b[i]);\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqw8qp2bc.d(12): Error: no identifier for declarator `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqw8qp2bc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           result += \"0\";\n        } \n        else \n        {\n         \
    \   result += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv61vuwhv.d(16): Error: slice `result` is not mutable\\n/tmp/tmpv61vuwhv.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpv61vuwhv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    foreach(i, c; a)\n\
    \    {\n        if(c == b[i])\n            result ~= \"0\";\n        else\n  \
    \          result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    foreach(i,\
    \ c; a)\n    {\n        result ~= (c ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp46wijg3r.d(16): Error: slice `result` is not mutable\\n/tmp/tmp46wijg3r.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp46wijg3r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    for (int i = 0;\
    \ i < a.length; i++) \n    {\n        result ~= (a[i] ^ b[i]) ? \"1\" : \"0\"\
    ;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string res = \"\";\n    foreach(i, c;\
    \ a)\n    {\n        res ~= (c ^ b[i]);\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjerjtyd8.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpjerjtyd8.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpjerjtyd8.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x8e49e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result ~= (a[i] ^ b[i]);\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n   \
    \ assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpo0kvwv6i.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f8d]\\n??:? void tmpo0kvwv6i.__unittest_L18_C1()\
    \ [0x427b99]\\n??:? void tmpo0kvwv6i.__modtest() [0x427d0c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c697]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5a6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff7d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43042c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff09]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b57d]\\n??:? runModuleUnitTests [0x42c46d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428450]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283d7]\\n??:? _d_run_main [0x428342]\\n??:? main [0x427d1f]\\\
    n??:? __libc_start_main [0xc92a3554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4bqarwfy.d(16): Error: slice `result` is not mutable\\n/tmp/tmp4bqarwfy.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp4bqarwfy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result += \"0\";\n        }\n        else\n        {\n            result\
    \ += \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxviw64kh.d(16): Error: slice `result` is not mutable\\n/tmp/tmpxviw64kh.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpxviw64kh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring\
    \ string_xor(string a, string b) \n{\n    string result;\n    for (int i = 0;\
    \ i < a.length; i++)\n    {\n        if (a[i] == b[i])\n            result ~=\
    \ \"0\";\n        else\n            result ~= \"1\";\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
