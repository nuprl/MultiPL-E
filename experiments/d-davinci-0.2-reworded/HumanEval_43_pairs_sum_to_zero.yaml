name: HumanEval_43_pairs_sum_to_zero
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    pairs_sum_to_zero takes\
  \ an array of integers as an input.\n    it returns true if there are two distinct\
  \ elements in the array that\n    sum to zero, and false otherwise.\n    >>> pairs_sum_to_zero([1L,\
  \ 3L, 5L, 0L])\n    false\n    >>> pairs_sum_to_zero([1L, 3L, -2L, 1L])\n    false\n\
  \    >>> pairs_sum_to_zero([1L, 2L, 3L, 7L])\n    false\n    >>> pairs_sum_to_zero([2L,\
  \ 4L, -5L, 3L, 5L, 7L])\n    true\n    >>> pairs_sum_to_zero([1L])\n    false\n\
  \    \n*/\nbool pairs_sum_to_zero(long[] l) \n"
tests: "unittest\n{\n    alias candidate = pairs_sum_to_zero;\n\n    assert(candidate([1L,\
  \ 3L, 5L, 0L]) == false);\n    assert(candidate([1L, 3L, -2L, 1L]) == false);\n\
  \    assert(candidate([1L, 2L, 3L, 7L]) == false);\n    assert(candidate([2L, 4L,\
  \ -5L, 3L, 5L, 7L]) == true);\n    assert(candidate([1L]) == false);\n    assert(candidate([-3L,\
  \ 9L, -1L, 3L, 2L, 30L]) == true);\n    assert(candidate([-3L, 9L, -1L, 3L, 2L,\
  \ 31L]) == true);\n    assert(candidate([-3L, 9L, -1L, 4L, 2L, 30L]) == false);\n\
  \    assert(candidate([-3L, 9L, -1L, 4L, 2L, 31L]) == false);\n}\nvoid main(){}"
completions: ["{\n    long[] a = l.dup;\n    a.sort;\n    foreach(long i; a)\n   \
    \ {\n        if(a.count(i) > 1)\n        {\n            return true;\n       \
    \ }\n    }\n    return false;\n}\n/*", "{\n    if (l.length < 2)\n    {\n    \
    \    return false;\n    }\n    else\n    {\n        long[] l_sorted = l.dup;\n\
    \        l_sorted.sort;\n        long i = 0;\n        long j = l_sorted.length\
    \ - 1;\n        while (i < j)\n        {\n            if (l_sorted[i] + l_sorted[j]\
    \ == 0)\n            {\n                return true;\n            }\n        \
    \    else if (l_sorted[i] + l_sorted[j] < 0)\n            {\n                i++;\n\
    \            }\n            else\n            {\n                j--;\n      \
    \      }\n        }\n        return false;\n    }\n}\n/*", "{\n    if (l.length\
    \ < 2)\n    {\n        return false;\n    }\n    else\n    {\n        long[] l2\
    \ = l[1..$];\n        foreach (long i; l2)\n        {\n            if (l.find(-i)\
    \ != -1)\n            {\n                return true;\n            }\n       \
    \ }\n        return false;\n    }\n}", "{\n    if (l.length < 2)\n    {\n    \
    \    return false;\n    }\n    else\n    {\n        bool found = false;\n    \
    \    foreach (i; 0 .. l.length)\n        {\n            foreach (j; i+1 .. l.length)\n\
    \            {\n                if (l[i] + l[j] == 0)\n                {\n   \
    \                 found = true;\n                }\n            }\n        }\n\
    \        return found;\n    }\n}\n/*", "{\n    long[] a = l.dup;\n    a.sort;\n\
    \    long i = 0;\n    long j = a.length - 1;\n    while (i < j) \n    {\n    \
    \    if (a[i] + a[j] == 0) \n        {\n            return true;\n        }\n\
    \        else if (a[i] + a[j] < 0) \n        {\n            i++;\n        }\n\
    \        else \n        {\n            j--;\n        }\n    }\n    return false;\n\
    }\n/*", "{\n    bool result = false;\n    foreach(long x; l)\n    {\n        foreach(long\
    \ y; l)\n        {\n            if(x + y == 0)\n            {\n              \
    \  result = true;\n            }\n        }\n    }\n    return result;\n}\n/*",
  "{\n    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n    {\n\
    \        long[] l_sorted = l.dup;\n        l_sorted.sort;\n        long[] l_sorted_neg\
    \ = l_sorted.map!(a => -a)();\n        long[] l_sorted_neg_sorted = l_sorted_neg.dup;\n\
    \        l_sorted_neg_sorted.sort;\n        long[] l_sorted_neg_sorted_unique\
    \ = l_sorted_neg_sorted.dup;\n        l_sorted_neg_sorted_unique.unique;\n   \
    \     long[] l_sorted_unique = l_sorted.dup;\n        l_sorted_unique.unique;\n\
    \        long[] l_sorted_unique_neg = l_sorted_unique.map!(a => -a)();\n     \
    \   long[] l_sorted_unique_neg_sorted = l_sorted_unique_neg.dup;\n        l_sorted_unique_neg_sorted.sort;\n\
    \        long[] l_sorted_unique_neg_sorted_unique = l_sorted_unique_neg_sorted.dup;\n\
    \        l_sorted_unique_neg_sorted_unique.unique;\n        long[] l_sorted_unique_neg_sorted_unique_sorted\
    \ = l_sorted_unique_neg_sorted_unique.dup;\n        l_sorted_unique_neg_sorted_unique_sorted.sort;\n\
    \        long[] l_sorted_unique_neg_sorted_unique_sorted_unique = l_sorted_unique_neg_sorted_unique_sorted.dup;\n\
    \        l_sorted_unique_neg_sorted_unique_sorted_unique.unique;\n        long[]\
    \ l_sorted_unique_neg_sorted_unique_sorted_unique_sorted = l_sorted_unique_neg_sorted_unique_sorted_unique.dup;\n\
    \        l_sorted_unique_neg_sorted_unique_sorted_unique_sorted.sort", "{\n  \
    \  bool result = false;\n    foreach(long i; l)\n    {\n        foreach(long j;\
    \ l)\n        {\n            if(i != j && i + j == 0)\n            {\n       \
    \         result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    bool result = false;\n    for (int i = 0; i < l.length; i++) \n\
    \    {\n        for (int j = i + 1; j < l.length; j++) \n        {\n         \
    \   if (l[i] + l[j] == 0) \n            {\n                result = true;\n  \
    \          }\n        }\n    }\n    return result;\n}\n/*", "{\n    if (l.length\
    \ < 2)\n    {\n        return false;\n    }\n    else\n    {\n        long[] sorted\
    \ = l.sort();\n        long[] negs = sorted.filter!(x => x < 0)();\n        long[]\
    \ poss = sorted.filter!(x => x > 0)();\n        if (negs.length == 0 || poss.length\
    \ == 0)\n        {\n            return false;\n        }\n        else\n     \
    \   {\n            long[] negs_abs = negs.map!(x => abs(x))();\n            long[]\
    \ poss_abs = poss.map!(x => abs(x))();\n            long[] negs_abs_sorted = negs_abs.sort();\n\
    \            long[] poss_abs_sorted = poss_abs.sort();\n            long[] negs_abs_sorted_rev\
    \ = negs_abs_sorted.reverse();\n            long[] poss_abs_sorted_rev = poss_abs_sorted.reverse();\n\
    \            long[] negs_abs_sorted_rev_poss_abs_sorted = negs_abs_sorted_rev.cat(poss_abs_sorted);\n\
    \            long[] poss_abs_sorted_rev_negs_abs_sorted = poss_abs_sorted_rev.cat(negs_abs_sorted);\n\
    \            long[] negs_abs_sorted_rev_poss_abs_sorted_rev = negs_abs_sorted_rev.cat(poss_abs_sorted_rev);\n\
    \            long[] poss_abs_sorted_rev_negs_abs_sorted_rev = poss_abs_sorted_rev.cat(negs_abs_sorted_rev);\n\
    \            long[] negs_abs_sorted_poss_abs_sorted = negs_abs_sorted.cat(poss_abs_sorted);\n\
    \            long[] poss_abs_sorted_negs_abs_sorted = poss_abs_sorted.cat(negs_abs_sorted);\n\
    \            long[] negs_abs_sorted_poss_abs_sorted_rev = negs_abs_sorted.cat(",
  "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ i+1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n\
    \                result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    return l.length > 1 && l.length < 4 && l[0] + l[1] == 0;\n}\n\
    /*", "{\n    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n\
    \    {\n        long[] sorted = l.sort();\n        long[] negative = sorted.filter!(x\
    \ => x < 0);\n        long[] positive = sorted.filter!(x => x > 0);\n        if\
    \ (negative.length > 0 && positive.length > 0)\n        {\n            long[]\
    \ negative_squared = negative.map!(x => x * x);\n            long[] positive_squared\
    \ = positive.map!(x => x * x);\n            return negative_squared.any!(x =>\
    \ positive_squared.contains(x));\n        }\n        else\n        {\n       \
    \     return false;\n        }\n    }\n}\n/*", "{\n    if (l.length < 2) \n  \
    \  {\n        return false;\n    }\n    else \n    {\n        long[] s = l.dup.sort;\n\
    \        long[] z = s.filter!(x => x == 0);\n        if (z.length > 1) \n    \
    \    {\n            return true;\n        }\n        else \n        {\n      \
    \      long[] p = s.filter!(x => x > 0);\n            long[] n = s.filter!(x =>\
    \ x < 0);\n            foreach (i; 0 .. p.length) \n            {\n          \
    \      foreach (j; 0 .. n.length) \n                {\n                    if\
    \ (p[i] + n[j] == 0) \n                    {\n                        return true;\n\
    \                    }\n                }\n            }\n            return false;\n\
    \        }\n    }\n}\n/*", "{\n    bool result = false;\n    long[] l2 = l.dup;\n\
    \    l2.sort;\n    foreach(long i; l2)\n    {\n        if(l2.count(i) > 1)\n \
    \       {\n            result = true;\n            break;\n        }\n       \
    \ else if(l2.count(-i) > 0)\n        {\n            result = true;\n         \
    \   break;\n        }\n    }\n    return result;\n}", "{\n    if (l.length < 2)\n\
    \    {\n        return false;\n    }\n    else\n    {\n        long[] sorted =\
    \ l.sort();\n        long[] neg = sorted.filter!(x => x < 0);\n        long[]\
    \ pos = sorted.filter!(x => x > 0);\n        foreach (n; neg)\n        {\n   \
    \         if (pos.canFind(-n))\n            {\n                return true;\n\
    \            }\n        }\n        return false;\n    }\n}\n/*", "{\n    if (l.length\
    \ < 2) \n    {\n        return false;\n    }\n    else \n    {\n        long[]\
    \ sorted_l = l.dup.sort;\n        long[] negative_l = sorted_l.filter!(x => x\
    \ < 0);\n        long[] positive_l = sorted_l.filter!(x => x > 0);\n        return\
    \ negative_l.any!(x => positive_l.any!(y => x + y == 0));\n    }\n}\n/*", "{\n\
    \    long[] sorted = l.dup.sort;\n    long i = 0;\n    long j = sorted.length\
    \ - 1;\n    while (i < j) \n    {\n        long sum = sorted[i] + sorted[j];\n\
    \        if (sum == 0) \n        {\n            return true;\n        }\n    \
    \    else if (sum < 0) \n        {\n            i++;\n        }\n        else\
    \ \n        {\n            j--;\n        }\n    }\n    return false;\n}", "{\n\
    \    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n    {\n\
    \        long[] a = l.dup;\n        a.sort;\n        long i = 0;\n        long\
    \ j = a.length - 1;\n        while (i < j)\n        {\n            long sum =\
    \ a[i] + a[j];\n            if (sum == 0)\n            {\n                return\
    \ true;\n            }\n            else if (sum < 0)\n            {\n       \
    \         i++;\n            }\n            else\n            {\n             \
    \   j--;\n            }\n        }\n        return false;\n    }\n}", "{\n   \
    \ bool result = false;\n    long[] sorted = l.dup.sort;\n    foreach(i; 0..sorted.length)\n\
    \    {\n        if(sorted[i] == 0)\n        {\n            if(i < sorted.length\
    \ - 1)\n            {\n                if(sorted[i+1] == 0)\n                {\n\
    \                    result = true;\n                    break;\n            \
    \    }\n            }\n        }\n        else\n        {\n            if(sorted.binarySearch(-sorted[i])\
    \ != -1)\n            {\n                result = true;\n                break;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*", "{\n    bool result\
    \ = false;\n    foreach(i; l) \n    {\n        foreach(j; l) \n        {\n   \
    \         if (i != j && i + j == 0) \n            {\n                result =\
    \ true;\n            }\n        }\n    }\n    return result;\n}", "{\n    if (l.length\
    \ < 2)\n    {\n        return false;\n    }\n    else\n    {\n        long[] temp\
    \ = l.dup;\n        temp.sort;\n        long i = 0;\n        long j = temp.length\
    \ - 1;\n        while (i < j)\n        {\n            if (temp[i] + temp[j] ==\
    \ 0)\n            {\n                return true;\n            }\n           \
    \ else if (temp[i] + temp[j] < 0)\n            {\n                i++;\n     \
    \       }\n            else\n            {\n                j--;\n           \
    \ }\n        }\n        return false;\n    }\n}\n/*", "{\n    long[] a = l.dup;\n\
    \    a.sort;\n    long i = 0L;\n    long j = a.length - 1L;\n    while (i < j)\
    \ \n    {\n        if (a[i] + a[j] == 0L) \n        {\n            return true;\n\
    \        }\n        else if (a[i] + a[j] < 0L) \n        {\n            i++;\n\
    \        }\n        else \n        {\n            j--;\n        }\n    }\n   \
    \ return false;\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n\
    \    }\n    else \n    {\n        long[] sorted_l = l.dup.sort;\n        long[]\
    \ neg_l = sorted_l.filter!(x => x < 0);\n        long[] pos_l = sorted_l.filter!(x\
    \ => x > 0);\n        foreach (long neg_num; neg_l) \n        {\n            foreach\
    \ (long pos_num; pos_l) \n            {\n                if (neg_num + pos_num\
    \ == 0) \n                {\n                    return true;\n              \
    \  }\n            }\n        }\n        return false;\n    }\n}", "{\n    bool\
    \ result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1\
    \ .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n \
    \               result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    bool result = false;\n    int i = 0;\n    int j = 0;\n    while\
    \ (i < l.length) \n    {\n        j = i + 1;\n        while (j < l.length) \n\
    \        {\n            if (l[i] + l[j] == 0) \n            {\n              \
    \  result = true;\n            }\n            j = j + 1;\n        }\n        i\
    \ = i + 1;\n    }\n    return result;\n}\n/*", "{\n    if (l.length < 2)\n   \
    \ {\n        return false;\n    }\n    else\n    {\n        auto s = set!(long)();\n\
    \        foreach (i; l)\n        {\n            if (s.contains(i))\n         \
    \   {\n                return true;\n            }\n            else\n       \
    \     {\n                s.insert(i);\n            }\n        }\n        return\
    \ false;\n    }\n}\n/*", "{\n    bool ret = false;\n    for (int i = 0; i < l.length;\
    \ i++) {\n        for (int j = i + 1; j < l.length; j++) {\n            if (l[i]\
    \ + l[j] == 0) {\n                ret = true;\n            }\n        }\n    }\n\
    \    return ret;\n}\n/*", "{\n    if (l.length < 2)\n    {\n        return false;\n\
    \    }\n    else\n    {\n        bool[] seen = new bool[l.length];\n        for\
    \ (int i = 0; i < l.length; i++)\n        {\n            seen[i] = false;\n  \
    \      }\n        for (int i = 0; i < l.length; i++)\n        {\n            for\
    \ (int j = 0; j < l.length; j++)\n            {\n                if (i != j &&\
    \ !seen[i] && !seen[j] && l[i] + l[j] == 0)\n                {\n             \
    \       return true;\n                }\n            }\n            seen[i] =\
    \ true;\n        }\n        return false;\n    }\n}\n/*", "{\n    if (l.length\
    \ < 2) \n    {\n        return false;\n    }\n    else \n    {\n        long[]\
    \ l_sorted = l.dup;\n        l_sorted.sort;\n        int i = 0;\n        int j\
    \ = l_sorted.length - 1;\n        while (i < j) \n        {\n            long\
    \ sum = l_sorted[i] + l_sorted[j];\n            if (sum == 0) \n            {\n\
    \                return true;\n            }\n            else if (sum < 0) \n\
    \            {\n                i += 1;\n            }\n            else \n  \
    \          {\n                j -= 1;\n            }\n        }\n        return\
    \ false;\n    }\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n\
    \    }\n    else \n    {\n        int i = 0;\n        int j = 1;\n        while\
    \ (i < l.length) \n        {\n            while (j < l.length) \n            {\n\
    \                if (l[i] + l[j] == 0) \n                {\n                 \
    \   return true;\n                }\n                j = j + 1;\n            }\n\
    \            i = i + 1;\n            j = i + 1;\n        }\n        return false;\n\
    \    }\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n   \
    \ }\n    else \n    {\n        long[] sorted = l.dup.sort;\n        long[] negs\
    \ = sorted.filter!(x => x < 0L).array;\n        long[] poss = sorted.filter!(x\
    \ => x >= 0L).array;\n        foreach (long n; negs) \n        {\n           \
    \ if (poss.canFind(x => x == -n)) \n            {\n                return true;\n\
    \            }\n        }\n        return false;\n    }\n}\n/*", "{\n    bool\
    \ result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1\
    \ .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n \
    \               result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    bool result = false;\n    foreach(long i; l)\n    {\n        foreach(long\
    \ j; l)\n        {\n            if(i != j && i + j == 0)\n            {\n    \
    \            result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    // this is a bit of a hack, but it works.\n    // we use the fact\
    \ that the array is sorted to find the\n    // two elements that sum to zero.\n\
    \    // we start at the beginning and end of the array, and\n    // move the pointers\
    \ towards each other until we find\n    // the two elements that sum to zero.\n\
    \    // if we get to the end of the array without finding\n    // the two elements,\
    \ we return false.\n    auto sorted = l.dup.sort;\n    auto i = 0;\n    auto j\
    \ = sorted.length - 1;\n    while (i < j) {\n        auto sum = sorted[i] + sorted[j];\n\
    \        if (sum == 0) {\n            return true;\n        } else if (sum < 0)\
    \ {\n            i++;\n        } else {\n            j--;\n        }\n    }\n\
    \    return false;\n}\n/*", "{\n    if (l.length < 2)\n    {\n        return false;\n\
    \    }\n    else\n    {\n        long[] sorted = l.dup.sort;\n        long[] neg\
    \ = sorted.filter!(x => x < 0);\n        long[] pos = sorted.filter!(x => x >\
    \ 0);\n        foreach (n; neg)\n        {\n            if (pos.canFind(-n))\n\
    \            {\n                return true;\n            }\n        }\n     \
    \   return false;\n    }\n}", "{\n    bool result = false;\n    foreach(long i;\
    \ l)\n    {\n        foreach(long j; l)\n        {\n            if(i != j && i\
    \ + j == 0)\n            {\n                result = true;\n            }\n  \
    \      }\n    }\n    return result;\n}\n/*", "{\n    bool result = false;\n  \
    \  foreach(i; 0 .. l.length)\n    {\n        foreach(j; 0 .. l.length)\n     \
    \   {\n            if(i != j)\n            {\n                if(l[i] + l[j] ==\
    \ 0)\n                {\n                    result = true;\n                }\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    long[] l2 =\
    \ l.dup;\n    l2.sort;\n    long i = 0;\n    long j = l2.length - 1;\n    while\
    \ (i < j) \n    {\n        if (l2[i] + l2[j] == 0) \n        {\n            return\
    \ true;\n        }\n        else if (l2[i] + l2[j] < 0) \n        {\n        \
    \    i++;\n        }\n        else \n        {\n            j--;\n        }\n\
    \    }\n    return false;\n}\n/*", "{\n    if (l.length < 2) return false;\n \
    \   long[] sorted = l.dup.sort;\n    long[] neg = sorted.filter!(x => x < 0);\n\
    \    long[] pos = sorted.filter!(x => x > 0);\n    return neg.any!(x => pos.any!(y\
    \ => x + y == 0));\n}", "{\n    bool result = false;\n    for (size_t i = 0; i\
    \ < l.length; i++)\n    {\n        for (size_t j = i + 1; j < l.length; j++)\n\
    \        {\n            if (l[i] + l[j] == 0)\n            {\n               \
    \ result = true;\n            }\n        }\n    }\n    return result;\n}\n/*",
  "{\n    // TODO: implement this function\n    return false;\n}", "{\n    if (l.length\
    \ < 2)\n    {\n        return false;\n    }\n    else\n    {\n        long[] l_sorted\
    \ = l.sort();\n        long[] l_sorted_unique = l_sorted.unique;\n        long[]\
    \ l_sorted_unique_neg = l_sorted_unique.map!(a => -a);\n        return l_sorted_unique.intersect(l_sorted_unique_neg).length\
    \ > 0;\n    }\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n\
    \    }\n    else \n    {\n        long[] sorted = l.dup.sort;\n        long[]\
    \ negs = sorted.filter!(x => x < 0);\n        long[] pos = sorted.filter!(x =>\
    \ x > 0);\n        foreach (n; negs) \n        {\n            if (pos.canFind(x\
    \ => x == -n)) \n            {\n                return true;\n            }\n\
    \        }\n        return false;\n    }\n}\n/*", "{\n    // TODO: implement this\
    \ function\n    return false;\n}\n/*", "{\n    long[] l2 = l.dup;\n    l2.sort;\n\
    \    long i = 0;\n    long j = l2.length - 1;\n    while (i < j) {\n        long\
    \ sum = l2[i] + l2[j];\n        if (sum == 0) {\n            return true;\n  \
    \      } else if (sum < 0) {\n            i++;\n        } else {\n           \
    \ j--;\n        }\n    }\n    return false;\n}\n/*", "{\n    long[] l2 = l.dup;\n\
    \    l2.sort;\n    foreach(long i; l2)\n    {\n        if(l2.count(i) > 1)\n \
    \       {\n            return true;\n        }\n    }\n    foreach(long i; l2)\n\
    \    {\n        if(l2.count(-i) > 0)\n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\n/*", "{\n    if (l.length < 2) \n    {\n\
    \        return false;\n    }\n    else \n    {\n        long[] sorted_l = l.dup.sort;\n\
    \        long[] negative_sorted_l = sorted_l.filter!(x => x < 0).reverse;\n  \
    \      long[] positive_sorted_l = sorted_l.filter!(x => x >= 0);\n        foreach\
    \ (long n; negative_sorted_l) \n        {\n            foreach (long p; positive_sorted_l)\
    \ \n            {\n                if (n + p == 0) \n                {\n     \
    \               return true;\n                }\n                else if (n +\
    \ p > 0) \n                {\n                    break;\n                }\n\
    \            }\n        }\n        return false;\n    }\n}\n/*", "{\n    if (l.length\
    \ < 2)\n    {\n        return false;\n    }\n    else\n    {\n        long[] sorted\
    \ = l.dup.sort;\n        long[] neg = sorted.filter!(a => a < 0);\n        long[]\
    \ pos = sorted.filter!(a => a > 0);\n        if (neg.length > 0 && pos.length\
    \ > 0)\n        {\n            if (neg.front + pos.back == 0)\n            {\n\
    \                return true;\n            }\n            else\n            {\n\
    \                return pairs_sum_to_zero(neg.dropOne) || pairs_sum_to_zero(pos.dropOne);\n\
    \            }\n        }\n        else\n        {\n            return false;\n\
    \        }\n    }\n}", "{\n    if (l.length < 2) \n    {\n        return false;\n\
    \    }\n    long[] sorted = l.dup.sort;\n    long[] neg = sorted.filter!(x =>\
    \ x < 0);\n    long[] pos = sorted.filter!(x => x > 0);\n    long[] zeros = sorted.filter!(x\
    \ => x == 0);\n    if (zeros.length > 1) \n    {\n        return true;\n    }\n\
    \    foreach (n; neg) \n    {\n        if (pos.canFind(x => x == -n)) \n     \
    \   {\n            return true;\n        }\n    }\n    return false;\n}\n/*",
  "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else \n   \
    \ {\n        long[] sorted = l.dup.sort();\n        long[] negative = sorted.filter!(x\
    \ => x < 0);\n        long[] positive = sorted.filter!(x => x > 0);\n        if\
    \ (negative.length > 0 && positive.length > 0) \n        {\n            if (negative.front\
    \ + positive.back == 0) \n            {\n                return true;\n      \
    \      }\n            else \n            {\n                return pairs_sum_to_zero(negative.dropOne)\
    \ || pairs_sum_to_zero(positive.dropOne);\n            }\n        }\n        else\
    \ \n        {\n            return false;\n        }\n    }\n}", "{\n    bool result\
    \ = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n\
    \        {\n            if (l[i] + l[j] == 0)\n            {\n               \
    \ result = true;\n            }\n        }\n    }\n    return result;\n}\n/*",
  "{\n    bool found = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ i+1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n\
    \                found = true;\n            }\n        }\n    }\n    return found;\n\
    }", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        long[] sorted = l.dup.sort;\n        long[] negs = sorted.filter!(x\
    \ => x < 0).map!(x => -x);\n        long[] poss = sorted.filter!(x => x >= 0);\n\
    \        return negs.any!(x => poss.binarySearch(x) != -1);\n    }\n}", "{\n \
    \   // your code here\n    return false;\n}\n/*", "{\n    bool[] b = new bool[l.length];\n\
    \    foreach(i; 0..l.length)\n    {\n        foreach(j; 0..l.length)\n       \
    \ {\n            if(i != j)\n            {\n                if(l[i] + l[j] ==\
    \ 0)\n                {\n                    return true;\n                }\n\
    \            }\n        }\n    }\n    return false;\n}", "{\n    if (l.length\
    \ < 2)\n    {\n        return false;\n    }\n    else\n    {\n        long[] sorted\
    \ = l.dup.sort;\n        long[] negs = sorted.filter!(x => x < 0);\n        long[]\
    \ poss = sorted.filter!(x => x > 0);\n        if (negs.length == 0 || poss.length\
    \ == 0)\n        {\n            return false;\n        }\n        else\n     \
    \   {\n            long[] negs_abs = negs.map!(x => abs(x));\n            long[]\
    \ poss_abs = poss.map!(x => abs(x));\n            long[] negs_abs_sorted = negs_abs.sort;\n\
    \            long[] poss_abs_sorted = poss_abs.sort;\n            long[] negs_abs_sorted_reversed\
    \ = negs_abs_sorted.dup.reverse;\n            long[] poss_abs_sorted_reversed\
    \ = poss_abs_sorted.dup.reverse;\n            long[] negs_abs_sorted_reversed_poss_abs_sorted\
    \ = negs_abs_sorted_reversed ~ poss_abs_sorted;\n            long[] poss_abs_sorted_reversed_negs_abs_sorted\
    \ = poss_abs_sorted_reversed ~ negs_abs_sorted;\n            long[] negs_abs_sorted_reversed_poss_abs_sorted_sorted\
    \ = negs_abs_sorted_reversed_poss_abs_sorted.sort;\n            long[] poss_abs_sorted_reversed_negs_abs_sorted_sorted\
    \ = poss_abs_sorted_reversed_negs_abs_sorted.sort;\n            long[] negs_abs_sorted_reversed_poss_abs_sorted_sorted_reversed\
    \ = negs_abs_sorted_reversed_poss_abs_sorted_sorted.dup.reverse;\n           \
    \ long[] poss_abs_sorted_reversed_negs_abs_sorted_sorted_reversed", "{\n    bool\
    \ result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1\
    \ .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n \
    \               result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n\
    \    {\n        long[] a = l.dup;\n        a.sort;\n        int i = 0;\n     \
    \   int j = a.length - 1;\n        while (i < j)\n        {\n            if (a[i]\
    \ + a[j] == 0)\n            {\n                return true;\n            }\n \
    \           else if (a[i] + a[j] < 0)\n            {\n                i++;\n \
    \           }\n            else\n            {\n                j--;\n       \
    \     }\n        }\n        return false;\n    }\n}", "{\n    bool result = false;\n\
    \    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n \
    \       {\n            if (l[i] + l[j] == 0)\n            {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}", "{\n    if\
    \ (l.length < 2) \n    {\n        return false;\n    }\n    long[] sorted = l.dup.sort;\n\
    \    long[] neg = sorted.filter!(x => x < 0).array;\n    long[] pos = sorted.filter!(x\
    \ => x >= 0).array;\n    if (neg.length == 0 || pos.length == 0) \n    {\n   \
    \     return false;\n    }\n    long neg_idx = neg.length - 1;\n    long pos_idx\
    \ = 0;\n    while (neg_idx >= 0 && pos_idx < pos.length) \n    {\n        long\
    \ sum = neg[neg_idx] + pos[pos_idx];\n        if (sum == 0) \n        {\n    \
    \        return true;\n        }\n        else if (sum < 0) \n        {\n    \
    \        pos_idx += 1;\n        }\n        else \n        {\n            neg_idx\
    \ -= 1;\n        }\n    }\n    return false;\n}\n/*", "{\n    if (l.length < 2)\
    \ \n    {\n        return false;\n    }\n    else \n    {\n        foreach (i;\
    \ l) \n        {\n            foreach (j; l) \n            {\n               \
    \ if (i + j == 0 && i != j) \n                {\n                    return true;\n\
    \                }\n            }\n        }\n        return false;\n    }\n}",
  "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else \n   \
    \ {\n        long[] l2 = l.dup;\n        l2.sort;\n        long i = 0;\n     \
    \   while (i < l2.length) \n        {\n            long j = i + 1;\n         \
    \   while (j < l2.length) \n            {\n                if (l2[i] + l2[j] ==\
    \ 0) \n                {\n                    return true;\n                }\n\
    \                j += 1;\n            }\n            i += 1;\n        }\n    \
    \    return false;\n    }\n}\n/*", "{\n    bool result = false;\n    foreach(i;\
    \ 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n        {\n    \
    \        if(l[i] + l[j] == 0)\n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*", "{\n    if (l.length\
    \ < 2) \n    {\n        return false;\n    }\n    else \n    {\n        long[]\
    \ sorted = l.dup.sort;\n        long[] neg = sorted.filter!(x => x < 0).dup;\n\
    \        long[] pos = sorted.filter!(x => x >= 0).dup;\n        long[] neg_cumsum\
    \ = neg.map!(x => -x).cumsum;\n        long[] pos_cumsum = pos.cumsum;\n     \
    \   return neg_cumsum.any!(x => pos_cumsum.canFind(x));\n    }\n}", "{\n    bool\
    \ result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; 0\
    \ .. l.length)\n        {\n            if(i != j)\n            {\n           \
    \     if(l[i] + l[j] == 0)\n                {\n                    result = true;\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\n/*",
  "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else \n   \
    \ {\n        long[] sorted = l.dup.sort;\n        long[] neg = sorted.filter!(x\
    \ => x < 0);\n        long[] pos = sorted.filter!(x => x > 0);\n        long[]\
    \ zeros = sorted.filter!(x => x == 0);\n        if (zeros.length > 1) \n     \
    \   {\n            return true;\n        }\n        else \n        {\n       \
    \     foreach (long n; neg) \n            {\n                if (pos.canFind(-n))\
    \ \n                {\n                    return true;\n                }\n \
    \           }\n            return false;\n        }\n    }\n}\n/*", "{\n    long[]\
    \ l2 = l.dup;\n    l2.sort;\n    long i = 0;\n    long j = l2.length - 1;\n  \
    \  while (i < j) \n    {\n        if (l2[i] + l2[j] == 0) \n        {\n      \
    \      return true;\n        }\n        else if (l2[i] + l2[j] < 0) \n       \
    \ {\n            i++;\n        }\n        else \n        {\n            j--;\n\
    \        }\n    }\n    return false;\n}\n/*", "{\n    bool found = false;\n  \
    \  for (int i = 0; i < l.length; i++)\n    {\n        for (int j = i + 1; j <\
    \ l.length; j++)\n        {\n            if (l[i] + l[j] == 0)\n            {\n\
    \                found = true;\n            }\n        }\n    }\n    return found;\n\
    }\n/*", "{\n    long[] sorted = sort(l);\n    long[] negative = filter!(x => x\
    \ < 0)(sorted);\n    long[] positive = filter!(x => x > 0)(sorted);\n    long[]\
    \ zero = filter!(x => x == 0)(sorted);\n    if (zero.length > 1)\n        return\
    \ true;\n    if (negative.length == 0 || positive.length == 0)\n        return\
    \ false;\n    return pairs_sum_to_zero_helper(negative, positive);\n}", "{\n \
    \   bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ i+1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n\
    \                result = true;\n            }\n        }\n    }\n    return result;\n\
    }", "{\n    bool result = false;\n    foreach(long i; l)\n    {\n        foreach(long\
    \ j; l)\n        {\n            if(i + j == 0)\n            {\n              \
    \  result = true;\n            }\n        }\n    }\n    return result;\n}\n/*",
  "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ i+1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n\
    \                result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        long[] sorted_l = l.sort();\n        long i = 0;\n        long\
    \ j = sorted_l.length - 1;\n        while (i < j) \n        {\n            if\
    \ (sorted_l[i] + sorted_l[j] == 0) \n            {\n                return true;\n\
    \            }\n            else if (sorted_l[i] + sorted_l[j] < 0) \n       \
    \     {\n                i++;\n            }\n            else \n            {\n\
    \                j--;\n            }\n        }\n        return false;\n    }\n\
    }\n/*", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    long i = 0;\n    long j\
    \ = l2.length - 1;\n    while (i < j) \n    {\n        if (l2[i] + l2[j] == 0)\
    \ \n        {\n            return true;\n        }\n        else if (l2[i] + l2[j]\
    \ < 0) \n        {\n            i++;\n        }\n        else \n        {\n  \
    \          j--;\n        }\n    }\n    return false;\n}\n/*", "{\n    if (l.length\
    \ < 2)\n    {\n        return false;\n    }\n    else\n    {\n        bool[] b\
    \ = new bool[l.length];\n        for (int i = 0; i < l.length; i++)\n        {\n\
    \            b[i] = false;\n        }\n        for (int i = 0; i < l.length; i++)\n\
    \        {\n            for (int j = 0; j < l.length; j++)\n            {\n  \
    \              if (i != j && l[i] + l[j] == 0)\n                {\n          \
    \          b[i] = true;\n                    b[j] = true;\n                }\n\
    \            }\n        }\n        for (int i = 0; i < l.length; i++)\n      \
    \  {\n            if (b[i] == true)\n            {\n                return true;\n\
    \            }\n        }\n        return false;\n    }\n}\n/*", "{\n    if (l.length\
    \ < 2)\n    {\n        return false;\n    }\n    else\n    {\n        long[] sorted\
    \ = l.dup.sort;\n        long[] negs = sorted.filter!(x => x < 0);\n        long[]\
    \ poss = sorted.filter!(x => x > 0);\n        if (negs.length < 2 && poss.length\
    \ < 2)\n        {\n            return false;\n        }\n        else\n      \
    \  {\n            if (negs.length > 0 && poss.length > 0)\n            {\n   \
    \             if (negs[0] + poss[poss.length - 1] == 0)\n                {\n \
    \                   return true;\n                }\n                else\n  \
    \              {\n                    return false;\n                }\n     \
    \       }\n            else\n            {\n                if (negs.length >\
    \ 1)\n                {\n                    if (negs[0] + negs[1] == 0)\n   \
    \                 {\n                        return true;\n                  \
    \  }\n                    else\n                    {\n                      \
    \  return false;\n                    }\n                }\n                else\n\
    \                {\n                    if (poss[0] + poss[1] == 0)\n        \
    \            {\n                        return true;\n                    }\n\
    \                    else\n                    {\n                        return\
    \ false;\n                    }\n                }\n            }\n        }\n\
    \    }\n}\n/*", "{\n    if (l.length < 2)\n    {\n        return false;\n    }\n\
    \    else\n    {\n        long[] sorted = l.sort();\n        long[] negs = sorted.filter!(x\
    \ => x < 0);\n        long[] pos = sorted.filter!(x => x > 0);\n        long[]\
    \ zeros = sorted.filter!(x => x == 0);\n        if (zeros.length > 1)\n      \
    \  {\n            return true;\n        }\n        else\n        {\n         \
    \   foreach (n; negs)\n            {\n                if (pos.binarySearch(n *\
    \ -1) != -1)\n                {\n                    return true;\n          \
    \      }\n            }\n            return false;\n        }\n    }\n}", "{\n\
    \    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n    {\n\
    \        long[] sorted = l.dup.sort;\n        long[] negative = sorted.filter!(x\
    \ => x < 0).array;\n        long[] positive = sorted.filter!(x => x >= 0).array;\n\
    \        foreach (n; negative)\n        {\n            if (positive.canFind(x\
    \ => x == -n))\n            {\n                return true;\n            }\n \
    \       }\n        return false;\n    }\n}\n/*", "{\n    if (l.length < 2)\n \
    \   {\n        return false;\n    }\n    else\n    {\n        auto s = set!(long)();\n\
    \        foreach (i; l)\n        {\n            if (s.count(i) > 0)\n        \
    \    {\n                return true;\n            }\n            else\n      \
    \      {\n                s.insert(i);\n            }\n        }\n        return\
    \ false;\n    }\n}\n/*", "{\n    // your code here\n    return false;\n}\n/*",
  "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else \n   \
    \ {\n        long[] sorted = l.dup.sort;\n        long i = 0;\n        while (i\
    \ < sorted.length - 1) \n        {\n            if (sorted[i] + sorted[i + 1]\
    \ == 0) \n            {\n                return true;\n            }\n       \
    \     else \n            {\n                i += 1;\n            }\n        }\n\
    \        return false;\n    }\n}\n/*", "{\n    bool result = false;\n    for (size_t\
    \ i = 0; i < l.length; i++) \n    {\n        for (size_t j = i + 1; j < l.length;\
    \ j++) \n        {\n            if (l[i] + l[j] == 0) \n            {\n      \
    \          result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n\
    \        {\n            if(l[i] + l[j] == 0)\n            {\n                return\
    \ true;\n            }\n        }\n    }\n    return false;\n}\n/*", "{\n    //\
    \ your code here\n    long[] temp = l.dup;\n    temp.sort;\n    long i = 0;\n\
    \    long j = temp.length - 1;\n    while (i < j)\n    {\n        if (temp[i]\
    \ + temp[j] == 0)\n        {\n            return true;\n        }\n        else\
    \ if (temp[i] + temp[j] < 0)\n        {\n            i++;\n        }\n       \
    \ else\n        {\n            j--;\n        }\n    }\n    return false;\n}",
  "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else \n   \
    \ {\n        long[] l1 = l[0..$-1];\n        long[] l2 = l[1..$];\n        return\
    \ l1.canFind(l[$-1]) || pairs_sum_to_zero(l1) || pairs_sum_to_zero(l2);\n    }\n\
    }\n/*", "{\n    if (l.length < 2) return false;\n    auto s = l.sort();\n    foreach\
    \ (i; 0 .. s.length - 1) \n    {\n        if (s[i] + s[i + 1] == 0) return true;\n\
    \    }\n    return false;\n}", "{\n    bool result = false;\n    for (int i =\
    \ 0; i < l.length; i++)\n    {\n        for (int j = i + 1; j < l.length; j++)\n\
    \        {\n            if (l[i] + l[j] == 0)\n            {\n               \
    \ result = true;\n            }\n        }\n    }\n    return result;\n}\n/*",
  "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ 0 .. l.length)\n        {\n            if(i != j)\n            {\n         \
    \       if(l[i] + l[j] == 0)\n                {\n                    result =\
    \ true;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    long[] sorted = l.dup.sort;\n    long[] pairs = [];\n    long\
    \ i = 0;\n    long j = sorted.length - 1;\n    while (i < j) \n    {\n       \
    \ if (sorted[i] + sorted[j] == 0) \n        {\n            pairs ~= [sorted[i],\
    \ sorted[j]];\n            i++;\n            j--;\n        } \n        else if\
    \ (sorted[i] + sorted[j] < 0) \n        {\n            i++;\n        } \n    \
    \    else \n        {\n            j--;\n        }\n    }\n    return pairs.length\
    \ > 0;\n}\n/*", "{\n    long[] sorted = l.dup.sort;\n    long[] zeros = sorted.filter!(x\
    \ => x == 0);\n    if (zeros.length > 1) return true;\n    long[] positives =\
    \ sorted.filter!(x => x > 0);\n    long[] negatives = sorted.filter!(x => x <\
    \ 0);\n    foreach (p; positives) {\n        if (negatives.canFind(x => x == -p))\
    \ return true;\n    }\n    return false;\n}", "{\n    return l.length > 1 && l.sort().pair.map!((a,\
    \ b) => a + b).canFind(0L);\n}\n/*", "{\n    if (l.length < 2) \n    {\n     \
    \   return false;\n    }\n    else \n    {\n        long[] sorted = l.dup.sort;\n\
    \        long[] negs = sorted.filter!(x => x < 0).map!(x => -x).sort;\n      \
    \  long[] poss = sorted.filter!(x => x >= 0).sort;\n        int i = 0;\n     \
    \   int j = 0;\n        while (i < negs.length && j < poss.length) \n        {\n\
    \            if (negs[i] == poss[j]) \n            {\n                return true;\n\
    \            }\n            else if (negs[i] < poss[j]) \n            {\n    \
    \            i += 1;\n            }\n            else \n            {\n      \
    \          j += 1;\n            }\n        }\n        return false;\n    }\n}\n\
    /*", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n    \
    \    foreach(j; i+1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n\
    \            {\n                result = true;\n            }\n        }\n   \
    \ }\n    return result;\n}", "{\n    if (l.length < 2) \n    {\n        return\
    \ false;\n    }\n    else \n    {\n        long[] sorted = l.dup.sort;\n     \
    \   long[] negs = sorted.filter!(x => x < 0).map!(x => -x);\n        long[] poss\
    \ = sorted.filter!(x => x >= 0);\n        return negs.any!(x => poss.binarySearch(x)\
    \ != -1);\n    }\n}", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\
    \ \n    {\n        foreach(j; i + 1 .. l.length) \n        {\n            if(l[i]\
    \ + l[j] == 0) \n            {\n                result = true;\n            }\n\
    \        }\n    }\n    return result;\n}\n/*", "{\n    if (l.length < 2) \n  \
    \  {\n        return false;\n    }\n    else \n    {\n        long[] sorted =\
    \ l.dup.sort;\n        long[] zeros = sorted.filter!(x => x == 0);\n        if\
    \ (zeros.length > 1) \n        {\n            return true;\n        }\n      \
    \  else \n        {\n            long[] positives = sorted.filter!(x => x > 0);\n\
    \            long[] negatives = sorted.filter!(x => x < 0);\n            foreach\
    \ (long p; positives) \n            {\n                foreach (long n; negatives)\
    \ \n                {\n                    if (p == -n) \n                   \
    \ {\n                        return true;\n                    }\n           \
    \     }\n            }\n            return false;\n        }\n    }\n}", "{\n\
    \    long[] sorted = l.dup.sort;\n    long[] neg = sorted.filter!(a => a < 0);\n\
    \    long[] pos = sorted.filter!(a => a > 0);\n    long[] zeros = sorted.filter!(a\
    \ => a == 0);\n    if (zeros.length > 1) \n    {\n        return true;\n    }\n\
    \    else \n    {\n        foreach (n; neg) \n        {\n            if (pos.canFind(-n))\
    \ \n            {\n                return true;\n            }\n        }\n  \
    \      return false;\n    }\n}\n/*", "{\n    if (l.length < 2) \n    {\n     \
    \   return false;\n    }\n    else \n    {\n        long[] sorted = l.dup.sort;\n\
    \        foreach (i; 0 .. sorted.length) \n        {\n            if (sorted[i]\
    \ == 0) \n            {\n                continue;\n            }\n          \
    \  else \n            {\n                long[] rest = sorted[i + 1 .. $];\n \
    \               if (rest.length > 0) \n                {\n                   \
    \ long[] negated = rest.map!(x => -x);\n                    if (negated.length\
    \ > 0) \n                    {\n                        if (negated.canFind(sorted[i]))\
    \ \n                        {\n                            return true;\n    \
    \                    }\n                    }\n                }\n           \
    \ }\n        }\n        return false;\n    }\n}\n/*", "{\n    if (l.length < 2)\
    \ \n    {\n        return false;\n    }\n    else \n    {\n        long[] sorted\
    \ = l.dup.sort;\n        long[] negs = sorted.filter!(x => x < 0).map!(x => -x);\n\
    \        long[] poss = sorted.filter!(x => x >= 0);\n        return negs.any!(x\
    \ => poss.binarySearch(x) != -1);\n    }\n}", "{\n    long[] a = l.dup;\n    a.sort;\n\
    \    int i = 0;\n    int j = a.length - 1;\n    while (i < j) {\n        long\
    \ sum = a[i] + a[j];\n        if (sum == 0) {\n            return true;\n    \
    \    }\n        else if (sum < 0) {\n            i++;\n        }\n        else\
    \ {\n            j--;\n        }\n    }\n    return false;\n}\n/*", "{\n    long[]\
    \ sorted = l.dup.sort;\n    long i = 0;\n    long j = sorted.length - 1;\n   \
    \ while (i < j) {\n        long sum = sorted[i] + sorted[j];\n        if (sum\
    \ == 0) {\n            return true;\n        } else if (sum < 0) {\n         \
    \   i += 1;\n        } else {\n            j -= 1;\n        }\n    }\n    return\
    \ false;\n}\n/*", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n\
    \    {\n        foreach(j; i+1 .. l.length)\n        {\n            if(l[i] +\
    \ l[j] == 0)\n            {\n                result = true;\n            }\n \
    \       }\n    }\n    return result;\n}", "{\n    if (l.length < 2) \n    {\n\
    \        return false;\n    }\n    else \n    {\n        long[] sorted = l.dup.sort();\n\
    \        long[] negative = sorted.filter!(x => x < 0)();\n        long[] positive\
    \ = sorted.filter!(x => x >= 0)();\n        if (negative.length == 0 || positive.length\
    \ == 0) \n        {\n            return false;\n        }\n        else \n   \
    \     {\n            long[] negative_sums = negative.map!(x => -x)();\n      \
    \      return negative_sums.any!(x => positive.canFind(x))();\n        }\n   \
    \ }\n}", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n\
    \        foreach(j; i+1 .. l.length)\n        {\n            if(l[i] + l[j] ==\
    \ 0)\n            {\n                result = true;\n            }\n        }\n\
    \    }\n    return result;\n}\n/*", "{\n    if (l.length < 2)\n    {\n       \
    \ return false;\n    }\n    else\n    {\n        long[] l2 = l.dup;\n        l2.sort;\n\
    \        long[] l3 = l2.dup;\n        long[] l4 = l2.dup;\n        l3.remove(0);\n\
    \        l4.remove(l4.length - 1);\n        long[] l5 = l3.dup;\n        l5.reverse;\n\
    \        return l3.sum == l4.sum || l3.sum == l5.sum;\n    }\n}\n/*", "{\n   \
    \ bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ i+1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n\
    \                result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        long[] sorted = l.dup.sort;\n        long[] negs = sorted.filter!(x\
    \ => x < 0).map!(x => -x).sort;\n        long[] poss = sorted.filter!(x => x >=\
    \ 0).sort;\n        if (negs.length == 0 || poss.length == 0) \n        {\n  \
    \          return false;\n        }\n        else \n        {\n            long\
    \ i = 0;\n            long j = 0;\n            while (i < negs.length && j < poss.length)\
    \ \n            {\n                if (negs[i] == poss[j]) \n                {\n\
    \                    return true;\n                }\n                else if\
    \ (negs[i] < poss[j]) \n                {\n                    i++;\n        \
    \        }\n                else \n                {\n                    j++;\n\
    \                }\n            }\n            return false;\n        }\n    }\n\
    }\n/*", "{\n    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n\
    \    {\n        long[] l2 = l.dup;\n        l2.sort;\n        long i = 0;\n  \
    \      long j = l2.length - 1;\n        while (i < j)\n        {\n           \
    \ if (l2[i] + l2[j] == 0)\n            {\n                return true;\n     \
    \       }\n            else if (l2[i] + l2[j] < 0)\n            {\n          \
    \      i++;\n            }\n            else\n            {\n                j--;\n\
    \            }\n        }\n        return false;\n    }\n}\n/*", "{\n    bool\
    \ result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1\
    \ .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n \
    \               result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n\
    \        {\n            if(l[i] + l[j] == 0)\n            {\n                return\
    \ true;\n            }\n        }\n    }\n    return false;\n}\n/*", "{\n    bool\
    \ result = false;\n    foreach(i; 0 .. l.length) \n    {\n        foreach(j; i\
    \ + 1 .. l.length) \n        {\n            if(l[i] + l[j] == 0) \n          \
    \  {\n                result = true;\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n\
    \    }\n    else \n    {\n        long[] sorted = l.sort();\n        long[] neg\
    \ = sorted.filter!(x => x < 0);\n        long[] pos = sorted.filter!(x => x >\
    \ 0);\n        if (neg.length == 0 || pos.length == 0) \n        {\n         \
    \   return false;\n        }\n        else \n        {\n            long[] neg_sq\
    \ = neg.map!(x => x * x);\n            long[] pos_sq = pos.map!(x => x * x);\n\
    \            return neg_sq.any!(x => pos_sq.any!(y => x == y));\n        }\n \
    \   }\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n\
    \    else \n    {\n        long[] sorted_l = l.sort();\n        long left = 0;\n\
    \        long right = sorted_l.length - 1;\n        while (left < right) \n  \
    \      {\n            if (sorted_l[left] + sorted_l[right] == 0) \n          \
    \  {\n                return true;\n            }\n            else if (sorted_l[left]\
    \ + sorted_l[right] < 0) \n            {\n                left++;\n          \
    \  }\n            else \n            {\n                right--;\n           \
    \ }\n        }\n        return false;\n    }\n}\n/*", "{\n    if (l.length < 2)\
    \ \n    {\n        return false;\n    }\n    l.sort();\n    long i = 0;\n    long\
    \ j = l.length - 1;\n    while (i < j) \n    {\n        if (l[i] + l[j] == 0)\
    \ \n        {\n            return true;\n        }\n        else if (l[i] + l[j]\
    \ < 0) \n        {\n            i++;\n        }\n        else \n        {\n  \
    \          j--;\n        }\n    }\n    return false;\n}\n/*", "{\n    if (l.length\
    \ < 2) \n    {\n        return false;\n    }\n    else \n    {\n        long[]\
    \ sorted = l.sort();\n        long[] neg = sorted.filter!(x => x < 0);\n     \
    \   long[] pos = sorted.filter!(x => x > 0);\n        foreach (n; neg) \n    \
    \    {\n            if (pos.canFind(-n)) \n            {\n                return\
    \ true;\n            }\n        }\n        return false;\n    }\n}\n/*", "{\n\
    \    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n    {\n\
    \        long[] l2 = l[1..$];\n        foreach (i; l2)\n        {\n          \
    \  if (l[0] + i == 0)\n            {\n                return true;\n         \
    \   }\n        }\n        return pairs_sum_to_zero(l2);\n    }\n}\n/*", "{\n \
    \   if (l.length < 2) \n    {\n        return false;\n    }\n    else \n    {\n\
    \        long[] l2 = l[1..$];\n        foreach (long i; l2) \n        {\n    \
    \        if (l.find(-i) != -1) \n            {\n                return true;\n\
    \            }\n        }\n        return false;\n    }\n}\n/*", "{\n    bool\
    \ result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1\
    \ .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n \
    \               result = true;\n            }\n        }\n    }\n    return result;\n\
    }", "{\n    bool result = false;\n    foreach(i; l)\n    {\n        foreach(j;\
    \ l)\n        {\n            if(i != j && i + j == 0)\n            {\n       \
    \         result = true;\n            }\n        }\n    }\n    return result;\n\
    }", "{\n    auto s = l.sort();\n    foreach(i; 0 .. s.length)\n    {\n       \
    \ if(s[i] == 0)\n        {\n            if(i != s.length - 1)\n            {\n\
    \                if(s[i + 1] == 0)\n                {\n                    return\
    \ true;\n                }\n            }\n        }\n        else\n        {\n\
    \            if(s.canFind(-s[i]))\n            {\n                return true;\n\
    \            }\n        }\n    }\n    return false;\n}\n/*", "{\n    bool result\
    \ = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n\
    \        {\n            if(l[i] + l[j] == 0)\n            {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}", "{\n    bool\
    \ result = false;\n    foreach(i; 0 .. l.length) \n    {\n        foreach(j; i\
    \ + 1 .. l.length) \n        {\n            if(l[i] + l[j] == 0) \n          \
    \  {\n                result = true;\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n\
    \    }\n    else \n    {\n        long[] sorted_l = l.dup.sort;\n        long[]\
    \ unique_l = sorted_l.dup.uniq;\n        foreach (long i; unique_l) \n       \
    \ {\n            if (unique_l.canFind(0L - i)) \n            {\n             \
    \   return true;\n            }\n        }\n        return false;\n    }\n}\n\
    /*", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n    \
    \    foreach(j; 0 .. l.length)\n        {\n            if(i != j && l[i] + l[j]\
    \ == 0)\n            {\n                result = true;\n            }\n      \
    \  }\n    }\n    return result;\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n\
    \    long i = 0L;\n    while (i < l2.length)\n    {\n        long j = i + 1L;\n\
    \        while (j < l2.length)\n        {\n            if (l2[i] + l2[j] == 0L)\n\
    \            {\n                return true;\n            }\n            j +=\
    \ 1L;\n        }\n        i += 1L;\n    }\n    return false;\n}\n/*", "{\n   \
    \ int n = l.length;\n    foreach(i; 0..n)\n    {\n        foreach(j; i+1..n)\n\
    \        {\n            if(l[i] + l[j] == 0)\n            {\n                return\
    \ true;\n            }\n        }\n    }\n    return false;\n}\n/*", "{\n    if\
    \ (l.length < 2) \n    {\n        return false;\n    }\n    else \n    {\n   \
    \     long[] sorted = l.dup.sort();\n        long[] neg = sorted.filter!(x =>\
    \ x < 0);\n        long[] pos = sorted.filter!(x => x > 0);\n        if (neg.length\
    \ == 0 || pos.length == 0) \n        {\n            return false;\n        }\n\
    \        else \n        {\n            long[] neg_abs = neg.map!(x => abs(x)).sort();\n\
    \            long[] pos_abs = pos.map!(x => abs(x)).sort();\n            long[]\
    \ neg_abs_rev = neg_abs.dup.reverse;\n            long[] pos_abs_rev = pos_abs.dup.reverse;\n\
    \            long[] neg_abs_rev_pos_abs = neg_abs_rev.zip(pos_abs);\n        \
    \    long[] neg_abs_pos_abs_rev = neg_abs.zip(pos_abs_rev);\n            return\
    \ neg_abs_rev_pos_abs.any!(x => x[0] == x[1]) || neg_abs_pos_abs_rev.any!(x =>\
    \ x[0] == x[1]);\n        }\n    }\n}", "{\n    bool result = false;\n    foreach(i;\
    \ 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n        {\n    \
    \        if(l[i] + l[j] == 0)\n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    if (l.length\
    \ < 2)\n    {\n        return false;\n    }\n    else\n    {\n        long[] sorted\
    \ = l.dup.sort;\n        long[] negs = sorted.filter!(x => x < 0);\n        long[]\
    \ poss = sorted.filter!(x => x > 0);\n        long[] zeros = sorted.filter!(x\
    \ => x == 0);\n        if (zeros.length > 1)\n        {\n            return true;\n\
    \        }\n        else\n        {\n            foreach (n; negs)\n         \
    \   {\n                if (poss.canFind(-n))\n                {\n            \
    \        return true;\n                }\n            }\n            return false;\n\
    \        }\n    }\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n\
    \    }\n    else \n    {\n        long[] l_sorted = l.dup.sort;\n        long[]\
    \ l_sorted_neg = l_sorted.map!(x => -x);\n        long[] l_sorted_neg_sorted =\
    \ l_sorted_neg.dup.sort;\n        long[] l_sorted_neg_sorted_unique = l_sorted_neg_sorted.dup.uniq;\n\
    \        long[] l_sorted_unique = l_sorted.dup.uniq;\n        return l_sorted_unique.length\
    \ != l_sorted.length || l_sorted_neg_sorted_unique.length != l_sorted_neg_sorted.length;\n\
    \    }\n}", "{\n    bool result = false;\n    for (int i = 0; i < l.length; i++)\n\
    \    {\n        for (int j = i + 1; j < l.length; j++)\n        {\n          \
    \  if (l[i] + l[j] == 0)\n            {\n                result = true;\n    \
    \        }\n        }\n    }\n    return result;\n}\n/*", "{\n    bool found =\
    \ false;\n    for (int i = 0; i < l.length; i++)\n    {\n        for (int j =\
    \ i + 1; j < l.length; j++)\n        {\n            if (l[i] + l[j] == 0)\n  \
    \          {\n                found = true;\n            }\n        }\n    }\n\
    \    return found;\n}\n/*", "{\n    if (l.length < 2) return false;\n    long[]\
    \ sorted = l.dup.sort;\n    long[] neg = sorted.filter!(x => x < 0);\n    long[]\
    \ pos = sorted.filter!(x => x > 0);\n    if (neg.length == 0 || pos.length ==\
    \ 0) return false;\n    if (neg.length == 1 && pos.length == 1) return neg[0]\
    \ + pos[0] == 0;\n    if (neg.length == 1) return pos.canFind(x => -neg[0] ==\
    \ x);\n    if (pos.length == 1) return neg.canFind(x => -pos[0] == x);\n    return\
    \ true;\n}", "{\n    long[] sorted_l = l.dup.sort;\n    long i = 0;\n    long\
    \ j = sorted_l.length - 1;\n    while (i < j) {\n        long sum = sorted_l[i]\
    \ + sorted_l[j];\n        if (sum == 0) {\n            return true;\n        }\n\
    \        else if (sum < 0) {\n            i++;\n        }\n        else {\n  \
    \          j--;\n        }\n    }\n    return false;\n}\n/*", "{\n    bool result\
    \ = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i + 1 ..\
    \ l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n    \
    \            result = true;\n            }\n        }\n    }\n    return result;\n\
    }", "{\n    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n\
    \    {\n        long[] l2 = l.dup;\n        l2.sort;\n        foreach (long i;\
    \ l2)\n        {\n            if (l2.count(i) > 1)\n            {\n          \
    \      return true;\n            }\n        }\n        foreach (long i; l2)\n\
    \        {\n            if (l2.count(-i) > 0)\n            {\n               \
    \ return true;\n            }\n        }\n        return false;\n    }\n}", "{\n\
    \    if (l.length < 2)\n    {\n        return false;\n    }\n    long[] l2 = l.dup;\n\
    \    l2.sort;\n    long i = 0;\n    long j = l2.length - 1;\n    while (i < j)\n\
    \    {\n        if (l2[i] + l2[j] == 0)\n        {\n            return true;\n\
    \        }\n        else if (l2[i] + l2[j] < 0)\n        {\n            i++;\n\
    \        }\n        else\n        {\n            j--;\n        }\n    }\n    return\
    \ false;\n}\n/*", "{\n    bool res = false;\n    foreach(i; 0 .. l.length)\n \
    \   {\n        foreach(j; i+1 .. l.length)\n        {\n            if(l[i] + l[j]\
    \ == 0)\n            {\n                res = true;\n            }\n        }\n\
    \    }\n    return res;\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return\
    \ false;\n    }\n    else \n    {\n        long[] sorted_l = l.dup.sort;\n   \
    \     long[] negative_l = sorted_l.filter!(x => x < 0);\n        long[] positive_l\
    \ = sorted_l.filter!(x => x > 0);\n        if (negative_l.length > 0 && positive_l.length\
    \ > 0) \n        {\n            if (negative_l.back + positive_l.front == 0) \n\
    \            {\n                return true;\n            }\n            else\
    \ \n            {\n                return pairs_sum_to_zero(negative_l.dropRight(1))\
    \ || pairs_sum_to_zero(positive_l.dropFront(1));\n            }\n        }\n \
    \       else \n        {\n            return false;\n        }\n    }\n}\n/*",
  "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ 0 .. l.length)\n        {\n            if(i != j)\n            {\n         \
    \       if(l[i] + l[j] == 0)\n                {\n                    result =\
    \ true;\n                }\n            }\n        }\n    }\n    return result;\n\
    }", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        auto s = l.sort();\n        long i = 0;\n        long j = s.length\
    \ - 1;\n        while (i < j) \n        {\n            if (s[i] + s[j] == 0) \n\
    \            {\n                return true;\n            }\n            else\
    \ if (s[i] + s[j] < 0) \n            {\n                i++;\n            }\n\
    \            else \n            {\n                j--;\n            }\n     \
    \   }\n        return false;\n    }\n}\n/*", "{\n    bool result = false;\n  \
    \  foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n   \
    \     {\n            if(l[i] + l[j] == 0)\n            {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}\n/*", "{\n \
    \   auto s = l.sort();\n    for (int i = 0; i < s.length; i++)\n    {\n      \
    \  if (s[i] == 0)\n        {\n            if (i + 1 < s.length && s[i + 1] ==\
    \ 0)\n            {\n                return true;\n            }\n        }\n\
    \        else\n        {\n            if (s.binarySearch(-s[i]) != -1)\n     \
    \       {\n                return true;\n            }\n        }\n    }\n   \
    \ return false;\n}\n/*", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n\
    \    {\n        foreach(j; 0 .. l.length)\n        {\n            if(i != j)\n\
    \            {\n                if(l[i] + l[j] == 0)\n                {\n    \
    \                result = true;\n                }\n            }\n        }\n\
    \    }\n    return result;\n}\n/*", "{\n    bool result = false;\n    foreach(i;\
    \ 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n        {\n    \
    \        if(l[i] + l[j] == 0)\n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*", "{\n    bool result\
    \ = false;\n    long[] l2 = l.dup;\n    l2.sort;\n    foreach(long i; l2)\n  \
    \  {\n        if(l2.count(i) > 1)\n        {\n            result = true;\n   \
    \         break;\n        }\n        else if(l2.count(-i) > 0)\n        {\n  \
    \          result = true;\n            break;\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    long[]\
    \ sorted = l.dup.sort;\n    long[] neg = sorted.filter!(x => x < 0).array;\n \
    \   long[] pos = sorted.filter!(x => x >= 0).array;\n    bool found = false;\n\
    \    foreach (n; neg) \n    {\n        if (pos.canFind(x => x == -n)) \n     \
    \   {\n            found = true;\n            break;\n        }\n    }\n    return\
    \ found;\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n \
    \   }\n    else \n    {\n        long[] sorted = l.dup.sort;\n        foreach\
    \ (i; 0 .. sorted.length - 1) \n        {\n            if (sorted[i] + sorted[i\
    \ + 1] == 0) \n            {\n                return true;\n            }\n  \
    \      }\n        return false;\n    }\n}\n/*", "{\n    if (l.length < 2) \n \
    \   {\n        return false;\n    }\n    else \n    {\n        long[] sorted =\
    \ l.dup.sort;\n        for (int i = 0; i < sorted.length - 1; i++) \n        {\n\
    \            if (sorted[i] + sorted[i + 1] == 0) \n            {\n           \
    \     return true;\n            }\n        }\n        return false;\n    }\n}\n\
    /*", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        long[] sorted = l.dup.sort;\n        long[] neg = sorted.filter!(x\
    \ => x < 0).map!(x => -x).sort;\n        long[] pos = sorted.filter!(x => x >=\
    \ 0).sort;\n        return neg.pairs_sum_to_zero_helper(pos);\n    }\n}", "{\n\
    \    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ i+1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n\
    \                result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    bool ret = false;\n    foreach(i; 0 .. l.length)\n    {\n    \
    \    foreach(j; i + 1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n\
    \            {\n                ret = true;\n            }\n        }\n    }\n\
    \    return ret;\n}", "{\n    if (l.length < 2) \n    {\n        return false;\n\
    \    }\n    else \n    {\n        long[] sorted = l.dup.sort;\n        long[]\
    \ negative = sorted.filter!(x => x < 0).array;\n        long[] positive = sorted.filter!(x\
    \ => x > 0).array;\n        long[] zero = sorted.filter!(x => x == 0).array;\n\
    \        if (zero.length > 1) \n        {\n            return true;\n        }\n\
    \        else \n        {\n            foreach (long neg; negative) \n       \
    \     {\n                if (positive.binarySearch(abs(neg)) != -1) \n       \
    \         {\n                    return true;\n                }\n           \
    \ }\n            return false;\n        }\n    }\n}\n/*", "{\n    if (l.length\
    \ < 2)\n    {\n        return false;\n    }\n    long[] sorted = l.dup.sort;\n\
    \    long[] neg = sorted.filter!(x => x < 0).map!(x => -x);\n    long[] pos =\
    \ sorted.filter!(x => x >= 0);\n    return neg.any!(x => pos.binarySearch(x) !=\
    \ -1);\n}", "{\n    if (l.length < 2) return false;\n    auto s = l.sort();\n\
    \    foreach (i; 0 .. s.length - 1) \n    {\n        if (s[i] + s[i + 1] == 0)\
    \ return true;\n    }\n    return false;\n}\n/*", "{\n    long[] l2 = l.dup;\n\
    \    l2.sort;\n    long i = 0;\n    long j = l2.length - 1;\n    while (i < j)\
    \ {\n        if (l2[i] + l2[j] == 0) {\n            return true;\n        }\n\
    \        else if (l2[i] + l2[j] < 0) {\n            i++;\n        }\n        else\
    \ {\n            j--;\n        }\n    }\n    return false;\n}\n/*", "{\n    long[]\
    \ sorted = sort(l);\n    long[] negs = filter!(x => x < 0)(sorted);\n    long[]\
    \ poss = filter!(x => x >= 0)(sorted);\n    long[] negs_reversed = negs.reverse;\n\
    \    long[] poss_reversed = poss.reverse;\n    long[] negs_reversed_and_poss =\
    \ negs_reversed ~ poss;\n    long[] poss_reversed_and_negs = poss_reversed ~ negs;\n\
    \    long[] negs_reversed_and_poss_reversed = negs_reversed ~ poss_reversed;\n\
    \    long[] poss_reversed_and_negs_reversed = poss_reversed ~ negs_reversed;\n\
    \    return (negs_reversed_and_poss.length > 1 && negs_reversed_and_poss[0] +\
    \ negs_reversed_and_poss[1] == 0) || (poss_reversed_and_negs.length > 1 && poss_reversed_and_negs[0]\
    \ + poss_reversed_and_negs[1] == 0) || (negs_reversed_and_poss_reversed.length\
    \ > 1 && negs_reversed_and_poss_reversed[0] + negs_reversed_and_poss_reversed[1]\
    \ == 0) || (poss_reversed_and_negs_reversed.length > 1 && poss_reversed_and_negs_reversed[0]\
    \ + poss_reversed_and_negs_reversed[1] == 0);\n}\n/*", "{\n    if (l.length <\
    \ 2) \n    {\n        return false;\n    }\n    else \n    {\n        long[] sorted\
    \ = l.dup.sort;\n        long[] neg = sorted.filter!(x => x < 0).map!(x => -x);\n\
    \        long[] pos = sorted.filter!(x => x >= 0);\n        long[] neg_sorted\
    \ = neg.sort;\n        long[] pos_sorted = pos.sort;\n        int i = 0;\n   \
    \     int j = 0;\n        while (i < neg_sorted.length && j < pos_sorted.length)\
    \ \n        {\n            if (neg_sorted[i] == pos_sorted[j]) \n            {\n\
    \                return true;\n            }\n            else if (neg_sorted[i]\
    \ < pos_sorted[j]) \n            {\n                i += 1;\n            }\n \
    \           else \n            {\n                j += 1;\n            }\n   \
    \     }\n        return false;\n    }\n}\n/*", "{\n    bool found = false;\n \
    \   foreach(long i; l)\n    {\n        foreach(long j; l)\n        {\n       \
    \     if(i + j == 0)\n            {\n                found = true;\n         \
    \   }\n        }\n    }\n    return found;\n}\n/*", "{\n    if (l.length < 2)\
    \ \n    {\n        return false;\n    }\n    else \n    {\n        long[] sorted\
    \ = l.sort();\n        long[] negs = sorted.filter!(x => x < 0);\n        long[]\
    \ poss = sorted.filter!(x => x > 0);\n        foreach (n; negs) \n        {\n\
    \            foreach (p; poss) \n            {\n                if (n + p == 0)\
    \ \n                {\n                    return true;\n                }\n \
    \           }\n        }\n        return false;\n    }\n}", "{\n    if (l.length\
    \ < 2) return false;\n    long[] sorted = l.dup.sort();\n    long i = 0;\n   \
    \ long j = sorted.length - 1;\n    while (i < j) \n    {\n        long sum = sorted[i]\
    \ + sorted[j];\n        if (sum == 0) return true;\n        if (sum < 0) i +=\
    \ 1;\n        else j -= 1;\n    }\n    return false;\n}", "{\n    long[] sorted\
    \ = l.dup.sort;\n    long[] neg = sorted.filter!(x => x < 0);\n    long[] pos\
    \ = sorted.filter!(x => x > 0);\n    foreach(n; neg)\n    {\n        foreach(p;\
    \ pos)\n        {\n            if (n + p == 0)\n            {\n              \
    \  return true;\n            }\n        }\n    }\n    return false;\n}", "{\n\
    \    if (l.length < 2) \n    {\n        return false;\n    }\n    else \n    {\n\
    \        long[] sorted = l.dup.sort;\n        long[] neg = sorted.filter!(x =>\
    \ x < 0);\n        long[] pos = sorted.filter!(x => x > 0);\n        if (neg.length\
    \ > 0 && pos.length > 0) \n        {\n            if (neg.back + pos.front ==\
    \ 0) \n            {\n                return true;\n            }\n          \
    \  else \n            {\n                return pairs_sum_to_zero(neg.dropOne)\
    \ || pairs_sum_to_zero(pos.dropOne);\n            }\n        }\n        else \n\
    \        {\n            return false;\n        }\n    }\n}\n/*", "{\n    bool\
    \ result = false;\n    foreach(i; 0 .. l.length) \n    {\n        foreach(j; i+1\
    \ .. l.length) \n        {\n            if(l[i] + l[j] == 0) \n            {\n\
    \                result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        long[] sorted = l.dup.sort();\n        long[] negs = sorted.filter!(x\
    \ => x < 0).array;\n        long[] poss = sorted.filter!(x => x >= 0).array;\n\
    \        if (negs.length > 0 && poss.length > 0) \n        {\n            if (negs[0]\
    \ == -poss[0]) \n            {\n                return true;\n            }\n\
    \            else \n            {\n                return pairs_sum_to_zero(negs[1..$])\
    \ || pairs_sum_to_zero(poss[1..$]);\n            }\n        }\n        else \n\
    \        {\n            return false;\n        }\n    }\n}\n/*", "{\n    if (l.length\
    \ < 2)\n    {\n        return false;\n    }\n    else\n    {\n        long[] l2\
    \ = l[1 .. $];\n        foreach (i; l2)\n        {\n            if (l[0] + i ==\
    \ 0)\n            {\n                return true;\n            }\n        }\n\
    \        return pairs_sum_to_zero(l2);\n    }\n}\n/*", "{\n    bool found = false;\n\
    \    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n \
    \       {\n            if(l[i] + l[j] == 0)\n            {\n                found\
    \ = true;\n            }\n        }\n    }\n    return found;\n}", "{\n    long[]\
    \ sorted = l.dup.sort;\n    long[] negs = sorted.filter!(a => a < 0);\n    long[]\
    \ poss = sorted.filter!(a => a > 0);\n    long[] zeros = sorted.filter!(a => a\
    \ == 0);\n    if (zeros.length > 1) \n    {\n        return true;\n    }\n   \
    \ foreach (n; negs) \n    {\n        if (poss.canFind(a => a == -n)) \n      \
    \  {\n            return true;\n        }\n    }\n    return false;\n}\n/*", "{\n\
    \    auto s = l.length;\n    if (s < 2) \n    {\n        return false;\n    }\n\
    \    else \n    {\n        foreach (i; 0 .. s) \n        {\n            foreach\
    \ (j; i + 1 .. s) \n            {\n                if (l[i] + l[j] == 0) \n  \
    \              {\n                    return true;\n                }\n      \
    \      }\n        }\n        return false;\n    }\n}", "{\n    bool result = false;\n\
    \    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n \
    \       {\n            if(l[i] + l[j] == 0)\n            {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}\n/*", "{\n \
    \   if (l.length < 2)\n    {\n        return false;\n    }\n    else\n    {\n\
    \        foreach (i; l)\n        {\n            foreach (j; l)\n            {\n\
    \                if (i + j == 0 && i != j)\n                {\n              \
    \      return true;\n                }\n            }\n        }\n        return\
    \ false;\n    }\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    long i = 0;\n\
    \    long j = l2.length - 1;\n    while (i < j) \n    {\n        if (l2[i] + l2[j]\
    \ == 0) \n        {\n            return true;\n        }\n        else if (l2[i]\
    \ + l2[j] < 0) \n        {\n            i++;\n        }\n        else \n     \
    \   {\n            j--;\n        }\n    }\n    return false;\n}", "{\n    long[]\
    \ sorted = l.dup.sort;\n    long[] negative = sorted.filter!(a => a < 0);\n  \
    \  long[] positive = sorted.filter!(a => a > 0);\n    long[] zero = sorted.filter!(a\
    \ => a == 0);\n    if (zero.length > 1)\n        return true;\n    for (long i\
    \ = 0; i < negative.length; i++)\n    {\n        if (positive.canFind(a => a ==\
    \ -negative[i]))\n            return true;\n    }\n    return false;\n}", "{\n\
    \    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n    {\n\
    \        long[] sorted = l.sort();\n        long[] negative = sorted.filter!(x\
    \ => x < 0);\n        long[] positive = sorted.filter!(x => x > 0);\n        foreach\
    \ (n; negative)\n        {\n            if (positive.canFind(-n))\n          \
    \  {\n                return true;\n            }\n        }\n        return false;\n\
    \    }\n}\n/*", "{\n    if (l.length < 2)\n    {\n        return false;\n    }\n\
    \    else\n    {\n        long[] l2 = l.dup;\n        l2.sort;\n        foreach\
    \ (i; 0 .. l2.length)\n        {\n            if (l2[i] == 0)\n            {\n\
    \                if (i + 1 < l2.length)\n                {\n                 \
    \   if (l2[i + 1] == 0)\n                    {\n                        return\
    \ true;\n                    }\n                }\n            }\n           \
    \ else\n            {\n                if (l2.binarySearch(l2[i] * -1) != -1)\n\
    \                {\n                    return true;\n                }\n    \
    \        }\n        }\n        return false;\n    }\n}", "{\n    if (l.length\
    \ < 2)\n    {\n        return false;\n    }\n    else\n    {\n        long[] sorted\
    \ = l.sort();\n        long[] negs = sorted.filter!(x => x < 0);\n        long[]\
    \ poss = sorted.filter!(x => x > 0);\n        if (negs.length == 0 || poss.length\
    \ == 0)\n        {\n            return false;\n        }\n        else\n     \
    \   {\n            long[] negs_reversed = negs.reverse();\n            foreach\
    \ (long neg; negs_reversed)\n            {\n                foreach (long pos;\
    \ poss)\n                {\n                    if (neg + pos == 0)\n        \
    \            {\n                        return true;\n                    }\n\
    \                }\n            }\n            return false;\n        }\n    }\n\
    }", "{\n    return l.length > 1 && l.length < 3 && l[0] + l[1] == 0;\n}\n/*",
  "{\n    long[] sorted = l.dup.sort;\n    long i = 0L;\n    long j = sorted.length\
    \ - 1L;\n    while (i < j)\n    {\n        long sum = sorted[i] + sorted[j];\n\
    \        if (sum == 0L)\n        {\n            return true;\n        }\n    \
    \    else if (sum < 0L)\n        {\n            i += 1L;\n        }\n        else\n\
    \        {\n            j -= 1L;\n        }\n    }\n    return false;\n}\n/*",
  "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ i + 1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n          \
    \  {\n                result = true;\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] sorted = l.dup.sort;\n    long[] negs = sorted.filter!(x\
    \ => x < 0);\n    long[] pos = sorted.filter!(x => x > 0);\n    foreach(n; negs)\
    \ {\n        foreach(p; pos) {\n            if(n + p == 0) {\n               \
    \ return true;\n            }\n        }\n    }\n    return false;\n}", "{\n \
    \   if (l.length < 2)\n    {\n        return false;\n    }\n    else\n    {\n\
    \        long[] sorted_l = l.dup.sort;\n        long[] negative_l = sorted_l.filter!(a\
    \ => a < 0);\n        long[] positive_l = sorted_l.filter!(a => a > 0);\n    \
    \    foreach (long i; negative_l)\n        {\n            foreach (long j; positive_l)\n\
    \            {\n                if (i + j == 0)\n                {\n         \
    \           return true;\n                }\n            }\n        }\n      \
    \  return false;\n    }\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return\
    \ false;\n    }\n    else \n    {\n        long[] l1 = l[0..$-1];\n        long[]\
    \ l2 = l[1..$];\n        return pairs_sum_to_zero(l1) || pairs_sum_to_zero(l2)\
    \ || (l1.length > 0 && l2.length > 0 && l1[0] + l2[0] == 0);\n    }\n}\n/*", "{\n\
    \    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n    {\n\
    \        foreach (i; l)\n        {\n            foreach (j; l)\n            {\n\
    \                if (i != j && i + j == 0)\n                {\n              \
    \      return true;\n                }\n            }\n        }\n        return\
    \ false;\n    }\n}", "{\n    if (l.length < 2) \n    {\n        return false;\n\
    \    }\n    else \n    {\n        long[] l2 = l.dup;\n        l2.sort;\n     \
    \   long i = 0L;\n        while (i < l2.length) \n        {\n            long\
    \ j = i + 1L;\n            while (j < l2.length) \n            {\n           \
    \     if (l2[i] + l2[j] == 0L) \n                {\n                    return\
    \ true;\n                }\n                j += 1L;\n            }\n        \
    \    i += 1L;\n        }\n        return false;\n    }\n}\n/*", "{\n    bool ret\
    \ = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n\
    \        {\n            if(l[i] + l[j] == 0)\n            {\n                ret\
    \ = true;\n            }\n        }\n    }\n    return ret;\n}\n/*", "{\n    if\
    \ (l.length < 2) \n    {\n        return false;\n    }\n    else \n    {\n   \
    \     long[] sorted = l.dup.sort();\n        long[] negs = sorted.filter!(x =>\
    \ x < 0);\n        long[] poss = sorted.filter!(x => x > 0);\n        long[] zeros\
    \ = sorted.filter!(x => x == 0);\n        if (zeros.length > 1) \n        {\n\
    \            return true;\n        }\n        else \n        {\n            foreach\
    \ (n; negs) \n            {\n                if (poss.canFind(-n)) \n        \
    \        {\n                    return true;\n                }\n            }\n\
    \            return false;\n        }\n    }\n}", "{\n    if (l.length < 2) \n\
    \    {\n        return false;\n    }\n    else \n    {\n        long[] sorted\
    \ = l.dup.sort;\n        long[] negs = sorted.filter!(x => x < 0).map!(x => -x);\n\
    \        long[] poss = sorted.filter!(x => x >= 0);\n        long[] neg_poss =\
    \ negs.zip(poss);\n        return neg_poss.any!(x => x[0] == x[1]);\n    }\n}",
  "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ i+1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n\
    \                result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        long[] sorted_l = l.sort();\n        long[] negative_l = sorted_l.filter!(x\
    \ => x < 0L);\n        long[] positive_l = sorted_l.filter!(x => x > 0L);\n  \
    \      foreach (n; negative_l) \n        {\n            if (positive_l.canFind(x\
    \ => x == -n)) \n            {\n                return true;\n            }\n\
    \        }\n        return false;\n    }\n}\n/*", "{\n    if (l.length < 2) \n\
    \    {\n        return false;\n    }\n    else \n    {\n        long[] sorted\
    \ = l.dup.sort;\n        long[] negs = sorted.filter!(x => x < 0);\n        long[]\
    \ poss = sorted.filter!(x => x > 0);\n        if (negs.length > 0 && poss.length\
    \ > 0) \n        {\n            long last_neg = negs[negs.length - 1];\n     \
    \       long first_pos = poss[0];\n            return last_neg + first_pos ==\
    \ 0;\n        }\n        else \n        {\n            return false;\n       \
    \ }\n    }\n}", "{\n    if (l.length < 2) \n    {\n        return false;\n   \
    \ }\n    else \n    {\n        long[] sorted = l.sort();\n        long[] neg =\
    \ sorted.filter!(x => x < 0);\n        long[] pos = sorted.filter!(x => x > 0);\n\
    \        long[] zeros = sorted.filter!(x => x == 0);\n        if (zeros.length\
    \ > 1) \n        {\n            return true;\n        }\n        else \n     \
    \   {\n            foreach (n; neg) \n            {\n                if (pos.binarySearch(n\
    \ * -1) != -1) \n                {\n                    return true;\n       \
    \         }\n            }\n            return false;\n        }\n    }\n}\n/*",
  "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else \n   \
    \ {\n        long[] sorted = l.sort();\n        long[] negative = sorted.filter!(x\
    \ => x < 0);\n        long[] positive = sorted.filter!(x => x > 0);\n        if\
    \ (negative.length == 0 || positive.length == 0) \n        {\n            return\
    \ false;\n        }\n        else \n        {\n            long[] negative_squared\
    \ = negative.map!(x => x * x);\n            long[] positive_squared = positive.map!(x\
    \ => x * x);\n            return negative_squared.any!(x => positive_squared.contains(x));\n\
    \        }\n    }\n}", "{\n    long[] sorted = l.dup.sort;\n    long i = 0;\n\
    \    long j = sorted.length - 1;\n    while (i < j) \n    {\n        if (sorted[i]\
    \ + sorted[j] == 0) \n        {\n            return true;\n        }\n       \
    \ else if (sorted[i] + sorted[j] < 0) \n        {\n            i++;\n        }\n\
    \        else \n        {\n            j--;\n        }\n    }\n    return false;\n\
    }\n/*", "{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int n = l.length;\n\
    \    for (i = 0; i < n; i++) \n    {\n        for (j = i + 1; j < n; j++) \n \
    \       {\n            if (l[i] + l[j] == 0) \n            {\n               \
    \ return true;\n            }\n        }\n    }\n    return false;\n}\n/*", "{\n\
    \    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ i + 1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n          \
    \  {\n                result = true;\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    long i = 0L;\n\
    \    long j = l2.length - 1L;\n    while (i < j)\n    {\n        long sum = l2[i]\
    \ + l2[j];\n        if (sum == 0L)\n        {\n            return true;\n    \
    \    }\n        else if (sum < 0L)\n        {\n            i += 1L;\n        }\n\
    \        else\n        {\n            j -= 1L;\n        }\n    }\n    return false;\n\
    }\n/*", "{\n    int n = l.length;\n    if (n < 2)\n        return false;\n   \
    \ else\n    {\n        int i = 0;\n        int j = n - 1;\n        while (i <\
    \ j)\n        {\n            if (l[i] + l[j] == 0)\n                return true;\n\
    \            else if (l[i] + l[j] < 0)\n                i++;\n            else\n\
    \                j--;\n        }\n        return false;\n    }\n}\n/*", "{\n \
    \   if (l.length < 2)\n    {\n        return false;\n    }\n    else\n    {\n\
    \        long[] sorted = l.sort();\n        long[] negs = sorted.filter!(x =>\
    \ x < 0);\n        long[] poss = sorted.filter!(x => x > 0);\n        if (negs.length\
    \ == 0 || poss.length == 0)\n        {\n            return false;\n        }\n\
    \        else\n        {\n            long[] negs_abs = negs.map!(x => abs(x));\n\
    \            long[] poss_abs = poss.map!(x => abs(x));\n            long[] negs_abs_sorted\
    \ = negs_abs.sort();\n            long[] poss_abs_sorted = poss_abs.sort();\n\
    \            long[] negs_abs_sorted_rev = negs_abs_sorted.reverse();\n       \
    \     long[] poss_abs_sorted_rev = poss_abs_sorted.reverse();\n            long[]\
    \ negs_abs_sorted_rev_poss_abs_sorted = negs_abs_sorted_rev ~ poss_abs_sorted;\n\
    \            long[] poss_abs_sorted_rev_negs_abs_sorted = poss_abs_sorted_rev\
    \ ~ negs_abs_sorted;\n            long[] negs_abs_sorted_rev_poss_abs_sorted_rev\
    \ = negs_abs_sorted_rev ~ poss_abs_sorted_rev;\n            long[] poss_abs_sorted_rev_negs_abs_sorted_rev\
    \ = poss_abs_sorted_rev ~ negs_abs_sorted_rev;\n            long[] negs_abs_sorted_rev_poss_abs_sorted_rev_negs_abs_sorted\
    \ = negs_abs_sorted_rev_poss_abs_sorted ~ negs_abs_sorted;\n            long[]\
    \ poss_abs_sorted_rev_negs_abs_sorted_rev_poss_abs_sorted = poss_abs_sorted_rev_negs_abs_sorted\
    \ ~ poss_abs_sorted;\n            long[] negs_", "{\n    long[] sorted = l.dup.sort;\n\
    \    long[] unique = sorted.dup.uniq;\n    long[] neg = unique.filter!(a => a\
    \ < 0);\n    long[] pos = unique.filter!(a => a > 0);\n    return neg.any!(a =>\
    \ pos.any!(b => a + b == 0));\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
