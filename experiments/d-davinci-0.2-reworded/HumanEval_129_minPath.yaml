name: HumanEval_129_minPath
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given a grid with N rows\
  \ and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains\
  \ a value. Every integer in the range [1, N * N]\n    inclusive appears exactly\
  \ once on the cells of the grid.\n\n    You have to find the minimum path of length\
  \ k in the grid. You can start\n    from any cell, and in each step you can move\
  \ to any of the neighbor cells,\n    in other words, you can go to cells which share\
  \ an edge with you current\n    cell.\n    Please note that a path of length k means\
  \ visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off\
  \ the grid.\n    A path A (of length k) is considered less than a path B (of length\
  \ k) if\n    after making the ordered arrays of the values on the cells that A and\
  \ B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically\
  \ less\n    than lst_B, in other words, there exist an integer index i (1 <= i <=\
  \ k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n   \
  \ lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return\
  \ an ordered array of the values on the cells that the minimum path go through.\n\
  \    \n    >>> minPath([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]], 3L)\n    [1L,\
  \ 2L, 1L]\n\n    >>> minPath([[5L, 9L, 3L], [4L, 1L, 6L], [7L, 8L, 2L]], 1L)\n \
  \   [1L]\n    \n*/\nlong[] minPath(long[][] grid, long k) \n"
tests: "unittest\n{\n    alias candidate = minPath;\n\n    assert(candidate([[1L,\
  \ 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]], 3L) == [1L, 2L, 1L]);\n    assert(candidate([[5L,\
  \ 9L, 3L], [4L, 1L, 6L], [7L, 8L, 2L]], 1L) == [1L]);\n    assert(candidate([[1L,\
  \ 2L, 3L, 4L], [5L, 6L, 7L, 8L], [9L, 10L, 11L, 12L], [13L, 14L, 15L, 16L]], 4L)\
  \ == [1L, 2L, 1L, 2L]);\n    assert(candidate([[6L, 4L, 13L, 10L], [5L, 7L, 12L,\
  \ 1L], [3L, 16L, 11L, 15L], [8L, 14L, 9L, 2L]], 7L) == [1L, 10L, 1L, 10L, 1L, 10L,\
  \ 1L]);\n    assert(candidate([[8L, 14L, 9L, 2L], [6L, 4L, 13L, 15L], [5L, 7L, 1L,\
  \ 12L], [3L, 10L, 11L, 16L]], 5L) == [1L, 7L, 1L, 7L, 1L]);\n    assert(candidate([[11L,\
  \ 8L, 7L, 2L], [5L, 16L, 14L, 4L], [9L, 3L, 15L, 6L], [12L, 13L, 10L, 1L]], 9L)\
  \ == [1L, 6L, 1L, 6L, 1L, 6L, 1L, 6L, 1L]);\n    assert(candidate([[12L, 13L, 10L,\
  \ 1L], [9L, 3L, 15L, 6L], [5L, 16L, 14L, 4L], [11L, 8L, 7L, 2L]], 12L) == [1L, 6L,\
  \ 1L, 6L, 1L, 6L, 1L, 6L, 1L, 6L, 1L, 6L]);\n    assert(candidate([[2L, 7L, 4L],\
  \ [3L, 1L, 5L], [6L, 8L, 9L]], 8L) == [1L, 3L, 1L, 3L, 1L, 3L, 1L, 3L]);\n    assert(candidate([[6L,\
  \ 1L, 5L], [3L, 8L, 9L], [2L, 7L, 4L]], 8L) == [1L, 5L, 1L, 5L, 1L, 5L, 1L, 5L]);\n\
  \    assert(candidate([[1L, 2L], [3L, 4L]], 10L) == [1L, 2L, 1L, 2L, 1L, 2L, 1L,\
  \ 2L, 1L, 2L]);\n    assert(candidate([[1L, 3L], [3L, 2L]], 10L) == [1L, 3L, 1L,\
  \ 3L, 1L, 3L, 1L, 3L, 1L, 3L]);\n}\nvoid main(){}"
completions: ["{\n    int n = grid.length;\n    int[][] dp = new int[n][n];\n    for\
    \ (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j]\
    \ = -1;\n    int[][] parent = new int[n][n];\n    for (int i = 0; i < n; i++)\n\
    \        for (int j = 0; j < n; j++)\n            parent[i][j] = -1;\n    int[][]\
    \ dir = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    dp[0][0] = 0;\n  \
    \  parent[0][0] = -1;\n    for (int i = 0; i < n; i++)\n        for (int j = 0;\
    \ j < n; j++)\n            for (int[] d : dir)\n            {\n              \
    \  int x = i + d[0];\n                int y = j + d[1];\n                if (x\
    \ < 0 || x >= n || y < 0 || y >= n)\n                    continue;\n         \
    \       if (dp[x][y] == -1 || dp[x][y] > dp[i][j] + 1)\n                {\n  \
    \                  dp[x][y] = dp[i][j] + 1;\n                    parent[x][y]\
    \ = i * n + j;\n                }\n                else if (dp[x][y] == dp[i][j]\
    \ + 1)\n                {\n                    if (grid[x][y] < grid[i][j])\n\
    \                    {\n                        parent[x][y] = i * n + j;\n  \
    \                  }\n                }\n            }\n    int[] path = new int[(int)k];\n\
    \    int cur = n * n - 1;\n    for (int i = (int)k - 1; i >= 0; i--)\n    {\n\
    \        path[i] = cur;\n        cur = parent[cur / n][cur % n];\n    }\n    long[]\
    \ res = new long[(int)k];\n    for (int", "{\n    int n = grid.length;\n    int[][]\
    \ dp = new int[n][n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0;\
    \ j < n; j++)\n            dp[i][j] = -1;\n    int[] res = new int[(int)k];\n\
    \    int[] min = new int[(int)k];\n    for (int i = 0; i < k; i++)\n        min[i]\
    \ = int.max;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n;\
    \ j++)\n            if (grid[i][j] == 1)\n                dfs(grid, dp, i, j,\
    \ k, res, 0, min);\n    return min.map!(a => a).array;\n}", "{\n    int N = grid.length;\n\
    \    int[][] dp = new int[N][N];\n    for (int i = 0; i < N; i++)\n        for\
    \ (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n\
    \    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n      \
    \  {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i -\
    \ 1][j] + 1);\n            if (j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + 1);\n        }\n    int[][] dp2 = new int[N][N];\n    for (int\
    \ i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp2[i][j]\
    \ = int.max;\n    dp2[N - 1][N - 1] = 0;\n    for (int i = N - 1; i >= 0; i--)\n\
    \        for (int j = N - 1; j >= 0; j--)\n        {\n            if (i < N -\
    \ 1)\n                dp2[i][j] = min(dp2[i][j], dp2[i + 1][j] + 1);\n       \
    \     if (j < N - 1)\n                dp2[i][j] = min(dp2[i][j], dp2[i][j + 1]\
    \ + 1);\n        }\n    int[][] dp3 = new int[N][N];\n    for (int i = 0; i <\
    \ N; i++)\n        for (int j = 0; j < N; j++)\n            dp3[i][j] = dp[i][j]\
    \ + dp2[i][j];\n    int[][] dp4 = new int[N][N];\n    for (int i = 0; i < N; i++)\n\
    \        for (", "{\n    // TODO: Implement this function\n    return null;\n}",
  "{\n    long n = grid.length;\n    long[][] dp = new long[n][n];\n    foreach(i;\
    \ 0 .. n)\n        foreach(j; 0 .. n)\n            dp[i][j] = long.max;\n    dp[0][0]\
    \ = grid[0][0];\n    foreach(i; 0 .. n)\n        foreach(j; 0 .. n)\n        {\n\
    \            if(i > 0)\n                dp[i][j] = min(dp[i][j], dp[i - 1][j]\
    \ + grid[i][j]);\n            if(j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + grid[i][j]);\n        }\n    long[] ans = new long[k];\n    long\
    \ cur = dp[n - 1][n - 1];\n    ans[$ - 1] = grid[n - 1][n - 1];\n    long i =\
    \ n - 1;\n    long j = n - 1;\n    foreach(x; k - 1 .. 0)\n    {\n        if(i\
    \ > 0 && dp[i - 1][j] + grid[i][j] == cur)\n        {\n            cur -= grid[i][j];\n\
    \            ans[x] = grid[i - 1][j];\n            i--;\n        }\n        else\n\
    \        {\n            cur -= grid[i][j];\n            ans[x] = grid[i][j - 1];\n\
    \            j--;\n        }\n    }\n    return ans;\n}", "{\n    int N = grid.length;\n\
    \    int[][] dp = new int[N][N];\n    int[][] prev = new int[N][N];\n    for (int\
    \ i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j]\
    \ = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for\
    \ (int j = 0; j < N; j++)\n        {\n            if (i > 0 && dp[i][j] + grid[i\
    \ - 1][j] < dp[i - 1][j])\n            {\n                dp[i - 1][j] = dp[i][j]\
    \ + grid[i - 1][j];\n                prev[i - 1][j] = 1;\n            }\n    \
    \        if (j > 0 && dp[i][j] + grid[i][j - 1] < dp[i][j - 1])\n            {\n\
    \                dp[i][j - 1] = dp[i][j] + grid[i][j - 1];\n                prev[i][j\
    \ - 1] = 2;\n            }\n            if (i < N - 1 && dp[i][j] + grid[i + 1][j]\
    \ < dp[i + 1][j])\n            {\n                dp[i + 1][j] = dp[i][j] + grid[i\
    \ + 1][j];\n                prev[i + 1][j] = 3;\n            }\n            if\
    \ (j < N - 1 && dp[i][j] + grid[i][j + 1] < dp[i][j + 1])\n            {\n   \
    \             dp[i][j + 1] = dp[i][j] + grid[i][j + 1];\n                prev[i][j\
    \ + 1] = 4;\n            }\n        }\n    int[] path = new int[k];\n    int x\
    \ = N - 1, y = N - 1;\n    for (int i = 0; i < k; i++)\n    {\n        path[i]",
  "{\n    long n = grid.length;\n    long[][] dp = new long[n][n];\n    long[][] prev\
    \ = new long[n][n];\n    foreach(i; 0 .. n)\n    {\n        foreach(j; 0 .. n)\n\
    \        {\n            dp[i][j] = long.max;\n            prev[i][j] = -1;\n \
    \       }\n    }\n    dp[0][0] = grid[0][0];\n    foreach(i; 0 .. n)\n    {\n\
    \        foreach(j; 0 .. n)\n        {\n            if (i > 0 && dp[i][j] > dp[i\
    \ - 1][j] + grid[i][j])\n            {\n                dp[i][j] = dp[i - 1][j]\
    \ + grid[i][j];\n                prev[i][j] = 0;\n            }\n            if\
    \ (j > 0 && dp[i][j] > dp[i][j - 1] + grid[i][j])\n            {\n           \
    \     dp[i][j] = dp[i][j - 1] + grid[i][j];\n                prev[i][j] = 1;\n\
    \            }\n            if (i < n - 1 && dp[i][j] > dp[i + 1][j] + grid[i][j])\n\
    \            {\n                dp[i][j] = dp[i + 1][j] + grid[i][j];\n      \
    \          prev[i][j] = 2;\n            }\n            if (j < n - 1 && dp[i][j]\
    \ > dp[i][j + 1] + grid[i][j])\n            {\n                dp[i][j] = dp[i][j\
    \ + 1] + grid[i][j];\n                prev[i][j] = 3;\n            }\n       \
    \ }\n    }\n    long[] res = new long[k];\n    long i = n - 1;\n    long j = n\
    \ - 1;\n    foreach(k; k .. 0)\n    {\n        res[k] = grid[i][j];", "{\n   \
    \ import std.algorithm : min, max;\n    import std.range : iota;\n    import std.array\
    \ : array;\n    import std.typecons : tuple;\n    import std.conv : to;\n    import\
    \ std.math : floor;\n    import std.algorithm : sort;\n    import std.algorithm\
    \ : map;\n    import std.algorithm : filter;\n    import std.algorithm : zip;\n\
    \    import std.algorithm : reduce;\n    import std.algorithm : each;\n    import\
    \ std.algorithm : take;\n    import std.algorithm : drop;\n    import std.algorithm\
    \ : takeExactly;\n    import std.algorithm : dropExactly;\n    import std.algorithm\
    \ : minElement;\n    import std.algorithm : maxElement;\n    import std.algorithm\
    \ : minPos;\n    import std.algorithm : maxPos;\n    import std.algorithm : minElement;\n\
    \    import std.algorithm : maxElement;\n    import std.algorithm : minPos;\n\
    \    import std.algorithm : maxPos;\n    import std.algorithm : minElement;\n\
    \    import std.algorithm : maxElement;\n    import std.algorithm : minPos;\n\
    \    import std.algorithm : maxPos;\n    import std.algorithm : minElement;\n\
    \    import std.algorithm : maxElement;\n    import std.algorithm : minPos;\n\
    \    import std.algorithm : maxPos;\n    import std.algorithm : minElement;\n\
    \    import std.algorithm : maxElement;\n    import std.algorithm : minPos;\n\
    \    import std.algorithm : maxPos;\n    import std.algorithm : minElement;\n\
    \    import std.algorithm : maxElement;\n    import std.algorithm : minPos;\n\
    \    import std.algorithm : maxPos;\n    import std.algorithm : minElement;\n\
    \    import std.algorithm : maxElement;\n    import std.algorithm : minPos;\n\
    \    import std.algorithm : maxPos;\n    import std.algorithm : minElement;\n\
    \    import std.algorithm : maxElement;\n    import std.algorithm : minPos;\n\
    \    import std.algorithm :", "{\n    // Write your code here\n    auto n = grid.length;\n\
    \    auto m = grid[0].length;\n    auto dp = new long[][](n, m);\n    foreach\
    \ (i; 0 .. n)\n    {\n        foreach (j; 0 .. m)\n        {\n            dp[i][j]\
    \ = grid[i][j];\n        }\n    }\n    foreach (i; 1 .. n)\n    {\n        dp[i][0]\
    \ += dp[i - 1][0];\n    }\n    foreach (j; 1 .. m)\n    {\n        dp[0][j] +=\
    \ dp[0][j - 1];\n    }\n    foreach (i; 1 .. n)\n    {\n        foreach (j; 1\
    \ .. m)\n        {\n            dp[i][j] += min(dp[i - 1][j], dp[i][j - 1]);\n\
    \        }\n    }\n    auto res = new long[k];\n    auto i = n - 1;\n    auto\
    \ j = m - 1;\n    foreach (idx; k .. 0)\n    {\n        res[idx] = grid[i][j];\n\
    \        if (i == 0)\n        {\n            j--;\n        }\n        else if\
    \ (j == 0)\n        {\n            i--;\n        }\n        else\n        {\n\
    \            if (dp[i - 1][j] < dp[i][j - 1])\n            {\n               \
    \ i--;\n            }\n            else\n            {\n                j--;\n\
    \            }\n        }\n    }\n    return res;\n}", "{\n    int N = grid.length;\n\
    \    int[][] dp = new int[N][N];\n    int[][] path = new int[N][N];\n    for (int\
    \ i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n\
    \            dp[i][j] = int.max;\n            path[i][j] = -1;\n        }\n  \
    \  }\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n    {\n        for (int\
    \ j = 0; j < N; j++)\n        {\n            if (i > 0 && dp[i][j] + grid[i -\
    \ 1][j] < dp[i - 1][j])\n            {\n                dp[i - 1][j] = dp[i][j]\
    \ + grid[i - 1][j];\n                path[i - 1][j] = 0;\n            }\n    \
    \        if (j > 0 && dp[i][j] + grid[i][j - 1] < dp[i][j - 1])\n            {\n\
    \                dp[i][j - 1] = dp[i][j] + grid[i][j - 1];\n                path[i][j\
    \ - 1] = 1;\n            }\n            if (i < N - 1 && dp[i][j] + grid[i + 1][j]\
    \ < dp[i + 1][j])\n            {\n                dp[i + 1][j] = dp[i][j] + grid[i\
    \ + 1][j];\n                path[i + 1][j] = 2;\n            }\n            if\
    \ (j < N - 1 && dp[i][j] + grid[i][j + 1] < dp[i][j + 1])\n            {\n   \
    \             dp[i][j + 1] = dp[i][j] + grid[i][j + 1];\n                path[i][j\
    \ + 1] = 3;\n            }\n        }\n    }\n    long[] res = new long[k];\n\
    \    int i = N - 1;", "{\n    int n = grid.length;\n    int[][] dp = new int[n][n];\n\
    \    int[][] prev = new int[n][n];\n    for (int i = 0; i < n; i++)\n        for\
    \ (int j = 0; j < n; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n\
    \    prev[0][0] = -1;\n    for (int i = 0; i < n; i++)\n        for (int j = 0;\
    \ j < n; j++)\n        {\n            if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i - 1][j] + 1;\n               \
    \ prev[i][j] = i * n + j - n;\n            }\n            if (j > 0 && dp[i][j\
    \ - 1] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j - 1]\
    \ + 1;\n                prev[i][j] = i * n + j - 1;\n            }\n         \
    \   if (i < n - 1 && dp[i + 1][j] + 1 < dp[i][j])\n            {\n           \
    \     dp[i][j] = dp[i + 1][j] + 1;\n                prev[i][j] = i * n + j + n;\n\
    \            }\n            if (j < n - 1 && dp[i][j + 1] + 1 < dp[i][j])\n  \
    \          {\n                dp[i][j] = dp[i][j + 1] + 1;\n                prev[i][j]\
    \ = i * n + j + 1;\n            }\n        }\n    long[] res = new long[(int)k];\n\
    \    int cur = 0;\n    for (int i = 0; i < k; i++)\n    {\n        res[i] = grid[cur\
    \ / n][cur % n];\n        cur = prev[cur / n][cur % n];\n    }\n", "{\n    long\
    \ n = grid.length;\n    long[][] dp = new long[n][n];\n    long[][] prev = new\
    \ long[n][n];\n    long[][] next = new long[n][n];\n    for (long i = 0; i < n;\
    \ i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n            dp[i][j]\
    \ = grid[i][j];\n            prev[i][j] = -1;\n            next[i][j] = -1;\n\
    \        }\n    }\n    for (long step = 1; step < k; step++)\n    {\n        for\
    \ (long i = 0; i < n; i++)\n        {\n            for (long j = 0; j < n; j++)\n\
    \            {\n                long min = dp[i][j];\n                long min_i\
    \ = i;\n                long min_j = j;\n                if (i > 0 && dp[i - 1][j]\
    \ < min)\n                {\n                    min = dp[i - 1][j];\n       \
    \             min_i = i - 1;\n                    min_j = j;\n               \
    \ }\n                if (i < n - 1 && dp[i + 1][j] < min)\n                {\n\
    \                    min = dp[i + 1][j];\n                    min_i = i + 1;\n\
    \                    min_j = j;\n                }\n                if (j > 0\
    \ && dp[i][j - 1] < min)\n                {\n                    min = dp[i][j\
    \ - 1];\n                    min_i = i;\n                    min_j = j - 1;\n\
    \                }\n                if (j < n - 1 && dp[i][j + 1] < min)\n   \
    \             {\n                    min = dp[i][j + 1];\n                   \
    \ min_i = i;\n                    min_j = j + 1;\n                }\n        \
    \        dp[i][j] = min;\n                prev[i][j] = min_i * n + min_j;\n  \
    \          }\n        }\n    }\n    long min = dp[0][0];\n    long min_", "{\n\
    \    int n = grid.length;\n    int[][] dp = new int[n][n];\n    int[][] parent\
    \ = new int[n][n];\n    int[][] dir = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0,\
    \ -1}};\n    int[][] dist = new int[n][n];\n    for (int i = 0; i < n; i++)\n\
    \        for (int j = 0; j < n; j++)\n            dist[i][j] = int.max;\n    dist[0][0]\
    \ = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n\
    \            dp[i][j] = int.max;\n    dp[0][0] = grid[0][0];\n    for (int i =\
    \ 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            for (int[]\
    \ d : dir)\n            {\n                int x = i + d[0];\n               \
    \ int y = j + d[1];\n                if (x < 0 || x >= n || y < 0 || y >= n)\n\
    \                    continue;\n                if (dp[x][y] > dp[i][j] + grid[x][y])\n\
    \                {\n                    dp[x][y] = dp[i][j] + grid[x][y];\n  \
    \                  dist[x][y] = dist[i][j] + 1;\n                    parent[x][y]\
    \ = i * n + j;\n                }\n                else if (dp[x][y] == dp[i][j]\
    \ + grid[x][y])\n                {\n                    if (dist[x][y] > dist[i][j]\
    \ + 1)\n                    {\n                        dist[x][y] = dist[i][j]\
    \ + 1;\n                        parent[x][y] = i * n + j;\n                  \
    \  }\n                }\n            }\n    int[] res = new int[k];\n    int cur\
    \ = n * n - 1;\n    for (int i = k - 1; i", "{\n    int n = grid.length;\n   \
    \ int[][] dp = new int[n][n];\n    int[][] prev = new int[n][n];\n    for (int\
    \ i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j]\
    \ = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++)\n        for\
    \ (int j = 0; j < n; j++)\n        {\n            if (i > 0 && dp[i][j] + grid[i\
    \ - 1][j] < dp[i - 1][j])\n            {\n                dp[i - 1][j] = dp[i][j]\
    \ + grid[i - 1][j];\n                prev[i - 1][j] = 1;\n            }\n    \
    \        if (j > 0 && dp[i][j] + grid[i][j - 1] < dp[i][j - 1])\n            {\n\
    \                dp[i][j - 1] = dp[i][j] + grid[i][j - 1];\n                prev[i][j\
    \ - 1] = 2;\n            }\n            if (i < n - 1 && dp[i][j] + grid[i + 1][j]\
    \ < dp[i + 1][j])\n            {\n                dp[i + 1][j] = dp[i][j] + grid[i\
    \ + 1][j];\n                prev[i + 1][j] = 3;\n            }\n            if\
    \ (j < n - 1 && dp[i][j] + grid[i][j + 1] < dp[i][j + 1])\n            {\n   \
    \             dp[i][j + 1] = dp[i][j] + grid[i][j + 1];\n                prev[i][j\
    \ + 1] = 4;\n            }\n        }\n    int[] path = new int[k];\n    int x\
    \ = n - 1, y = n - 1;\n    for (int i = k - 1; i >= 0; i--)\n    {\n        path",
  "{\n    long N = grid.length;\n    long[][] dp = new long[N][N];\n    long[][] prev\
    \ = new long[N][N];\n    long[][] next = new long[N][N];\n    for (long i = 0;\
    \ i < N; i++)\n    {\n        for (long j = 0; j < N; j++)\n        {\n      \
    \      dp[i][j] = grid[i][j];\n            prev[i][j] = -1;\n            next[i][j]\
    \ = -1;\n        }\n    }\n    for (long step = 1; step < k; step++)\n    {\n\
    \        for (long i = 0; i < N; i++)\n        {\n            for (long j = 0;\
    \ j < N; j++)\n            {\n                long min = dp[i][j];\n         \
    \       long min_prev = -1;\n                long min_next = -1;\n           \
    \     if (i > 0 && dp[i - 1][j] < min)\n                {\n                  \
    \  min = dp[i - 1][j];\n                    min_prev = i - 1;\n              \
    \      min_next = j;\n                }\n                if (i < N - 1 && dp[i\
    \ + 1][j] < min)\n                {\n                    min = dp[i + 1][j];\n\
    \                    min_prev = i + 1;\n                    min_next = j;\n  \
    \              }\n                if (j > 0 && dp[i][j - 1] < min)\n         \
    \       {\n                    min = dp[i][j - 1];\n                    min_prev\
    \ = i;\n                    min_next = j - 1;\n                }\n           \
    \     if (j < N - 1 && dp[i][j + 1] < min)\n                {\n              \
    \      min = dp[i][j + 1];\n                    min_prev = i;\n              \
    \      min_next = j + 1;\n                }\n                dp[i][j] = min +\
    \ grid[i][j];\n                prev[i][j] = min_prev;\n                next[i][j]\
    \ = min_next;\n            }\n        }\n    }\n   ", "{\n    long n = grid.length;\n\
    \    long[][] dp = new long[n][n];\n    long[][] prev = new long[n][n];\n    foreach(i;\
    \ 0 .. n)\n    {\n        foreach(j; 0 .. n)\n        {\n            dp[i][j]\
    \ = long.max;\n            prev[i][j] = -1;\n        }\n    }\n    dp[0][0] =\
    \ grid[0][0];\n    foreach(i; 0 .. n)\n    {\n        foreach(j; 0 .. n)\n   \
    \     {\n            if (i > 0 && dp[i - 1][j] + grid[i][j] < dp[i][j])\n    \
    \        {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n          \
    \      prev[i][j] = 0;\n            }\n            if (j > 0 && dp[i][j - 1] +\
    \ grid[i][j] < dp[i][j])\n            {\n                dp[i][j] = dp[i][j -\
    \ 1] + grid[i][j];\n                prev[i][j] = 1;\n            }\n         \
    \   if (i < n - 1 && dp[i + 1][j] + grid[i][j] < dp[i][j])\n            {\n  \
    \              dp[i][j] = dp[i + 1][j] + grid[i][j];\n                prev[i][j]\
    \ = 2;\n            }\n            if (j < n - 1 && dp[i][j + 1] + grid[i][j]\
    \ < dp[i][j])\n            {\n                dp[i][j] = dp[i][j + 1] + grid[i][j];\n\
    \                prev[i][j] = 3;\n            }\n        }\n    }\n    long[]\
    \ res = new long[k];\n    long i = n - 1;\n    long j = n - 1;\n    foreach(idx;\
    \ k)\n    {\n        res[idx] = grid[i][j];", "{\n    long n = grid.length;\n\
    \    long[][] dp = new long[n][n];\n    foreach(i; 0 .. n)\n        foreach(j;\
    \ 0 .. n)\n            dp[i][j] = long.max;\n    dp[0][0] = grid[0][0];\n    foreach(i;\
    \ 0 .. n)\n        foreach(j; 0 .. n)\n        {\n            if(i > 0)\n    \
    \            dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n          \
    \  if(j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n\
    \        }\n    long[] res = new long[k];\n    long cur = dp[n - 1][n - 1];\n\
    \    res[$ - 1] = grid[n - 1][n - 1];\n    long i = n - 1;\n    long j = n - 1;\n\
    \    foreach(l; k - 1 .. 0)\n    {\n        if(i > 0 && dp[i - 1][j] + grid[i][j]\
    \ == cur)\n        {\n            res[l] = grid[i - 1][j];\n            cur -=\
    \ grid[i][j];\n            i--;\n        }\n        else if(j > 0 && dp[i][j -\
    \ 1] + grid[i][j] == cur)\n        {\n            res[l] = grid[i][j - 1];\n \
    \           cur -= grid[i][j];\n            j--;\n        }\n    }\n    return\
    \ res;\n}", "{\n    int n = grid.length;\n    int[][] dp = new int[n][n];\n  \
    \  for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n        \
    \    dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++)\n\
    \        for (int j = 0; j < n; j++)\n        {\n            if (i > 0)\n    \
    \            dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n          \
    \  if (j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n\
    \        }\n    int[] path = new int[k];\n    int i = n - 1;\n    int j = n -\
    \ 1;\n    for (int l = k - 1; l >= 0; l--)\n    {\n        path[l] = grid[i][j];\n\
    \        if (i > 0 && dp[i - 1][j] + grid[i][j] == dp[i][j])\n            i--;\n\
    \        else\n            j--;\n    }\n    return path;\n}", "{\n    int n =\
    \ grid.length;\n    int[][] dp = new int[n][n];\n    int[][] prev = new int[n][n];\n\
    \    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n      \
    \      dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++)\n\
    \        for (int j = 0; j < n; j++)\n        {\n            if (i > 0 && dp[i\
    \ - 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i - 1][j]\
    \ + 1;\n                prev[i][j] = 1;\n            }\n            if (j > 0\
    \ && dp[i][j - 1] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j\
    \ - 1] + 1;\n                prev[i][j] = 2;\n            }\n            if (i\
    \ < n - 1 && dp[i + 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i + 1][j] + 1;\n                prev[i][j] = 3;\n            }\n      \
    \      if (j < n - 1 && dp[i][j + 1] + 1 < dp[i][j])\n            {\n        \
    \        dp[i][j] = dp[i][j + 1] + 1;\n                prev[i][j] = 4;\n     \
    \       }\n        }\n    long[] res = new long[(int)k];\n    int x = 0, y = 0;\n\
    \    for (int i = 0; i < k; i++)\n    {\n        res[i] = grid[x][y];\n      \
    \  if (prev[x][y] == 1)\n            x--;\n        else if (prev[x][y] == 2)\n\
    \            y--;\n        else if (prev[x][y] == 3)\n            x", "{\n   \
    \ int N = grid.length;\n    int[][] dp = new int[N][N];\n    for (int i = 0; i\
    \ < N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n\
    \    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j\
    \ < N; j++)\n        {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i - 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j]\
    \ = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n        }\n    int[][] dp2 = new\
    \ int[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N;\
    \ j++)\n            dp2[i][j] = int.max;\n    dp2[N - 1][N - 1] = 0;\n    for\
    \ (int i = N - 1; i >= 0; i--)\n        for (int j = N - 1; j >= 0; j--)\n   \
    \     {\n            if (i < N - 1)\n                dp2[i][j] = min(dp2[i][j],\
    \ dp2[i + 1][j] + grid[i][j]);\n            if (j < N - 1)\n                dp2[i][j]\
    \ = min(dp2[i][j], dp2[i][j + 1] + grid[i][j]);\n        }\n    int[][] dp3 =\
    \ new int[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j <\
    \ N; j++)\n            dp3[i][j] = dp[i][j] + dp2[i][j] - grid[i][j];\n    int[][]\
    \ dp4 = new int[", "{\n    long N = grid.length;\n    long[][] dp = new long[N][N];\n\
    \    foreach (i; 0 .. N)\n        foreach (j; 0 .. N)\n            dp[i][j] =\
    \ -1;\n    dp[0][0] = 0;\n    long[][] prev = new long[N][N];\n    foreach (i;\
    \ 0 .. N)\n        foreach (j; 0 .. N)\n            prev[i][j] = -1;\n    prev[0][0]\
    \ = 0;\n    long[][] next = new long[N][N];\n    foreach (i; 0 .. N)\n       \
    \ foreach (j; 0 .. N)\n            next[i][j] = -1;\n    next[0][0] = 0;\n   \
    \ long[][] dir = [[-1, 0], [0, -1], [1, 0], [0, 1]];\n    long[][] dir_prev =\
    \ [[1, 0], [0, 1], [-1, 0], [0, -1]];\n    long[][] dir_next = [[1, 0], [0, 1],\
    \ [-1, 0], [0, -1]];\n    long[][] dir_prev_next = [[1, 0], [0, 1], [-1, 0], [0,\
    \ -1]];\n    foreach (i; 0 .. N)\n        foreach (j; 0 .. N)\n            foreach\
    \ (d; 0 .. 4)\n            {\n                long x = i + dir[d][0];\n      \
    \          long y = j + dir[d][1];\n                if (x >= 0 && x < N && y >=\
    \ 0 && y < N)\n                {\n                    if (dp[x][y] == -1 || dp[x][y]\
    \ > dp[i][j] + grid[x][y])\n                    {\n                        dp[x][y]\
    \ = dp[i][j] + grid[x][y];\n                        prev[x][y] = i;\n        \
    \                next[x][y] = j;\n                    }\n                    else\
    \ if (dp[x][y] == dp[i", "{\n    int n = grid.length;\n    int[][] dp = new int[n][n];\n\
    \    int[][] prev = new int[n][n];\n    for (int i = 0; i < n; i++)\n        for\
    \ (int j = 0; j < n; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n\
    \    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n      \
    \  {\n            if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n            {\n \
    \               dp[i][j] = dp[i - 1][j] + 1;\n                prev[i][j] = 1;\n\
    \            }\n            if (j > 0 && dp[i][j - 1] + 1 < dp[i][j])\n      \
    \      {\n                dp[i][j] = dp[i][j - 1] + 1;\n                prev[i][j]\
    \ = 2;\n            }\n            if (i < n - 1 && dp[i + 1][j] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i + 1][j] + 1;\n               \
    \ prev[i][j] = 3;\n            }\n            if (j < n - 1 && dp[i][j + 1] +\
    \ 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j + 1] + 1;\n\
    \                prev[i][j] = 4;\n            }\n        }\n    int x = 0, y =\
    \ 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n \
    \           if (dp[i][j] < dp[x][y])\n            {\n                x = i;\n\
    \                y = j;\n            }\n    long[] res = new long[(int)k];\n \
    \   for (int i = 0; i < k; i++)\n    {\n", "{\n    int N = grid.length;\n    int[][]\
    \ dp = new int[N][N];\n    int[][] prev = new int[N][N];\n    for (int i = 0;\
    \ i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n\
    \    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j\
    \ < N; j++)\n        {\n            if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i - 1][j] + 1;\n               \
    \ prev[i][j] = 0;\n            }\n            if (j > 0 && dp[i][j - 1] + 1 <\
    \ dp[i][j])\n            {\n                dp[i][j] = dp[i][j - 1] + 1;\n   \
    \             prev[i][j] = 1;\n            }\n            if (i < N - 1 && dp[i\
    \ + 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j]\
    \ + 1;\n                prev[i][j] = 2;\n            }\n            if (j < N\
    \ - 1 && dp[i][j + 1] + 1 < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i][j + 1] + 1;\n                prev[i][j] = 3;\n            }\n      \
    \  }\n    int x = 0, y = 0;\n    long[] res = new long[k];\n    for (int i = 0;\
    \ i < k; i++)\n    {\n        res[i] = grid[x][y];\n        switch (prev[x][y])\n\
    \        {\n            case 0:\n                x--;\n                break;\n\
    \            case 1:\n                y--;\n                break;\n         \
    \   case 2:\n                x++;\n                break;\n            case",
  "{\n    long N = grid.length;\n    long[][] dp = new long[N][N];\n    long[][] prev\
    \ = new long[N][N];\n    for (long i = 0; i < N; i++)\n    {\n        for (long\
    \ j = 0; j < N; j++)\n        {\n            dp[i][j] = grid[i][j];\n        \
    \    prev[i][j] = -1;\n        }\n    }\n    for (long i = 0; i < N; i++)\n  \
    \  {\n        for (long j = 0; j < N; j++)\n        {\n            if (i > 0 &&\
    \ dp[i][j] > dp[i - 1][j])\n            {\n                dp[i][j] = dp[i - 1][j];\n\
    \                prev[i][j] = 0;\n            }\n            if (j > 0 && dp[i][j]\
    \ > dp[i][j - 1])\n            {\n                dp[i][j] = dp[i][j - 1];\n \
    \               prev[i][j] = 1;\n            }\n            if (i < N - 1 && dp[i][j]\
    \ > dp[i + 1][j])\n            {\n                dp[i][j] = dp[i + 1][j];\n \
    \               prev[i][j] = 2;\n            }\n            if (j < N - 1 && dp[i][j]\
    \ > dp[i][j + 1])\n            {\n                dp[i][j] = dp[i][j + 1];\n \
    \               prev[i][j] = 3;\n            }\n        }\n    }\n    long[] res\
    \ = new long[(int)k];\n    long i = 0;\n    long j = 0;\n    for (long l = 0;\
    \ l < k; l++)\n    {\n        res[(int)l] = grid[(int)i][(int)j];\n        switch\
    \ ((int)prev[(int)i][(int)j])\n        {\n            case 0:\n              \
    \  i--;\n                break;\n            case 1:\n               ", "{\n \
    \   long N = grid.length;\n    long[][] dp = new long[N][N];\n    foreach (i;\
    \ 0 .. N)\n        foreach (j; 0 .. N)\n            dp[i][j] = long.max;\n   \
    \ dp[0][0] = grid[0][0];\n    foreach (i; 0 .. N)\n        foreach (j; 0 .. N)\n\
    \        {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i\
    \ - 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + grid[i][j]);\n        }\n    long[] path = new long[k];\n   \
    \ path[0] = grid[0][0];\n    long i = 0, j = 0;\n    foreach (idx; 1 .. k)\n \
    \   {\n        if (i + 1 < N && dp[i + 1][j] + grid[i + 1][j] == dp[i][j])\n \
    \       {\n            i++;\n            path[idx] = grid[i][j];\n        }\n\
    \        else\n        {\n            j++;\n            path[idx] = grid[i][j];\n\
    \        }\n    }\n    return path;\n}", "{\n    int n = grid.length;\n    int[][]\
    \ dp = new int[n][n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0;\
    \ j < n; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int\
    \ i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n        {\n       \
    \     if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n\
    \            if (j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1]\
    \ + grid[i][j]);\n        }\n    int[] path = new int[(int)k];\n    int x = n\
    \ - 1, y = n - 1;\n    for (int i = (int)k - 1; i >= 0; i--)\n    {\n        path[i]\
    \ = grid[x][y];\n        if (x > 0 && dp[x - 1][y] + grid[x][y] == dp[x][y])\n\
    \            x--;\n        else\n            y--;\n    }\n    return path;\n}",
  "{\n    int n = grid.length;\n    int m = grid[0].length;\n    long[][] dp = new\
    \ long[n][m];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m;\
    \ j++)\n            dp[i][j] = grid[i][j];\n    for (int i = 0; i < n; i++)\n\
    \        for (int j = 0; j < m; j++)\n        {\n            if (i > 0)\n    \
    \            dp[i][j] = min(dp[i][j], dp[i - 1][j]);\n            if (j > 0)\n\
    \                dp[i][j] = min(dp[i][j], dp[i][j - 1]);\n        }\n    long[]\
    \ res = new long[(int)k];\n    int i = 0;\n    int j = 0;\n    for (int l = 0;\
    \ l < k; l++)\n    {\n        res[l] = dp[i][j];\n        if (i > 0 && dp[i -\
    \ 1][j] < dp[i][j])\n            i--;\n        else if (j > 0 && dp[i][j - 1]\
    \ < dp[i][j])\n            j--;\n        else if (i < n - 1 && dp[i + 1][j] <\
    \ dp[i][j])\n            i++;\n        else if (j < m - 1 && dp[i][j + 1] < dp[i][j])\n\
    \            j++;\n    }\n    return res;\n}", "{\n    int n = grid.length;\n\
    \    int[][] dist = new int[n][n];\n    for (int i = 0; i < n; i++)\n        for\
    \ (int j = 0; j < n; j++)\n            dist[i][j] = int.max;\n    dist[0][0] =\
    \ 0;\n    int[][] prev = new int[n][n];\n    for (int i = 0; i < n; i++)\n   \
    \     for (int j = 0; j < n; j++)\n            prev[i][j] = -1;\n    auto q =\
    \ new PriorityQueue!(tuple!(int, int, int), \"a[2] < b[2]\")();\n    q.put(tuple(0,\
    \ 0, 0));\n    while (!q.empty)\n    {\n        auto cur = q.get();\n        int\
    \ x = cur[0];\n        int y = cur[1];\n        int d = cur[2];\n        if (d\
    \ > dist[x][y])\n            continue;\n        if (x > 0)\n        {\n      \
    \      if (d + 1 < dist[x - 1][y])\n            {\n                dist[x - 1][y]\
    \ = d + 1;\n                prev[x - 1][y] = 0;\n                q.put(tuple(x\
    \ - 1, y, d + 1));\n            }\n            else if (d + 1 == dist[x - 1][y])\n\
    \            {\n                if (grid[x - 1][y] < grid[x][y])\n           \
    \     {\n                    dist[x - 1][y] = d + 1;\n                    prev[x\
    \ - 1][y] = 0;\n                    q.put(tuple(x - 1, y, d + 1));\n         \
    \       }\n            }\n        }\n        if (x < n - 1)\n        {\n     \
    \       if (d + 1 < dist[x + 1][y])\n            {\n                dist[x + 1][y]\
    \ = d + 1;\n                prev[x + 1][y] = 1;\n                q.put(tuple(x\
    \ + 1, y, d + 1));\n            }\n            else if (", "{\n    auto n = grid.length;\n\
    \    auto m = grid[0].length;\n    auto dp = new long[][][](n, m, k + 1);\n  \
    \  auto path = new long[][][](n, m, k + 1);\n    foreach (i; 0 .. n)\n    {\n\
    \        foreach (j; 0 .. m)\n        {\n            dp[i][j][0] = grid[i][j];\n\
    \            path[i][j][0] = grid[i][j];\n        }\n    }\n    foreach (i; 0\
    \ .. n)\n    {\n        foreach (j; 0 .. m)\n        {\n            foreach (l;\
    \ 1 .. k + 1)\n            {\n                dp[i][j][l] = long.max;\n      \
    \          if (i > 0)\n                {\n                    if (dp[i - 1][j][l\
    \ - 1] < dp[i][j][l])\n                    {\n                        dp[i][j][l]\
    \ = dp[i - 1][j][l - 1];\n                        path[i][j][l] = path[i - 1][j][l\
    \ - 1];\n                    }\n                    else if (dp[i - 1][j][l -\
    \ 1] == dp[i][j][l])\n                    {\n                        path[i][j][l]\
    \ = min(path[i - 1][j][l - 1], path[i][j][l]);\n                    }\n      \
    \          }\n                if (j > 0)\n                {\n                \
    \    if (dp[i][j - 1][l - 1] < dp[i][j][l])\n                    {\n         \
    \               dp[i][j][l] = dp[i][j - 1][l - 1];\n                        path[i][j][l]\
    \ = path[i][j - 1][l - 1];\n                    }\n                    else if\
    \ (dp[i][j - 1][l - 1] == dp[i][j][l])\n                    {\n              \
    \          path[i][j][l] = min(path[i][j - 1][l - 1], path[i][j][l]);\n      \
    \              }\n                }\n               ", "{\n    int N = grid.length;\n\
    \    int[][] dp = new int[N][N];\n    int[][] prev = new int[N][N];\n    for (int\
    \ i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            prev[i][j]\
    \ = -1;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n\
    \        {\n            int min = int.max;\n            if (i > 0 && dp[i - 1][j]\
    \ < min)\n            {\n                min = dp[i - 1][j];\n               \
    \ prev[i][j] = 0;\n            }\n            if (j > 0 && dp[i][j - 1] < min)\n\
    \            {\n                min = dp[i][j - 1];\n                prev[i][j]\
    \ = 1;\n            }\n            if (i < N - 1 && dp[i + 1][j] < min)\n    \
    \        {\n                min = dp[i + 1][j];\n                prev[i][j] =\
    \ 2;\n            }\n            if (j < N - 1 && dp[i][j + 1] < min)\n      \
    \      {\n                min = dp[i][j + 1];\n                prev[i][j] = 3;\n\
    \            }\n            dp[i][j] = min + grid[i][j];\n        }\n    int min\
    \ = int.max;\n    int[] pos = new int[2];\n    for (int i = 0; i < N; i++)\n \
    \       for (int j = 0; j < N; j++)\n            if (dp[i][j] < min)\n       \
    \     {\n                min = dp[i][j];\n                pos[0] = i;\n      \
    \          pos[1] = j;\n            }\n    long[] ans = new long[k];\n    for\
    \ (int i = 0; i < k; i++)\n    {\n        ans[i] = grid[pos[0]][pos[1]];\n   \
    \     int tmp = prev[pos[0]][pos[1", "{\n    long n = grid.length;\n    long[][]\
    \ dp = new long[n][n];\n    long[][] path = new long[n][n];\n    foreach(i; 0\
    \ .. n)\n    {\n        foreach(j; 0 .. n)\n        {\n            dp[i][j] =\
    \ long.max;\n            path[i][j] = long.max;\n        }\n    }\n    dp[0][0]\
    \ = grid[0][0];\n    path[0][0] = 0;\n    foreach(i; 0 .. n)\n    {\n        foreach(j;\
    \ 0 .. n)\n        {\n            if(i > 0)\n            {\n                if(dp[i][j]\
    \ > dp[i - 1][j] + grid[i][j])\n                {\n                    dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                    path[i][j] = path[i - 1][j]\
    \ + 1;\n                }\n                else if(dp[i][j] == dp[i - 1][j] +\
    \ grid[i][j])\n                {\n                    if(path[i][j] > path[i -\
    \ 1][j] + 1)\n                    {\n                        path[i][j] = path[i\
    \ - 1][j] + 1;\n                    }\n                }\n            }\n    \
    \        if(j > 0)\n            {\n                if(dp[i][j] > dp[i][j - 1]\
    \ + grid[i][j])\n                {\n                    dp[i][j] = dp[i][j - 1]\
    \ + grid[i][j];\n                    path[i][j] = path[i][j - 1] + 1;\n      \
    \          }\n                else if(dp[i][j] == dp[i][j - 1] + grid[i][j])\n\
    \                {\n                    if(path[i][j] > path[i][j - 1] + 1)\n\
    \                    {\n                        path[i][j] = path[i][j - 1] +\
    \ 1;\n                    }\n                }\n            }\n        }\n", "{\n\
    \    int N = grid.length;\n    int[][] dp = new int[N][N];\n    int[][] prev =\
    \ new int[N][N];\n    int[][] dir = new int[][] { {-1, 0}, {1, 0}, {0, -1}, {0,\
    \ 1} };\n    int[][] dir_prev = new int[][] { {1, 0}, {-1, 0}, {0, 1}, {0, -1}\
    \ };\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n \
    \           dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < N;\
    \ i++)\n        for (int j = 0; j < N; j++)\n            for (int d = 0; d < 4;\
    \ d++)\n            {\n                int x = i + dir[d][0];\n              \
    \  int y = j + dir[d][1];\n                if (x < 0 || x >= N || y < 0 || y >=\
    \ N)\n                    continue;\n                if (dp[x][y] > dp[i][j] +\
    \ 1)\n                {\n                    dp[x][y] = dp[i][j] + 1;\n      \
    \              prev[x][y] = d;\n                }\n            }\n    int x =\
    \ N - 1;\n    int y = N - 1;\n    long[] res = new long[(int)k];\n    for (int\
    \ i = (int)k - 1; i >= 0; i--)\n    {\n        res[i] = grid[x][y];\n        int\
    \ d = prev[x][y];\n        x += dir_prev[d][0];\n        y += dir_prev[d][1];\n\
    \    }\n    return res;\n}", "{\n    long N = grid.length;\n    long[][] dp =\
    \ new long[N][N];\n    long[][] prev = new long[N][N];\n    foreach (i; 0 .. N)\n\
    \    {\n        foreach (j; 0 .. N)\n        {\n            dp[i][j] = long.max;\n\
    \            prev[i][j] = -1;\n        }\n    }\n    dp[0][0] = 0;\n    foreach\
    \ (i; 0 .. N)\n    {\n        foreach (j; 0 .. N)\n        {\n            if (i\
    \ > 0)\n            {\n                if (dp[i - 1][j] + grid[i][j] < dp[i][j])\n\
    \                {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                    prev[i][j] = 0;\n                }\n            }\n     \
    \       if (j > 0)\n            {\n                if (dp[i][j - 1] + grid[i][j]\
    \ < dp[i][j])\n                {\n                    dp[i][j] = dp[i][j - 1]\
    \ + grid[i][j];\n                    prev[i][j] = 1;\n                }\n    \
    \        }\n        }\n    }\n    long[] res = new long[k];\n    long i = N -\
    \ 1;\n    long j = N - 1;\n    foreach (k; k .. 0)\n    {\n        res[k] = grid[i][j];\n\
    \        if (prev[i][j] == 0)\n        {\n            i--;\n        }\n      \
    \  else\n        {\n            j--;\n        }\n    }\n    return res;\n}", "{\n\
    \    int N = grid.length;\n    int[][] dp = new int[N][N];\n    for (int i = 0;\
    \ i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n\
    \    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j\
    \ < N; j++)\n        {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i - 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j]\
    \ = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n        }\n    int[] path = new\
    \ int[k];\n    for (int i = 0; i < k; i++)\n        path[i] = grid[0][0];\n  \
    \  int cur = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j <\
    \ N; j++)\n            if (dp[i][j] < dp[cur / N][cur % N])\n                cur\
    \ = i * N + j;\n    int x = cur / N;\n    int y = cur % N;\n    for (int i = k\
    \ - 1; i >= 0; i--)\n    {\n        path[i] = grid[x][y];\n        if (x > 0 &&\
    \ dp[x - 1][y] + grid[x][y] == dp[x][y])\n            x--;\n        else if (y\
    \ > 0 && dp[x][y - 1] + grid[x][y] == dp[x][y])\n            y--;\n    }\n   \
    \ return path;\n}", "{\n    // TODO: implement\n    return null;\n}", "{\n   \
    \ int N = grid.length;\n    int[][] dp = new int[N][N];\n    int[][] prev = new\
    \ int[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N;\
    \ j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n    prev[0][0] = -1;\n\
    \    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n      \
    \  {\n            if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n            {\n \
    \               dp[i][j] = dp[i - 1][j] + 1;\n                prev[i][j] = 0;\n\
    \            }\n            if (j > 0 && dp[i][j - 1] + 1 < dp[i][j])\n      \
    \      {\n                dp[i][j] = dp[i][j - 1] + 1;\n                prev[i][j]\
    \ = 1;\n            }\n            if (i < N - 1 && dp[i + 1][j] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i + 1][j] + 1;\n               \
    \ prev[i][j] = 2;\n            }\n            if (j < N - 1 && dp[i][j + 1] +\
    \ 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j + 1] + 1;\n\
    \                prev[i][j] = 3;\n            }\n        }\n    long[] res = new\
    \ long[k];\n    int x = N - 1, y = N - 1;\n    for (int i = 0; i < k; i++)\n \
    \   {\n        res[i] = grid[x][y];\n        switch (prev[x][y])\n        {\n\
    \            case 0:\n                x++;\n                break;\n         \
    \   case 1:\n                y++;\n                break;\n           ", "{\n\
    \    long N = grid.length;\n    long[][] dp = new long[N][N];\n    foreach (i;\
    \ 0 .. N)\n        foreach (j; 0 .. N)\n            dp[i][j] = long.max;\n   \
    \ dp[0][0] = grid[0][0];\n    foreach (i; 0 .. N)\n        foreach (j; 0 .. N)\n\
    \        {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i\
    \ - 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + grid[i][j]);\n        }\n    long[] res = new long[k];\n    long\
    \ cur = dp[N - 1][N - 1];\n    long i = N - 1;\n    long j = N - 1;\n    foreach\
    \ (idx; k .. 0)\n    {\n        res[idx] = grid[i][j];\n        if (i > 0 && dp[i\
    \ - 1][j] + grid[i][j] == cur)\n        {\n            cur -= grid[i][j];\n  \
    \          i--;\n        }\n        else if (j > 0 && dp[i][j - 1] + grid[i][j]\
    \ == cur)\n        {\n            cur -= grid[i][j];\n            j--;\n     \
    \   }\n    }\n    return res;\n}", "{\n    auto n = grid.length;\n    auto m =\
    \ grid[0].length;\n    auto dp = new long[][](n, m);\n    auto path = new long[][](n,\
    \ m);\n    foreach (i; 0 .. n)\n    {\n        foreach (j; 0 .. m)\n        {\n\
    \            if (i == 0 && j == 0)\n            {\n                dp[i][j] =\
    \ grid[i][j];\n                path[i][j] = 1;\n            }\n            else\
    \ if (i == 0)\n            {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                path[i][j] = path[i][j - 1];\n            }\n            else\
    \ if (j == 0)\n            {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n            }\n            else\n\
    \            {\n                if (dp[i - 1][j] < dp[i][j - 1])\n           \
    \     {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n         \
    \           path[i][j] = path[i - 1][j];\n                }\n                else\
    \ if (dp[i - 1][j] > dp[i][j - 1])\n                {\n                    dp[i][j]\
    \ = dp[i][j - 1] + grid[i][j];\n                    path[i][j] = path[i][j - 1];\n\
    \                }\n                else\n                {\n                \
    \    dp[i][j] = dp[i - 1][j] + grid[i][j];\n                    path[i][j] = path[i\
    \ - 1][j] + path[i][j - 1];\n                }\n            }\n        }\n   \
    \ }\n    auto res = new long[k];\n    auto i = n - 1;\n    auto j = m - 1;\n \
    \   auto cnt = k;\n    while (cnt > 0)\n    {\n        res[c", "{\n    long n\
    \ = grid.length;\n    long[][] dp = new long[n][n];\n    foreach (i; 0 .. n)\n\
    \        foreach (j; 0 .. n)\n            dp[i][j] = long.max;\n    dp[0][0] =\
    \ 0;\n    foreach (i; 0 .. n)\n        foreach (j; 0 .. n)\n        {\n      \
    \      if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n\
    \            if (j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1]\
    \ + grid[i][j]);\n        }\n    long[] path = new long[k];\n    long cur = dp[n\
    \ - 1][n - 1];\n    long i = n - 1;\n    long j = n - 1;\n    foreach (idx; k\
    \ .. 0)\n    {\n        path[idx] = grid[i][j];\n        if (i > 0 && dp[i - 1][j]\
    \ + grid[i][j] == cur)\n        {\n            cur -= grid[i][j];\n          \
    \  i--;\n        }\n        else if (j > 0 && dp[i][j - 1] + grid[i][j] == cur)\n\
    \        {\n            cur -= grid[i][j];\n            j--;\n        }\n    }\n\
    \    return path;\n}", "{\n    int N = grid.length;\n    int[][] dp = new int[N][N];\n\
    \    foreach(i; 0 .. N)\n        foreach(j; 0 .. N)\n            dp[i][j] = -1;\n\
    \    dp[0][0] = 0;\n    int[][] dir = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n  \
    \  auto cmp = (a, b) => a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\n    auto\
    \ cmp2 = (a, b) => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\n    auto cmp3\
    \ = (a, b) => a[0] > b[0] || (a[0] == b[0] && a[1] < b[1]);\n    auto cmp4 = (a,\
    \ b) => a[0] > b[0] || (a[0] == b[0] && a[1] > b[1]);\n    auto cmp5 = (a, b)\
    \ => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]);\n    auto cmp6 = (a, b) =>\
    \ a[1] < b[1] || (a[1] == b[1] && a[0] > b[0]);\n    auto cmp7 = (a, b) => a[1]\
    \ > b[1] || (a[1] == b[1] && a[0] < b[0]);\n    auto cmp8 = (a, b) => a[1] > b[1]\
    \ || (a[1] == b[1] && a[0] > b[0]);\n    auto cmp9 = (a, b) => a[0] < b[0] ||\
    \ (a[0] == b[0] && a[1] < b[1]) || (a[0] == b[0] && a[1] == b[1] &&", "{\n   \
    \ long n = grid.length;\n    long[][] dp = new long[n][n];\n    long[][] prev\
    \ = new long[n][n];\n    long[][] next = new long[n][n];\n    long[][] dist =\
    \ new long[n][n];\n    long[][] path = new long[n][n];\n    long[][] path_len\
    \ = new long[n][n];\n    long[][] path_idx = new long[n][n];\n    long[][] path_prev\
    \ = new long[n][n];\n    long[][] path_next = new long[n][n];\n    long[][] path_dist\
    \ = new long[n][n];\n    long[][] path_path = new long[n][n];\n    long[][] path_path_len\
    \ = new long[n][n];\n    long[][] path_path_idx = new long[n][n];\n    long[][]\
    \ path_path_prev = new long[n][n];\n    long[][] path_path_next = new long[n][n];\n\
    \    long[][] path_path_dist = new long[n][n];\n    long[][] path_path_path =\
    \ new long[n][n];\n    long[][] path_path_path_len = new long[n][n];\n    long[][]\
    \ path_path_path_idx = new long[n][n];\n    long[][] path_path_path_prev = new\
    \ long[n][n];\n    long[][] path_path_path_next = new long[n][n];\n    long[][]\
    \ path_path_path_dist = new long[n][n];\n    long[][] path_path_path_path = new\
    \ long[n][n];\n    long[][] path_path_path_path_len = new long[n][n];\n    long[][]\
    \ path_path_path_path_idx = new long[n][n];\n    long[][] path_path_path_path_prev\
    \ = new long[n][n];\n    long[][] path_path_", "{\n    long n = grid.length;\n\
    \    long[][] dp = new long[n][n];\n    long[][] prev = new long[n][n];\n    for\
    \ (long i = 0; i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n    \
    \    {\n            dp[i][j] = grid[i][j];\n            prev[i][j] = -1;\n   \
    \     }\n    }\n    for (long i = 0; i < n; i++)\n    {\n        for (long j =\
    \ 0; j < n; j++)\n        {\n            if (i > 0 && dp[i][j] > dp[i - 1][j])\n\
    \            {\n                dp[i][j] = dp[i - 1][j];\n                prev[i][j]\
    \ = 0;\n            }\n            if (j > 0 && dp[i][j] > dp[i][j - 1])\n   \
    \         {\n                dp[i][j] = dp[i][j - 1];\n                prev[i][j]\
    \ = 1;\n            }\n            if (i < n - 1 && dp[i][j] > dp[i + 1][j])\n\
    \            {\n                dp[i][j] = dp[i + 1][j];\n                prev[i][j]\
    \ = 2;\n            }\n            if (j < n - 1 && dp[i][j] > dp[i][j + 1])\n\
    \            {\n                dp[i][j] = dp[i][j + 1];\n                prev[i][j]\
    \ = 3;\n            }\n        }\n    }\n    long[] res = new long[k];\n    long\
    \ i = 0;\n    long j = 0;\n    for (long l = 0; l < k; l++)\n    {\n        res[l]\
    \ = grid[i][j];\n        switch ((int)prev[i][j])\n        {\n            case\
    \ 0:\n                i--;\n                break;\n            case 1:\n    \
    \            j--;\n                break;\n            case 2:\n             \
    \   i++;\n               ", "{\n    long n = grid.length;\n    long[][] dp = new\
    \ long[n][n];\n    long[][] prev = new long[n][n];\n    for (long i = 0; i < n;\
    \ i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n            dp[i][j]\
    \ = grid[i][j];\n            prev[i][j] = -1;\n        }\n    }\n    for (long\
    \ i = 0; i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n\
    \            if (i > 0 && dp[i][j] > dp[i - 1][j])\n            {\n          \
    \      dp[i][j] = dp[i - 1][j];\n                prev[i][j] = 0;\n           \
    \ }\n            if (j > 0 && dp[i][j] > dp[i][j - 1])\n            {\n      \
    \          dp[i][j] = dp[i][j - 1];\n                prev[i][j] = 1;\n       \
    \     }\n            if (i < n - 1 && dp[i][j] > dp[i + 1][j])\n            {\n\
    \                dp[i][j] = dp[i + 1][j];\n                prev[i][j] = 2;\n \
    \           }\n            if (j < n - 1 && dp[i][j] > dp[i][j + 1])\n       \
    \     {\n                dp[i][j] = dp[i][j + 1];\n                prev[i][j]\
    \ = 3;\n            }\n        }\n    }\n    long[] ans = new long[(int)k];\n\
    \    long cur = 0;\n    for (long i = 0; i < n; i++)\n    {\n        for (long\
    \ j = 0; j < n; j++)\n        {\n            if (dp[i][j] == grid[i][j])\n   \
    \         {\n                cur = i * n + j;\n                break;\n      \
    \      }\n        }\n    }\n    for (long i = 0; i", "{\n    int n = grid.length;\n\
    \    int[][] dp = new int[n][n];\n    foreach(i; 0 .. n)\n        foreach(j; 0\
    \ .. n)\n            dp[i][j] = int.max;\n    dp[0][0] = grid[0][0];\n    foreach(i;\
    \ 0 .. n)\n        foreach(j; 0 .. n)\n        {\n            if(i > 0)\n    \
    \            dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n          \
    \  if(j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n\
    \        }\n    long[] res = new long[k];\n    int i = 0;\n    int j = 0;\n  \
    \  foreach(idx; 0 .. k)\n    {\n        res[idx] = grid[i][j];\n        if(i ==\
    \ n - 1 && j == n - 1)\n            break;\n        if(i == n - 1)\n         \
    \   j++;\n        else if(j == n - 1)\n            i++;\n        else if(dp[i\
    \ + 1][j] < dp[i][j + 1])\n            i++;\n        else\n            j++;\n\
    \    }\n    return res;\n}", "{\n    auto N = grid.length;\n    auto M = grid[0].length;\n\
    \    auto dp = new long[][][](N, M, k + 1);\n    auto path = new long[][][](N,\
    \ M, k + 1);\n    auto min = new long[][](N, M);\n    foreach (i, j; grid)\n \
    \   {\n        min[i][j] = grid[i][j];\n        dp[i][j][1] = grid[i][j];\n  \
    \      path[i][j][1] = grid[i][j];\n    }\n    for (long i = 2; i <= k; i++)\n\
    \    {\n        for (long j = 0; j < N; j++)\n        {\n            for (long\
    \ l = 0; l < M; l++)\n            {\n                dp[j][l][i] = long.max;\n\
    \                foreach (x; [-1L, 0L, 1L])\n                {\n             \
    \       foreach (y; [-1L, 0L, 1L])\n                    {\n                  \
    \      if (x == 0L && y == 0L)\n                            continue;\n      \
    \                  if (j + x < 0L || j + x >= N || l + y < 0L || l + y >= M)\n\
    \                            continue;\n                        if (dp[j + x][l\
    \ + y][i - 1L] + grid[j][l] < dp[j][l][i])\n                        {\n      \
    \                      dp[j][l][i] = dp[j + x][l + y][i - 1L] + grid[j][l];\n\
    \                            path[j][l][i] = path[j + x][l + y][i - 1L] * 10L\
    \ + grid[j][l];\n                        }\n                    }\n          \
    \      }\n            }\n        }\n    }\n    long min_path = long.max;\n   \
    \ long min_i = 0L;\n    long min_j = 0L;\n    for (long i = 0; i < N; i++)\n \
    \   {\n        for (long j = 0; j < M; j++)\n        {\n            if (dp[i][j",
  "{\n    int N = grid.length;\n    int[][] dp = new int[N][N];\n    int[][] path\
    \ = new int[N][N];\n    int[][] dir = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0,\
    \ -1}};\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n\
    \            dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < N;\
    \ i++)\n        for (int j = 0; j < N; j++)\n            for (int d = 0; d < 4;\
    \ d++)\n            {\n                int x = i + dir[d][0];\n              \
    \  int y = j + dir[d][1];\n                if (x < 0 || x >= N || y < 0 || y >=\
    \ N)\n                    continue;\n                if (dp[x][y] > dp[i][j] +\
    \ grid[x][y])\n                {\n                    dp[x][y] = dp[i][j] + grid[x][y];\n\
    \                    path[x][y] = d;\n                }\n            }\n    int\
    \ x = N - 1;\n    int y = N - 1;\n    long[] ret = new long[k];\n    for (int\
    \ i = 0; i < k; i++)\n    {\n        ret[i] = grid[x][y];\n        int d = path[x][y];\n\
    \        x -= dir[d][0];\n        y -= dir[d][1];\n    }\n    return ret;\n}",
  "{\n    int n = grid.length;\n    int[][] dp = new int[n][n];\n    for (int i =\
    \ 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j] =\
    \ int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++)\n        for (int\
    \ j = 0; j < n; j++)\n        {\n            if (i > 0)\n                dp[i][j]\
    \ = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n            if (j > 0)\n      \
    \          dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n        }\n \
    \   int[][] dp2 = new int[n][n];\n    for (int i = 0; i < n; i++)\n        for\
    \ (int j = 0; j < n; j++)\n            dp2[i][j] = int.max;\n    dp2[n - 1][n\
    \ - 1] = 0;\n    for (int i = n - 1; i >= 0; i--)\n        for (int j = n - 1;\
    \ j >= 0; j--)\n        {\n            if (i < n - 1)\n                dp2[i][j]\
    \ = min(dp2[i][j], dp2[i + 1][j] + grid[i][j]);\n            if (j < n - 1)\n\
    \                dp2[i][j] = min(dp2[i][j], dp2[i][j + 1] + grid[i][j]);\n   \
    \     }\n    int[][] dp3 = new int[n][n];\n    for (int i = 0; i < n; i++)\n \
    \       for (int j = 0; j < n; j++)\n            dp3[i][j] = dp[i][j] + dp2[i][j]\
    \ - grid[i][j];\n    int[][] dp4 = new int[", "{\n    int n = grid.length;\n \
    \   int[][] dp = new int[n][n];\n    int[][] prev = new int[n][n];\n    for (int\
    \ i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j]\
    \ = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++)\n        for\
    \ (int j = 0; j < n; j++)\n        {\n            if (i > 0 && dp[i - 1][j] +\
    \ 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i - 1][j] + 1;\n\
    \                prev[i][j] = 1;\n            }\n            if (j > 0 && dp[i][j\
    \ - 1] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j - 1]\
    \ + 1;\n                prev[i][j] = 2;\n            }\n            if (i < n\
    \ - 1 && dp[i + 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i + 1][j] + 1;\n                prev[i][j] = 3;\n            }\n      \
    \      if (j < n - 1 && dp[i][j + 1] + 1 < dp[i][j])\n            {\n        \
    \        dp[i][j] = dp[i][j + 1] + 1;\n                prev[i][j] = 4;\n     \
    \       }\n        }\n    int[] path = new int[(int)k];\n    int x = 0, y = 0;\n\
    \    for (int i = 0; i < k; i++)\n    {\n        path[i] = grid[x][y];\n     \
    \   switch (prev[x][y])\n        {\n            case 1:\n                x--;\n\
    \                break;\n            case 2:\n                y--;\n         \
    \       break;\n            case 3:\n                x++;\n                break;",
  "{\n    int n = grid.length;\n    long[][] dp = new long[n][n];\n    for (int i\
    \ = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j]\
    \ = grid[i][j];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j <\
    \ n; j++)\n        {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i - 1][j]);\n            if (j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1]);\n        }\n    long[] res = new long[(int)k];\n    int x = 0,\
    \ y = 0;\n    for (int i = 0; i < k; i++)\n    {\n        res[i] = dp[x][y];\n\
    \        if (x > 0 && dp[x - 1][y] == dp[x][y])\n            x--;\n        else\
    \ if (y > 0 && dp[x][y - 1] == dp[x][y])\n            y--;\n        else\n   \
    \         break;\n    }\n    return res;\n}", "{\n    int N = grid.length;\n \
    \   int[][] dp = new int[N][N];\n    for (int i = 0; i < N; i++)\n        for\
    \ (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n\
    \    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n      \
    \  {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i -\
    \ 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + grid[i][j]);\n        }\n    int[][] dp2 = new int[N][N];\n \
    \   for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n       \
    \     dp2[i][j] = int.max;\n    dp2[N - 1][N - 1] = 0;\n    for (int i = N - 1;\
    \ i >= 0; i--)\n        for (int j = N - 1; j >= 0; j--)\n        {\n        \
    \    if (i < N - 1)\n                dp2[i][j] = min(dp2[i][j], dp2[i + 1][j]\
    \ + grid[i][j]);\n            if (j < N - 1)\n                dp2[i][j] = min(dp2[i][j],\
    \ dp2[i][j + 1] + grid[i][j]);\n        }\n    int[][] dp3 = new int[N][N];\n\
    \    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n      \
    \      dp3[i][j] = dp[i][j] + dp2[i][j] - grid[i][j];\n    int[][] dp4 = new int[",
  "{\n    int N = grid.length;\n    int[][] dp = new int[N][N];\n    for (int i =\
    \ 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j] =\
    \ int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for (int\
    \ j = 0; j < N; j++)\n        {\n            if (i > 0)\n                dp[i][j]\
    \ = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n            if (j > 0)\n      \
    \          dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n        }\n \
    \   int[] path = new int[k];\n    path[0] = 1;\n    int cur = 1;\n    int i =\
    \ 0;\n    int j = 0;\n    while (cur < k)\n    {\n        if (i + 1 < N && dp[i\
    \ + 1][j] + grid[i + 1][j] == dp[i][j])\n        {\n            path[cur] = grid[i\
    \ + 1][j];\n            i++;\n        }\n        else\n        {\n           \
    \ path[cur] = grid[i][j + 1];\n            j++;\n        }\n        cur++;\n \
    \   }\n    return path;\n}", "{\n    // TODO: implement\n    return null;\n}",
  "{\n    long N = grid.length;\n    long[] result = new long[k];\n    long[][] dp\
    \ = new long[N][N];\n    long[][] prev = new long[N][N];\n    for (long i = 0;\
    \ i < N; i++)\n    {\n        for (long j = 0; j < N; j++)\n        {\n      \
    \      dp[i][j] = grid[i][j];\n            prev[i][j] = -1;\n        }\n    }\n\
    \    for (long i = 0; i < N; i++)\n    {\n        for (long j = 0; j < N; j++)\n\
    \        {\n            if (i > 0 && dp[i - 1][j] > dp[i][j])\n            {\n\
    \                dp[i][j] = dp[i - 1][j];\n                prev[i][j] = 0;\n \
    \           }\n            if (j > 0 && dp[i][j - 1] > dp[i][j])\n           \
    \ {\n                dp[i][j] = dp[i][j - 1];\n                prev[i][j] = 1;\n\
    \            }\n            if (i < N - 1 && dp[i + 1][j] > dp[i][j])\n      \
    \      {\n                dp[i][j] = dp[i + 1][j];\n                prev[i][j]\
    \ = 2;\n            }\n            if (j < N - 1 && dp[i][j + 1] > dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i][j + 1];\n                prev[i][j]\
    \ = 3;\n            }\n        }\n    }\n    long curr = 0;\n    for (long i =\
    \ 0; i < N; i++)\n    {\n        for (long j = 0; j < N; j++)\n        {\n   \
    \         if (dp[i][j] == grid[i][j])\n            {\n                curr = i\
    \ * N + j;\n                break;\n            }\n        }\n    }\n    for (long\
    \ i = 0; i <", "{\n    long n = grid.length;\n    long[][] dp = new long[n][n];\n\
    \    long[][] prev = new long[n][n];\n    long[][] next = new long[n][n];\n  \
    \  foreach (i; 0 .. n)\n    {\n        foreach (j; 0 .. n)\n        {\n      \
    \      dp[i][j] = long.max;\n            prev[i][j] = -1;\n            next[i][j]\
    \ = -1;\n        }\n    }\n    dp[0][0] = 0;\n    foreach (i; 0 .. n)\n    {\n\
    \        foreach (j; 0 .. n)\n        {\n            if (i > 0)\n            {\n\
    \                if (dp[i - 1][j] + 1 < dp[i][j])\n                {\n       \
    \             dp[i][j] = dp[i - 1][j] + 1;\n                    prev[i][j] = i\
    \ - 1;\n                    next[i][j] = j;\n                }\n             \
    \   else if (dp[i - 1][j] + 1 == dp[i][j])\n                {\n              \
    \      if (grid[i - 1][j] < grid[prev[i][j]][next[i][j]])\n                  \
    \  {\n                        prev[i][j] = i - 1;\n                        next[i][j]\
    \ = j;\n                    }\n                }\n            }\n            if\
    \ (j > 0)\n            {\n                if (dp[i][j - 1] + 1 < dp[i][j])\n \
    \               {\n                    dp[i][j] = dp[i][j - 1] + 1;\n        \
    \            prev[i][j] = i;\n                    next[i][j] = j - 1;\n      \
    \          }\n                else if (dp[i][j - 1] + 1 == dp[i][j])\n       \
    \         {\n                    if (grid[i][j - 1] < grid[prev[i][j]][next[i][j]])\n\
    \                    {\n                        prev[i][j] = i;\n            \
    \            next[i][j] = j - 1;", "{\n    int N = grid.length;\n    int[][] dp\
    \ = new int[N][N];\n    int[][] prev = new int[N][N];\n    for (int i = 0; i <\
    \ N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n\
    \    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j\
    \ < N; j++)\n        {\n            if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i - 1][j] + 1;\n               \
    \ prev[i][j] = 1;\n            }\n            if (j > 0 && dp[i][j - 1] + 1 <\
    \ dp[i][j])\n            {\n                dp[i][j] = dp[i][j - 1] + 1;\n   \
    \             prev[i][j] = 2;\n            }\n            if (i < N - 1 && dp[i\
    \ + 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j]\
    \ + 1;\n                prev[i][j] = 3;\n            }\n            if (j < N\
    \ - 1 && dp[i][j + 1] + 1 < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i][j + 1] + 1;\n                prev[i][j] = 4;\n            }\n      \
    \  }\n    long[] res = new long[(int)k];\n    int i = 0;\n    int j = 0;\n   \
    \ for (int l = 0; l < k; l++)\n    {\n        res[l] = grid[i][j];\n        switch\
    \ (prev[i][j])\n        {\n            case 1:\n                i--;\n       \
    \         break;\n            case 2:\n                j--;\n                break;\n\
    \            case 3:\n                i++;\n", "{\n    int n = grid.length;\n\
    \    int m = grid[0].length;\n    long[][] dp = new long[n][m];\n    for (int\
    \ i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            dp[i][j]\
    \ = grid[i][j];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j <\
    \ m; j++)\n        {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i - 1][j]);\n            if (j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1]);\n        }\n    long[] res = new long[(int)k];\n    for (int\
    \ i = 0; i < k; i++)\n        res[i] = dp[n - 1][m - 1];\n    return res;\n}",
  "{\n    long N = grid.length;\n    long[][] dp = new long[N][N];\n    long[][] pre\
    \ = new long[N][N];\n    for (long i = 0; i < N; i++)\n    {\n        for (long\
    \ j = 0; j < N; j++)\n        {\n            dp[i][j] = grid[i][j];\n        \
    \    pre[i][j] = -1;\n        }\n    }\n    for (long i = 0; i < N; i++)\n   \
    \ {\n        for (long j = 0; j < N; j++)\n        {\n            if (i > 0 &&\
    \ dp[i - 1][j] < dp[i][j])\n            {\n                dp[i][j] = dp[i - 1][j];\n\
    \                pre[i][j] = 0;\n            }\n            if (j > 0 && dp[i][j\
    \ - 1] < dp[i][j])\n            {\n                dp[i][j] = dp[i][j - 1];\n\
    \                pre[i][j] = 1;\n            }\n            if (i < N - 1 && dp[i\
    \ + 1][j] < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j];\n\
    \                pre[i][j] = 2;\n            }\n            if (j < N - 1 && dp[i][j\
    \ + 1] < dp[i][j])\n            {\n                dp[i][j] = dp[i][j + 1];\n\
    \                pre[i][j] = 3;\n            }\n        }\n    }\n    long[] res\
    \ = new long[(int)k];\n    long x = 0;\n    long y = 0;\n    for (long i = 0;\
    \ i < k; i++)\n    {\n        res[(int)i] = grid[(int)x][(int)y];\n        if\
    \ (pre[(int)x][(int)y] == 0)\n        {\n            x -= 1;\n        }\n    \
    \    else if (pre[(int)x", "{\n    int n = grid.length;\n    int[][] dp = new\
    \ int[n][n];\n    int[][] prev = new int[n][n];\n    for (int i = 0; i < n; i++)\n\
    \        for (int j = 0; j < n; j++)\n            dp[i][j] = int.max;\n    dp[0][0]\
    \ = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n\
    \        {\n            if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n          \
    \  {\n                dp[i][j] = dp[i - 1][j] + 1;\n                prev[i][j]\
    \ = 0;\n            }\n            if (j > 0 && dp[i][j - 1] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i][j - 1] + 1;\n               \
    \ prev[i][j] = 1;\n            }\n            if (i < n - 1 && dp[i + 1][j] +\
    \ 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j] + 1;\n\
    \                prev[i][j] = 2;\n            }\n            if (j < n - 1 &&\
    \ dp[i][j + 1] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j\
    \ + 1] + 1;\n                prev[i][j] = 3;\n            }\n        }\n    long[]\
    \ res = new long[(int)k];\n    int x = n - 1, y = n - 1;\n    for (int i = (int)k\
    \ - 1; i >= 0; i--)\n    {\n        res[i] = grid[x][y];\n        switch (prev[x][y])\n\
    \        {\n            case 0:\n                x++;\n                break;\n\
    \            case 1:\n                y++;\n                break;\n         \
    \   case 2:", "{\n    long n = grid.length;\n    long[][] dp = new long[n][n];\n\
    \    long[][] prev = new long[n][n];\n    foreach(i; 0 .. n)\n    {\n        foreach(j;\
    \ 0 .. n)\n        {\n            dp[i][j] = long.max;\n            prev[i][j]\
    \ = -1;\n        }\n    }\n    dp[0][0] = grid[0][0];\n    foreach(i; 0 .. n)\n\
    \    {\n        foreach(j; 0 .. n)\n        {\n            if(i > 0)\n       \
    \     {\n                if(dp[i - 1][j] + grid[i][j] < dp[i][j])\n          \
    \      {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n        \
    \            prev[i][j] = 0;\n                }\n            }\n            if(j\
    \ > 0)\n            {\n                if(dp[i][j - 1] + grid[i][j] < dp[i][j])\n\
    \                {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                    prev[i][j] = 1;\n                }\n            }\n     \
    \   }\n    }\n    long[] res = new long[k];\n    long x = n - 1;\n    long y =\
    \ n - 1;\n    foreach(i; 0 .. k)\n    {\n        res[k - i - 1] = grid[x][y];\n\
    \        if(prev[x][y] == 0)\n        {\n            x--;\n        }\n       \
    \ else\n        {\n            y--;\n        }\n    }\n    return res;\n}", "{\n\
    \    long N = grid.length;\n    long[][] dp = new long[N][N];\n    long[][] path\
    \ = new long[N][N];\n    long[][] path_len = new long[N][N];\n    long[][] path_val\
    \ = new long[N][N];\n    long[][] path_val_len = new long[N][N];\n    long[][]\
    \ path_val_len_idx = new long[N][N];\n    long[][] path_val_len_idx_len = new\
    \ long[N][N];\n    long[][] path_val_len_idx_len_idx = new long[N][N];\n    for\
    \ (long i = 0; i < N; i++)\n    {\n        for (long j = 0; j < N; j++)\n    \
    \    {\n            dp[i][j] = long.max;\n            path[i][j] = -1;\n     \
    \       path_len[i][j] = -1;\n            path_val[i][j] = -1;\n            path_val_len[i][j]\
    \ = -1;\n            path_val_len_idx[i][j] = -1;\n            path_val_len_idx_len[i][j]\
    \ = -1;\n            path_val_len_idx_len_idx[i][j] = -1;\n        }\n    }\n\
    \    dp[0][0] = 0;\n    path[0][0] = 0;\n    path_len[0][0] = 0;\n    path_val[0][0]\
    \ = grid[0][0];\n    path_val_len[0][0] = 1;\n    path_val_len_idx[0][0] = 0;\n\
    \    path_val_len_idx_len[0][0] = 1;\n    path_val_len_idx_len_idx[0][0] = 0;\n\
    \    for (long i = 0; i < N; i++)\n    {\n        for (long j = 0; j < N; j++)\n\
    \        {\n            if", "{\n    int n = grid.length;\n    int[][] dp = new\
    \ int[n][n];\n    int[][] path = new int[n][n];\n    for (int i = 0; i < n; i++)\n\
    \    {\n        for (int j = 0; j < n; j++)\n        {\n            dp[i][j] =\
    \ int.max;\n            path[i][j] = -1;\n        }\n    }\n    dp[0][0] = 0;\n\
    \    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n\
    \        {\n            if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n          \
    \  {\n                dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j]\
    \ = 0;\n            }\n            if (j > 0 && dp[i][j - 1] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i][j - 1] + 1;\n               \
    \ path[i][j] = 1;\n            }\n            if (i < n - 1 && dp[i + 1][j] +\
    \ 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j] + 1;\n\
    \                path[i][j] = 2;\n            }\n            if (j < n - 1 &&\
    \ dp[i][j + 1] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j\
    \ + 1] + 1;\n                path[i][j] = 3;\n            }\n        }\n    }\n\
    \    int[] cur = [n - 1, n - 1];\n    long[] res = new long[k];\n    for (int\
    \ i = 0; i < k; i++)\n    {\n        res[i] = grid[cur[0]][cur[1]];\n        switch\
    \ (path[cur[0]][cur[1]])\n", "{\n    int N = grid.length;\n    long[][] dp = new\
    \ long[N][N];\n    long[][] prev = new long[N][N];\n    for (int i = 0; i < N;\
    \ i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n            dp[i][j]\
    \ = grid[i][j];\n            prev[i][j] = -1;\n        }\n    }\n    for (int\
    \ i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n\
    \            if (i > 0 && dp[i][j] > dp[i - 1][j])\n            {\n          \
    \      dp[i][j] = dp[i - 1][j];\n                prev[i][j] = 0;\n           \
    \ }\n            if (j > 0 && dp[i][j] > dp[i][j - 1])\n            {\n      \
    \          dp[i][j] = dp[i][j - 1];\n                prev[i][j] = 1;\n       \
    \     }\n            if (i < N - 1 && dp[i][j] > dp[i + 1][j])\n            {\n\
    \                dp[i][j] = dp[i + 1][j];\n                prev[i][j] = 2;\n \
    \           }\n            if (j < N - 1 && dp[i][j] > dp[i][j + 1])\n       \
    \     {\n                dp[i][j] = dp[i][j + 1];\n                prev[i][j]\
    \ = 3;\n            }\n        }\n    }\n    long[] res = new long[(int)k];\n\
    \    int x = 0, y = 0;\n    for (int i = 0; i < k; i++)\n    {\n        res[i]\
    \ = grid[x][y];\n        switch ((int)prev[x][y])\n        {\n            case\
    \ 0:\n                x--;\n                break;\n            case 1:\n    \
    \            y--;\n                break;\n            case 2:\n             \
    \   x++;\n               ", "{\n    long n = grid.length;\n    long[] result =\
    \ new long[(int)k];\n    long[][] dp = new long[(int)n][(int)n];\n    for (long\
    \ i = 0; i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n\
    \            dp[(int)i][(int)j] = grid[(int)i][(int)j];\n        }\n    }\n  \
    \  for (long i = 0; i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n\
    \        {\n            if (i > 0)\n            {\n                dp[(int)i][(int)j]\
    \ = min(dp[(int)i][(int)j], dp[(int)i - 1][(int)j]);\n            }\n        \
    \    if (j > 0)\n            {\n                dp[(int)i][(int)j] = min(dp[(int)i][(int)j],\
    \ dp[(int)i][(int)j - 1]);\n            }\n        }\n    }\n    long i = 0;\n\
    \    long j = 0;\n    for (long l = 0; l < k; l++)\n    {\n        result[(int)l]\
    \ = dp[(int)i][(int)j];\n        if (i > 0 && dp[(int)i - 1][(int)j] < dp[(int)i][(int)j])\n\
    \        {\n            i--;\n        }\n        else if (j > 0 && dp[(int)i][(int)j\
    \ - 1] < dp[(int)i][(int)j])\n        {\n            j--;\n        }\n       \
    \ else if (i < n - 1 && dp[(int)i + 1][(int)j] < dp[(int)i][(int)j])\n       \
    \ {\n            i++;\n        }\n        else if (j < n - 1 && dp[(int)i][(int)j\
    \ + 1] < dp[(int)", "{\n    int n = grid.length;\n    int[][] dp = new int[n][n];\n\
    \    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n      \
    \      dp[i][j] = (int)grid[i][j];\n    for (int i = 1; i < n; i++)\n        dp[0][i]\
    \ += dp[0][i - 1];\n    for (int i = 1; i < n; i++)\n        dp[i][0] += dp[i\
    \ - 1][0];\n    for (int i = 1; i < n; i++)\n        for (int j = 1; j < n; j++)\n\
    \            dp[i][j] += min(dp[i - 1][j], dp[i][j - 1]);\n    long[] res = new\
    \ long[(int)k];\n    int i = 0, j = 0;\n    for (int l = 0; l < k; l++)\n    {\n\
    \        res[l] = grid[i][j];\n        if (i == n - 1)\n            j++;\n   \
    \     else if (j == n - 1)\n            i++;\n        else if (dp[i + 1][j] <\
    \ dp[i][j + 1])\n            i++;\n        else\n            j++;\n    }\n   \
    \ return res;\n}", "{\n    int N = grid.length;\n    int[][] dp = new int[N][N];\n\
    \    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n      \
    \      dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n\
    \        for (int j = 0; j < N; j++)\n        {\n            if (i > 0)\n    \
    \            dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n          \
    \  if (j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n\
    \        }\n    int[][] dp2 = new int[N][N];\n    for (int i = 0; i < N; i++)\n\
    \        for (int j = 0; j < N; j++)\n            dp2[i][j] = int.max;\n    dp2[N\
    \ - 1][N - 1] = 0;\n    for (int i = N - 1; i >= 0; i--)\n        for (int j =\
    \ N - 1; j >= 0; j--)\n        {\n            if (i < N - 1)\n               \
    \ dp2[i][j] = min(dp2[i][j], dp2[i + 1][j] + grid[i][j]);\n            if (j <\
    \ N - 1)\n                dp2[i][j] = min(dp2[i][j], dp2[i][j + 1] + grid[i][j]);\n\
    \        }\n    int[][] dp3 = new int[N][N];\n    for (int i = 0; i < N; i++)\n\
    \        for (int j = 0; j < N; j++)\n            dp3[i][j] = dp[i][j] + dp2[i][j]\
    \ - grid[i][j];\n    int[][] dp4 = new int[", "{\n    int n = grid.length;\n \
    \   int[][] dp = new int[n][n];\n    for (int i = 0; i < n; i++)\n        for\
    \ (int j = 0; j < n; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n\
    \    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n      \
    \  {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i -\
    \ 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + grid[i][j]);\n        }\n    int[][] dp2 = new int[n][n];\n \
    \   for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n       \
    \     dp2[i][j] = int.max;\n    dp2[n - 1][n - 1] = 0;\n    for (int i = n - 1;\
    \ i >= 0; i--)\n        for (int j = n - 1; j >= 0; j--)\n        {\n        \
    \    if (i < n - 1)\n                dp2[i][j] = min(dp2[i][j], dp2[i + 1][j]\
    \ + grid[i][j]);\n            if (j < n - 1)\n                dp2[i][j] = min(dp2[i][j],\
    \ dp2[i][j + 1] + grid[i][j]);\n        }\n    int[][] dp3 = new int[n][n];\n\
    \    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n      \
    \      dp3[i][j] = dp[i][j] + dp2[i][j] - grid[i][j];\n    int[][] dp4 = new int[",
  "{\n    long n = grid.length;\n    long[][] dp = new long[n][n];\n    long[][] prev\
    \ = new long[n][n];\n    for (long i = 0; i < n; i++)\n    {\n        for (long\
    \ j = 0; j < n; j++)\n        {\n            dp[i][j] = long.max;\n          \
    \  prev[i][j] = -1;\n        }\n    }\n    dp[0][0] = grid[0][0];\n    for (long\
    \ i = 0; i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n\
    \            if (i > 0 && dp[i - 1][j] + grid[i][j] < dp[i][j])\n            {\n\
    \                dp[i][j] = dp[i - 1][j] + grid[i][j];\n                prev[i][j]\
    \ = 0;\n            }\n            if (j > 0 && dp[i][j - 1] + grid[i][j] < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n      \
    \          prev[i][j] = 1;\n            }\n            if (i < n - 1 && dp[i +\
    \ 1][j] + grid[i][j] < dp[i][j])\n            {\n                dp[i][j] = dp[i\
    \ + 1][j] + grid[i][j];\n                prev[i][j] = 2;\n            }\n    \
    \        if (j < n - 1 && dp[i][j + 1] + grid[i][j] < dp[i][j])\n            {\n\
    \                dp[i][j] = dp[i][j + 1] + grid[i][j];\n                prev[i][j]\
    \ = 3;\n            }\n        }\n    }\n    long[] res = new long[k];\n    long\
    \ i = n - 1;\n    long j = n - 1;\n    for (long t = k - 1;", "{\n    int N =\
    \ grid.length;\n    int[][] dp = new int[N][N];\n    for (int i = 0; i < N; i++)\n\
    \        for (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n    dp[0][0]\
    \ = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n\
    \        {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i\
    \ - 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + grid[i][j]);\n        }\n    int[] path = new int[k];\n    path[0]\
    \ = grid[0][0];\n    int i = 0, j = 0;\n    for (int l = 1; l < k; l++)\n    {\n\
    \        if (i > 0 && j > 0)\n        {\n            if (dp[i - 1][j] < dp[i][j\
    \ - 1])\n            {\n                path[l] = grid[i - 1][j];\n          \
    \      i--;\n            }\n            else\n            {\n                path[l]\
    \ = grid[i][j - 1];\n                j--;\n            }\n        }\n        else\
    \ if (i > 0)\n        {\n            path[l] = grid[i - 1][j];\n            i--;\n\
    \        }\n        else\n        {\n            path[l] = grid[i][j - 1];\n \
    \           j--;\n        }\n    }\n    return path;\n}", "{\n    int n = grid.length;\n\
    \    int[][] dp = new int[n][n];\n    int[][] prev = new int[n][n];\n    for (int\
    \ i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j]\
    \ = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++)\n        for\
    \ (int j = 0; j < n; j++)\n        {\n            if (i > 0 && dp[i - 1][j] +\
    \ grid[i][j] < dp[i][j])\n            {\n                dp[i][j] = dp[i - 1][j]\
    \ + grid[i][j];\n                prev[i][j] = 1;\n            }\n            if\
    \ (j > 0 && dp[i][j - 1] + grid[i][j] < dp[i][j])\n            {\n           \
    \     dp[i][j] = dp[i][j - 1] + grid[i][j];\n                prev[i][j] = 2;\n\
    \            }\n            if (i < n - 1 && dp[i + 1][j] + grid[i][j] < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i + 1][j] + grid[i][j];\n      \
    \          prev[i][j] = 3;\n            }\n            if (j < n - 1 && dp[i][j\
    \ + 1] + grid[i][j] < dp[i][j])\n            {\n                dp[i][j] = dp[i][j\
    \ + 1] + grid[i][j];\n                prev[i][j] = 4;\n            }\n       \
    \ }\n    int x = 0, y = 0;\n    long[] res = new long[(int)k];\n    for (int i\
    \ = 0; i < k; i++)\n    {\n        res[i] = grid[x][y];\n        if (prev[x][y]\
    \ == 1)\n            x--;", "{\n    int N = grid.length;\n    long[][] dp = new\
    \ long[N][N];\n    foreach(i; 0 .. N)\n        foreach(j; 0 .. N)\n          \
    \  dp[i][j] = long.max;\n    dp[0][0] = grid[0][0];\n    foreach(i; 0 .. N)\n\
    \        foreach(j; 0 .. N)\n        {\n            if(i > 0)\n              \
    \  dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n            if(j > 0)\n\
    \                dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n      \
    \  }\n    long[] ans = new long[k];\n    int i = 0, j = 0;\n    foreach(idx; 0\
    \ .. k)\n    {\n        ans[idx] = grid[i][j];\n        if(i < N - 1 && dp[i +\
    \ 1][j] + grid[i][j] == dp[i][j])\n            i++;\n        else\n          \
    \  j++;\n    }\n    return ans;\n}", "{\n    auto n = grid.length;\n    auto m\
    \ = grid[0].length;\n    auto dp = new long[][](n, m);\n    auto p = new long[][](n,\
    \ m);\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m;\
    \ j++)\n        {\n            dp[i][j] = grid[i][j];\n            p[i][j] = 1;\n\
    \        }\n    }\n    for (int i = 1; i < n; i++)\n    {\n        for (int j\
    \ = 0; j < m; j++)\n        {\n            if (dp[i - 1][j] < dp[i][j])\n    \
    \        {\n                dp[i][j] = dp[i - 1][j];\n                p[i][j]\
    \ = p[i - 1][j];\n            }\n            else if (dp[i - 1][j] == dp[i][j])\n\
    \            {\n                p[i][j] += p[i - 1][j];\n            }\n     \
    \   }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 1;\
    \ j < m; j++)\n        {\n            if (dp[i][j - 1] < dp[i][j])\n         \
    \   {\n                dp[i][j] = dp[i][j - 1];\n                p[i][j] = p[i][j\
    \ - 1];\n            }\n            else if (dp[i][j - 1] == dp[i][j])\n     \
    \       {\n                p[i][j] += p[i][j - 1];\n            }\n        }\n\
    \    }\n    auto res = new long[k];\n    res[0] = dp[n - 1][m - 1];\n    int i\
    \ = n - 1;\n    int j = m - 1;\n    for (int l = 1; l < k; l++)\n    {\n     \
    \   if (i > 0 && dp[i - 1][j] == dp[i][j] - 1)\n        {\n", "{\n    long n =\
    \ grid.length;\n    long[][] dp = new long[n][n];\n    long[][] prev = new long[n][n];\n\
    \    long[][] next = new long[n][n];\n    for (long i = 0; i < n; i++)\n    {\n\
    \        for (long j = 0; j < n; j++)\n        {\n            dp[i][j] = grid[i][j];\n\
    \            prev[i][j] = -1;\n            next[i][j] = -1;\n        }\n    }\n\
    \    for (long step = 1; step < k; step++)\n    {\n        for (long i = 0; i\
    \ < n; i++)\n        {\n            for (long j = 0; j < n; j++)\n           \
    \ {\n                long min = dp[i][j];\n                long min_i = i;\n \
    \               long min_j = j;\n                if (i > 0 && dp[i - 1][j] < min)\n\
    \                {\n                    min = dp[i - 1][j];\n                \
    \    min_i = i - 1;\n                    min_j = j;\n                }\n     \
    \           if (i < n - 1 && dp[i + 1][j] < min)\n                {\n        \
    \            min = dp[i + 1][j];\n                    min_i = i + 1;\n       \
    \             min_j = j;\n                }\n                if (j > 0 && dp[i][j\
    \ - 1] < min)\n                {\n                    min = dp[i][j - 1];\n  \
    \                  min_i = i;\n                    min_j = j - 1;\n          \
    \      }\n                if (j < n - 1 && dp[i][j + 1] < min)\n             \
    \   {\n                    min = dp[i][j + 1];\n                    min_i = i;\n\
    \                    min_j = j + 1;\n                }\n                dp[i][j]\
    \ = min * 10 + grid[i][j];\n                prev[i][j] = min_i * n + min_j;\n\
    \            }\n        }\n    }\n    long min = dp[0", "{\n    int n = grid.length;\n\
    \    int[][] dp = new int[n][n];\n    for (int i = 0; i < n; i++)\n        for\
    \ (int j = 0; j < n; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n\
    \    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n      \
    \  {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i -\
    \ 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + grid[i][j]);\n        }\n    int[][] dp2 = new int[n][n];\n \
    \   for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n       \
    \     dp2[i][j] = int.max;\n    dp2[n - 1][n - 1] = 0;\n    for (int i = n - 1;\
    \ i >= 0; i--)\n        for (int j = n - 1; j >= 0; j--)\n        {\n        \
    \    if (i < n - 1)\n                dp2[i][j] = min(dp2[i][j], dp2[i + 1][j]\
    \ + grid[i][j]);\n            if (j < n - 1)\n                dp2[i][j] = min(dp2[i][j],\
    \ dp2[i][j + 1] + grid[i][j]);\n        }\n    int[][] dp3 = new int[n][n];\n\
    \    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n      \
    \      dp3[i][j] = dp[i][j] + dp2[i][j] - grid[i][j];\n    int[][] dp4 = new int[",
  "{\n    long N = grid.length;\n    long[][] dp = new long[N][N];\n    long[][] prev\
    \ = new long[N][N];\n    foreach (i; 0 .. N)\n    {\n        foreach (j; 0 ..\
    \ N)\n        {\n            dp[i][j] = long.max;\n            prev[i][j] = -1;\n\
    \        }\n    }\n    dp[0][0] = grid[0][0];\n    foreach (i; 0 .. N)\n    {\n\
    \        foreach (j; 0 .. N)\n        {\n            if (i > 0)\n            {\n\
    \                if (dp[i][j] > dp[i - 1][j] + grid[i][j])\n                {\n\
    \                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n                 \
    \   prev[i][j] = 0;\n                }\n            }\n            if (j > 0)\n\
    \            {\n                if (dp[i][j] > dp[i][j - 1] + grid[i][j])\n  \
    \              {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                    prev[i][j] = 1;\n                }\n            }\n     \
    \   }\n    }\n    long[] res = new long[k];\n    long i = N - 1;\n    long j =\
    \ N - 1;\n    foreach (idx; k .. 0)\n    {\n        res[idx] = grid[i][j];\n \
    \       if (prev[i][j] == 0)\n        {\n            i--;\n        }\n       \
    \ else if (prev[i][j] == 1)\n        {\n            j--;\n        }\n    }\n \
    \   return res;\n}", "{\n    long n = grid.length;\n    long[][] dp = new long[n][n];\n\
    \    foreach(i; 0 .. n)\n        foreach(j; 0 .. n)\n            dp[i][j] = long.max;\n\
    \    dp[0][0] = grid[0][0];\n    foreach(i; 0 .. n)\n        foreach(j; 0 .. n)\n\
    \        {\n            if(i + 1 < n)\n                dp[i + 1][j] = min(dp[i\
    \ + 1][j], dp[i][j] + grid[i + 1][j]);\n            if(j + 1 < n)\n          \
    \      dp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + grid[i][j + 1]);\n        }\n\
    \    long[] res = new long[k];\n    long cur = 0;\n    foreach(i; 0 .. k)\n  \
    \  {\n        res[i] = grid[cur / n][cur % n];\n        if(cur % n + 1 < n &&\
    \ dp[cur / n][cur % n + 1] + grid[cur / n][cur % n + 1] == dp[cur / n][cur % n])\n\
    \            cur++;\n        else if(cur / n + 1 < n && dp[cur / n + 1][cur %\
    \ n] + grid[cur / n + 1][cur % n] == dp[cur / n][cur % n])\n            cur +=\
    \ n;\n    }\n    return res;\n}", "{\n    int n = grid.length;\n    int[][] dp\
    \ = new int[n][n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j\
    \ < n; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int\
    \ i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n        {\n       \
    \     if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n\
    \            if (j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1]\
    \ + grid[i][j]);\n        }\n    int[] ans = new int[k];\n    for (int i = 0;\
    \ i < k; i++)\n        ans[i] = grid[0][0];\n    int x = 0, y = 0;\n    for (int\
    \ i = 1; i < k; i++)\n    {\n        if (x + 1 < n && dp[x + 1][y] + grid[x +\
    \ 1][y] == dp[x][y])\n        {\n            x++;\n            ans[i] = grid[x][y];\n\
    \        }\n        else\n        {\n            y++;\n            ans[i] = grid[x][y];\n\
    \        }\n    }\n    return ans;\n}", "{\n    long n = grid.length;\n    long[][]\
    \ dp = new long[n][n];\n    long[][] prev = new long[n][n];\n    long[][] next\
    \ = new long[n][n];\n    long[][] dist = new long[n][n];\n    for (long i = 0;\
    \ i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n      \
    \      dp[i][j] = grid[i][j];\n            prev[i][j] = -1;\n            next[i][j]\
    \ = -1;\n            dist[i][j] = -1;\n        }\n    }\n    for (long i = 0;\
    \ i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n      \
    \      if (i > 0 && dp[i - 1][j] < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i - 1][j];\n                prev[i][j] = (i - 1) * n + j;\n           \
    \ }\n            if (j > 0 && dp[i][j - 1] < dp[i][j])\n            {\n      \
    \          dp[i][j] = dp[i][j - 1];\n                prev[i][j] = i * n + j -\
    \ 1;\n            }\n            if (i < n - 1 && dp[i + 1][j] < dp[i][j])\n \
    \           {\n                dp[i][j] = dp[i + 1][j];\n                prev[i][j]\
    \ = (i + 1) * n + j;\n            }\n            if (j < n - 1 && dp[i][j + 1]\
    \ < dp[i][j])\n            {\n                dp[i][j] = dp[i][j + 1];\n     \
    \           prev[i][j] = i * n + j + 1;\n            }\n        }\n    }\n   \
    \ for (long i = 0; i < n; i++)\n    {\n        for (long j = 0; j", "{\n    //\
    \ Write your code here\n    int N = grid.length;\n    int[][] dp = new int[N][N];\n\
    \    int[][] prev = new int[N][N];\n    for (int i = 0; i < N; i++) {\n      \
    \  for (int j = 0; j < N; j++) {\n            dp[i][j] = int.max;\n          \
    \  prev[i][j] = -1;\n        }\n    }\n    dp[0][0] = 0;\n    prev[0][0] = -1;\n\
    \    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n  \
    \          if (i > 0) {\n                if (dp[i - 1][j] + 1 < dp[i][j]) {\n\
    \                    dp[i][j] = dp[i - 1][j] + 1;\n                    prev[i][j]\
    \ = 0;\n                }\n            }\n            if (j > 0) {\n         \
    \       if (dp[i][j - 1] + 1 < dp[i][j]) {\n                    dp[i][j] = dp[i][j\
    \ - 1] + 1;\n                    prev[i][j] = 1;\n                }\n        \
    \    }\n            if (i < N - 1) {\n                if (dp[i + 1][j] + 1 < dp[i][j])\
    \ {\n                    dp[i][j] = dp[i + 1][j] + 1;\n                    prev[i][j]\
    \ = 2;\n                }\n            }\n            if (j < N - 1) {\n     \
    \           if (dp[i][j + 1] + 1 < dp[i][j]) {\n                    dp[i][j] =\
    \ dp[i][j + 1] + 1;\n                    prev[i][j] = 3;\n                }\n\
    \            }\n        }\n    }\n    int x = 0;\n    int y = 0;\n    long[] res\
    \ = new long[k];\n    for (int i = 0; i < k; i++) {\n        res[i] = grid", "{\n\
    \    long n = grid.length;\n    long[][] dp = new long[n][n];\n    foreach(i;\
    \ 0 .. n)\n        foreach(j; 0 .. n)\n            dp[i][j] = grid[i][j];\n  \
    \  foreach(i; 1 .. n)\n        foreach(j; 1 .. n)\n            dp[i][j] += min(dp[i\
    \ - 1][j], dp[i][j - 1]);\n    long[] res = new long[k];\n    long i = n - 1,\
    \ j = n - 1;\n    foreach(idx; k)\n    {\n        res[idx] = grid[i][j];\n   \
    \     if(i == 0)\n            j--;\n        else if(j == 0)\n            i--;\n\
    \        else if(dp[i - 1][j] < dp[i][j - 1])\n            i--;\n        else\n\
    \            j--;\n    }\n    return res;\n}", "{\n    long n = grid.length;\n\
    \    long[][] dp = new long[n][n];\n    long[][] prev = new long[n][n];\n    long[][]\
    \ next = new long[n][n];\n    foreach (i; 0 .. n)\n    {\n        foreach (j;\
    \ 0 .. n)\n        {\n            dp[i][j] = grid[i][j];\n            prev[i][j]\
    \ = -1;\n            next[i][j] = -1;\n        }\n    }\n    foreach (i; 1 ..\
    \ k)\n    {\n        foreach (j; 0 .. n)\n        {\n            foreach (l; 0\
    \ .. n)\n            {\n                dp[j][l] = grid[j][l];\n             \
    \   prev[j][l] = -1;\n                next[j][l] = -1;\n            }\n      \
    \  }\n        foreach (j; 0 .. n)\n        {\n            foreach (l; 0 .. n)\n\
    \            {\n                if (j > 0)\n                {\n              \
    \      if (dp[j - 1][l] < dp[j][l])\n                    {\n                 \
    \       dp[j][l] = dp[j - 1][l];\n                        prev[j][l] = j - 1;\n\
    \                        next[j][l] = l;\n                    }\n            \
    \        else if (dp[j - 1][l] == dp[j][l])\n                    {\n         \
    \               if (prev[j - 1][l] != -1)\n                        {\n       \
    \                     if (dp[prev[j - 1][l]][next[j - 1][l]] < dp[prev[j][l]][next[j][l]])\n\
    \                            {\n                                dp[j][l] = dp[j\
    \ - 1][l];\n                                prev[j][l] = j - 1;\n            \
    \                    next[j][l] = l;\n                            }\n        \
    \                }\n                    }\n                }\n               \
    \ if (j < n - 1)\n                {\n                    if (dp[j + 1][l] < dp[j][l])\n\
    \                    {\n", "{\n    import std.algorithm : min;\n    import std.array\
    \ : array;\n    import std.range : iota;\n    import std.typecons : tuple;\n \
    \   import std.typecons : tuple;\n    import std.math : min;\n    import std.algorithm\
    \ : min;\n    import std.array : array;\n    import std.range : iota;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.math\
    \ : min;\n    import std.algorithm : min;\n    import std.array : array;\n   \
    \ import std.range : iota;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.math : min;\n    import std.algorithm : min;\n    import\
    \ std.array : array;\n    import std.range : iota;\n    import std.typecons :\
    \ tuple;\n    import std.typecons : tuple;\n    import std.math : min;\n    import\
    \ std.algorithm : min;\n    import std.array : array;\n    import std.range :\
    \ iota;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.math : min;\n    import std.algorithm : min;\n    import std.array\
    \ : array;\n    import std.range : iota;\n    import std.typecons : tuple;\n \
    \   import std.typecons : tuple;\n    import std.math : min;\n    import std.algorithm\
    \ : min;\n    import std.array : array;\n    import std.range : iota;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.math\
    \ : min;\n    import std.algorithm : min;\n    import std.array : array;\n   \
    \ import std.range : iota;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.math : min;\n    import std.algorithm : min;\n    import\
    \ std.array : array;\n    import std.range : iota;\n    import std.typecons :\
    \ tuple;\n    import std.typecons", "{\n    long n = grid.length;\n    long[][]\
    \ dp = new long[n][n];\n    long[][] prev = new long[n][n];\n    for (long i =\
    \ 0; i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n   \
    \         dp[i][j] = long.max;\n            prev[i][j] = -1;\n        }\n    }\n\
    \    dp[0][0] = grid[0][0];\n    for (long i = 0; i < n; i++)\n    {\n       \
    \ for (long j = 0; j < n; j++)\n        {\n            if (i > 0 && dp[i - 1][j]\
    \ < dp[i][j])\n            {\n                dp[i][j] = dp[i - 1][j];\n     \
    \           prev[i][j] = 0;\n            }\n            if (j > 0 && dp[i][j -\
    \ 1] < dp[i][j])\n            {\n                dp[i][j] = dp[i][j - 1];\n  \
    \              prev[i][j] = 1;\n            }\n            if (i < n - 1 && dp[i\
    \ + 1][j] < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j];\n\
    \                prev[i][j] = 2;\n            }\n            if (j < n - 1 &&\
    \ dp[i][j + 1] < dp[i][j])\n            {\n                dp[i][j] = dp[i][j\
    \ + 1];\n                prev[i][j] = 3;\n            }\n            dp[i][j]\
    \ += grid[i][j];\n        }\n    }\n    long[] res = new long[k];\n    long i\
    \ = n - 1;\n    long j = n - 1;\n    for (long l = k - 1; l >= 0; l--)\n    {\n\
    \        res[l] = grid[i][j];\n        if (prev[i][j] == 0)\n            i--",
  "{\n    int N = grid.length;\n    int[][] dp = new int[N][N];\n    int[][] prev\
    \ = new int[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j\
    \ < N; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int\
    \ i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n        {\n       \
    \     if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n            {\n             \
    \   dp[i][j] = dp[i - 1][j] + 1;\n                prev[i][j] = 0;\n          \
    \  }\n            if (j > 0 && dp[i][j - 1] + 1 < dp[i][j])\n            {\n \
    \               dp[i][j] = dp[i][j - 1] + 1;\n                prev[i][j] = 1;\n\
    \            }\n            if (i < N - 1 && dp[i + 1][j] + 1 < dp[i][j])\n  \
    \          {\n                dp[i][j] = dp[i + 1][j] + 1;\n                prev[i][j]\
    \ = 2;\n            }\n            if (j < N - 1 && dp[i][j + 1] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i][j + 1] + 1;\n               \
    \ prev[i][j] = 3;\n            }\n        }\n    long[] res = new long[(int)k];\n\
    \    int i = N - 1, j = N - 1;\n    for (int t = (int)k - 1; t >= 0; t--)\n  \
    \  {\n        res[t] = grid[i][j];\n        switch (prev[i][j])\n        {\n \
    \           case 0:\n                i++;\n                break;\n          \
    \  case 1:\n                j++;\n                break;\n            case 2:",
  "{\n    import std.algorithm : min, max;\n    import std.range : iota;\n    import\
    \ std.array : array;\n    import std.conv : to;\n    import std.algorithm : sort;\n\
    \    import std.range : retro;\n    import std.typecons : tuple;\n    import std.math\
    \ : min;\n    import std.algorithm : minElement;\n    import std.algorithm : map;\n\
    \    import std.algorithm : zip;\n    import std.algorithm : sort;\n    import\
    \ std.algorithm : retro;\n    import std.range : retro;\n    import std.range\
    \ : iota;\n    import std.array : array;\n    import std.typecons : tuple;\n \
    \   import std.algorithm : minElement;\n    import std.algorithm : map;\n    import\
    \ std.algorithm : zip;\n    import std.algorithm : sort;\n    import std.algorithm\
    \ : retro;\n    import std.range : retro;\n    import std.range : iota;\n    import\
    \ std.array : array;\n    import std.typecons : tuple;\n    import std.algorithm\
    \ : minElement;\n    import std.algorithm : map;\n    import std.algorithm : zip;\n\
    \    import std.algorithm : sort;\n    import std.algorithm : retro;\n    import\
    \ std.range : retro;\n    import std.range : iota;\n    import std.array : array;\n\
    \    import std.typecons : tuple;\n    import std.algorithm : minElement;\n  \
    \  import std.algorithm : map;\n    import std.algorithm : zip;\n    import std.algorithm\
    \ : sort;\n    import std.algorithm : retro;\n    import std.range : retro;\n\
    \    import std.range : iota;\n    import std.array : array;\n    import std.typecons\
    \ : tuple;\n    import std.algorithm : minElement;\n    import std.algorithm :\
    \ map;\n    import std.algorithm : zip;\n    import std.algorithm : sort;\n  \
    \  import std.algorithm : retro;\n    import std.range : retro;\n    import std.range\
    \ : iota;\n    import std.array", "{\n    long N = grid.length;\n    long[][]\
    \ dp = new long[N][N];\n    long[][] prev = new long[N][N];\n    long[][] next\
    \ = new long[N][N];\n    long[][] visited = new long[N][N];\n    long[][] path\
    \ = new long[N][N];\n    long[][] path_prev = new long[N][N];\n    long[][] path_next\
    \ = new long[N][N];\n    long[][] path_visited = new long[N][N];\n    long[][]\
    \ path_length = new long[N][N];\n    long[][] path_length_prev = new long[N][N];\n\
    \    long[][] path_length_next = new long[N][N];\n    long[][] path_length_visited\
    \ = new long[N][N];\n    long[][] path_length_path = new long[N][N];\n    long[][]\
    \ path_length_path_prev = new long[N][N];\n    long[][] path_length_path_next\
    \ = new long[N][N];\n    long[][] path_length_path_visited = new long[N][N];\n\
    \    long[][] path_length_path_length = new long[N][N];\n    long[][] path_length_path_length_prev\
    \ = new long[N][N];\n    long[][] path_length_path_length_next = new long[N][N];\n\
    \    long[][] path_length_path_length_visited = new long[N][N];\n    long[][]\
    \ path_length_path_length_path = new long[N][N];\n    long[][] path_length_path_length_path_prev\
    \ = new long[N][N];\n    long[][] path_length_path_length_path_next = new long[N][N];\n\
    \    long[][] path_length_path_length_path_visited = new long[N][N];\n    long[][]\
    \ path_length_path_length_path_length = new long[N][N];", "{\n    long N = grid.length;\n\
    \    long[][] dp = new long[N][N];\n    long[][] prev = new long[N][N];\n    for\
    \ (long i = 0; i < N; i++)\n    {\n        for (long j = 0; j < N; j++)\n    \
    \    {\n            dp[i][j] = grid[i][j];\n            prev[i][j] = -1;\n   \
    \     }\n    }\n    for (long i = 0; i < N; i++)\n    {\n        for (long j =\
    \ 0; j < N; j++)\n        {\n            if (i > 0 && dp[i - 1][j] < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i - 1][j];\n                prev[i][j]\
    \ = 0;\n            }\n            if (j > 0 && dp[i][j - 1] < dp[i][j])\n   \
    \         {\n                dp[i][j] = dp[i][j - 1];\n                prev[i][j]\
    \ = 1;\n            }\n            if (i < N - 1 && dp[i + 1][j] < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i + 1][j];\n                prev[i][j]\
    \ = 2;\n            }\n            if (j < N - 1 && dp[i][j + 1] < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i][j + 1];\n                prev[i][j]\
    \ = 3;\n            }\n        }\n    }\n    long[] res = new long[k];\n    long\
    \ i = 0;\n    long j = 0;\n    for (long l = 0; l < k; l++)\n    {\n        res[l]\
    \ = grid[i][j];\n        if (prev[i][j] == 0)\n        {\n            i--;\n \
    \       }\n        else if (prev[i][j] == 1)\n        {\n            j--;\n  \
    \      }\n        else if (", "{\n    long N = grid.length;\n    long[][] dp =\
    \ new long[N][N];\n    long[][] prev = new long[N][N];\n    long[][] next = new\
    \ long[N][N];\n    long[][] dist = new long[N][N];\n    for (long i = 0; i < N;\
    \ i++)\n    {\n        for (long j = 0; j < N; j++)\n        {\n            dp[i][j]\
    \ = grid[i][j];\n            prev[i][j] = -1;\n            next[i][j] = -1;\n\
    \            dist[i][j] = -1;\n        }\n    }\n    for (long i = 0; i < N; i++)\n\
    \    {\n        for (long j = 0; j < N; j++)\n        {\n            if (i > 0\
    \ && dp[i - 1][j] > dp[i][j])\n            {\n                dp[i][j] = dp[i\
    \ - 1][j];\n                prev[i][j] = (i - 1) * N + j;\n            }\n   \
    \         if (j > 0 && dp[i][j - 1] > dp[i][j])\n            {\n             \
    \   dp[i][j] = dp[i][j - 1];\n                prev[i][j] = i * N + j - 1;\n  \
    \          }\n            if (i < N - 1 && dp[i + 1][j] > dp[i][j])\n        \
    \    {\n                dp[i][j] = dp[i + 1][j];\n                prev[i][j] =\
    \ (i + 1) * N + j;\n            }\n            if (j < N - 1 && dp[i][j + 1] >\
    \ dp[i][j])\n            {\n                dp[i][j] = dp[i][j + 1];\n       \
    \         prev[i][j] = i * N + j + 1;\n            }\n        }\n    }\n    for\
    \ (long i = 0; i < N; i++)\n    {\n        for (long j = 0; j", "{\n    int n\
    \ = grid.length;\n    int[][] dp = new int[n][n];\n    int[][] prev = new int[n][n];\n\
    \    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n      \
    \      dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++)\n\
    \        for (int j = 0; j < n; j++)\n        {\n            if (i > 0 && dp[i\
    \ - 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i - 1][j]\
    \ + 1;\n                prev[i][j] = 1;\n            }\n            if (j > 0\
    \ && dp[i][j - 1] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j\
    \ - 1] + 1;\n                prev[i][j] = 2;\n            }\n            if (i\
    \ < n - 1 && dp[i + 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i + 1][j] + 1;\n                prev[i][j] = 3;\n            }\n      \
    \      if (j < n - 1 && dp[i][j + 1] + 1 < dp[i][j])\n            {\n        \
    \        dp[i][j] = dp[i][j + 1] + 1;\n                prev[i][j] = 4;\n     \
    \       }\n        }\n    int[] path = new int[k];\n    int x = 0, y = 0;\n  \
    \  for (int i = 0; i < k; i++)\n    {\n        path[i] = grid[x][y];\n       \
    \ switch (prev[x][y])\n        {\n            case 1:\n                x--;\n\
    \                break;\n            case 2:\n                y--;\n         \
    \       break;\n            case 3:\n                x++;\n                break;\n\
    \            case", "{\n    int N = grid.length;\n    int[][] dp = new int[N][N];\n\
    \    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n      \
    \      dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n\
    \        for (int j = 0; j < N; j++)\n        {\n            if (i > 0)\n    \
    \            dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n          \
    \  if (j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n\
    \        }\n    int[] path = new int[k];\n    int cur = dp[N - 1][N - 1];\n  \
    \  for (int i = 0; i < k; i++)\n    {\n        path[i] = grid[N - 1][N - 1];\n\
    \        if (N > 1)\n        {\n            if (N - 2 >= 0 && dp[N - 2][N - 1]\
    \ + grid[N - 1][N - 1] == cur)\n                N--;\n            else\n     \
    \           N--;\n        }\n        cur -= grid[N - 1][N - 1];\n    }\n    return\
    \ path;\n}", "{\n    long n = grid.length;\n    long[] res = new long[(int)k];\n\
    \    long[][] dp = new long[(int)n][(int)n];\n    long[][] path = new long[(int)n][(int)n];\n\
    \    for (long i = 0; i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n\
    \        {\n            dp[(int)i][(int)j] = grid[(int)i][(int)j];\n         \
    \   path[(int)i][(int)j] = grid[(int)i][(int)j];\n        }\n    }\n    for (long\
    \ i = 1; i < k; i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n\
    \            for (long l = 0; l < n; l++)\n            {\n                long\
    \ min = dp[(int)j][(int)l];\n                long minPath = path[(int)j][(int)l];\n\
    \                if (j > 0 && dp[(int)j - 1][(int)l] < min)\n                {\n\
    \                    min = dp[(int)j - 1][(int)l];\n                    minPath\
    \ = path[(int)j - 1][(int)l];\n                }\n                if (j < n -\
    \ 1 && dp[(int)j + 1][(int)l] < min)\n                {\n                    min\
    \ = dp[(int)j + 1][(int)l];\n                    minPath = path[(int)j + 1][(int)l];\n\
    \                }\n                if (l > 0 && dp[(int)j][(int)l - 1] < min)\n\
    \                {\n                    min = dp[(int)j][(int)l - 1];\n      \
    \              minPath = path[(int)j][(int)l - 1];\n                }\n      \
    \          if (l < n - 1 && dp[(int)j][(int)l + 1] < min)\n                {\n\
    \                    min = dp[(int)j][(int", "{\n    auto N = grid.length;\n \
    \   auto M = grid[0].length;\n    auto dp = new long[][](N, M);\n    foreach (i;\
    \ 0 .. N)\n    {\n        foreach (j; 0 .. M)\n        {\n            dp[i][j]\
    \ = grid[i][j];\n        }\n    }\n    foreach (i; 1 .. N)\n    {\n        dp[i][0]\
    \ += dp[i - 1][0];\n    }\n    foreach (j; 1 .. M)\n    {\n        dp[0][j] +=\
    \ dp[0][j - 1];\n    }\n    foreach (i; 1 .. N)\n    {\n        foreach (j; 1\
    \ .. M)\n        {\n            dp[i][j] += min(dp[i - 1][j], dp[i][j - 1]);\n\
    \        }\n    }\n    auto path = new long[k];\n    auto i = N - 1;\n    auto\
    \ j = M - 1;\n    auto idx = k - 1;\n    while (i != 0 || j != 0)\n    {\n   \
    \     path[idx--] = grid[i][j];\n        if (i == 0)\n        {\n            j--;\n\
    \        }\n        else if (j == 0)\n        {\n            i--;\n        }\n\
    \        else\n        {\n            if (dp[i - 1][j] < dp[i][j - 1])\n     \
    \       {\n                i--;\n            }\n            else\n           \
    \ {\n                j--;\n            }\n        }\n    }\n    path[idx] = grid[i][j];\n\
    \    return path;\n}", "{\n    int N = grid.length;\n    int[][] dp = new int[N][N];\n\
    \    int[][] prev = new int[N][N];\n    int[][] dir = new int[][]{{0, 1}, {1,\
    \ 0}, {0, -1}, {-1, 0}};\n    for (int i = 0; i < N; i++)\n        for (int j\
    \ = 0; j < N; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for\
    \ (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            for\
    \ (int d = 0; d < 4; d++)\n            {\n                int x = i + dir[d][0];\n\
    \                int y = j + dir[d][1];\n                if (x < 0 || x >= N ||\
    \ y < 0 || y >= N)\n                    continue;\n                if (dp[x][y]\
    \ > dp[i][j] + grid[x][y])\n                {\n                    dp[x][y] =\
    \ dp[i][j] + grid[x][y];\n                    prev[x][y] = d;\n              \
    \  }\n            }\n    int x = N - 1;\n    int y = N - 1;\n    long[] res =\
    \ new long[k];\n    for (int i = 0; i < k; i++)\n    {\n        res[i] = grid[x][y];\n\
    \        int d = prev[x][y];\n        x -= dir[d][0];\n        y -= dir[d][1];\n\
    \    }\n    return res;\n}", "{\n    long n = grid.length;\n    long[][] dp =\
    \ new long[n][n];\n    long[][] prev = new long[n][n];\n    long[][] next = new\
    \ long[n][n];\n    long[][] dist = new long[n][n];\n    for (long i = 0; i < n;\
    \ i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n            dp[i][j]\
    \ = grid[i][j];\n            prev[i][j] = -1;\n            next[i][j] = -1;\n\
    \            dist[i][j] = 1;\n        }\n    }\n    for (long i = 0; i < n; i++)\n\
    \    {\n        for (long j = 0; j < n; j++)\n        {\n            if (i > 0\
    \ && dp[i][j] > dp[i - 1][j])\n            {\n                dp[i][j] = dp[i\
    \ - 1][j];\n                prev[i][j] = i - 1;\n                next[i][j] =\
    \ j;\n                dist[i][j] = dist[i - 1][j] + 1;\n            }\n      \
    \      if (j > 0 && dp[i][j] > dp[i][j - 1])\n            {\n                dp[i][j]\
    \ = dp[i][j - 1];\n                prev[i][j] = i;\n                next[i][j]\
    \ = j - 1;\n                dist[i][j] = dist[i][j - 1] + 1;\n            }\n\
    \            if (i < n - 1 && dp[i][j] > dp[i + 1][j])\n            {\n      \
    \          dp[i][j] = dp[i + 1][j];\n                prev[i][j] = i + 1;\n   \
    \             next[i][j] = j;\n                dist[i][j] = dist[i + 1][j] + 1;\n\
    \            }\n            if (j < n - 1 && dp[i][j] > dp[i][j + 1])", "{\n \
    \   int N = grid.length;\n    int[][] dp = new int[N][N];\n    int[][] path =\
    \ new int[N][N];\n    for (int i = 0; i < N; i++)\n    {\n        for (int j =\
    \ 0; j < N; j++)\n        {\n            dp[i][j] = int.max;\n            path[i][j]\
    \ = -1;\n        }\n    }\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n\
    \    {\n        for (int j = 0; j < N; j++)\n        {\n            if (i > 0\
    \ && dp[i - 1][j] + grid[i][j] < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                path[i][j] = 0;\n            }\n\
    \            if (j > 0 && dp[i][j - 1] + grid[i][j] < dp[i][j])\n            {\n\
    \                dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = 1;\n            }\n            if (i < N - 1 && dp[i + 1][j] + grid[i][j]\
    \ < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j] + grid[i][j];\n\
    \                path[i][j] = 2;\n            }\n            if (j < N - 1 &&\
    \ dp[i][j + 1] + grid[i][j] < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i][j + 1] + grid[i][j];\n                path[i][j] = 3;\n            }\n\
    \        }\n    }\n    long[] ans = new long[k];\n    int curr_i = N - 1;\n  \
    \  int curr_j = N - 1;\n    for (int i = 0;", "{\n    long N = grid.length;\n\
    \    long[][] dp = new long[N][N];\n    long[][] prev = new long[N][N];\n    foreach\
    \ (i; 0 .. N)\n    {\n        foreach (j; 0 .. N)\n        {\n            dp[i][j]\
    \ = long.max;\n            prev[i][j] = -1;\n        }\n    }\n    dp[0][0] =\
    \ grid[0][0];\n    foreach (i; 0 .. N)\n    {\n        foreach (j; 0 .. N)\n \
    \       {\n            if (i > 0)\n            {\n                if (dp[i][j]\
    \ > dp[i - 1][j] + grid[i][j])\n                {\n                    dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                    prev[i][j] = 0;\n        \
    \        }\n            }\n            if (j > 0)\n            {\n           \
    \     if (dp[i][j] > dp[i][j - 1] + grid[i][j])\n                {\n         \
    \           dp[i][j] = dp[i][j - 1] + grid[i][j];\n                    prev[i][j]\
    \ = 1;\n                }\n            }\n        }\n    }\n    long[] path =\
    \ new long[k];\n    long i = N - 1;\n    long j = N - 1;\n    foreach (k; 0 ..\
    \ k)\n    {\n        path[k] = grid[i][j];\n        if (prev[i][j] == 0)\n   \
    \     {\n            i--;\n        }\n        else if (prev[i][j] == 1)\n    \
    \    {\n            j--;\n        }\n    }\n    return path;\n}", "{\n    int\
    \ N = grid.length;\n    int M = grid[0].length;\n    long[][] dp = new long[N][M];\n\
    \    for (int i = 0; i < N; i++)\n        for (int j = 0; j < M; j++)\n      \
    \      dp[i][j] = grid[i][j];\n    for (int i = 1; i < N; i++)\n        dp[i][0]\
    \ += dp[i - 1][0];\n    for (int j = 1; j < M; j++)\n        dp[0][j] += dp[0][j\
    \ - 1];\n    for (int i = 1; i < N; i++)\n        for (int j = 1; j < M; j++)\n\
    \            dp[i][j] += min(dp[i - 1][j], dp[i][j - 1]);\n    long[][] dp2 =\
    \ new long[N][M];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j\
    \ < M; j++)\n            dp2[i][j] = grid[i][j];\n    for (int i = 1; i < N; i++)\n\
    \        dp2[i][M - 1] += dp2[i - 1][M - 1];\n    for (int j = 1; j < M; j++)\n\
    \        dp2[N - 1][j] += dp2[N - 1][j - 1];\n    for (int i = 1; i < N; i++)\n\
    \        for (int j = 1; j < M; j++)\n            dp2[i][M - 1 - j] += min(dp2[i\
    \ - 1][M - 1 - j], dp2[i][M - j]);\n    long[][] dp3 = new long[N][M];\n    for\
    \ (int i = 0; i < N; i++)\n        for (int j = 0; j < M; j++)\n            dp3[i][j]\
    \ = grid[i][j];\n    for (int i = 1; i < N; i++)\n        dp3[i][", "{\n    int\
    \ n = grid.length;\n    int[][] dp = new int[n][n];\n    for (int i = 0; i < n;\
    \ i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j] = int.max;\n\
    \    dp[0][0] = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j\
    \ < n; j++)\n        {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i - 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j]\
    \ = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n        }\n    int[][] dp2 = new\
    \ int[n][n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n;\
    \ j++)\n            dp2[i][j] = int.max;\n    dp2[n - 1][n - 1] = 0;\n    for\
    \ (int i = n - 1; i >= 0; i--)\n        for (int j = n - 1; j >= 0; j--)\n   \
    \     {\n            if (i < n - 1)\n                dp2[i][j] = min(dp2[i][j],\
    \ dp2[i + 1][j] + grid[i][j]);\n            if (j < n - 1)\n                dp2[i][j]\
    \ = min(dp2[i][j], dp2[i][j + 1] + grid[i][j]);\n        }\n    int[][] dp3 =\
    \ new int[n][n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j <\
    \ n; j++)\n            dp3[i][j] = dp[i][j] + dp2[i][j] - grid[i][j];\n    int[][]\
    \ dp4 = new int[", "{\n    long N = grid.length;\n    long[][] dp = new long[N][N];\n\
    \    long[][] prev = new long[N][N];\n    long[][] next = new long[N][N];\n  \
    \  long[][] dirs = new long[][]{{0L, 1L}, {1L, 0L}, {0L, -1L}, {-1L, 0L}};\n \
    \   for (long i = 0L; i < N; i++)\n    {\n        for (long j = 0L; j < N; j++)\n\
    \        {\n            dp[i][j] = grid[i][j];\n            prev[i][j] = -1L;\n\
    \            next[i][j] = -1L;\n        }\n    }\n    for (long step = 1L; step\
    \ < k; step++)\n    {\n        for (long i = 0L; i < N; i++)\n        {\n    \
    \        for (long j = 0L; j < N; j++)\n            {\n                dp[i][j]\
    \ = long.max;\n                for (long[] dir : dirs)\n                {\n  \
    \                  long x = i + dir[0];\n                    long y = j + dir[1];\n\
    \                    if (x >= 0L && x < N && y >= 0L && y < N)\n             \
    \       {\n                        if (dp[i][j] > dp[x][y] + grid[i][j])\n   \
    \                     {\n                            dp[i][j] = dp[x][y] + grid[i][j];\n\
    \                            prev[i][j] = x * N + y;\n                       \
    \ }\n                        else if (dp[i][j] == dp[x][y] + grid[i][j])\n   \
    \                     {\n                            if (prev[i][j] == -1L ||\
    \ grid[prev[i][j] / N][prev[i][j] % N] > grid[x][y])\n                       \
    \     {\n                                prev[i][j] = x * N + y;\n           \
    \                 }\n                        }\n                    }\n      \
    \          }\n            }\n        }\n    }\n    long min = long", "{\n    int\
    \ N = grid.length;\n    int[][] dp = new int[N][N];\n    int[][] prev = new int[N][N];\n\
    \    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n  \
    \          dp[i][j] = int.max;\n            prev[i][j] = -1;\n        }\n    }\n\
    \    dp[0][0] = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0;\
    \ j < N; j++) {\n            if (i > 0 && dp[i - 1][j] + 1 < dp[i][j]) {\n   \
    \             dp[i][j] = dp[i - 1][j] + 1;\n                prev[i][j] = 0;\n\
    \            }\n            if (j > 0 && dp[i][j - 1] + 1 < dp[i][j]) {\n    \
    \            dp[i][j] = dp[i][j - 1] + 1;\n                prev[i][j] = 1;\n \
    \           }\n            if (i < N - 1 && dp[i + 1][j] + 1 < dp[i][j]) {\n \
    \               dp[i][j] = dp[i + 1][j] + 1;\n                prev[i][j] = 2;\n\
    \            }\n            if (j < N - 1 && dp[i][j + 1] + 1 < dp[i][j]) {\n\
    \                dp[i][j] = dp[i][j + 1] + 1;\n                prev[i][j] = 3;\n\
    \            }\n        }\n    }\n    int[] path = new int[k];\n    int x = 0;\n\
    \    int y = 0;\n    for (int i = 0; i < k; i++) {\n        path[i] = grid[x][y];\n\
    \        if (prev[x][y] == 0) {\n            x--;\n        } else if (prev[x][y]\
    \ == 1) {\n            y--;\n       ", "{\n    int N = grid.length;\n    int[][]\
    \ dp = new int[N][N];\n    int[][] prev = new int[N][N];\n    for (int i = 0;\
    \ i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n\
    \    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j\
    \ < N; j++)\n        {\n            if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i - 1][j] + 1;\n               \
    \ prev[i][j] = 0;\n            }\n            if (j > 0 && dp[i][j - 1] + 1 <\
    \ dp[i][j])\n            {\n                dp[i][j] = dp[i][j - 1] + 1;\n   \
    \             prev[i][j] = 1;\n            }\n            if (i < N - 1 && dp[i\
    \ + 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j]\
    \ + 1;\n                prev[i][j] = 2;\n            }\n            if (j < N\
    \ - 1 && dp[i][j + 1] + 1 < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i][j + 1] + 1;\n                prev[i][j] = 3;\n            }\n      \
    \  }\n    long[] path = new long[(int)k];\n    int x = 0, y = 0;\n    for (int\
    \ i = 0; i < k; i++)\n    {\n        path[i] = grid[x][y];\n        switch (prev[x][y])\n\
    \        {\n            case 0:\n                x--;\n                break;\n\
    \            case 1:\n                y--;\n                break;\n         \
    \   case 2:\n                x++;\n                break;", "{\n    int n = grid.length;\n\
    \    int[][] dp = new int[n][n];\n    int[][] parent = new int[n][n];\n    int[][]\
    \ dir = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    for (int i = 0; i\
    \ < n; i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j] = int.max;\n\
    \    dp[0][0] = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j\
    \ < n; j++)\n            for (int d = 0; d < 4; d++)\n            {\n        \
    \        int x = i + dir[d][0];\n                int y = j + dir[d][1];\n    \
    \            if (x < 0 || x >= n || y < 0 || y >= n)\n                    continue;\n\
    \                if (dp[x][y] > dp[i][j] + grid[x][y])\n                {\n  \
    \                  dp[x][y] = dp[i][j] + grid[x][y];\n                    parent[x][y]\
    \ = d * n * n + i * n + j;\n                }\n                else if (dp[x][y]\
    \ == dp[i][j] + grid[x][y])\n                {\n                    int[] a =\
    \ new int[k];\n                    int[] b = new int[k];\n                   \
    \ int p = x * n + y;\n                    for (int l = k - 1; l >= 0; l--)\n \
    \                   {\n                        a[l] = grid[p / n][p % n];\n  \
    \                      p = parent[p / n][p % n] / (n * n);\n                 \
    \   }\n                    p = i * n + j;\n                    for (int l = k\
    \ - 1; l >= 0; l--)\n                    {\n                        b[l] = grid[p\
    \ / n][p % n];\n                        p = parent[p / n][p % n] / (n * n);\n\
    \                    }\n                    if (a.compare(b", "{\n    int n =\
    \ grid.length;\n    int[][] dp = new int[n][n];\n    for (int i = 0; i < n; i++)\n\
    \        for (int j = 0; j < n; j++)\n            dp[i][j] = grid[i][j];\n   \
    \ for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n         \
    \   for (int x = 0; x < n; x++)\n                for (int y = 0; y < n; y++)\n\
    \                    if (abs(i - x) + abs(j - y) == 1)\n                     \
    \   dp[i][j] = min(dp[i][j], grid[i][j] + dp[x][y]);\n    long[] ans = new long[(int)k];\n\
    \    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n      \
    \      if (dp[i][j] == grid[i][j])\n            {\n                ans[0] = grid[i][j];\n\
    \                int x = i, y = j;\n                for (int l = 1; l < k; l++)\n\
    \                {\n                    int nx = -1, ny = -1;\n              \
    \      for (int a = 0; a < n; a++)\n                        for (int b = 0; b\
    \ < n; b++)\n                            if (abs(x - a) + abs(y - b) == 1 && dp[x][y]\
    \ == grid[x][y] + dp[a][b])\n                            {\n                 \
    \               nx = a;\n                                ny = b;\n           \
    \                 }\n                    ans[l] = grid[nx][ny];\n            \
    \        x = nx;\n                    y = ny;\n                }\n           \
    \     return ans;\n            }\n    return ans;\n}", "{\n    int n = grid.length;\n\
    \    int[][] dp = new int[n][n];\n    int[][] prev = new int[n][n];\n    for (int\
    \ i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j]\
    \ = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++)\n        for\
    \ (int j = 0; j < n; j++)\n        {\n            if (i > 0 && dp[i - 1][j] +\
    \ 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i - 1][j] + 1;\n\
    \                prev[i][j] = 1;\n            }\n            if (j > 0 && dp[i][j\
    \ - 1] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j - 1]\
    \ + 1;\n                prev[i][j] = 2;\n            }\n            if (i < n\
    \ - 1 && dp[i + 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i + 1][j] + 1;\n                prev[i][j] = 3;\n            }\n      \
    \      if (j < n - 1 && dp[i][j + 1] + 1 < dp[i][j])\n            {\n        \
    \        dp[i][j] = dp[i][j + 1] + 1;\n                prev[i][j] = 4;\n     \
    \       }\n        }\n    long[] res = new long[k];\n    int x = 0, y = 0;\n \
    \   for (int i = 0; i < k; i++)\n    {\n        res[i] = grid[x][y];\n       \
    \ if (prev[x][y] == 1)\n            x--;\n        else if (prev[x][y] == 2)\n\
    \            y--;\n        else if (prev[x][y] == 3)\n            x++;\n     \
    \  ", "{\n    auto n = grid.length;\n    auto m = grid[0].length;\n    auto dp\
    \ = new long[][](n, m);\n    auto path = new long[][](n, m);\n    foreach (i;\
    \ 0 .. n)\n    {\n        foreach (j; 0 .. m)\n        {\n            if (i ==\
    \ 0 && j == 0)\n            {\n                dp[i][j] = grid[i][j];\n      \
    \          path[i][j] = 0;\n            }\n            else if (i == 0)\n    \
    \        {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n          \
    \      path[i][j] = j - 1;\n            }\n            else if (j == 0)\n    \
    \        {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n          \
    \      path[i][j] = i - 1;\n            }\n            else\n            {\n \
    \               if (dp[i - 1][j] < dp[i][j - 1])\n                {\n        \
    \            dp[i][j] = dp[i - 1][j] + grid[i][j];\n                    path[i][j]\
    \ = i - 1;\n                }\n                else\n                {\n     \
    \               dp[i][j] = dp[i][j - 1] + grid[i][j];\n                    path[i][j]\
    \ = j - 1;\n                }\n            }\n        }\n    }\n    auto res =\
    \ new long[k];\n    auto i = n - 1;\n    auto j = m - 1;\n    foreach (l; 0 ..\
    \ k)\n    {\n        res[l] = grid[i][j];\n        if (path[i][j] < n)\n     \
    \   {\n            i = path[i][j];\n        }\n        else\n        {\n     \
    \       j = path[i][j];\n        }\n    }\n    return res;\n}", "{\n    long n\
    \ = grid.length;\n    long[][] dp = new long[n][n];\n    foreach(i; 0 .. n)\n\
    \        foreach(j; 0 .. n)\n            dp[i][j] = long.max;\n    dp[0][0] =\
    \ grid[0][0];\n    foreach(i; 0 .. n)\n        foreach(j; 0 .. n)\n        {\n\
    \            if(i > 0)\n                dp[i][j] = min(dp[i][j], dp[i - 1][j]\
    \ + grid[i][j]);\n            if(j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + grid[i][j]);\n        }\n    long[] path = new long[k];\n   \
    \ long[] cur = new long[2];\n    cur[0] = n - 1;\n    cur[1] = n - 1;\n    path[k\
    \ - 1] = grid[cur[0]][cur[1]];\n    foreach(i; k - 2 .. 0)\n    {\n        if(cur[0]\
    \ > 0 && dp[cur[0] - 1][cur[1]] + grid[cur[0]][cur[1]] == dp[cur[0]][cur[1]])\n\
    \        {\n            cur[0]--;\n            path[i] = grid[cur[0]][cur[1]];\n\
    \        }\n        else\n        {\n            cur[1]--;\n            path[i]\
    \ = grid[cur[0]][cur[1]];\n        }\n    }\n    return path;\n}", "{\n    int\
    \ N = grid.length;\n    int[][] dp = new int[N][N];\n    for (int i = 0; i < N;\
    \ i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n\
    \    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j\
    \ < N; j++)\n        {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i - 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j]\
    \ = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n        }\n    int[] res = new\
    \ int[k];\n    int cur = 0;\n    for (int i = 0; i < k; i++)\n    {\n        res[i]\
    \ = grid[cur / N][cur % N];\n        int r = cur / N;\n        int c = cur % N;\n\
    \        if (r > 0 && dp[r - 1][c] + grid[r][c] == dp[r][c])\n            cur\
    \ -= N;\n        else\n            cur -= 1;\n    }\n    return res;\n}", "{\n\
    \    int n = grid.length;\n    int[][] dp = new int[n][n];\n    for (int i = 0;\
    \ i < n; i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j] = int.max;\n\
    \    dp[0][0] = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j\
    \ < n; j++)\n        {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i - 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j]\
    \ = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n        }\n    int[] res = new\
    \ int[k];\n    int cur = 0;\n    for (int i = 0; i < k; i++)\n    {\n        res[i]\
    \ = grid[cur / n][cur % n];\n        if (cur / n > 0 && dp[cur / n - 1][cur %\
    \ n] + grid[cur / n][cur % n] == dp[cur / n][cur % n])\n            cur -= n;\n\
    \        else\n            cur -= 1;\n    }\n    return res;\n}", "{\n    auto\
    \ N = grid.length;\n    auto M = grid[0].length;\n    auto dp = new long[][](N,\
    \ M);\n    auto path = new long[][](N, M);\n    foreach (i; 0 .. N)\n    {\n \
    \       foreach (j; 0 .. M)\n        {\n            if (i == 0 && j == 0)\n  \
    \          {\n                dp[i][j] = grid[i][j];\n                path[i][j]\
    \ = 1;\n            }\n            else if (i == 0)\n            {\n         \
    \       dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j] = path[i][j\
    \ - 1];\n            }\n            else if (j == 0)\n            {\n        \
    \        dp[i][j] = dp[i - 1][j] + grid[i][j];\n                path[i][j] = path[i\
    \ - 1][j];\n            }\n            else\n            {\n                if\
    \ (dp[i - 1][j] < dp[i][j - 1])\n                {\n                    dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                    path[i][j] = path[i - 1][j];\n\
    \                }\n                else if (dp[i - 1][j] > dp[i][j - 1])\n  \
    \              {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                    path[i][j] = path[i][j - 1];\n                }\n       \
    \         else\n                {\n                    dp[i][j] = dp[i - 1][j]\
    \ + grid[i][j];\n                    path[i][j] = path[i - 1][j] + path[i][j -\
    \ 1];\n                }\n            }\n        }\n    }\n    auto result = new\
    \ long[k];\n    auto i = N - 1;\n    auto j = M - 1;\n    auto index = k - 1;\n\
    \    while (i != 0 || j != 0)\n    {\n", "{\n    long N = grid.length;\n    long[][]\
    \ dp = new long[N][N];\n    long[][] prev = new long[N][N];\n    long[][] next\
    \ = new long[N][N];\n    long[][] path = new long[N][N];\n    long[][] path_prev\
    \ = new long[N][N];\n    long[][] path_next = new long[N][N];\n    for (long i\
    \ = 0; i < N; i++)\n    {\n        for (long j = 0; j < N; j++)\n        {\n \
    \           dp[i][j] = grid[i][j];\n            prev[i][j] = i;\n            next[i][j]\
    \ = j;\n            path[i][j] = grid[i][j];\n            path_prev[i][j] = i;\n\
    \            path_next[i][j] = j;\n        }\n    }\n    for (long step = 1; step\
    \ < k; step++)\n    {\n        for (long i = 0; i < N; i++)\n        {\n     \
    \       for (long j = 0; j < N; j++)\n            {\n                long min_val\
    \ = dp[i][j];\n                long min_prev = i;\n                long min_next\
    \ = j;\n                long min_path = path[i][j];\n                long min_path_prev\
    \ = i;\n                long min_path_next = j;\n                if (i > 0)\n\
    \                {\n                    if (dp[i - 1][j] < min_val)\n        \
    \            {\n                        min_val = dp[i - 1][j];\n            \
    \            min_prev = i - 1;\n                        min_next = j;\n      \
    \                  min_path = path[i - 1][j];\n                        min_path_prev\
    \ = i - 1;\n                        min_path_next = j;\n                    }\n\
    \                    else if (dp[i - 1][j] == min_val)\n                    {\n\
    \                        if (path[i - 1][j] < min_path)\n                    \
    \    {\n                            min_val = dp[i - 1][j];\n                \
    \            min", "{\n    long n = grid.length;\n    long[][] dp = new long[n][n];\n\
    \    long[][] prev = new long[n][n];\n    long[][] next = new long[n][n];\n  \
    \  foreach (i; 0 .. n)\n    {\n        foreach (j; 0 .. n)\n        {\n      \
    \      dp[i][j] = long.max;\n            prev[i][j] = -1;\n            next[i][j]\
    \ = -1;\n        }\n    }\n    dp[0][0] = grid[0][0];\n    foreach (i; 0 .. n)\n\
    \    {\n        foreach (j; 0 .. n)\n        {\n            if (i > 0)\n     \
    \       {\n                if (dp[i - 1][j] < dp[i][j])\n                {\n \
    \                   dp[i][j] = dp[i - 1][j];\n                    prev[i][j] =\
    \ i - 1;\n                    next[i][j] = j;\n                }\n           \
    \ }\n            if (j > 0)\n            {\n                if (dp[i][j - 1] <\
    \ dp[i][j])\n                {\n                    dp[i][j] = dp[i][j - 1];\n\
    \                    prev[i][j] = i;\n                    next[i][j] = j - 1;\n\
    \                }\n            }\n            dp[i][j] += grid[i][j];\n     \
    \   }\n    }\n    long[] res = new long[k];\n    long x = n - 1;\n    long y =\
    \ n - 1;\n    foreach (i; 0 .. k)\n    {\n        res[i] = grid[x][y];\n     \
    \   long tmp = x;\n        x = prev[x][y];\n        y = next[tmp][y];\n    }\n\
    \    return res;\n}", "{\n    int n = grid.length;\n    int[][] dp = new int[n][n];\n\
    \    int[][] path = new int[n][n];\n    for (int i = 0; i < n; i++)\n    {\n \
    \       for (int j = 0; j < n; j++)\n        {\n            dp[i][j] = int.max;\n\
    \            path[i][j] = -1;\n        }\n    }\n    dp[0][0] = 0;\n    for (int\
    \ i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n\
    \            if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n            {\n      \
    \          dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j] = 0;\n   \
    \         }\n            if (j > 0 && dp[i][j - 1] + 1 < dp[i][j])\n         \
    \   {\n                dp[i][j] = dp[i][j - 1] + 1;\n                path[i][j]\
    \ = 1;\n            }\n            if (i < n - 1 && dp[i + 1][j] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i + 1][j] + 1;\n               \
    \ path[i][j] = 2;\n            }\n            if (j < n - 1 && dp[i][j + 1] +\
    \ 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j + 1] + 1;\n\
    \                path[i][j] = 3;\n            }\n        }\n    }\n    int[] res\
    \ = new int[k];\n    int x = 0;\n    int y = 0;\n    for (int i = 0; i < k; i++)\n\
    \    {\n        res[i] = grid[x][y];\n        if (path[x][y] == 0)\n        {\n\
    \            x--;\n        }", "{\n    long n = grid.length;\n    long[][] dp\
    \ = new long[n][n];\n    long[][] prev = new long[n][n];\n    long[][] next =\
    \ new long[n][n];\n    long[][] sum = new long[n][n];\n    for (long i = 0; i\
    \ < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n        \
    \    if (i == 0 && j == 0)\n            {\n                dp[i][j] = grid[i][j];\n\
    \                prev[i][j] = -1;\n                next[i][j] = -1;\n        \
    \        sum[i][j] = grid[i][j];\n            }\n            else if (i == 0)\n\
    \            {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n      \
    \          prev[i][j] = -1;\n                next[i][j] = j - 1;\n           \
    \     sum[i][j] = sum[i][j - 1] + grid[i][j];\n            }\n            else\
    \ if (j == 0)\n            {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                prev[i][j] = i - 1;\n                next[i][j] = -1;\n     \
    \           sum[i][j] = sum[i - 1][j] + grid[i][j];\n            }\n         \
    \   else\n            {\n                dp[i][j] = min(dp[i - 1][j], dp[i][j\
    \ - 1]) + grid[i][j];\n                if (dp[i - 1][j] < dp[i][j - 1])\n    \
    \            {\n                    prev[i][j] = i - 1;\n                    next[i][j]\
    \ = -1;\n                    sum[i][j] = sum[i - 1][j] + grid[i][j];\n       \
    \         }\n                else\n                {\n                    prev[i][j]\
    \ = -1;\n                    next[i][j] = j - 1;\n", "{\n    int N = grid.length;\n\
    \    int[][] dp = new int[N][N];\n    for (int i = 0; i < N; i++)\n        for\
    \ (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n\
    \    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n      \
    \  {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i -\
    \ 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + grid[i][j]);\n        }\n    int[] res = new int[k];\n    for\
    \ (int i = 0; i < k; i++)\n        res[i] = grid[0][0];\n    int x = 0, y = 0;\n\
    \    for (int i = 1; i < k; i++)\n    {\n        if (x + 1 < N && dp[x + 1][y]\
    \ + grid[x + 1][y] == dp[x][y])\n        {\n            x++;\n            res[i]\
    \ = grid[x][y];\n        }\n        else\n        {\n            y++;\n      \
    \      res[i] = grid[x][y];\n        }\n    }\n    return res;\n}", "{\n    int\
    \ N = grid.length;\n    int[][] dp = new int[N][N];\n    int[][] prev = new int[N][N];\n\
    \    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n      \
    \      dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n\
    \        for (int j = 0; j < N; j++)\n        {\n            if (i > 0 && dp[i\
    \ - 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i - 1][j]\
    \ + 1;\n                prev[i][j] = 1;\n            }\n            if (j > 0\
    \ && dp[i][j - 1] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j\
    \ - 1] + 1;\n                prev[i][j] = 2;\n            }\n            if (i\
    \ < N - 1 && dp[i + 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i + 1][j] + 1;\n                prev[i][j] = 3;\n            }\n      \
    \      if (j < N - 1 && dp[i][j + 1] + 1 < dp[i][j])\n            {\n        \
    \        dp[i][j] = dp[i][j + 1] + 1;\n                prev[i][j] = 4;\n     \
    \       }\n        }\n    int[] path = new int[k];\n    int cur = 0;\n    int\
    \ x = 0;\n    int y = 0;\n    for (int i = 0; i < k; i++)\n    {\n        path[i]\
    \ = grid[x][y];\n        if (prev[x][y] == 1)\n            x--;\n        else\
    \ if (prev[x][y] == 2)\n            y--;\n        else if (prev[x][y", "{\n  \
    \  long n = grid.length;\n    long[][] dp = new long[n][n];\n    long[][] prev\
    \ = new long[n][n];\n    long[][] next = new long[n][n];\n    long[][] path =\
    \ new long[n][n];\n    long[][] path_prev = new long[n][n];\n    long[][] path_next\
    \ = new long[n][n];\n    long[][] path_prev_prev = new long[n][n];\n    long[][]\
    \ path_next_next = new long[n][n];\n    long[][] path_prev_prev_prev = new long[n][n];\n\
    \    long[][] path_next_next_next = new long[n][n];\n    long[][] path_prev_prev_prev_prev\
    \ = new long[n][n];\n    long[][] path_next_next_next_next = new long[n][n];\n\
    \    long[][] path_prev_prev_prev_prev_prev = new long[n][n];\n    long[][] path_next_next_next_next_next\
    \ = new long[n][n];\n    long[][] path_prev_prev_prev_prev_prev_prev = new long[n][n];\n\
    \    long[][] path_next_next_next_next_next_next = new long[n][n];\n    long[][]\
    \ path_prev_prev_prev_prev_prev_prev_prev = new long[n][n];\n    long[][] path_next_next_next_next_next_next_next\
    \ = new long[n][n];\n    long[][] path_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = new long[n][n];\n    long[][] path_next_next_next_next_next_next_next_next\
    \ = new long[n][n];\n    long[][] path_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = new long[n][n];\n    long[][] path_next_next_next_next_next_next_next_next",
  "{\n    int N = grid.length;\n    int M = grid[0].length;\n    int[][] dp = new\
    \ int[N][M];\n    int[][] prev = new int[N][M];\n    for (int i = 0; i < N; i++)\n\
    \        for (int j = 0; j < M; j++)\n            dp[i][j] = int.max;\n    dp[0][0]\
    \ = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < M; j++)\n\
    \        {\n            if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n          \
    \  {\n                dp[i][j] = dp[i - 1][j] + 1;\n                prev[i][j]\
    \ = 0;\n            }\n            if (j > 0 && dp[i][j - 1] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i][j - 1] + 1;\n               \
    \ prev[i][j] = 1;\n            }\n            if (i < N - 1 && dp[i + 1][j] +\
    \ 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j] + 1;\n\
    \                prev[i][j] = 2;\n            }\n            if (j < M - 1 &&\
    \ dp[i][j + 1] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j\
    \ + 1] + 1;\n                prev[i][j] = 3;\n            }\n        }\n    int[]\
    \ cur = new int[2];\n    cur[0] = N - 1;\n    cur[1] = M - 1;\n    long[] res\
    \ = new long[(int)k];\n    for (int i = (int)k - 1; i >= 0; i--)\n    {\n    \
    \    res[i] = grid[cur[0]][cur[1]];\n        int nxt = prev[cur", "{\n    long\
    \ n = grid.length;\n    long[][] dp = new long[n][n];\n    long[][] prev = new\
    \ long[n][n];\n    long[][] next = new long[n][n];\n    foreach (i; 0 .. n)\n\
    \    {\n        foreach (j; 0 .. n)\n        {\n            dp[i][j] = long.max;\n\
    \            prev[i][j] = -1;\n            next[i][j] = -1;\n        }\n    }\n\
    \    dp[0][0] = grid[0][0];\n    foreach (i; 0 .. n)\n    {\n        foreach (j;\
    \ 0 .. n)\n        {\n            if (i > 0)\n            {\n                if\
    \ (dp[i - 1][j] + grid[i][j] < dp[i][j])\n                {\n                \
    \    dp[i][j] = dp[i - 1][j] + grid[i][j];\n                    prev[i][j] = i\
    \ - 1;\n                    next[i][j] = j;\n                }\n            }\n\
    \            if (j > 0)\n            {\n                if (dp[i][j - 1] + grid[i][j]\
    \ < dp[i][j])\n                {\n                    dp[i][j] = dp[i][j - 1]\
    \ + grid[i][j];\n                    prev[i][j] = i;\n                    next[i][j]\
    \ = j - 1;\n                }\n            }\n        }\n    }\n    long[] res\
    \ = new long[k];\n    long i = n - 1;\n    long j = n - 1;\n    foreach (idx;\
    \ 0 .. k)\n    {\n        res[idx] = grid[i][j];\n        long tmp = i;\n    \
    \    i = prev[i][j];\n        j = next[tmp][j];\n    }\n    return res;\n}", "{\n\
    \    int N = grid.length;\n    int[][] dp = new int[N][N];\n    for (int i = 0;\
    \ i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n\
    \    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j\
    \ < N; j++)\n        {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i - 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j]\
    \ = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n        }\n    int[][] dp2 = new\
    \ int[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N;\
    \ j++)\n            dp2[i][j] = int.max;\n    dp2[N - 1][N - 1] = 0;\n    for\
    \ (int i = N - 1; i >= 0; i--)\n        for (int j = N - 1; j >= 0; j--)\n   \
    \     {\n            if (i < N - 1)\n                dp2[i][j] = min(dp2[i][j],\
    \ dp2[i + 1][j] + grid[i][j]);\n            if (j < N - 1)\n                dp2[i][j]\
    \ = min(dp2[i][j], dp2[i][j + 1] + grid[i][j]);\n        }\n    int[][] dp3 =\
    \ new int[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j <\
    \ N; j++)\n            dp3[i][j] = dp[i][j] + dp2[i][j] - grid[i][j];\n    int[][]\
    \ dp4 = new int[", "{\n    int N = grid.length;\n    int[][] dp = new int[N][N];\n\
    \    int[][] prev = new int[N][N];\n    for (int i = 0; i < N; i++)\n        for\
    \ (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n\
    \    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n      \
    \  {\n            if (i > 0 && dp[i][j] + grid[i - 1][j] < dp[i - 1][j])\n   \
    \         {\n                dp[i - 1][j] = dp[i][j] + grid[i - 1][j];\n     \
    \           prev[i - 1][j] = 1;\n            }\n            if (j > 0 && dp[i][j]\
    \ + grid[i][j - 1] < dp[i][j - 1])\n            {\n                dp[i][j - 1]\
    \ = dp[i][j] + grid[i][j - 1];\n                prev[i][j - 1] = 2;\n        \
    \    }\n            if (i < N - 1 && dp[i][j] + grid[i + 1][j] < dp[i + 1][j])\n\
    \            {\n                dp[i + 1][j] = dp[i][j] + grid[i + 1][j];\n  \
    \              prev[i + 1][j] = 3;\n            }\n            if (j < N - 1 &&\
    \ dp[i][j] + grid[i][j + 1] < dp[i][j + 1])\n            {\n                dp[i][j\
    \ + 1] = dp[i][j] + grid[i][j + 1];\n                prev[i][j + 1] = 4;\n   \
    \         }\n        }\n    long[] ans = new long[k];\n    int curi = N - 1, curj\
    \ = N - 1;\n    for (int i = 0; i < k; i++)\n    {\n        ans[", "{\n    int\
    \ n = grid.length;\n    int[][] dp = new int[n][n];\n    foreach(i; 0 .. n)\n\
    \        foreach(j; 0 .. n)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n\
    \    foreach(i; 0 .. n)\n        foreach(j; 0 .. n)\n        {\n            if(i\
    \ + 1 < n)\n                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + grid[i\
    \ + 1][j]);\n            if(j + 1 < n)\n                dp[i][j + 1] = min(dp[i][j\
    \ + 1], dp[i][j] + grid[i][j + 1]);\n        }\n    long[] res = new long[k];\n\
    \    int i = n - 1, j = n - 1;\n    foreach(idx; k)\n    {\n        res[idx] =\
    \ grid[i][j];\n        if(i + 1 < n && dp[i + 1][j] < dp[i][j])\n            i++;\n\
    \        else if(j + 1 < n && dp[i][j + 1] < dp[i][j])\n            j++;\n   \
    \     else\n            break;\n    }\n    return res;\n}", "{\n    long n = grid.length;\n\
    \    long[] path = new long[k];\n    long[][] dp = new long[n][n];\n    long[][]\
    \ prev = new long[n][n];\n    foreach (i; 0 .. n)\n    {\n        foreach (j;\
    \ 0 .. n)\n        {\n            dp[i][j] = cast(long)1e18;\n        }\n    }\n\
    \    dp[0][0] = 0;\n    foreach (i; 0 .. n)\n    {\n        foreach (j; 0 .. n)\n\
    \        {\n            if (i > 0)\n            {\n                if (dp[i][j]\
    \ + grid[i - 1][j] < dp[i - 1][j])\n                {\n                    dp[i\
    \ - 1][j] = dp[i][j] + grid[i - 1][j];\n                    prev[i - 1][j] = 1;\n\
    \                }\n            }\n            if (j > 0)\n            {\n   \
    \             if (dp[i][j] + grid[i][j - 1] < dp[i][j - 1])\n                {\n\
    \                    dp[i][j - 1] = dp[i][j] + grid[i][j - 1];\n             \
    \       prev[i][j - 1] = 2;\n                }\n            }\n            if\
    \ (i < n - 1)\n            {\n                if (dp[i][j] + grid[i + 1][j] <\
    \ dp[i + 1][j])\n                {\n                    dp[i + 1][j] = dp[i][j]\
    \ + grid[i + 1][j];\n                    prev[i + 1][j] = 3;\n               \
    \ }\n            }\n            if (j < n - 1)\n            {\n              \
    \  if (dp[i][j] + grid[i][j + 1] < dp[i][j + 1])\n                {\n        \
    \            dp[i][j + 1] = dp[i][j] + grid[i][j + 1];\n                    prev[i][j\
    \ + 1] = 4;\n                }\n            }\n        }", "{\n    long N = grid.length;\n\
    \    long[][] dp = new long[N][N];\n    long[][] prev = new long[N][N];\n    for\
    \ (long i = 0; i < N; i++)\n    {\n        for (long j = 0; j < N; j++)\n    \
    \    {\n            dp[i][j] = grid[i][j];\n            prev[i][j] = -1;\n   \
    \     }\n    }\n    for (long i = 0; i < N; i++)\n    {\n        for (long j =\
    \ 0; j < N; j++)\n        {\n            if (i > 0 && dp[i][j] > dp[i - 1][j])\n\
    \            {\n                dp[i][j] = dp[i - 1][j];\n                prev[i][j]\
    \ = 0;\n            }\n            if (j > 0 && dp[i][j] > dp[i][j - 1])\n   \
    \         {\n                dp[i][j] = dp[i][j - 1];\n                prev[i][j]\
    \ = 1;\n            }\n            if (i < N - 1 && dp[i][j] > dp[i + 1][j])\n\
    \            {\n                dp[i][j] = dp[i + 1][j];\n                prev[i][j]\
    \ = 2;\n            }\n            if (j < N - 1 && dp[i][j] > dp[i][j + 1])\n\
    \            {\n                dp[i][j] = dp[i][j + 1];\n                prev[i][j]\
    \ = 3;\n            }\n        }\n    }\n    long[] ans = new long[(int)k];\n\
    \    long x = 0, y = 0;\n    for (long i = 0; i < k; i++)\n    {\n        ans[(int)i]\
    \ = grid[(int)x][(int)y];\n        if (prev[(int)x][(int)y] == 0)\n          \
    \  x--;\n        else if (prev[(int)x][(int)y] == 1)\n", "{\n    int N = grid.length;\n\
    \    int[][] dp = new int[N][N];\n    int[][] prev = new int[N][N];\n    for (int\
    \ i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j]\
    \ = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for\
    \ (int j = 0; j < N; j++)\n        {\n            if (i > 0 && dp[i - 1][j] +\
    \ 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i - 1][j] + 1;\n\
    \                prev[i][j] = 1;\n            }\n            if (j > 0 && dp[i][j\
    \ - 1] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j - 1]\
    \ + 1;\n                prev[i][j] = 2;\n            }\n            if (i < N\
    \ - 1 && dp[i + 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i + 1][j] + 1;\n                prev[i][j] = 3;\n            }\n      \
    \      if (j < N - 1 && dp[i][j + 1] + 1 < dp[i][j])\n            {\n        \
    \        dp[i][j] = dp[i][j + 1] + 1;\n                prev[i][j] = 4;\n     \
    \       }\n        }\n    int[] path = new int[k];\n    int cur = 0;\n    int\
    \ x = 0;\n    int y = 0;\n    while (cur < k)\n    {\n        path[cur] = grid[x][y];\n\
    \        switch (prev[x][y])\n        {\n            case 1:\n               \
    \ x--;\n                break;\n            case 2:\n                y--;\n  \
    \              break;\n            case 3:\n                x++;\n           \
    \     break;", "{\n    int n = grid.length;\n    int[][] dp = new int[n][n];\n\
    \    int[][] prev = new int[n][n];\n    for (int i = 0; i < n; i++)\n        for\
    \ (int j = 0; j < n; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n\
    \    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n      \
    \  {\n            if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n            {\n \
    \               dp[i][j] = dp[i - 1][j] + 1;\n                prev[i][j] = 0;\n\
    \            }\n            if (j > 0 && dp[i][j - 1] + 1 < dp[i][j])\n      \
    \      {\n                dp[i][j] = dp[i][j - 1] + 1;\n                prev[i][j]\
    \ = 1;\n            }\n            if (i < n - 1 && dp[i + 1][j] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i + 1][j] + 1;\n               \
    \ prev[i][j] = 2;\n            }\n            if (j < n - 1 && dp[i][j + 1] +\
    \ 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j + 1] + 1;\n\
    \                prev[i][j] = 3;\n            }\n        }\n    int[] path = new\
    \ int[(int)k];\n    int x = n - 1, y = n - 1;\n    for (int i = (int)k - 1; i\
    \ >= 0; i--)\n    {\n        path[i] = grid[x][y];\n        switch (prev[x][y])\n\
    \        {\n            case 0:\n                x--;\n                break;\n\
    \            case 1:\n                y--;\n                break;\n         \
    \   case", "{\n    int n = grid.length;\n    int[][] dp = new int[n][n];\n   \
    \ int[][] prev = new int[n][n];\n    int[][] dir = new int[][] { {1, 0}, {0, 1},\
    \ {-1, 0}, {0, -1} };\n    int[][] dirs = new int[n * n][2];\n    int[] dirs_len\
    \ = new int[n * n];\n    int[][] dirs_prev = new int[n * n][2];\n    int[] dirs_prev_len\
    \ = new int[n * n];\n    int[][] dirs_next = new int[n * n][2];\n    int[] dirs_next_len\
    \ = new int[n * n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0;\
    \ j < n; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int\
    \ i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            for (int\
    \ d = 0; d < 4; d++)\n            {\n                int x = i + dir[d][0];\n\
    \                int y = j + dir[d][1];\n                if (x < 0 || x >= n ||\
    \ y < 0 || y >= n)\n                    continue;\n                if (dp[x][y]\
    \ > dp[i][j] + 1)\n                {\n                    dp[x][y] = dp[i][j]\
    \ + 1;\n                    prev[x][y] = d;\n                }\n            }\n\
    \    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n      \
    \      if (dp[i][j] <= k)\n            {\n                dirs[dp[i][j]][dirs_len[dp[i][j]]++]\
    \ = i * n + j;\n                dirs_prev[dp[i][j]][dirs_prev_len[dp[i][j]]++]\
    \ =", "{\n    long N = grid.length;\n    long[] res = new long[(int)k];\n    long[][]\
    \ dp = new long[(int)N][(int)N];\n    long[][] prev = new long[(int)N][(int)N];\n\
    \    for (long i = 0; i < N; i++)\n    {\n        for (long j = 0; j < N; j++)\n\
    \        {\n            dp[(int)i][(int)j] = grid[(int)i][(int)j];\n         \
    \   prev[(int)i][(int)j] = -1;\n        }\n    }\n    for (long i = 0; i < N;\
    \ i++)\n    {\n        for (long j = 0; j < N; j++)\n        {\n            if\
    \ (i > 0 && dp[(int)i][(int)j] > dp[(int)i - 1][(int)j])\n            {\n    \
    \            dp[(int)i][(int)j] = dp[(int)i - 1][(int)j];\n                prev[(int)i][(int)j]\
    \ = 0;\n            }\n            if (j > 0 && dp[(int)i][(int)j] > dp[(int)i][(int)j\
    \ - 1])\n            {\n                dp[(int)i][(int)j] = dp[(int)i][(int)j\
    \ - 1];\n                prev[(int)i][(int)j] = 1;\n            }\n          \
    \  if (i < N - 1 && dp[(int)i][(int)j] > dp[(int)i + 1][(int)j])\n           \
    \ {\n                dp[(int)i][(int)j] = dp[(int)i + 1][(int)j];\n          \
    \      prev[(int)i][(int)j] = 2;\n            }\n            if (j < N - 1 &&\
    \ dp[(int)i][(int)j] > dp[(int)i][(int)j + 1])\n            {\n              \
    \  d", "{\n    int n = grid.length;\n    int[][] dp = new int[n][n];\n    int[][]\
    \ prev = new int[n][n];\n    for (int i = 0; i < n; i++)\n        for (int j =\
    \ 0; j < n; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for\
    \ (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n        {\n  \
    \          if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n            {\n        \
    \        dp[i][j] = dp[i - 1][j] + 1;\n                prev[i][j] = 1;\n     \
    \       }\n            if (j > 0 && dp[i][j - 1] + 1 < dp[i][j])\n           \
    \ {\n                dp[i][j] = dp[i][j - 1] + 1;\n                prev[i][j]\
    \ = 2;\n            }\n            if (i < n - 1 && dp[i + 1][j] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i + 1][j] + 1;\n               \
    \ prev[i][j] = 3;\n            }\n            if (j < n - 1 && dp[i][j + 1] +\
    \ 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j + 1] + 1;\n\
    \                prev[i][j] = 4;\n            }\n        }\n    int x = 0, y =\
    \ 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n \
    \           if (dp[i][j] < dp[x][y])\n            {\n                x = i;\n\
    \                y = j;\n            }\n    long[] ans = new long[(int)k];\n \
    \   for (int i = (int)k - 1; i >= 0; i", "{\n    long n = grid.length;\n    long[][]\
    \ dp = new long[n][n];\n    long[][] prev = new long[n][n];\n    long[][] next\
    \ = new long[n][n];\n    foreach (i; 0 .. n)\n    {\n        foreach (j; 0 ..\
    \ n)\n        {\n            dp[i][j] = long.max;\n            prev[i][j] = -1;\n\
    \            next[i][j] = -1;\n        }\n    }\n    dp[0][0] = grid[0][0];\n\
    \    foreach (i; 0 .. n)\n    {\n        foreach (j; 0 .. n)\n        {\n    \
    \        if (i > 0)\n            {\n                if (dp[i][j] > dp[i - 1][j]\
    \ + grid[i][j])\n                {\n                    dp[i][j] = dp[i - 1][j]\
    \ + grid[i][j];\n                    prev[i][j] = i - 1;\n                   \
    \ next[i][j] = j;\n                }\n            }\n            if (j > 0)\n\
    \            {\n                if (dp[i][j] > dp[i][j - 1] + grid[i][j])\n  \
    \              {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                    prev[i][j] = i;\n                    next[i][j] = j - 1;\n\
    \                }\n            }\n        }\n    }\n    long[] res = new long[k];\n\
    \    long cur = n - 1;\n    long cur2 = n - 1;\n    foreach (i; 0 .. k)\n    {\n\
    \        res[i] = grid[cur][cur2];\n        long tmp = cur;\n        cur = prev[cur][cur2];\n\
    \        cur2 = next[tmp][cur2];\n    }\n    return res;\n}", "{\n    long n =\
    \ grid.length;\n    long[][] dp = new long[n][n];\n    long[][] prev = new long[n][n];\n\
    \    long[][] next = new long[n][n];\n    long[][] path = new long[n][n];\n  \
    \  long[][] path_prev = new long[n][n];\n    long[][] path_next = new long[n][n];\n\
    \    long[][] path_prev_prev = new long[n][n];\n    long[][] path_next_next =\
    \ new long[n][n];\n    long[][] path_prev_next = new long[n][n];\n    long[][]\
    \ path_next_prev = new long[n][n];\n    long[][] path_prev_prev_prev = new long[n][n];\n\
    \    long[][] path_next_next_next = new long[n][n];\n    long[][] path_prev_prev_next\
    \ = new long[n][n];\n    long[][] path_next_next_prev = new long[n][n];\n    long[][]\
    \ path_prev_next_next = new long[n][n];\n    long[][] path_next_prev_prev = new\
    \ long[n][n];\n    long[][] path_prev_prev_prev_prev = new long[n][n];\n    long[][]\
    \ path_next_next_next_next = new long[n][n];\n    long[][] path_prev_prev_prev_next\
    \ = new long[n][n];\n    long[][] path_next_next_next_prev = new long[n][n];\n\
    \    long[][] path_prev_prev_next_next = new long[n][n];\n    long[][] path_next_next_prev_prev\
    \ = new long[n][n];\n    long[][] path_prev_next_next_next = new long[n][n];\n\
    \    long[][] path_next_prev_prev_prev = new long[n][n];\n    long[][] path_prev_prev_prev_prev_prev\
    \ = new long", "{\n    long n = grid.length;\n    long[][] dp = new long[n][n];\n\
    \    long[][] prev = new long[n][n];\n    long[][] next = new long[n][n];\n  \
    \  long[][] path = new long[n][n];\n    foreach (i; 0 .. n)\n    {\n        foreach\
    \ (j; 0 .. n)\n        {\n            dp[i][j] = long.max;\n            prev[i][j]\
    \ = -1;\n            next[i][j] = -1;\n            path[i][j] = -1;\n        }\n\
    \    }\n    dp[0][0] = 0;\n    foreach (i; 0 .. n)\n    {\n        foreach (j;\
    \ 0 .. n)\n        {\n            if (i > 0)\n            {\n                if\
    \ (dp[i - 1][j] + 1 < dp[i][j])\n                {\n                    dp[i][j]\
    \ = dp[i - 1][j] + 1;\n                    prev[i][j] = i - 1;\n             \
    \       next[i][j] = j;\n                }\n                else if (dp[i - 1][j]\
    \ + 1 == dp[i][j])\n                {\n                    if (grid[i - 1][j]\
    \ < grid[prev[i][j]][next[i][j]])\n                    {\n                   \
    \     prev[i][j] = i - 1;\n                        next[i][j] = j;\n         \
    \           }\n                }\n            }\n            if (j > 0)\n    \
    \        {\n                if (dp[i][j - 1] + 1 < dp[i][j])\n               \
    \ {\n                    dp[i][j] = dp[i][j - 1] + 1;\n                    prev[i][j]\
    \ = i;\n                    next[i][j] = j - 1;\n                }\n         \
    \       else if (dp[i][j - 1] + 1 == dp[i][j])\n                {\n          \
    \          if (grid[i][j - 1] < grid[prev[i][j]][next[i][j]])", "{\n    int N\
    \ = grid.length;\n    int[][] dp = new int[N][N];\n    for (int i = 0; i < N;\
    \ i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n\
    \    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j\
    \ < N; j++)\n        {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i - 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j]\
    \ = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n        }\n    int[][] dp2 = new\
    \ int[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N;\
    \ j++)\n            dp2[i][j] = int.max;\n    dp2[N - 1][N - 1] = 0;\n    for\
    \ (int i = N - 1; i >= 0; i--)\n        for (int j = N - 1; j >= 0; j--)\n   \
    \     {\n            if (i < N - 1)\n                dp2[i][j] = min(dp2[i][j],\
    \ dp2[i + 1][j] + grid[i][j]);\n            if (j < N - 1)\n                dp2[i][j]\
    \ = min(dp2[i][j], dp2[i][j + 1] + grid[i][j]);\n        }\n    int[][] dp3 =\
    \ new int[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j <\
    \ N; j++)\n            dp3[i][j] = dp[i][j] + dp2[i][j] - grid[i][j];\n    int[][]\
    \ dp4 = new int[", "{\n    // your code here\n    long[] result = new long[(int)k];\n\
    \    int n = (int)grid.length;\n    int[][] dp = new int[n][n];\n    for (int\
    \ i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n\
    \            dp[i][j] = (int)grid[i][j];\n        }\n    }\n    for (int i = 0;\
    \ i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n       \
    \     if (i > 0)\n            {\n                dp[i][j] = min(dp[i][j], dp[i\
    \ - 1][j]);\n            }\n            if (j > 0)\n            {\n          \
    \      dp[i][j] = min(dp[i][j], dp[i][j - 1]);\n            }\n        }\n   \
    \ }\n    int x = 0;\n    int y = 0;\n    for (int i = 0; i < k; i++)\n    {\n\
    \        result[i] = dp[x][y];\n        if (x + 1 < n && dp[x + 1][y] == dp[x][y])\n\
    \        {\n            x++;\n        }\n        else if (y + 1 < n && dp[x][y\
    \ + 1] == dp[x][y])\n        {\n            y++;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long n = grid.length;\n    long[][] dp = new long[n][n];\n\
    \    long[][] prev = new long[n][n];\n    foreach(i; 0 .. n)\n    {\n        foreach(j;\
    \ 0 .. n)\n        {\n            dp[i][j] = long.max;\n            prev[i][j]\
    \ = -1;\n        }\n    }\n    dp[0][0] = 0;\n    foreach(i; 0 .. n)\n    {\n\
    \        foreach(j; 0 .. n)\n        {\n            if(i > 0)\n            {\n\
    \                if(dp[i][j] + grid[i - 1][j] < dp[i - 1][j])\n              \
    \  {\n                    dp[i - 1][j] = dp[i][j] + grid[i - 1][j];\n        \
    \            prev[i - 1][j] = i * n + j;\n                }\n            }\n \
    \           if(j > 0)\n            {\n                if(dp[i][j] + grid[i][j\
    \ - 1] < dp[i][j - 1])\n                {\n                    dp[i][j - 1] =\
    \ dp[i][j] + grid[i][j - 1];\n                    prev[i][j - 1] = i * n + j;\n\
    \                }\n            }\n            if(i < n - 1)\n            {\n\
    \                if(dp[i][j] + grid[i + 1][j] < dp[i + 1][j])\n              \
    \  {\n                    dp[i + 1][j] = dp[i][j] + grid[i + 1][j];\n        \
    \            prev[i + 1][j] = i * n + j;\n                }\n            }\n \
    \           if(j < n - 1)\n            {\n                if(dp[i][j] + grid[i][j\
    \ + 1] < dp[i][j + 1])\n                {\n                    dp[i][j + 1] =\
    \ dp[i][j] + grid[i][j + 1];\n                    prev[i][j + 1] = i *", "{\n\
    \    long n = grid.length;\n    long[][] dp = new long[n][n];\n    long[][] path\
    \ = new long[n][n];\n    long[][] prev = new long[n][n];\n    for (long i = 0;\
    \ i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n      \
    \      dp[i][j] = grid[i][j];\n            path[i][j] = 1;\n            prev[i][j]\
    \ = -1;\n        }\n    }\n    for (long i = 0; i < n; i++)\n    {\n        for\
    \ (long j = 0; j < n; j++)\n        {\n            if (i > 0 && dp[i - 1][j] <\
    \ dp[i][j])\n            {\n                dp[i][j] = dp[i - 1][j];\n       \
    \         path[i][j] = path[i - 1][j];\n                prev[i][j] = 0;\n    \
    \        }\n            if (j > 0 && dp[i][j - 1] < dp[i][j])\n            {\n\
    \                dp[i][j] = dp[i][j - 1];\n                path[i][j] = path[i][j\
    \ - 1];\n                prev[i][j] = 1;\n            }\n            if (i < n\
    \ - 1 && dp[i + 1][j] < dp[i][j])\n            {\n                dp[i][j] = dp[i\
    \ + 1][j];\n                path[i][j] = path[i + 1][j];\n                prev[i][j]\
    \ = 2;\n            }\n            if (j < n - 1 && dp[i][j + 1] < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i][j + 1];\n                path[i][j]\
    \ = path[i][j + 1];\n                prev[i][j] = 3;\n            }\n        }\n\
    \    }\n    long[] ans = new long[(int)k];\n   ", "{\n    int N = grid.length;\n\
    \    int[][] dp = new int[N][N];\n    int[][] prev = new int[N][N];\n    for (int\
    \ i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j]\
    \ = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for\
    \ (int j = 0; j < N; j++)\n        {\n            if (i > 0 && dp[i - 1][j] +\
    \ 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i - 1][j] + 1;\n\
    \                prev[i][j] = 1;\n            }\n            if (j > 0 && dp[i][j\
    \ - 1] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j - 1]\
    \ + 1;\n                prev[i][j] = 2;\n            }\n            if (i < N\
    \ - 1 && dp[i + 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i + 1][j] + 1;\n                prev[i][j] = 3;\n            }\n      \
    \      if (j < N - 1 && dp[i][j + 1] + 1 < dp[i][j])\n            {\n        \
    \        dp[i][j] = dp[i][j + 1] + 1;\n                prev[i][j] = 4;\n     \
    \       }\n        }\n    int[] path = new int[k];\n    int x = 0, y = 0;\n  \
    \  for (int i = 0; i < k; i++)\n    {\n        path[i] = grid[x][y];\n       \
    \ if (prev[x][y] == 1)\n            x--;\n        else if (prev[x][y] == 2)\n\
    \            y--;\n        else if (prev[x][y] == 3)\n            x++;\n     \
    \  ", "{\n    long n = grid.length;\n    long[][] dp = new long[n][n];\n    long[][]\
    \ prev = new long[n][n];\n    long[][] next = new long[n][n];\n    foreach (i;\
    \ 0 .. n)\n    {\n        foreach (j; 0 .. n)\n        {\n            dp[i][j]\
    \ = long.max;\n            prev[i][j] = -1;\n            next[i][j] = -1;\n  \
    \      }\n    }\n    dp[0][0] = grid[0][0];\n    foreach (i; 0 .. n)\n    {\n\
    \        foreach (j; 0 .. n)\n        {\n            if (i > 0)\n            {\n\
    \                if (dp[i][j] > dp[i - 1][j] + grid[i][j])\n                {\n\
    \                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n                 \
    \   prev[i][j] = i - 1;\n                    next[i][j] = j;\n               \
    \ }\n            }\n            if (j > 0)\n            {\n                if\
    \ (dp[i][j] > dp[i][j - 1] + grid[i][j])\n                {\n                \
    \    dp[i][j] = dp[i][j - 1] + grid[i][j];\n                    prev[i][j] = i;\n\
    \                    next[i][j] = j - 1;\n                }\n            }\n \
    \       }\n    }\n    long[] res = new long[k];\n    long cur_i = n - 1;\n   \
    \ long cur_j = n - 1;\n    foreach (i; 0 .. k)\n    {\n        res[i] = grid[cur_i][cur_j];\n\
    \        long tmp_i = cur_i;\n        cur_i = prev[cur_i][cur_j];\n        cur_j\
    \ = next[tmp_i][cur_j];\n    }\n    return res;\n}", "{\n    auto n = grid.length;\n\
    \    auto m = grid[0].length;\n    auto visited = new bool[][](n, m);\n    auto\
    \ minPath = new long[][](n, m);\n    auto minPathLen = new long[][](n, m);\n \
    \   auto minPaths = new long[][][](n, m);\n    auto minPathsLen = new long[][](n,\
    \ m);\n    auto minPathsSize = new long[][](n, m);\n    auto minPathsCapacity\
    \ = new long[][](n, m);\n    auto minPathsCapacityInit = new long[][](n, m);\n\
    \    auto minPathsCapacityInitValue = new long[][](n, m);\n    auto minPathsCapacityInitValueIndex\
    \ = new long[][](n, m);\n    auto minPathsCapacityInitValueIndex2 = new long[][](n,\
    \ m);\n    auto minPathsCapacityInitValueIndex3 = new long[][](n, m);\n    auto\
    \ minPathsCapacityInitValueIndex4 = new long[][](n, m);\n    auto minPathsCapacityInitValueIndex5\
    \ = new long[][](n, m);\n    auto minPathsCapacityInitValueIndex6 = new long[][](n,\
    \ m);\n    auto minPathsCapacityInitValueIndex7 = new long[][](n, m);\n    auto\
    \ minPathsCapacityInitValueIndex8 = new long[][](n, m);\n    auto minPathsCapacityInitValueIndex9\
    \ = new long[][](n, m);\n    auto minPathsCapacityInitValueIndex10 = new long[][](n,\
    \ m);\n    auto minPathsCapacityInitValueIndex11 = new long[][](n, m);\n    auto\
    \ minPathsCapacityInitValueIndex12 = new long[][](n, m);\n    auto minPathsCapacityInitValueIndex13\
    \ = new long[][](n, m);\n    auto minPathsCapacityInitValueIndex14 = new long[][](n,\
    \ m);\n    auto minPathsCapacityInitValueIndex15 = new long[][](n, m);\n    auto\
    \ minPathsCapacity", "{\n    long N = grid.length;\n    long[][] dp = new long[N][N];\n\
    \    foreach (i; 0 .. N)\n        foreach (j; 0 .. N)\n            dp[i][j] =\
    \ long.max;\n    dp[0][0] = grid[0][0];\n    foreach (i; 0 .. N)\n        foreach\
    \ (j; 0 .. N)\n        {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i - 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j]\
    \ = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n        }\n    long[] res = new\
    \ long[k];\n    long i = N - 1;\n    long j = N - 1;\n    foreach (x; 0 .. k)\n\
    \    {\n        res[x] = grid[i][j];\n        if (i > 0 && dp[i - 1][j] + grid[i][j]\
    \ == dp[i][j])\n            i--;\n        else\n            j--;\n    }\n    return\
    \ res;\n}", "{\n    long N = grid.length;\n    long[] result = new long[k];\n\
    \    long[] min = new long[k];\n    long[] cur = new long[k];\n    long[] next\
    \ = new long[k];\n    long[] temp;\n    long minSum = long.max;\n    long curSum\
    \ = 0;\n    long nextSum = 0;\n    long[] minPath = new long[k];\n    long[] curPath\
    \ = new long[k];\n    long[] nextPath = new long[k];\n    long[] tempPath;\n \
    \   long[] minPath2 = new long[k];\n    long[] curPath2 = new long[k];\n    long[]\
    \ nextPath2 = new long[k];\n    long[] tempPath2;\n    long[] minPath3 = new long[k];\n\
    \    long[] curPath3 = new long[k];\n    long[] nextPath3 = new long[k];\n   \
    \ long[] tempPath3;\n    long[] minPath4 = new long[k];\n    long[] curPath4 =\
    \ new long[k];\n    long[] nextPath4 = new long[k];\n    long[] tempPath4;\n \
    \   long[] minPath5 = new long[k];\n    long[] curPath5 = new long[k];\n    long[]\
    \ nextPath5 = new long[k];\n    long[] tempPath5;\n    long[] minPath6 = new long[k];\n\
    \    long[] curPath6 = new long[k];\n    long[] nextPath6 = new long[k];\n   \
    \ long[] tempPath6;\n    long[] minPath7 = new long[k];\n    long[] curPath7 =\
    \ new long[k];\n    long[] nextPath7 = new long[k];\n    long[] tempPath7;\n \
    \   long[] minPath8 = new long[k];\n    long[] curPath8 = new long[k];\n    long[]\
    \ nextPath8 = new long[k];\n    long[] tempPath8;\n    long[] minPath9 = new long[k];\n\
    \    long[] curPath9 = new long[k];\n    long[] nextPath9 = new long[k];\n   \
    \ long[] tempPath9;\n    long[] minPath", "{\n    int N = grid.length;\n    int[][]\
    \ dp = new int[N][N];\n    int[][] prev = new int[N][N];\n    for (int i = 0;\
    \ i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n\
    \    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j\
    \ < N; j++)\n        {\n            if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i - 1][j] + 1;\n               \
    \ prev[i][j] = 1;\n            }\n            if (j > 0 && dp[i][j - 1] + 1 <\
    \ dp[i][j])\n            {\n                dp[i][j] = dp[i][j - 1] + 1;\n   \
    \             prev[i][j] = 2;\n            }\n            if (i < N - 1 && dp[i\
    \ + 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j]\
    \ + 1;\n                prev[i][j] = 3;\n            }\n            if (j < N\
    \ - 1 && dp[i][j + 1] + 1 < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i][j + 1] + 1;\n                prev[i][j] = 4;\n            }\n      \
    \  }\n    long[] res = new long[k];\n    int x = 0, y = 0;\n    for (int i = 0;\
    \ i < k; i++)\n    {\n        res[i] = grid[x][y];\n        if (prev[x][y] ==\
    \ 1)\n            x--;\n        else if (prev[x][y] == 2)\n            y--;\n\
    \        else if (prev[x][y] == 3)\n            x++;\n       ", "{\n    long n\
    \ = grid.length;\n    long[][] dp = new long[n][n];\n    long[][] prev = new long[n][n];\n\
    \    long[][] next = new long[n][n];\n    long[][] path = new long[n][n];\n  \
    \  foreach (i; 0 .. n)\n    {\n        foreach (j; 0 .. n)\n        {\n      \
    \      dp[i][j] = long.max;\n            prev[i][j] = long.max;\n            next[i][j]\
    \ = long.max;\n            path[i][j] = long.max;\n        }\n    }\n    foreach\
    \ (i; 0 .. n)\n    {\n        foreach (j; 0 .. n)\n        {\n            if (i\
    \ > 0)\n            {\n                prev[i][j] = dp[i - 1][j];\n          \
    \      path[i][j] = grid[i - 1][j];\n            }\n            if (j > 0)\n \
    \           {\n                if (prev[i][j] > dp[i][j - 1])\n              \
    \  {\n                    prev[i][j] = dp[i][j - 1];\n                    path[i][j]\
    \ = grid[i][j - 1];\n                }\n            }\n            if (i < n -\
    \ 1)\n            {\n                if (prev[i][j] > dp[i + 1][j])\n        \
    \        {\n                    prev[i][j] = dp[i + 1][j];\n                 \
    \   path[i][j] = grid[i + 1][j];\n                }\n            }\n         \
    \   if (j < n - 1)\n            {\n                if (prev[i][j] > dp[i][j +\
    \ 1])\n                {\n                    prev[i][j] = dp[i][j + 1];\n   \
    \                 path[i][j] = grid[i][j + 1];\n                }\n          \
    \  }\n            dp[i][j] = prev[i][j] + grid[i][j];\n        }\n    }\n    long[]\
    \ ans = new long[k];\n    long x = n -", "{\n    int N = grid.length;\n    int[][]\
    \ dp = new int[N][N];\n    int[][] prev = new int[N][N];\n    for (int i = 0;\
    \ i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n\
    \    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j\
    \ < N; j++)\n        {\n            if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i - 1][j] + 1;\n               \
    \ prev[i][j] = 1;\n            }\n            if (j > 0 && dp[i][j - 1] + 1 <\
    \ dp[i][j])\n            {\n                dp[i][j] = dp[i][j - 1] + 1;\n   \
    \             prev[i][j] = 2;\n            }\n            if (i < N - 1 && dp[i\
    \ + 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j]\
    \ + 1;\n                prev[i][j] = 3;\n            }\n            if (j < N\
    \ - 1 && dp[i][j + 1] + 1 < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i][j + 1] + 1;\n                prev[i][j] = 4;\n            }\n      \
    \  }\n    long[] res = new long[(int)k];\n    int i = N - 1, j = N - 1;\n    for\
    \ (int t = (int)k - 1; t >= 0; t--)\n    {\n        res[t] = grid[i][j];\n   \
    \     switch (prev[i][j])\n        {\n            case 1:\n                i--;\n\
    \                break;\n            case 2:\n                j--;\n         \
    \       break;\n            case", "{\n    int n = grid.length;\n    int[][] dp\
    \ = new int[n][n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j\
    \ < n; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int\
    \ i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n        {\n       \
    \     if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n\
    \            if (j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1]\
    \ + grid[i][j]);\n        }\n    int[][] dp2 = new int[n][n];\n    for (int i\
    \ = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            dp2[i][j]\
    \ = int.max;\n    dp2[n - 1][n - 1] = 0;\n    for (int i = n - 1; i >= 0; i--)\n\
    \        for (int j = n - 1; j >= 0; j--)\n        {\n            if (i < n -\
    \ 1)\n                dp2[i][j] = min(dp2[i][j], dp2[i + 1][j] + grid[i][j]);\n\
    \            if (j < n - 1)\n                dp2[i][j] = min(dp2[i][j], dp2[i][j\
    \ + 1] + grid[i][j]);\n        }\n    int[][] dp3 = new int[n][n];\n    for (int\
    \ i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            dp3[i][j]\
    \ = dp[i][j] + dp2[i][j] - grid[i][j];\n    int[][] dp4 = new int[", "{\n    int\
    \ n = grid.length;\n    int[][] dp = new int[n][n];\n    int[][] pre = new int[n][n];\n\
    \    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n      \
    \      dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++)\n\
    \        for (int j = 0; j < n; j++)\n        {\n            if (i > 0 && dp[i\
    \ - 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i - 1][j]\
    \ + 1;\n                pre[i][j] = 1;\n            }\n            if (j > 0 &&\
    \ dp[i][j - 1] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i][j\
    \ - 1] + 1;\n                pre[i][j] = 2;\n            }\n            if (i\
    \ < n - 1 && dp[i + 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i + 1][j] + 1;\n                pre[i][j] = 3;\n            }\n       \
    \     if (j < n - 1 && dp[i][j + 1] + 1 < dp[i][j])\n            {\n         \
    \       dp[i][j] = dp[i][j + 1] + 1;\n                pre[i][j] = 4;\n       \
    \     }\n        }\n    long[] ans = new long[(int)k];\n    int x = 0, y = 0;\n\
    \    for (int i = 0; i < k; i++)\n    {\n        ans[i] = grid[x][y];\n      \
    \  if (pre[x][y] == 1)\n            x--;\n        else if (pre[x][y] == 2)\n \
    \           y--;\n        else if (pre[x][y] == 3)\n            x", "{\n    long\
    \ N = grid.length;\n    long[][] dp = new long[N][N];\n    foreach (i; 0 .. N)\n\
    \        foreach (j; 0 .. N)\n            dp[i][j] = long.max;\n    dp[0][0] =\
    \ grid[0][0];\n    foreach (i; 0 .. N)\n        foreach (j; 0 .. N)\n        {\n\
    \            if (i + 1 < N)\n                dp[i + 1][j] = min(dp[i + 1][j],\
    \ dp[i][j] + grid[i + 1][j]);\n            if (j + 1 < N)\n                dp[i][j\
    \ + 1] = min(dp[i][j + 1], dp[i][j] + grid[i][j + 1]);\n        }\n    long[]\
    \ res = new long[k];\n    foreach (i; 0 .. k)\n        res[i] = grid[0][0];\n\
    \    long cur = 0;\n    long i = 0;\n    long j = 0;\n    while (cur < k)\n  \
    \  {\n        if (i + 1 < N && dp[i + 1][j] < dp[i][j + 1])\n        {\n     \
    \       res[cur] = grid[i + 1][j];\n            i++;\n        }\n        else\n\
    \        {\n            res[cur] = grid[i][j + 1];\n            j++;\n       \
    \ }\n        cur++;\n    }\n    return res;\n}", "{\n    int N = grid.length;\n\
    \    int[][] dp = new int[N][N];\n    int[][] prev = new int[N][N];\n    for (int\
    \ i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j]\
    \ = int.max;\n    dp[0][0] = 0;\n    prev[0][0] = -1;\n    for (int i = 0; i <\
    \ N; i++)\n        for (int j = 0; j < N; j++)\n        {\n            if (i >\
    \ 0 && dp[i][j] + grid[i - 1][j] < dp[i - 1][j])\n            {\n            \
    \    dp[i - 1][j] = dp[i][j] + grid[i - 1][j];\n                prev[i - 1][j]\
    \ = i * N + j;\n            }\n            if (j > 0 && dp[i][j] + grid[i][j -\
    \ 1] < dp[i][j - 1])\n            {\n                dp[i][j - 1] = dp[i][j] +\
    \ grid[i][j - 1];\n                prev[i][j - 1] = i * N + j;\n            }\n\
    \            if (i < N - 1 && dp[i][j] + grid[i + 1][j] < dp[i + 1][j])\n    \
    \        {\n                dp[i + 1][j] = dp[i][j] + grid[i + 1][j];\n      \
    \          prev[i + 1][j] = i * N + j;\n            }\n            if (j < N -\
    \ 1 && dp[i][j] + grid[i][j + 1] < dp[i][j + 1])\n            {\n            \
    \    dp[i][j + 1] = dp[i][j] + grid[i][j + 1];\n                prev[i][j + 1]\
    \ = i * N + j;\n            }\n        }\n    int[] path = new int[k];\n    int\
    \ cur = N * N - 1;", "{\n    auto n = grid.length;\n    auto m = grid[0].length;\n\
    \    auto dp = new long[][](n, m);\n    auto path = new long[][](n, m);\n    dp[0][0]\
    \ = grid[0][0];\n    path[0][0] = 1;\n    foreach (i; 1 .. n)\n    {\n       \
    \ dp[i][0] = dp[i - 1][0] + grid[i][0];\n        path[i][0] = 1;\n    }\n    foreach\
    \ (i; 1 .. m)\n    {\n        dp[0][i] = dp[0][i - 1] + grid[0][i];\n        path[0][i]\
    \ = 1;\n    }\n    foreach (i; 1 .. n)\n    {\n        foreach (j; 1 .. m)\n \
    \       {\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n\
    \            path[i][j] = dp[i - 1][j] < dp[i][j - 1] ? path[i - 1][j] : path[i][j\
    \ - 1];\n        }\n    }\n    auto res = new long[k];\n    auto i = n - 1;\n\
    \    auto j = m - 1;\n    foreach (l; k .. 0)\n    {\n        res[l] = grid[i][j];\n\
    \        if (path[i][j] == 1)\n        {\n            i--;\n        }\n      \
    \  else\n        {\n            j--;\n        }\n    }\n    return res;\n}", "{\n\
    \    int n = grid.length;\n    int[][] dp = new int[n][n];\n    int[][] prev =\
    \ new int[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j\
    \ < n; j++) {\n            dp[i][j] = int.max;\n            prev[i][j] = -1;\n\
    \        }\n    }\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++) {\n    \
    \    for (int j = 0; j < n; j++) {\n            if (i > 0 && dp[i - 1][j] + 1\
    \ < dp[i][j]) {\n                dp[i][j] = dp[i - 1][j] + 1;\n              \
    \  prev[i][j] = i * n + j - n;\n            }\n            if (j > 0 && dp[i][j\
    \ - 1] + 1 < dp[i][j]) {\n                dp[i][j] = dp[i][j - 1] + 1;\n     \
    \           prev[i][j] = i * n + j - 1;\n            }\n            if (i < n\
    \ - 1 && dp[i + 1][j] + 1 < dp[i][j]) {\n                dp[i][j] = dp[i + 1][j]\
    \ + 1;\n                prev[i][j] = i * n + j + n;\n            }\n         \
    \   if (j < n - 1 && dp[i][j + 1] + 1 < dp[i][j]) {\n                dp[i][j]\
    \ = dp[i][j + 1] + 1;\n                prev[i][j] = i * n + j + 1;\n         \
    \   }\n        }\n    }\n    int[] path = new int[(int)k];\n    int cur = 0;\n\
    \    for (int i = 0; i < k; i++) {\n        path[i] = grid[cur / n][cur % n];\n\
    \        cur = prev[cur / n][cur % n];\n    }\n", "{\n    long n = grid.length;\n\
    \    long[][] dp = new long[n][n];\n    for (long i = 0; i < n; i++)\n       \
    \ for (long j = 0; j < n; j++)\n            dp[i][j] = grid[i][j];\n    for (long\
    \ i = 0; i < n; i++)\n        for (long j = 0; j < n; j++)\n        {\n      \
    \      if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i - 1][j]);\n \
    \           if (j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1]);\n\
    \        }\n    long[] ans = new long[(int)k];\n    long i = 0, j = 0;\n    for\
    \ (long l = 0; l < k; l++)\n    {\n        ans[(int)l] = dp[(int)i][(int)j];\n\
    \        if (i > 0 && dp[(int)i - 1][(int)j] < dp[(int)i][(int)j])\n         \
    \   i--;\n        else if (j > 0 && dp[(int)i][(int)j - 1] < dp[(int)i][(int)j])\n\
    \            j--;\n        else if (i < n - 1 && dp[(int)i + 1][(int)j] < dp[(int)i][(int)j])\n\
    \            i++;\n        else if (j < n - 1 && dp[(int)i][(int)j + 1] < dp[(int)i][(int)j])\n\
    \            j++;\n    }\n    return ans;\n}", "{\n    int n = grid.length;\n\
    \    int[][] dp = new int[n][n];\n    foreach(i; 0 .. n)\n        foreach(j; 0\
    \ .. n)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n    foreach(i; 0\
    \ .. n)\n        foreach(j; 0 .. n)\n        {\n            if(i > 0)\n      \
    \          dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1);\n            if(j > 0)\n\
    \                dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1);\n        }\n    int[][]\
    \ dp2 = new int[n][n];\n    foreach(i; 0 .. n)\n        foreach(j; 0 .. n)\n \
    \           dp2[i][j] = int.max;\n    dp2[n - 1][n - 1] = 0;\n    foreach(i; n\
    \ - 1 .. 0)\n        foreach(j; n - 1 .. 0)\n        {\n            if(i < n -\
    \ 1)\n                dp2[i][j] = min(dp2[i][j], dp2[i + 1][j] + 1);\n       \
    \     if(j < n - 1)\n                dp2[i][j] = min(dp2[i][j], dp2[i][j + 1]\
    \ + 1);\n        }\n    int[][] dp3 = new int[n][n];\n    foreach(i; 0 .. n)\n\
    \        foreach(j; 0 .. n)\n            dp3[i][j] = dp[i][j] + dp2[i][j];\n \
    \   int[][] dp4 = new int[n][n];\n    foreach(i; 0 .. n)\n        foreach(j; 0\
    \ .. n)\n            dp4[i][j] = int.max;\n    dp4[0][0] = grid[0][0];\n    foreach(i;",
  "{\n    long n = grid.length;\n    long[][] dp = new long[n][n];\n    long[][] prev\
    \ = new long[n][n];\n    for (long i = 0; i < n; i++)\n    {\n        for (long\
    \ j = 0; j < n; j++)\n        {\n            dp[i][j] = grid[i][j];\n        \
    \    prev[i][j] = -1;\n        }\n    }\n    for (long i = 0; i < n; i++)\n  \
    \  {\n        for (long j = 0; j < n; j++)\n        {\n            if (i > 0 &&\
    \ dp[i][j] > dp[i - 1][j])\n            {\n                dp[i][j] = dp[i - 1][j];\n\
    \                prev[i][j] = 0;\n            }\n            if (j > 0 && dp[i][j]\
    \ > dp[i][j - 1])\n            {\n                dp[i][j] = dp[i][j - 1];\n \
    \               prev[i][j] = 1;\n            }\n            if (i < n - 1 && dp[i][j]\
    \ > dp[i + 1][j])\n            {\n                dp[i][j] = dp[i + 1][j];\n \
    \               prev[i][j] = 2;\n            }\n            if (j < n - 1 && dp[i][j]\
    \ > dp[i][j + 1])\n            {\n                dp[i][j] = dp[i][j + 1];\n \
    \               prev[i][j] = 3;\n            }\n        }\n    }\n    long[] ans\
    \ = new long[(int)k];\n    long x = 0;\n    long y = 0;\n    for (long i = 0;\
    \ i < k; i++)\n    {\n        ans[(int)i] = grid[(int)x][(int)y];\n        if\
    \ (prev[(int)x][(int)y] == 0)\n            x--;\n        else if (prev[(int)x][(int)y]\
    \ ==", "{\n    // write your code here\n    int n = grid.length;\n    int[][]\
    \ dp = new int[n][n];\n    for (int i = 0; i < n; i++)\n    {\n        for (int\
    \ j = 0; j < n; j++)\n        {\n            dp[i][j] = int.max;\n        }\n\
    \    }\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++)\n    {\n        for\
    \ (int j = 0; j < n; j++)\n        {\n            if (i > 0)\n            {\n\
    \                dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n      \
    \      }\n            if (j > 0)\n            {\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + grid[i][j]);\n            }\n        }\n    }\n    long[] res\
    \ = new long[k];\n    int i = n - 1;\n    int j = n - 1;\n    for (int t = k -\
    \ 1; t >= 0; t--)\n    {\n        res[t] = grid[i][j];\n        if (i > 0 && dp[i][j]\
    \ == dp[i - 1][j] + grid[i][j])\n        {\n            i--;\n        }\n    \
    \    else\n        {\n            j--;\n        }\n    }\n    return res;\n}",
  "{\n    long N = grid.length;\n    long[][] dp = new long[N][N];\n    long[][] next\
    \ = new long[N][N];\n    for (long i = 0; i < N; i++)\n    {\n        for (long\
    \ j = 0; j < N; j++)\n        {\n            dp[i][j] = grid[i][j];\n        \
    \    next[i][j] = -1;\n        }\n    }\n    for (long i = 0; i < N; i++)\n  \
    \  {\n        for (long j = 0; j < N; j++)\n        {\n            if (i > 0 &&\
    \ dp[i - 1][j] < dp[i][j])\n            {\n                dp[i][j] = dp[i - 1][j];\n\
    \                next[i][j] = 0;\n            }\n            if (j > 0 && dp[i][j\
    \ - 1] < dp[i][j])\n            {\n                dp[i][j] = dp[i][j - 1];\n\
    \                next[i][j] = 1;\n            }\n            if (i < N - 1 &&\
    \ dp[i + 1][j] < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j];\n\
    \                next[i][j] = 2;\n            }\n            if (j < N - 1 &&\
    \ dp[i][j + 1] < dp[i][j])\n            {\n                dp[i][j] = dp[i][j\
    \ + 1];\n                next[i][j] = 3;\n            }\n        }\n    }\n  \
    \  long[] res = new long[k];\n    long i = 0, j = 0;\n    for (long l = 0; l <\
    \ k; l++)\n    {\n        res[l] = grid[i][j];\n        switch ((int)next[i][j])\n\
    \        {\n            case 0:\n                i--;\n                break;\n\
    \            case 1:\n                j--;\n                break;\n         \
    \   case 2:\n                i++;\n                break;\n", "{\n    long n =\
    \ grid.length;\n    long[][] dp = new long[n][n];\n    foreach(i; 0 .. n)\n  \
    \      foreach(j; 0 .. n)\n            dp[i][j] = long.max;\n    dp[0][0] = 0;\n\
    \    foreach(i; 0 .. n)\n        foreach(j; 0 .. n)\n        {\n            if(i\
    \ > 0)\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n\
    \            if(j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1]\
    \ + grid[i][j]);\n        }\n    long[] res = new long[k];\n    long i = n - 1;\n\
    \    long j = n - 1;\n    foreach(idx; k .. 0)\n    {\n        res[idx] = grid[i][j];\n\
    \        if(i > 0 && dp[i - 1][j] + grid[i][j] == dp[i][j])\n            i--;\n\
    \        else\n            j--;\n    }\n    return res;\n}", "{\n    // your code\
    \ here\n    long[][] dp = new long[grid.length][grid[0].length];\n    foreach(i;\
    \ 0 .. grid.length)\n    {\n        foreach(j; 0 .. grid[0].length)\n        {\n\
    \            dp[i][j] = grid[i][j];\n        }\n    }\n    foreach(i; 0 .. grid.length)\n\
    \    {\n        foreach(j; 0 .. grid[0].length)\n        {\n            if(i >\
    \ 0)\n            {\n                dp[i][j] = min(dp[i][j], dp[i-1][j]);\n \
    \           }\n            if(j > 0)\n            {\n                dp[i][j]\
    \ = min(dp[i][j], dp[i][j-1]);\n            }\n        }\n    }\n    long[] res\
    \ = new long[k];\n    long i = 0;\n    long j = 0;\n    long cnt = 0;\n    while(cnt\
    \ < k)\n    {\n        res[cnt] = dp[i][j];\n        if(i > 0 && dp[i-1][j] ==\
    \ dp[i][j])\n        {\n            i--;\n        }\n        else if(j > 0 &&\
    \ dp[i][j-1] == dp[i][j])\n        {\n            j--;\n        }\n        else\n\
    \        {\n            i++;\n        }\n        cnt++;\n    }\n    return res;\n\
    }", "{\n    int N = grid.length;\n    int[][] dp = new int[N][N];\n    foreach(int\
    \ i; 0 .. N)\n        foreach(int j; 0 .. N)\n            dp[i][j] = int.max;\n\
    \    dp[0][0] = 0;\n    foreach(int i; 0 .. N)\n        foreach(int j; 0 .. N)\n\
    \        {\n            if(i > 0)\n                dp[i][j] = min(dp[i][j], dp[i\
    \ - 1][j] + 1);\n            if(j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + 1);\n        }\n    foreach(int i; 0 .. N)\n        foreach(int\
    \ j; 0 .. N)\n        {\n            if(i < N - 1)\n                dp[i][j] =\
    \ min(dp[i][j], dp[i + 1][j] + 1);\n            if(j < N - 1)\n              \
    \  dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1);\n        }\n    int[][] dp2 = new\
    \ int[N][N];\n    foreach(int i; 0 .. N)\n        foreach(int j; 0 .. N)\n   \
    \         dp2[i][j] = int.max;\n    dp2[N - 1][N - 1] = 0;\n    foreach(int i;\
    \ N - 1 .. -1)\n        foreach(int j; N - 1 .. -1)\n        {\n            if(i\
    \ < N - 1)\n                dp2[i][j] = min(dp2[i][j], dp2[i + 1][j] + 1);\n \
    \           if(j < N - 1)\n                dp2[i][j] = min(dp2[i][j], dp2[i][j\
    \ + 1] + 1);\n        }\n    foreach(int i; N - 1 .. -1)\n        foreach(int\
    \ j; N", "{\n    int N = grid.length;\n    int[][] dp = new int[N][N];\n    for\
    \ (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j]\
    \ = int.max;\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for\
    \ (int j = 0; j < N; j++)\n        {\n            if (i > 0)\n               \
    \ dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n            if (j > 0)\n\
    \                dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n      \
    \  }\n    int[] path = new int[k];\n    int i = N - 1;\n    int j = N - 1;\n \
    \   for (int l = k - 1; l >= 0; l--)\n    {\n        path[l] = grid[i][j];\n \
    \       if (i > 0 && dp[i - 1][j] + grid[i][j] == dp[i][j])\n            i--;\n\
    \        else\n            j--;\n    }\n    return path;\n}", "{\n    int n =\
    \ grid.length;\n    int[][] dp = new int[n][n];\n    for (int i = 0; i < n; i++)\n\
    \        for (int j = 0; j < n; j++)\n            dp[i][j] = i * n + j;\n    for\
    \ (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            for\
    \ (int x = 0; x < n; x++)\n                for (int y = 0; y < n; y++)\n     \
    \               if (abs(x - i) + abs(y - j) == 1)\n                        if\
    \ (grid[i][j] < grid[x][y])\n                            dp[x][y] = min(dp[x][y],\
    \ dp[i][j]);\n    int[] res = new int[k];\n    int x = 0, y = 0;\n    for (int\
    \ i = 0; i < k; i++)\n    {\n        res[i] = dp[x][y];\n        for (int j =\
    \ 0; j < n; j++)\n            for (int l = 0; l < n; l++)\n                if\
    \ (abs(j - x) + abs(l - y) == 1)\n                    dp[j][l] = min(dp[j][l],\
    \ dp[x][y]);\n        int min = dp[x][y];\n        for (int j = 0; j < n; j++)\n\
    \            for (int l = 0; l < n; l++)\n                if (abs(j - x) + abs(l\
    \ - y) == 1)\n                    if (dp[j][l] < min)\n                    {\n\
    \                        min = dp[j][l];\n                        x = j;\n   \
    \                     y = l;\n                    }\n    }\n    return res;\n}",
  "{\n    long n = grid.length;\n    long[][] dp = new long[n][n];\n    long[][] prev\
    \ = new long[n][n];\n    long[][] next = new long[n][n];\n    for (long i = 0;\
    \ i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n      \
    \      dp[i][j] = grid[i][j];\n            prev[i][j] = -1;\n            next[i][j]\
    \ = -1;\n        }\n    }\n    for (long step = 1; step < k; step++)\n    {\n\
    \        for (long i = 0; i < n; i++)\n        {\n            for (long j = 0;\
    \ j < n; j++)\n            {\n                long min = dp[i][j];\n         \
    \       long min_i = i;\n                long min_j = j;\n                if (i\
    \ > 0 && dp[i - 1][j] < min)\n                {\n                    min = dp[i\
    \ - 1][j];\n                    min_i = i - 1;\n                    min_j = j;\n\
    \                }\n                if (i < n - 1 && dp[i + 1][j] < min)\n   \
    \             {\n                    min = dp[i + 1][j];\n                   \
    \ min_i = i + 1;\n                    min_j = j;\n                }\n        \
    \        if (j > 0 && dp[i][j - 1] < min)\n                {\n               \
    \     min = dp[i][j - 1];\n                    min_i = i;\n                  \
    \  min_j = j - 1;\n                }\n                if (j < n - 1 && dp[i][j\
    \ + 1] < min)\n                {\n                    min = dp[i][j + 1];\n  \
    \                  min_i = i;\n                    min_j = j + 1;\n          \
    \      }\n                dp[i][j] = min * 10 + grid[i][j];\n                prev[i][j]\
    \ = min_i * n + min_j;\n            }\n        }\n    }\n    long min = dp[0",
  "{\n    int n = grid.length;\n    int[][] dp = new int[n][n];\n    int[][] prev\
    \ = new int[n][n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j\
    \ < n; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int\
    \ i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n        {\n       \
    \     if (i > 0 && dp[i - 1][j] < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i - 1][j];\n                prev[i][j] = 1;\n            }\n          \
    \  if (j > 0 && dp[i][j - 1] < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i][j - 1];\n                prev[i][j] = 2;\n            }\n          \
    \  if (i < n - 1 && dp[i + 1][j] < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i + 1][j];\n                prev[i][j] = 3;\n            }\n          \
    \  if (j < n - 1 && dp[i][j + 1] < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i][j + 1];\n                prev[i][j] = 4;\n            }\n          \
    \  dp[i][j] += grid[i][j];\n        }\n    long[] res = new long[(int)k];\n  \
    \  int x = n - 1, y = n - 1;\n    for (int i = (int)k - 1; i >= 0; i--)\n    {\n\
    \        res[i] = grid[x][y];\n        if (prev[x][y] == 1)\n            x--;\n\
    \        else if (prev[x][y] == 2)\n            y--;\n        else if (prev[x][y]",
  "{\n    // TODO\n    return null;\n}", "{\n    long N = grid.length;\n    long[][]\
    \ dp = new long[N][N];\n    long[][] prev = new long[N][N];\n    long[][] next\
    \ = new long[N][N];\n    long[][] dir = new long[][]{{1L, 0L}, {0L, 1L}, {-1L,\
    \ 0L}, {0L, -1L}};\n    for (long i = 0L; i < N; i++) \n    {\n        for (long\
    \ j = 0L; j < N; j++) \n        {\n            dp[i][j] = grid[i][j];\n      \
    \      prev[i][j] = -1L;\n            next[i][j] = -1L;\n        }\n    }\n  \
    \  for (long step = 1L; step < k; step++) \n    {\n        for (long i = 0L; i\
    \ < N; i++) \n        {\n            for (long j = 0L; j < N; j++) \n        \
    \    {\n                long min = dp[i][j];\n                for (long d = 0L;\
    \ d < 4L; d++) \n                {\n                    long x = i + dir[d][0L];\n\
    \                    long y = j + dir[d][1L];\n                    if (x >= 0L\
    \ && x < N && y >= 0L && y < N && dp[x][y] < min) \n                    {\n  \
    \                      min = dp[x][y];\n                        prev[i][j] = x\
    \ * N + y;\n                    }\n                }\n                dp[i][j]\
    \ += min;\n            }\n        }\n    }\n    long min = dp[0L][0L];\n    long\
    \ start = 0L;\n    for (long i = 0L; i < N; i++) \n    {\n        for (long j\
    \ = 0L; j < N; j++) \n        {\n            if (dp[i][j] < min) \n          \
    \  {\n                min = dp[i][j];\n                start = i * N + j;\n  \
    \          }\n        }\n    }\n    long[]", "{\n    int N = grid.length;\n  \
    \  int[][] dp = new int[N][N];\n    for (int i = 0; i < N; i++)\n        for (int\
    \ j = 0; j < N; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n   \
    \ for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n        {\n\
    \            if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i - 1][j]\
    \ + grid[i][j]);\n            if (j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + grid[i][j]);\n        }\n    int[] path = new int[k];\n    int\
    \ cur = dp[N - 1][N - 1];\n    path[$ - 1] = grid[N - 1][N - 1];\n    for (int\
    \ i = N - 1; i >= 0; i--)\n        for (int j = N - 1; j >= 0; j--)\n        \
    \    if (dp[i][j] == cur - grid[i][j])\n            {\n                cur -=\
    \ grid[i][j];\n                path[$ - 1] = grid[i][j];\n                if (i\
    \ > 0)\n                    cur = min(cur, dp[i - 1][j]);\n                if\
    \ (j > 0)\n                    cur = min(cur, dp[i][j - 1]);\n               \
    \ break;\n            }\n    return path;\n}", "{\n    auto n = grid.length;\n\
    \    auto m = grid[0].length;\n    auto dp = new long[][](n, m);\n    auto pq\
    \ = new PriorityQueue!(long[], \"a.length > b.length || (a.length == b.length\
    \ && a > b)\")();\n    pq.put([grid[0][0]]);\n    dp[0][0] = 1;\n    while (!pq.empty)\n\
    \    {\n        auto cur = pq.get;\n        if (cur.length == k)\n           \
    \ return cur;\n        auto x = cur[$ - 1] - 1;\n        auto i = x / m;\n   \
    \     auto j = x % m;\n        if (i > 0 && dp[i - 1][j] == 0)\n        {\n  \
    \          dp[i - 1][j] = 1;\n            pq.put(cur ~ [grid[i - 1][j]]);\n  \
    \      }\n        if (i < n - 1 && dp[i + 1][j] == 0)\n        {\n           \
    \ dp[i + 1][j] = 1;\n            pq.put(cur ~ [grid[i + 1][j]]);\n        }\n\
    \        if (j > 0 && dp[i][j - 1] == 0)\n        {\n            dp[i][j - 1]\
    \ = 1;\n            pq.put(cur ~ [grid[i][j - 1]]);\n        }\n        if (j\
    \ < m - 1 && dp[i][j + 1] == 0)\n        {\n            dp[i][j + 1] = 1;\n  \
    \          pq.put(cur ~ [grid[i][j + 1]]);\n        }\n    }\n    return [];\n\
    }", "{\n    long n = grid.length;\n    long[][] dp = new long[n][n];\n    long[][]\
    \ prev = new long[n][n];\n    long[][] next = new long[n][n];\n    foreach (i;\
    \ 0 .. n)\n    {\n        foreach (j; 0 .. n)\n        {\n            dp[i][j]\
    \ = long.max;\n            prev[i][j] = -1;\n            next[i][j] = -1;\n  \
    \      }\n    }\n    dp[0][0] = grid[0][0];\n    prev[0][0] = -1;\n    next[0][0]\
    \ = -1;\n    foreach (i; 0 .. n)\n    {\n        foreach (j; 0 .. n)\n       \
    \ {\n            if (i > 0)\n            {\n                if (dp[i - 1][j] +\
    \ grid[i][j] < dp[i][j])\n                {\n                    dp[i][j] = dp[i\
    \ - 1][j] + grid[i][j];\n                    prev[i][j] = i - 1;\n           \
    \         next[i][j] = j;\n                }\n            }\n            if (j\
    \ > 0)\n            {\n                if (dp[i][j - 1] + grid[i][j] < dp[i][j])\n\
    \                {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                    prev[i][j] = i;\n                    next[i][j] = j - 1;\n\
    \                }\n            }\n        }\n    }\n    long[] res = new long[k];\n\
    \    long i = n - 1;\n    long j = n - 1;\n    foreach (t; 0 .. k)\n    {\n  \
    \      res[t] = grid[i][j];\n        long tmp = i;\n        i = prev[i][j];\n\
    \        j = next[tmp][j];\n    }\n    return res;\n}", "{\n    long n = grid.length;\n\
    \    long[][] dp = new long[n][n];\n    foreach(i; 0 .. n)\n        foreach(j;\
    \ 0 .. n)\n            dp[i][j] = long.max;\n    dp[0][0] = grid[0][0];\n    foreach(i;\
    \ 0 .. n)\n        foreach(j; 0 .. n)\n        {\n            if(i > 0)\n    \
    \            dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n          \
    \  if(j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n\
    \        }\n    long[] ans = new long[k];\n    ans[0] = grid[0][0];\n    long\
    \ i = 0, j = 0;\n    foreach(idx; 1 .. k)\n    {\n        if(i > 0 && dp[i - 1][j]\
    \ + grid[i][j] == dp[i][j])\n        {\n            ans[idx] = grid[i - 1][j];\n\
    \            i--;\n        }\n        else\n        {\n            ans[idx] =\
    \ grid[i][j - 1];\n            j--;\n        }\n    }\n    return ans;\n}", "{\n\
    \    long n = grid.length;\n    long[][] dp = new long[n][n];\n    long[][] prev\
    \ = new long[n][n];\n    long[][] next = new long[n][n];\n    long[][] dist =\
    \ new long[n][n];\n    long[][] path = new long[n][n];\n    for (long i = 0; i\
    \ < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n        \
    \    dp[i][j] = grid[i][j];\n            prev[i][j] = -1;\n            next[i][j]\
    \ = -1;\n            dist[i][j] = 1;\n            path[i][j] = grid[i][j];\n \
    \       }\n    }\n    for (long i = 0; i < n; i++)\n    {\n        for (long j\
    \ = 0; j < n; j++)\n        {\n            if (i > 0 && dp[i - 1][j] < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i - 1][j];\n                prev[i][j]\
    \ = 0;\n                next[i][j] = 1;\n                dist[i][j] = dist[i -\
    \ 1][j] + 1;\n                path[i][j] = path[i - 1][j] * 10 + grid[i][j];\n\
    \            }\n            if (j > 0 && dp[i][j - 1] < dp[i][j])\n          \
    \  {\n                dp[i][j] = dp[i][j - 1];\n                prev[i][j] = 1;\n\
    \                next[i][j] = 0;\n                dist[i][j] = dist[i][j - 1]\
    \ + 1;\n                path[i][j] = path[i][j - 1] * 10 + grid[i][j];\n     \
    \       }\n            if (i < n - 1 && dp[i + 1][j] < dp[i][j])\n           \
    \ {\n                dp[i][j] = dp[i +", "{\n    int N = grid.length;\n    int[][]\
    \ dp = new int[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0;\
    \ j < N; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int\
    \ i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n        {\n       \
    \     if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n\
    \            if (j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1]\
    \ + grid[i][j]);\n        }\n    int[][] dp2 = new int[N][N];\n    for (int i\
    \ = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp2[i][j]\
    \ = int.max;\n    dp2[N - 1][N - 1] = 0;\n    for (int i = N - 1; i >= 0; i--)\n\
    \        for (int j = N - 1; j >= 0; j--)\n        {\n            if (i < N -\
    \ 1)\n                dp2[i][j] = min(dp2[i][j], dp2[i + 1][j] + grid[i][j]);\n\
    \            if (j < N - 1)\n                dp2[i][j] = min(dp2[i][j], dp2[i][j\
    \ + 1] + grid[i][j]);\n        }\n    int[][] dp3 = new int[N][N];\n    for (int\
    \ i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp3[i][j]\
    \ = dp[i][j] + dp2[i][j] - grid[i][j];\n    int min = int.max;\n    int[]", "{\n\
    \    int N = grid.length;\n    int[][] dp = new int[N][N];\n    for (int i = 0;\
    \ i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n\
    \    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j\
    \ < N; j++)\n        {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i - 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j]\
    \ = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n        }\n    int[] path = new\
    \ int[k];\n    int cur = 0;\n    for (int i = 0; i < N; i++)\n        for (int\
    \ j = 0; j < N; j++)\n            if (dp[i][j] == cur)\n            {\n      \
    \          path[cur] = grid[i][j];\n                cur++;\n                if\
    \ (cur == k)\n                    return path;\n                if (i < N - 1)\n\
    \                    dp[i + 1][j] = int.max;\n                if (j < N - 1)\n\
    \                    dp[i][j + 1] = int.max;\n            }\n    return path;\n\
    }", "{\n    // Write your code here\n    int N = grid.length;\n    int[][] dp\
    \ = new int[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j\
    \ < N; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = grid[0][0];\n   \
    \ for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n        {\n\
    \            if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i - 1][j]\
    \ + grid[i][j]);\n            if (j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + grid[i][j]);\n        }\n    int[] path = new int[k];\n    int\
    \ i = 0;\n    int j = 0;\n    for (int l = 0; l < k; l++)\n    {\n        path[l]\
    \ = grid[i][j];\n        if (i == N - 1 && j == N - 1)\n            break;\n \
    \       if (i == N - 1)\n            j++;\n        else if (j == N - 1)\n    \
    \        i++;\n        else if (dp[i + 1][j] < dp[i][j + 1])\n            i++;\n\
    \        else\n            j++;\n    }\n    return path;\n}", "{\n    long n =\
    \ grid.length;\n    long[][] dp = new long[n][n];\n    foreach (i; 0 .. n)\n \
    \       foreach (j; 0 .. n)\n            dp[i][j] = long.max;\n    dp[0][0] =\
    \ 0;\n    foreach (i; 0 .. n)\n        foreach (j; 0 .. n)\n        {\n      \
    \      if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n\
    \            if (j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1]\
    \ + grid[i][j]);\n        }\n    long[] res = new long[k];\n    long cur = 0;\n\
    \    foreach (i; 0 .. k)\n    {\n        res[i] = grid[cur / n][cur % n];\n  \
    \      if (cur / n == n - 1 && cur % n == n - 1)\n            break;\n       \
    \ if (cur / n == n - 1)\n            cur++;\n        else if (cur % n == n - 1)\n\
    \            cur += n;\n        else if (dp[cur / n + 1][cur % n] < dp[cur / n][cur\
    \ % n + 1])\n            cur += n;\n        else\n            cur++;\n    }\n\
    \    return res;\n}", "{\n    long N = grid.length;\n    long[][] dp = new long[N][N];\n\
    \    long[][] prev = new long[N][N];\n    long[][] next = new long[N][N];\n  \
    \  foreach (i; 0 .. N)\n    {\n        foreach (j; 0 .. N)\n        {\n      \
    \      dp[i][j] = long.max;\n            prev[i][j] = -1;\n            next[i][j]\
    \ = -1;\n        }\n    }\n    dp[0][0] = 0;\n    foreach (i; 0 .. N)\n    {\n\
    \        foreach (j; 0 .. N)\n        {\n            if (i > 0)\n            {\n\
    \                if (dp[i - 1][j] + 1 < dp[i][j])\n                {\n       \
    \             dp[i][j] = dp[i - 1][j] + 1;\n                    prev[i][j] = i\
    \ - 1;\n                    next[i][j] = j;\n                }\n             \
    \   else if (dp[i - 1][j] + 1 == dp[i][j])\n                {\n              \
    \      if (grid[i - 1][j] < grid[prev[i][j]][next[i][j]])\n                  \
    \  {\n                        prev[i][j] = i - 1;\n                        next[i][j]\
    \ = j;\n                    }\n                }\n            }\n            if\
    \ (j > 0)\n            {\n                if (dp[i][j - 1] + 1 < dp[i][j])\n \
    \               {\n                    dp[i][j] = dp[i][j - 1] + 1;\n        \
    \            prev[i][j] = i;\n                    next[i][j] = j - 1;\n      \
    \          }\n                else if (dp[i][j - 1] + 1 == dp[i][j])\n       \
    \         {\n                    if (grid[i][j - 1] < grid[prev[i][j]][next[i][j]])\n\
    \                    {\n                        prev[i][j] = i;\n            \
    \            next[i][j] = j - 1;", "{\n    long N = grid.length;\n    long[][]\
    \ dp = new long[N][N];\n    long[][] prev = new long[N][N];\n    for (long i =\
    \ 0; i < N; i++) \n    {\n        for (long j = 0; j < N; j++) \n        {\n \
    \           dp[i][j] = grid[i][j];\n            prev[i][j] = -1;\n        }\n\
    \    }\n    for (long i = 0; i < N; i++) \n    {\n        for (long j = 0; j <\
    \ N; j++) \n        {\n            if (i > 0 && dp[i][j] > dp[i - 1][j]) \n  \
    \          {\n                dp[i][j] = dp[i - 1][j];\n                prev[i][j]\
    \ = 0;\n            }\n            if (j > 0 && dp[i][j] > dp[i][j - 1]) \n  \
    \          {\n                dp[i][j] = dp[i][j - 1];\n                prev[i][j]\
    \ = 1;\n            }\n            if (i < N - 1 && dp[i][j] > dp[i + 1][j]) \n\
    \            {\n                dp[i][j] = dp[i + 1][j];\n                prev[i][j]\
    \ = 2;\n            }\n            if (j < N - 1 && dp[i][j] > dp[i][j + 1]) \n\
    \            {\n                dp[i][j] = dp[i][j + 1];\n                prev[i][j]\
    \ = 3;\n            }\n        }\n    }\n    long[] res = new long[k];\n    long\
    \ i = 0, j = 0;\n    for (long l = 0; l < k; l++) \n    {\n        res[l] = grid[i][j];\n\
    \        long p = prev[i][j];\n        if (p == 0) \n        {\n            i--;\n\
    \        } \n        else if (p == 1) \n        {\n            j", "{\n    int\
    \ N = grid.length;\n    long[] result = new long[(int)k];\n    int[][] dp = new\
    \ int[N][N];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N;\
    \ j++) {\n            dp[i][j] = (int)grid[i][j];\n        }\n    }\n    for (int\
    \ i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if\
    \ (i > 0) {\n                dp[i][j] = min(dp[i][j], dp[i - 1][j]);\n       \
    \     }\n            if (j > 0) {\n                dp[i][j] = min(dp[i][j], dp[i][j\
    \ - 1]);\n            }\n        }\n    }\n    int x = 0;\n    int y = 0;\n  \
    \  for (int i = 0; i < k; i++) {\n        result[i] = dp[x][y];\n        if (x\
    \ + 1 < N && dp[x + 1][y] == dp[x][y] + 1) {\n            x++;\n        } else\
    \ if (y + 1 < N && dp[x][y + 1] == dp[x][y] + 1) {\n            y++;\n       \
    \ }\n    }\n    return result;\n}", "{\n    int n = grid.length;\n    int[][]\
    \ dp = new int[n][n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0;\
    \ j < n; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int\
    \ i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n        {\n       \
    \     if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n\
    \            if (j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1]\
    \ + grid[i][j]);\n        }\n    int[] path = new int[k];\n    int cur = dp[n\
    \ - 1][n - 1];\n    path[$ - 1] = grid[n - 1][n - 1];\n    for (int i = n - 1;\
    \ i >= 0; i--)\n        for (int j = n - 1; j >= 0; j--)\n        {\n        \
    \    if (i > 0 && dp[i - 1][j] + grid[i][j] == cur)\n            {\n         \
    \       path[$ - 1] = grid[i - 1][j];\n                cur -= grid[i][j];\n  \
    \              i--;\n                break;\n            }\n            if (j\
    \ > 0 && dp[i][j - 1] + grid[i][j] == cur)\n            {\n                path[$\
    \ - 1] = grid[i][j - 1];\n                cur -= grid[i][j];\n               \
    \ j--;\n                break;\n            }\n        }\n    return path;\n}",
  "{\n    long N = grid.length;\n    long[][] dp = new long[N][N];\n    long[][] prev\
    \ = new long[N][N];\n    foreach (i; 0 .. N)\n    {\n        foreach (j; 0 ..\
    \ N)\n        {\n            dp[i][j] = long.max;\n            prev[i][j] = -1;\n\
    \        }\n    }\n    dp[0][0] = 0;\n    foreach (i; 0 .. N)\n    {\n       \
    \ foreach (j; 0 .. N)\n        {\n            if (i + 1 < N)\n            {\n\
    \                if (dp[i][j] + grid[i + 1][j] < dp[i + 1][j])\n             \
    \   {\n                    dp[i + 1][j] = dp[i][j] + grid[i + 1][j];\n       \
    \             prev[i + 1][j] = j;\n                }\n            }\n        \
    \    if (j + 1 < N)\n            {\n                if (dp[i][j] + grid[i][j +\
    \ 1] < dp[i][j + 1])\n                {\n                    dp[i][j + 1] = dp[i][j]\
    \ + grid[i][j + 1];\n                    prev[i][j + 1] = j;\n               \
    \ }\n            }\n        }\n    }\n    long[] res = new long[k];\n    long\
    \ cur = N - 1;\n    foreach (i; 0 .. k)\n    {\n        res[i] = grid[cur][prev[cur][prev[cur][cur]]];\n\
    \        cur = prev[cur][prev[cur][cur]];\n    }\n    return res;\n}", "{\n  \
    \  long n = grid.length;\n    long[][] dp = new long[n][n];\n    foreach (i; 0\
    \ .. n)\n        foreach (j; 0 .. n)\n            dp[i][j] = long.max;\n    dp[0][0]\
    \ = grid[0][0];\n    foreach (i; 0 .. n)\n        foreach (j; 0 .. n)\n      \
    \  {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i -\
    \ 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + grid[i][j]);\n        }\n    long[] ans = new long[k];\n    long\
    \ cur = dp[n - 1][n - 1];\n    long i = n - 1;\n    long j = n - 1;\n    foreach\
    \ (idx; k .. 0)\n    {\n        ans[idx] = grid[i][j];\n        if (i > 0 && dp[i\
    \ - 1][j] + grid[i][j] == cur)\n        {\n            cur -= grid[i][j];\n  \
    \          i--;\n        }\n        else if (j > 0 && dp[i][j - 1] + grid[i][j]\
    \ == cur)\n        {\n            cur -= grid[i][j];\n            j--;\n     \
    \   }\n    }\n    return ans;\n}", "{\n    int n = grid.length;\n    if (n ==\
    \ 0)\n        return new long[0];\n    if (k == 0)\n        return new long[0];\n\
    \    if (k == 1)\n        return new long[]{grid[0][0]};\n    if (k == n * n)\n\
    \    {\n        long[] result = new long[n * n];\n        int index = 0;\n   \
    \     foreach (row; grid)\n            foreach (element; row)\n              \
    \  result[index++] = element;\n        return result;\n    }\n    int[][] dp =\
    \ new int[n][n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j <\
    \ n; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n    for (int i\
    \ = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n        {\n         \
    \   if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1);\n\
    \            if (j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1]\
    \ + 1);\n        }\n    int[][] dp2 = new int[n][n];\n    for (int i = 0; i <\
    \ n; i++)\n        for (int j = 0; j < n; j++)\n            dp2[i][j] = int.max;\n\
    \    dp2[n - 1][n - 1] = 0;\n    for (int i = n - 1; i >= 0; i--)\n        for\
    \ (int j = n - 1; j >= 0; j--)\n        {\n            if (i < n - 1)\n      \
    \          dp2[i][j] = min(dp2[i][j], dp2[i + 1][j] + 1);\n            if (j <\
    \ n - 1)\n                dp2[i][j] = min(dp2[i][j], dp2", "{\n    long n = grid.length;\n\
    \    long[][] dp = new long[n][n];\n    long[][] prev = new long[n][n];\n    long[][]\
    \ next = new long[n][n];\n    long[][] min = new long[n][n];\n    for (long i\
    \ = 0; i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n \
    \           dp[i][j] = grid[i][j];\n            prev[i][j] = -1;\n           \
    \ next[i][j] = -1;\n            min[i][j] = grid[i][j];\n        }\n    }\n  \
    \  for (long i = 1; i < k; i++)\n    {\n        for (long j = 0; j < n; j++)\n\
    \        {\n            for (long l = 0; l < n; l++)\n            {\n        \
    \        if (j > 0 && dp[j - 1][l] < dp[j][l])\n                {\n          \
    \          dp[j][l] = dp[j - 1][l];\n                    prev[j][l] = j - 1;\n\
    \                    next[j][l] = l;\n                }\n                if (j\
    \ < n - 1 && dp[j + 1][l] < dp[j][l])\n                {\n                   \
    \ dp[j][l] = dp[j + 1][l];\n                    prev[j][l] = j + 1;\n        \
    \            next[j][l] = l;\n                }\n                if (l > 0 &&\
    \ dp[j][l - 1] < dp[j][l])\n                {\n                    dp[j][l] =\
    \ dp[j][l - 1];\n                    prev[j][l] = j;\n                    next[j][l]\
    \ = l - 1;\n                }\n                if (l < n - 1 && dp[j][l + 1] <\
    \ dp[j][l])\n                {\n                    dp[j][l] = dp[j][l + 1];\n\
    \                    prev[j][l] = j;\n                    next[j", "{\n    int\
    \ N = grid.length;\n    int[][] dp = new int[N][N];\n    int[][] prev = new int[N][N];\n\
    \    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n\
    \        {\n            dp[i][j] = int.max;\n            prev[i][j] = -1;\n  \
    \      }\n    }\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n    {\n \
    \       for (int j = 0; j < N; j++)\n        {\n            if (i > 0 && dp[i\
    \ - 1][j] + grid[i][j] < dp[i][j])\n            {\n                dp[i][j] =\
    \ dp[i - 1][j] + grid[i][j];\n                prev[i][j] = 0;\n            }\n\
    \            if (j > 0 && dp[i][j - 1] + grid[i][j] < dp[i][j])\n            {\n\
    \                dp[i][j] = dp[i][j - 1] + grid[i][j];\n                prev[i][j]\
    \ = 1;\n            }\n            if (i < N - 1 && dp[i + 1][j] + grid[i][j]\
    \ < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j] + grid[i][j];\n\
    \                prev[i][j] = 2;\n            }\n            if (j < N - 1 &&\
    \ dp[i][j + 1] + grid[i][j] < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i][j + 1] + grid[i][j];\n                prev[i][j] = 3;\n            }\n\
    \        }\n    }\n    long[] ans = new long[k];\n    int i = N - 1;\n    int\
    \ j = N - 1;\n    for (int t = k - 1; t >= 0;", "{\n    // Write your code here\n\
    \    long[] result = new long[(int)k];\n    long[] temp = new long[(int)k];\n\
    \    long[] temp2 = new long[(int)k];\n    long[] temp3 = new long[(int)k];\n\
    \    long[] temp4 = new long[(int)k];\n    long[] temp5 = new long[(int)k];\n\
    \    long[] temp6 = new long[(int)k];\n    long[] temp7 = new long[(int)k];\n\
    \    long[] temp8 = new long[(int)k];\n    long[] temp9 = new long[(int)k];\n\
    \    long[] temp10 = new long[(int)k];\n    long[] temp11 = new long[(int)k];\n\
    \    long[] temp12 = new long[(int)k];\n    long[] temp13 = new long[(int)k];\n\
    \    long[] temp14 = new long[(int)k];\n    long[] temp15 = new long[(int)k];\n\
    \    long[] temp16 = new long[(int)k];\n    long[] temp17 = new long[(int)k];\n\
    \    long[] temp18 = new long[(int)k];\n    long[] temp19 = new long[(int)k];\n\
    \    long[] temp20 = new long[(int)k];\n    long[] temp21 = new long[(int)k];\n\
    \    long[] temp22 = new long[(int)k];\n    long[] temp23 = new long[(int)k];\n\
    \    long[] temp24 = new long[(int)k];\n    long[] temp25 = new long[(int)k];\n\
    \    long[] temp26 = new long[(int)k];\n    long[] temp27 = new long[(int)k];\n\
    \    long[] temp28 = new long[(int)k];\n    long[] temp29 = new long[(int)k];\n\
    \    long[] temp30 = new long[(int)k];\n    long[] temp31 = new long[(int)k];\n\
    \    long[] temp32 = new long[(int)k];\n    long[] temp33 = new long[", "{\n \
    \   int N = grid.length;\n    int[][] dp = new int[N][N];\n    int[][] prev =\
    \ new int[N][N];\n    for (int i = 0; i < N; i++)\n    {\n        for (int j =\
    \ 0; j < N; j++)\n        {\n            dp[i][j] = int.max;\n            prev[i][j]\
    \ = -1;\n        }\n    }\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n\
    \    {\n        for (int j = 0; j < N; j++)\n        {\n            if (i > 0\
    \ && dp[i - 1][j] + grid[i][j] < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                prev[i][j] = 0;\n            }\n\
    \            if (j > 0 && dp[i][j - 1] + grid[i][j] < dp[i][j])\n            {\n\
    \                dp[i][j] = dp[i][j - 1] + grid[i][j];\n                prev[i][j]\
    \ = 1;\n            }\n            if (i < N - 1 && dp[i + 1][j] + grid[i][j]\
    \ < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j] + grid[i][j];\n\
    \                prev[i][j] = 2;\n            }\n            if (j < N - 1 &&\
    \ dp[i][j + 1] + grid[i][j] < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i][j + 1] + grid[i][j];\n                prev[i][j] = 3;\n            }\n\
    \        }\n    }\n    long[] ans = new long[k];\n    int x = N - 1;\n    int\
    \ y = N - 1;\n    for (int i = 0; i < k; i++)", "{\n    long n = grid.length;\n\
    \    long[][] dp = new long[n][n];\n    foreach (i; 0 .. n)\n        foreach (j;\
    \ 0 .. n)\n            dp[i][j] = long.max;\n    dp[0][0] = grid[0][0];\n    foreach\
    \ (i; 0 .. n)\n        foreach (j; 0 .. n)\n        {\n            if (i > 0)\n\
    \                dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n      \
    \      if (j > 0)\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n\
    \        }\n    long[] res = new long[k];\n    long i = n - 1;\n    long j = n\
    \ - 1;\n    foreach (l; k .. 0)\n    {\n        res[l] = grid[i][j];\n       \
    \ if (i > 0 && dp[i - 1][j] + grid[i][j] == dp[i][j])\n            i--;\n    \
    \    else\n            j--;\n    }\n    return res;\n}", "{\n    int N = grid.length;\n\
    \    int[][] dp = new int[N][N];\n    for (int i = 0; i < N; i++)\n        for\
    \ (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n\
    \    int[][] prev = new int[N][N];\n    for (int i = 0; i < N; i++)\n        for\
    \ (int j = 0; j < N; j++)\n            prev[i][j] = -1;\n    for (int i = 0; i\
    \ < N; i++)\n        for (int j = 0; j < N; j++)\n        {\n            if (i\
    \ > 0 && dp[i - 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i - 1][j] + 1;\n                prev[i][j] = 0;\n            }\n      \
    \      if (j > 0 && dp[i][j - 1] + 1 < dp[i][j])\n            {\n            \
    \    dp[i][j] = dp[i][j - 1] + 1;\n                prev[i][j] = 1;\n         \
    \   }\n            if (i < N - 1 && dp[i + 1][j] + 1 < dp[i][j])\n           \
    \ {\n                dp[i][j] = dp[i + 1][j] + 1;\n                prev[i][j]\
    \ = 2;\n            }\n            if (j < N - 1 && dp[i][j + 1] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i][j + 1] + 1;\n               \
    \ prev[i][j] = 3;\n            }\n        }\n    int x = N - 1;\n    int y = N\
    \ - 1;\n    long[] res = new long[k];\n    for (int i = 0; i < k; i++)\n    {\n\
    \        res[i] = grid[x][y];\n        int p = prev[x", "{\n    long n = grid.length;\n\
    \    long[][] dp = new long[n][n];\n    long[][] path = new long[n][n];\n    long[][]\
    \ path_len = new long[n][n];\n    long[][] path_val = new long[n][n];\n    for\
    \ (long i = 0; i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n    \
    \    {\n            dp[i][j] = grid[i][j];\n            path[i][j] = grid[i][j];\n\
    \            path_len[i][j] = 1;\n            path_val[i][j] = grid[i][j];\n \
    \       }\n    }\n    for (long i = 0; i < n; i++)\n    {\n        for (long j\
    \ = 0; j < n; j++)\n        {\n            if (i > 0)\n            {\n       \
    \         if (dp[i][j] > dp[i - 1][j] + grid[i][j])\n                {\n     \
    \               dp[i][j] = dp[i - 1][j] + grid[i][j];\n                    path[i][j]\
    \ = path[i - 1][j];\n                    path_len[i][j] = path_len[i - 1][j];\n\
    \                    path_val[i][j] = path_val[i - 1][j];\n                }\n\
    \                else if (dp[i][j] == dp[i - 1][j] + grid[i][j])\n           \
    \     {\n                    if (path[i][j] > path[i - 1][j] + grid[i][j])\n \
    \                   {\n                        path[i][j] = path[i - 1][j] + grid[i][j];\n\
    \                        path_len[i][j] = path_len[i - 1][j];\n              \
    \          path_val[i][j] = path_val[i - 1][j];\n                    }\n     \
    \               else if (path[i][j] == path[i - 1][j] + grid[i][j])\n        \
    \            {\n                        if (path_len[i", "{\n    // TODO: Implement\
    \ this function\n    return null;\n}", "{\n    // TODO: Implement your solution\
    \ here\n    return null;\n}", "{\n    long N = grid.length;\n    long[][] dp =\
    \ new long[N][N];\n    long[][] prev = new long[N][N];\n    long[][] next = new\
    \ long[N][N];\n    long[][] path = new long[N][N];\n    long[][] path_prev = new\
    \ long[N][N];\n    long[][] path_next = new long[N][N];\n    for (long i = 0;\
    \ i < N; i++)\n    {\n        for (long j = 0; j < N; j++)\n        {\n      \
    \      dp[i][j] = grid[i][j];\n            prev[i][j] = i;\n            next[i][j]\
    \ = j;\n            path[i][j] = grid[i][j];\n            path_prev[i][j] = i;\n\
    \            path_next[i][j] = j;\n        }\n    }\n    for (long i = 0; i <\
    \ k - 1; i++)\n    {\n        for (long j = 0; j < N; j++)\n        {\n      \
    \      for (long l = 0; l < N; l++)\n            {\n                long min =\
    \ dp[j][l];\n                long min_prev = prev[j][l];\n                long\
    \ min_next = next[j][l];\n                if (j > 0 && dp[j - 1][l] < min)\n \
    \               {\n                    min = dp[j - 1][l];\n                 \
    \   min_prev = prev[j - 1][l];\n                    min_next = next[j - 1][l];\n\
    \                }\n                if (j < N - 1 && dp[j + 1][l] < min)\n   \
    \             {\n                    min = dp[j + 1][l];\n                   \
    \ min_prev = prev[j + 1][l];\n                    min_next = next[j + 1][l];\n\
    \                }\n                if (l > 0 && dp[j][l - 1] < min)\n       \
    \         {\n                    min = dp[j][l - 1];\n                    min_prev\
    \ = prev[j][l - 1];\n                    min_next", "{\n    int N = grid.length;\n\
    \    int[][] dp = new int[N][N];\n    for (int i = 0; i < N; i++)\n        for\
    \ (int j = 0; j < N; j++)\n            dp[i][j] = int.max;\n    dp[0][0] = 0;\n\
    \    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n      \
    \  {\n            if (i > 0)\n                dp[i][j] = min(dp[i][j], dp[i -\
    \ 1][j] + grid[i][j]);\n            if (j > 0)\n                dp[i][j] = min(dp[i][j],\
    \ dp[i][j - 1] + grid[i][j]);\n        }\n    int[] path = new int[k];\n    int\
    \ cur = dp[N - 1][N - 1];\n    for (int i = k - 1; i >= 0; i--)\n    {\n     \
    \   path[i] = grid[N - 1][N - 1];\n        if (i > 0)\n        {\n           \
    \ if (N > 1 && dp[N - 2][N - 1] + grid[N - 1][N - 1] == cur)\n            {\n\
    \                cur -= grid[N - 1][N - 1];\n                N--;\n          \
    \  }\n            else\n            {\n                cur -= grid[N - 1][N -\
    \ 2];\n                N--;\n                path[i] = grid[N - 1][N - 1];\n \
    \           }\n        }\n    }\n    return path;\n}", "{\n    long N = grid.length;\n\
    \    long[][] dp = new long[N][N];\n    for (long i = 0; i < N; i++)\n       \
    \ for (long j = 0; j < N; j++)\n            dp[i][j] = grid[i][j];\n    for (long\
    \ i = 0; i < N; i++)\n        for (long j = 0; j < N; j++)\n            for (long\
    \ x = 0; x < N; x++)\n                for (long y = 0; y < N; y++)\n         \
    \           if (abs(i - x) + abs(j - y) == 1)\n                        dp[i][j]\
    \ = min(dp[i][j], dp[x][y] + grid[i][j]);\n    long[] ans = new long[N];\n   \
    \ for (long i = 0; i < N; i++)\n        ans[i] = dp[i][0];\n    for (long i =\
    \ 0; i < N; i++)\n        for (long j = 0; j < N; j++)\n            ans[i] = min(ans[i],\
    \ dp[i][j]);\n    long[] ret = new long[k];\n    for (long i = 0; i < k; i++)\n\
    \        ret[i] = ans[i];\n    return ret;\n}", "{\n    auto N = grid.length;\n\
    \    auto M = grid[0].length;\n    auto dp = new long[][](N, M);\n    auto parent\
    \ = new long[][](N, M);\n    for (long i = 0; i < N; i++)\n    {\n        for\
    \ (long j = 0; j < M; j++)\n        {\n            dp[i][j] = long.max;\n    \
    \        parent[i][j] = -1;\n        }\n    }\n    dp[0][0] = grid[0][0];\n  \
    \  for (long i = 0; i < N; i++)\n    {\n        for (long j = 0; j < M; j++)\n\
    \        {\n            if (i > 0)\n            {\n                if (dp[i -\
    \ 1][j] + grid[i][j] < dp[i][j])\n                {\n                    dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                    parent[i][j] = 0;\n      \
    \          }\n            }\n            if (j > 0)\n            {\n         \
    \       if (dp[i][j - 1] + grid[i][j] < dp[i][j])\n                {\n       \
    \             dp[i][j] = dp[i][j - 1] + grid[i][j];\n                    parent[i][j]\
    \ = 1;\n                }\n            }\n        }\n    }\n    auto path = new\
    \ long[][](k);\n    auto cur = tuple(N - 1, M - 1);\n    for (long i = k - 1;\
    \ i >= 0; i--)\n    {\n        path[i] = grid[cur[0]][cur[1]];\n        if (parent[cur[0]][cur[1]]\
    \ == 0)\n        {\n            cur = tuple(cur[0] - 1, cur[1]);\n        }\n\
    \        else\n        {\n            cur = tuple(cur[0], cur[1] - 1);\n     \
    \   }\n    }\n    return path;\n}", "{\n    int N = grid.length;\n    int[][]\
    \ dp = new int[N][N];\n    int[][] prev = new int[N][N];\n    for (int i = 0;\
    \ i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n       \
    \     dp[i][j] = int.max;\n            prev[i][j] = -1;\n        }\n    }\n  \
    \  dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n    {\n        for (int j =\
    \ 0; j < N; j++)\n        {\n            if (i > 0 && dp[i - 1][j] + 1 < dp[i][j])\n\
    \            {\n                dp[i][j] = dp[i - 1][j] + 1;\n               \
    \ prev[i][j] = 0;\n            }\n            if (j > 0 && dp[i][j - 1] + 1 <\
    \ dp[i][j])\n            {\n                dp[i][j] = dp[i][j - 1] + 1;\n   \
    \             prev[i][j] = 1;\n            }\n            if (i < N - 1 && dp[i\
    \ + 1][j] + 1 < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j]\
    \ + 1;\n                prev[i][j] = 2;\n            }\n            if (j < N\
    \ - 1 && dp[i][j + 1] + 1 < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i][j + 1] + 1;\n                prev[i][j] = 3;\n            }\n      \
    \  }\n    }\n    long[] res = new long[k];\n    int cur = 0;\n    int x = 0;\n\
    \    int y = 0;\n    for (int i = 0; i < k; i++)\n    {\n        res[i] = grid[x][y];\n\
    \        switch (prev[x][y])\n        {\n            case 0", "{\n    // Write\
    \ your code here\n    long n = grid.length;\n    long[][] dp = new long[n][n];\n\
    \    long[][] path = new long[n][n];\n    long[][] path_idx = new long[n][n];\n\
    \    long[][] path_len = new long[n][n];\n    for (long i = 0; i < n; i++)\n \
    \   {\n        for (long j = 0; j < n; j++)\n        {\n            dp[i][j] =\
    \ grid[i][j];\n            path[i][j] = grid[i][j];\n            path_idx[i][j]\
    \ = 1;\n            path_len[i][j] = 1;\n        }\n    }\n    for (long i = 1;\
    \ i < k; i++)\n    {\n        long[][] dp_new = new long[n][n];\n        long[][]\
    \ path_new = new long[n][n];\n        long[][] path_idx_new = new long[n][n];\n\
    \        long[][] path_len_new = new long[n][n];\n        for (long j = 0; j <\
    \ n; j++)\n        {\n            for (long l = 0; l < n; l++)\n            {\n\
    \                long min = dp[j][l];\n                long min_path = path[j][l];\n\
    \                long min_path_idx = path_idx[j][l];\n                long min_path_len\
    \ = path_len[j][l];\n                if (j > 0)\n                {\n         \
    \           if (dp[j - 1][l] < min)\n                    {\n                 \
    \       min = dp[j - 1][l];\n                        min_path = path[j - 1][l];\n\
    \                        min_path_idx = path_idx[j - 1][l];\n                \
    \        min_path_len = path_len[j - 1][l];\n                    }\n         \
    \           else if (dp[j - 1][l] == min)\n                    {\n           \
    \             long[] tmp = new long[(int)min_path_len + 1];\n                \
    \        for", "{\n    int n = grid.length;\n    int m = grid[0].length;\n   \
    \ long[][] dp = new long[n][m];\n    for (int i = 0; i < n; i++)\n        for\
    \ (int j = 0; j < m; j++)\n            dp[i][j] = grid[i][j];\n    for (int i\
    \ = 1; i < n; i++)\n        dp[i][0] += dp[i - 1][0];\n    for (int j = 1; j <\
    \ m; j++)\n        dp[0][j] += dp[0][j - 1];\n    for (int i = 1; i < n; i++)\n\
    \        for (int j = 1; j < m; j++)\n            dp[i][j] += min(dp[i - 1][j],\
    \ dp[i][j - 1]);\n    long[] res = new long[(int)k];\n    int i = 0;\n    int\
    \ j = 0;\n    for (int l = 0; l < k; l++)\n    {\n        res[l] = grid[i][j];\n\
    \        if (i == n - 1)\n            j++;\n        else if (j == m - 1)\n   \
    \         i++;\n        else if (dp[i + 1][j] < dp[i][j + 1])\n            i++;\n\
    \        else\n            j++;\n    }\n    return res;\n}", "{\n    auto N =\
    \ grid.length;\n    auto M = grid[0].length;\n    auto dp = new long[N][M][k +\
    \ 1];\n    auto path = new long[N][M][k + 1];\n    foreach (i; 0 .. N)\n    {\n\
    \        foreach (j; 0 .. M)\n        {\n            foreach (l; 0 .. k + 1)\n\
    \            {\n                dp[i][j][l] = long.max;\n                path[i][j][l]\
    \ = long.max;\n            }\n        }\n    }\n    dp[0][0][1] = grid[0][0];\n\
    \    path[0][0][1] = grid[0][0];\n    foreach (i; 0 .. N)\n    {\n        foreach\
    \ (j; 0 .. M)\n        {\n            foreach (l; 1 .. k + 1)\n            {\n\
    \                if (i > 0)\n                {\n                    if (dp[i][j][l]\
    \ > dp[i - 1][j][l - 1] + grid[i][j])\n                    {\n               \
    \         dp[i][j][l] = dp[i - 1][j][l - 1] + grid[i][j];\n                  \
    \      path[i][j][l] = path[i - 1][j][l - 1];\n                    }\n       \
    \             else if (dp[i][j][l] == dp[i - 1][j][l - 1] + grid[i][j])\n    \
    \                {\n                        path[i][j][l] = min(path[i][j][l],\
    \ path[i - 1][j][l - 1]);\n                    }\n                }\n        \
    \        if (j > 0)\n                {\n                    if (dp[i][j][l] >\
    \ dp[i][j - 1][l - 1] + grid[i][j])\n                    {\n                 \
    \       dp[i][j][l] = dp[i][j - 1][l - 1] + grid[i][j];\n                    \
    \    path[i][j][l] = path[i][j - 1][l - 1];\n                    }\n         \
    \           else if (dp[i", "{\n    int n = grid.length;\n    long[][] dp = new\
    \ long[n][n];\n    long[][] prev = new long[n][n];\n    for (int i = 0; i < n;\
    \ i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            dp[i][j]\
    \ = grid[i][j];\n            prev[i][j] = -1;\n        }\n    }\n    for (int\
    \ i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n\
    \            if (i > 0 && dp[i][j] > dp[i - 1][j])\n            {\n          \
    \      dp[i][j] = dp[i - 1][j];\n                prev[i][j] = 0;\n           \
    \ }\n            if (j > 0 && dp[i][j] > dp[i][j - 1])\n            {\n      \
    \          dp[i][j] = dp[i][j - 1];\n                prev[i][j] = 1;\n       \
    \     }\n            if (i < n - 1 && dp[i][j] > dp[i + 1][j])\n            {\n\
    \                dp[i][j] = dp[i + 1][j];\n                prev[i][j] = 2;\n \
    \           }\n            if (j < n - 1 && dp[i][j] > dp[i][j + 1])\n       \
    \     {\n                dp[i][j] = dp[i][j + 1];\n                prev[i][j]\
    \ = 3;\n            }\n        }\n    }\n    long[] res = new long[(int)k];\n\
    \    int i = 0;\n    int j = 0;\n    for (int l = 0; l < k; l++)\n    {\n    \
    \    res[l] = grid[i][j];\n        switch ((int)prev[i][j])\n        {\n     \
    \       case 0:\n                i--;\n                break;\n            case\
    \ 1:\n                j--;\n                break;\n            case 2:\n    \
    \            i", "{\n    int n = grid.length;\n    long[][] dp = new long[n][n];\n\
    \    long[][] path = new long[n][n];\n    for (int i = 0; i < n; i++)\n    {\n\
    \        for (int j = 0; j < n; j++)\n        {\n            dp[i][j] = grid[i][j];\n\
    \            path[i][j] = grid[i][j];\n        }\n    }\n    for (int i = 1; i\
    \ < k; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n         \
    \   for (int l = 0; l < n; l++)\n            {\n                long min = dp[j][l];\n\
    \                long minPath = path[j][l];\n                if (j > 0 && dp[j\
    \ - 1][l] < min)\n                {\n                    min = dp[j - 1][l];\n\
    \                    minPath = path[j - 1][l];\n                }\n          \
    \      if (j < n - 1 && dp[j + 1][l] < min)\n                {\n             \
    \       min = dp[j + 1][l];\n                    minPath = path[j + 1][l];\n \
    \               }\n                if (l > 0 && dp[j][l - 1] < min)\n        \
    \        {\n                    min = dp[j][l - 1];\n                    minPath\
    \ = path[j][l - 1];\n                }\n                if (l < n - 1 && dp[j][l\
    \ + 1] < min)\n                {\n                    min = dp[j][l + 1];\n  \
    \                  minPath = path[j][l + 1];\n                }\n            \
    \    dp[j][l] = min + grid[j][l];\n                path[j][l] = minPath * 10 +\
    \ grid[j][l];\n            }\n        }\n    }\n    long min = dp[0][0];\n   \
    \ long minPath = path[0][0];\n    for (int i = 0; i < n; i++)\n    {\n       \
    \ for (int j = 0; j < n; j++)\n        {", "{\n    long n = grid.length;\n   \
    \ long[][] dp = new long[n][n];\n    long[][] prev = new long[n][n];\n    for\
    \ (long i = 0; i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n    \
    \    {\n            dp[i][j] = long.max;\n            prev[i][j] = -1;\n     \
    \   }\n    }\n    dp[0][0] = grid[0][0];\n    for (long i = 0; i < n; i++)\n \
    \   {\n        for (long j = 0; j < n; j++)\n        {\n            if (i > 0\
    \ && dp[i - 1][j] + grid[i][j] < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                prev[i][j] = 0;\n            }\n\
    \            if (j > 0 && dp[i][j - 1] + grid[i][j] < dp[i][j])\n            {\n\
    \                dp[i][j] = dp[i][j - 1] + grid[i][j];\n                prev[i][j]\
    \ = 1;\n            }\n            if (i < n - 1 && dp[i + 1][j] + grid[i][j]\
    \ < dp[i][j])\n            {\n                dp[i][j] = dp[i + 1][j] + grid[i][j];\n\
    \                prev[i][j] = 2;\n            }\n            if (j < n - 1 &&\
    \ dp[i][j + 1] + grid[i][j] < dp[i][j])\n            {\n                dp[i][j]\
    \ = dp[i][j + 1] + grid[i][j];\n                prev[i][j] = 3;\n            }\n\
    \        }\n    }\n    long[] ans = new long[(int)k];\n    long i = n - 1;\n \
    \   long j = n - 1;\n    for (long l = k", "{\n    long n = grid.length;\n   \
    \ long[][] dp = new long[n][n];\n    long[][] prev = new long[n][n];\n    long[][]\
    \ next = new long[n][n];\n    long[][] dir = new long[][]{{1L, 0L}, {0L, 1L},\
    \ {-1L, 0L}, {0L, -1L}};\n    for (long i = 0; i < n; i++)\n    {\n        for\
    \ (long j = 0; j < n; j++)\n        {\n            dp[i][j] = grid[i][j];\n  \
    \          prev[i][j] = -1L;\n            next[i][j] = -1L;\n        }\n    }\n\
    \    for (long i = 0; i < k - 1; i++)\n    {\n        for (long j = 0; j < n;\
    \ j++)\n        {\n            for (long l = 0; l < n; l++)\n            {\n \
    \               for (long m = 0; m < 4; m++)\n                {\n            \
    \        long x = j + dir[m][0];\n                    long y = l + dir[m][1];\n\
    \                    if (x >= 0 && x < n && y >= 0 && y < n)\n               \
    \     {\n                        if (dp[x][y] > dp[j][l] + grid[x][y])\n     \
    \                   {\n                            dp[x][y] = dp[j][l] + grid[x][y];\n\
    \                            prev[x][y] = j * n + l;\n                       \
    \ }\n                    }\n                }\n            }\n        }\n    }\n\
    \    long min = dp[0][0];\n    long min_i = 0L;\n    long min_j = 0L;\n    for\
    \ (long i = 0; i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n    \
    \    {\n            if (dp[i][j] < min)\n            {\n                min =\
    \ dp[i][j];\n                min_i = i;\n                min_j = j;\n        \
    \    }\n        }", "{\n    long N = grid.length;\n    long[][] dp = new long[N][N];\n\
    \    long[][] path = new long[N][N];\n    for (long i = 0; i < N; i++)\n    {\n\
    \        for (long j = 0; j < N; j++)\n        {\n            dp[i][j] = grid[i][j];\n\
    \            path[i][j] = grid[i][j];\n        }\n    }\n    for (long i = 1;\
    \ i < k; i++)\n    {\n        long[][] tmp = new long[N][N];\n        for (long\
    \ j = 0; j < N; j++)\n        {\n            for (long l = 0; l < N; l++)\n  \
    \          {\n                tmp[j][l] = dp[j][l];\n            }\n        }\n\
    \        for (long j = 0; j < N; j++)\n        {\n            for (long l = 0;\
    \ l < N; l++)\n            {\n                if (j > 0)\n                {\n\
    \                    if (tmp[j - 1][l] < dp[j][l])\n                    {\n  \
    \                      dp[j][l] = tmp[j - 1][l];\n                        path[j][l]\
    \ = grid[j][l];\n                    }\n                    else if (tmp[j - 1][l]\
    \ == dp[j][l])\n                    {\n                        if (grid[j][l]\
    \ < path[j][l])\n                        {\n                            path[j][l]\
    \ = grid[j][l];\n                        }\n                    }\n          \
    \      }\n                if (j < N - 1)\n                {\n                \
    \    if (tmp[j + 1][l] < dp[j][l])\n                    {\n                  \
    \      dp[j][l] = tmp[j + 1][l];\n                        path[j][l] = grid[j][l];\n\
    \                    }\n                    else if (tmp[j + 1][l] == dp[j][l])\n\
    \                    {\n                        if (grid[j][l] < path[j][l])\n\
    \                        {\n                            path[j][l] = grid[j][l"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
