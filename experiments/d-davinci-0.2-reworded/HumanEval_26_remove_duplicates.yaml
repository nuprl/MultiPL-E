name: HumanEval_26_remove_duplicates
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n From an array of integers, remove\
  \ all elements that occur more than once.\n    Keep order of elements left the same\
  \ as in the input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n    [1L, 3L,\
  \ 4L]\n    \n*/\nlong[] remove_duplicates(long[] numbers) \n"
tests: "unittest\n{\n    alias candidate = remove_duplicates;\n\n    assert(candidate([])\
  \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([1L,\
  \ 2L, 3L, 2L, 4L, 3L, 5L]) == [1L, 4L, 5L]);\n}\nvoid main(){}"
completions: ["{\n    long[] result;\n    foreach(i; numbers)\n    {\n        if(i\
    \ in result)\n            continue;\n        result ~= i;\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    foreach(n; numbers)\n    {\n        if(!result.canFind(n))\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    auto result = new long[];\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    auto result = new long[];\n    foreach(n; numbers)\n    {\n      \
    \  if(numbers.count(n) == 1)\n        {\n            result ~= n;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    int i;\n    int j;\n\
    \    int k;\n    int count;\n    int length;\n    length = numbers.length;\n \
    \   result = new long[length];\n    i = 0;\n    j = 0;\n    while (i < length)\
    \ {\n        count = 0;\n        k = 0;\n        while (k < length) {\n      \
    \      if (numbers[i] == numbers[k]) {\n                count = count + 1;\n \
    \           }\n            k = k + 1;\n        }\n        if (count == 1) {\n\
    \            result[j] = numbers[i];\n            j = j + 1;\n        }\n    \
    \    i = i + 1;\n    }\n    return result[0..j];\n}\n/*\n Given a list of integers,\
    \ return the sum of the integers that are in the list.\n    >>> sum_of_integers([1L,\
    \ 2L, 3L])\n    6L\n    >>> sum_of_integers([])\n    0L\n*/\nlong sum_of_integers(long[]\
    \ numbers) \n{\n    long result;\n    int i;\n    int length;\n    result = 0L;\n\
    \    length = numbers.length;\n    i = 0;\n    while (i < length) {\n        result\
    \ = result + numbers[i];\n        i = i + 1;\n    }\n    return result;\n}\n/*\n\
    \ Given a list of integers, return the sum of the integers that are in the list.\n\
    \    >>> sum_of_integers([1L, 2L, 3L])\n    6L\n    >>> sum_of_integers([])\n\
    \    0L\n*/\nlong sum_of_integers_2(long[] numbers) \n{\n    long result;\n  \
    \  int i;\n    int length;\n    result = 0L;\n    length = numbers.length;\n \
    \   i = 0;\n    while (i < length) {\n        result = result + numbers[i];\n\
    \        i = i + 1;\n    }\n    return result;\n}\n/*\n Given a list of integers,\
    \ return the sum of the integers that are in the list.\n    >>> sum_of_", "{\n\
    \    long[] result = new long[];\n    foreach(n; numbers) \n    {\n        if(!result.canFind(n))\n\
    \            result ~= n;\n    }\n    return result;\n}\n/*\n    Given a list\
    \ of integers, return a list of the integers, omitting any that are less than\
    \ 0.\n    >>> no_neg([1, -2])\n    [1]\n    >>> no_neg([-3, -3, 3, 3])\n    [3,\
    \ 3]\n    >>> no_neg([-1, -1, -1])\n    []\n*/\nlong[] no_neg(long[] numbers)\
    \ \n{\n    long[] result = new long[];\n    foreach(n; numbers) \n    {\n    \
    \    if(n >= 0)\n            result ~= n;\n    }\n    return result;\n}\n/*\n\
    \    Given a list of integers, return a list of the integers, omitting any that\
    \ are less than 0.\n    >>> no_9([1, 2, 19])\n    [1, 2]\n    >>> no_9([9, 19,\
    \ 29, 3])\n    [3]\n    >>> no_9([1, 2, 3])\n    [1, 2, 3]\n*/\nlong[] no_9(long[]\
    \ numbers) \n{\n    long[] result = new long[];\n    foreach(n; numbers) \n  \
    \  {\n        if(n % 10 != 9)\n            result ~= n;\n    }\n    return result;\n\
    }\n/*\n    Given a list of non-negative integers, return a list of those numbers\
    \ except omitting any that end with 9.\n    >>> no_teen([12, 13, 19, 20])\n  \
    \  [12, 20]\n    >>> no_teen([1, 14, 1])\n    [1, 1]\n    >>> no_teen([15])\n\
    \    []\n*/\nlong[] no_teen(long[] numbers) \n{\n    long[] result = new long[];\n\
    \    foreach(n; numbers) \n    {\n        if(n < 13 || n > 19)\n            result\
    \ ~= n;\n    }\n    return result;\n}\n/*\n   ", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(n in result)\n            continue;\n        result\
    \ ~= n;\n    }\n    return result;\n}", "{\n    auto result = new long[];\n  \
    \  foreach(n; numbers)\n    {\n        if(count(numbers, n) == 1)\n        {\n\
    \            result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    foreach(n; numbers)\n    {\n        if(numbers.count(n) == 1)\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    auto result = new long[];\n    auto seen = new bool[];\n    foreach (n;\
    \ numbers) {\n        if (seen[n]) continue;\n        seen[n] = true;\n      \
    \  result ~= n;\n    }\n    return result;\n}\n/*\n    Given a list of integers,\
    \ return the largest product that can be made by multiplying any three integers.\n\
    \    For example, if the list is [-10, -10, 5, 2], we should return 500, since\
    \ that's -10 * -10 * 5.\n    You can assume the list has at least three integers.\n\
    \    >>> largest_product([-10L, -10L, 5L, 2L])\n    500L\n*/\nlong largest_product(long[]\
    \ numbers) \n{\n    auto sorted = numbers.sort();\n    auto result = sorted[0]\
    \ * sorted[1] * sorted[$ - 1];\n    result = max(result, sorted[$ - 1] * sorted[$\
    \ - 2] * sorted[$ - 3]);\n    return result;\n}\n/*\n    Given a list of integers,\
    \ return the largest product that can be made by multiplying any three integers.\n\
    \    For example, if the list is [-10, -10, 5, 2], we should return 500, since\
    \ that's -10 * -10 * 5.\n    You can assume the list has at least three integers.\n\
    \    >>> largest_product([-10L, -10L, 5L, 2L])\n    500L\n*/\nlong largest_product(long[]\
    \ numbers) \n{\n    auto sorted = numbers.sort();\n    auto result = sorted[0]\
    \ * sorted[1] * sorted[$ - 1];\n    result = max(result, sorted[$ - 1] * sorted[$\
    \ - 2] * sorted[$ - 3]);\n    return result;\n}\n/*\n    Given a list of integers,\
    \ return the largest product that can be made by multiplying any three integers.\n\
    \    For example, if the list is [-10, -10, 5, 2], we should return 500, since\
    \ that's -10 * -10 * 5.\n    You can assume the list has at least three integers.\n\
    \    >>> largest_product([-10L, -10L, 5L, 2L", "{\n    long[] result;\n    long[]\
    \ unique;\n    foreach(num; numbers)\n    {\n        if(!unique.canFind(num))\n\
    \        {\n            unique ~= num;\n        }\n    }\n    foreach(num; unique)\n\
    \    {\n        if(!result.canFind(num))\n        {\n            result ~= num;\n\
    \        }\n    }\n    return result;\n}", "{\n    auto result = new long[];\n\
    \    auto seen = new bool[];\n    foreach (n; numbers) \n    {\n        if (seen[n])\
    \ \n        {\n            continue;\n        }\n        seen[n] = true;\n   \
    \     result ~= n;\n    }\n    return result;\n}", "{\n    auto result = new long[];\n\
    \    foreach(n; numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n\
    \            result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n         \
    \   continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n    auto\
    \ result = new long[];\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}\n/*\n\
    \    Given a list of integers, return a list of the integers, omitting any that\
    \ are less than 0.\n    >>> no_neg([1, -2])\n    [1]\n    >>> no_neg([-3, -3,\
    \ 3, 3])\n    []\n    >>> no_neg([-1, -1, -1])\n    []\n*/\nlong[] no_neg(long[]\
    \ numbers) \n{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(n\
    \ < 0)\n            continue;\n        result ~= n;\n    }\n    return result;\n\
    }\n/*\n    Given a list of integers, return a list of the integers, omitting any\
    \ that are less than 0.\n    >>> no_9([1, 2, 19])\n    [1, 2]\n    >>> no_9([9,\
    \ 19, 29, 3])\n    [3]\n    >>> no_9([1, 2, 3])\n    [1, 2, 3]\n*/\nlong[] no_9(long[]\
    \ numbers) \n{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(n\
    \ % 10 == 9)\n            continue;\n        result ~= n;\n    }\n    return result;\n\
    }\n/*\n    Given a list of non-negative integers, return a list of those numbers\
    \ except omitting any that end with 9.\n    >>> no_teen([12, 13, 19, 20])\n  \
    \  [12, 20]\n    >>> no_teen([1, 14, 1])\n    [1, 1]\n    >>> no_teen([15])\n\
    \    []\n*/\nlong[] no_teen(long[] numbers) \n{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(n > 12 && n < 20)\n            continue;\n     \
    \   result ~= n;\n    }\n    return result;\n}\n/*\n    Given a list of integers,\
    \ return a list of those numbers", "{\n    long[] result = new long[];\n    foreach(n;\
    \ numbers)\n    {\n        if(count(numbers, n) == 1)\n        {\n           \
    \ result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[] result\
    \ = [];\n    foreach(n; numbers)\n    {\n        if(!result.canFind(n))\n    \
    \    {\n            result ~= n;\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[];\n    foreach(n; numbers)\n    {\n        if(count(numbers,\
    \ n) == 1)\n        {\n            result ~= n;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result = [];\n    foreach(num; numbers)\n    {\n\
    \        if(count(numbers, num) == 1)\n        {\n            result ~= num;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(n in result)\n            continue;\n        else\n\
    \            result ~= n;\n    }\n    return result;\n}", "{\n    long[] result;\n\
    \    foreach(n; numbers)\n    {\n        if(n in result)\n            continue;\n\
    \        else\n            result ~= n;\n    }\n    return result;\n}", "{\n \
    \   long[] result;\n    foreach(n; numbers)\n    {\n        if(count(numbers,\
    \ n) == 1)\n        {\n            result ~= n;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[];\n    foreach(n; numbers)\n\
    \    {\n        if(numbers.count(n) == 1)\n        {\n            result ~= n;\n\
    \        }\n    }\n    return result;\n}\n/*\n    Given a list of integers, return\
    \ a list of integers where each integer is multiplied by 2.\n    >>> double_list([1L,\
    \ 2L, 3L])\n    [2L, 4L, 6L]\n*/\nlong[] double_list(long[] numbers) \n{\n   \
    \ long[] result = new long[];\n    foreach(n; numbers)\n    {\n        result\
    \ ~= n * 2;\n    }\n    return result;\n}\n/*\n    Given a list of integers, return\
    \ a list of integers where each integer is multiplied by 2.\n    >>> double_list([1L,\
    \ 2L, 3L])\n    [2L, 4L, 6L]\n*/\nlong[] double_list_map(long[] numbers) \n{\n\
    \    return numbers.map!(n => n * 2);\n}\n/*\n    Given a list of integers, return\
    \ a list of integers where each integer is multiplied by 2.\n    >>> double_list([1L,\
    \ 2L, 3L])\n    [2L, 4L, 6L]\n*/\nlong[] double_list_map_lambda(long[] numbers)\
    \ \n{\n    return numbers.map!((n) => n * 2);\n}\n/*\n    Given a list of integers,\
    \ return a list of integers where each integer is multiplied by 2.\n    >>> double_list([1L,\
    \ 2L, 3L])\n    [2L, 4L, 6L]\n*/\nlong[] double_list_map_lambda_2(long[] numbers)\
    \ \n{\n    return numbers.map!((n) => n * 2);\n}\n/*\n    Given a list of integers,\
    \ return a list of integers where each integer is multiplied by 2.\n    >>> double_list([1L,\
    \ 2L, 3L])\n    [2L, 4L, 6L]\n*/\nlong[] double_list_map_lambda_3(long[] numbers)\
    \ \n{\n    return numbers.map!", "{\n    long[] result;\n    long[] seen;\n  \
    \  foreach(n; numbers)\n    {\n        if(seen.canFind(n))\n        {\n      \
    \      result ~= n;\n        }\n        else\n        {\n            seen ~= n;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(n in result)\n            continue;\n        result\
    \ ~= n;\n    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(!result.canFind(n))\n        {\n            result\
    \ ~= n;\n        }\n    }\n    return result;\n}", "{\n    auto result = new long[];\n\
    \    foreach(n; numbers)\n    {\n        if(!result.canFind(n))\n        {\n \
    \           result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[];\n    foreach(n; numbers)\n    {\n        if(count(numbers,\
    \ n) == 1)\n        {\n            result ~= n;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n      \
    \  if(count(numbers, n) == 1)\n        {\n            result ~= n;\n        }\n\
    \    }\n    return result;\n}", "{\n    auto result = new long[];\n    foreach(n;\
    \ numbers)\n    {\n        if(!result.canFind(n))\n        {\n            result\
    \ ~= n;\n        }\n    }\n    return result;\n}", "{\n\tlong[] result;\n\tforeach(n;\
    \ numbers)\n\t{\n\t\tif(numbers.count(n) == 1)\n\t\t{\n\t\t\tresult ~= n;\n\t\t\
    }\n\t}\n\treturn result;\n}", "{\n    long[] result = [];\n    foreach(n; numbers)\n\
    \    {\n        if(!result.canFind(n))\n        {\n            result ~= n;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(n in result)\n            continue;\n        result\
    \ ~= n;\n    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(n in result)\n            continue;\n        result\
    \ ~= n;\n    }\n    return result;\n}", "{\n\tlong[] result = [];\n\tforeach(n;\
    \ numbers)\n\t{\n\t\tif(n in result)\n\t\t{\n\t\t\tresult -= n;\n\t\t}\n\t\telse\n\
    \t\t{\n\t\t\tresult ~= n;\n\t\t}\n\t}\n\treturn result;\n}", "{\n    long[] result\
    \ = new long[];\n    foreach(n; numbers)\n    {\n        if(numbers.count(n) ==\
    \ 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[];\n    foreach(n; numbers)\n    {\n    \
    \    if(!result.canFind(n))\n        {\n            result ~= n;\n        }\n\
    \    }\n    return result;\n}", "{\n    auto result = new long[];\n    foreach(n;\
    \ numbers)\n    {\n        if(count(numbers, n) == 1)\n        {\n           \
    \ result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n\
    \    foreach(n; numbers)\n    {\n        if(n in result)\n            continue;\n\
    \        else\n            result ~= n;\n    }\n    return result;\n}", "{\n \
    \   long[] result;\n    foreach(n; numbers) \n    {\n        if(result.count(n)\
    \ == 0) \n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(!result.canFind(n))\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    auto result = new long[];\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    auto result = new long[];\n    foreach(n; numbers)\n    {\n      \
    \  if(numbers.count(n) == 1)\n        {\n            result ~= n;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result = [];\n    foreach(n; numbers)\n\
    \    {\n        if(numbers.count(n) == 1)\n        {\n            result ~= n;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n\
    \    foreach(n; numbers) \n    {\n        if(numbers.count(n) == 1) \n       \
    \ {\n            result ~= n;\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        else\n            result ~= n;\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n      \
    \  if(n in result)\n            continue;\n        else\n            result ~=\
    \ n;\n    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n\
    \    {\n        if(numbers.count(n) == 1)\n        {\n            result ~= n;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n\
    \    foreach(n; numbers)\n    {\n        if(n in result)\n            continue;\n\
    \        else\n            result ~= n;\n    }\n    return result;\n}", "{\n \
    \   long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    long[] result = [];\n    foreach(n; numbers)\n    {\n        if(!result.canFind(n))\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    auto result = new long[];\n    foreach(n; numbers)\n    {\n        if(!result.canFind(n))\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        else\n            result ~= n;\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    foreach(i; numbers)\n    {\n      \
    \  if(!result.canFind(i))\n        {\n            result ~= i;\n        }\n  \
    \  }\n    return result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n\
    \    {\n        if(n in result)\n            continue;\n        result ~= n;\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n\
    \    {\n        if(n in result)\n            continue;\n        result ~= n;\n\
    \    }\n    return result;\n}", "{\n    long[] result = [];\n    foreach(n; numbers)\n\
    \    {\n        if(count(numbers, n) == 1)\n        {\n            result ~= n;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n\
    \    foreach(n; numbers)\n    {\n        if(n in result)\n            continue;\n\
    \        result ~= n;\n    }\n    return result;\n}", "{\n    long[] result;\n\
    \    foreach(n; numbers)\n    {\n        if(n in result)\n            continue;\n\
    \        result ~= n;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ [];\n    foreach(n; numbers)\n    {\n        if(!result.canFind(n))\n      \
    \  {\n            result ~= n;\n        }\n    }\n    return result;\n}", "{\n\
    \    auto result = new long[];\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    long[] unique;\n    unique = numbers.dup;\n    unique.sort;\n\
    \    unique.uniq;\n    foreach(n; numbers)\n    {\n        if(unique.canFind(n))\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(count(numbers,\
    \ n) == 1)\n        {\n            result ~= n;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[];\n    foreach(n; numbers)\n\
    \    {\n        if(numbers.count(n) == 1)\n        {\n            result ~= n;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n\
    \    foreach(n; numbers)\n    {\n        if(n in result)\n            continue;\n\
    \        result ~= n;\n    }\n    return result;\n}", "{\n    auto result = new\
    \ long[];\n    foreach(n; numbers)\n    {\n        if(!result.canFind(n))\n  \
    \      {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    auto result = new long[];\n    foreach(n; numbers)\n    {\n        if(count(numbers,\
    \ n) == 1)\n        {\n            result ~= n;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n      \
    \  if(n in result)\n            continue;\n        result ~= n;\n    }\n    return\
    \ result;\n}\n/*\n    Given a list of integers, find the pair of adjacent elements\
    \ that has the largest product and return that product.\n    >>> adjacent_product([3,\
    \ 6, -2, -5, 7, 3])\n    21\n*/\nlong adjacent_product(long[] numbers) \n{\n \
    \   long result = 0;\n    foreach(i; 0 .. numbers.length - 1)\n    {\n       \
    \ if(numbers[i] * numbers[i + 1] > result)\n            result = numbers[i] *\
    \ numbers[i + 1];\n    }\n    return result;\n}\n/*\n    Given a list of integers,\
    \ find the pair of adjacent elements that has the largest product and return that\
    \ product.\n    >>> adjacent_product([3, 6, -2, -5, 7, 3])\n    21\n*/\nlong adjacent_product(long[]\
    \ numbers) \n{\n    long result = 0;\n    foreach(i; 0 .. numbers.length - 1)\n\
    \    {\n        if(numbers[i] * numbers[i + 1] > result)\n            result =\
    \ numbers[i] * numbers[i + 1];\n    }\n    return result;\n}\n/*\n    Given a\
    \ list of integers, find the pair of adjacent elements that has the largest product\
    \ and return that product.\n    >>> adjacent_product([3, 6, -2, -5, 7, 3])\n \
    \   21\n*/\nlong adjacent_product(long[] numbers) \n{\n    long result = 0;\n\
    \    foreach(i; 0 .. numbers.length - 1)\n    {\n        if(numbers[i] * numbers[i\
    \ + 1] > result)\n            result = numbers[i] * numbers[i + 1];\n    }\n \
    \   return result;\n}\n/*\n    Given a list of integers, find the pair of adjacent\
    \ elements that has the largest product and return that product.\n    >>> adjacent_product([3,\
    \ 6, -2, -5, 7, 3])\n    21\n*/\nlong adjacent_product(long[] numbers", "{\n \
    \   auto result = new long[];\n    foreach(n; numbers)\n    {\n        if(count(numbers,\
    \ n) == 1)\n        {\n            result ~= n;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result = [];\n    foreach(i; numbers)\n    {\n \
    \       if(count(numbers, i) == 1)\n        {\n            result ~= i;\n    \
    \    }\n    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n            result\
    \ ~= n;\n        }\n    }\n    return result;\n}", "{\n    auto result = new long[];\n\
    \    foreach(n; numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n\
    \            result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n         \
    \   continue;\n        else\n            result ~= n;\n    }\n    return result;\n\
    }", "{\n    long[] result = [];\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    auto result = new long[];\n    foreach(n; numbers)\n    {\n      \
    \  if(count(numbers, n) == 1)\n        {\n            result ~= n;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result = [];\n    foreach(n; numbers)\n\
    \    {\n        if(n in result)\n            continue;\n        result ~= n;\n\
    \    }\n    return result;\n}", "{\n    auto result = new long[];\n    auto seen\
    \ = new bool[];\n    foreach (n; numbers) \n    {\n        if (seen[n]) \n   \
    \     {\n            continue;\n        }\n        seen[n] = true;\n        result\
    \ ~= n;\n    }\n    return result;\n}", "{\n    //long[] numbers = [1L, 2L, 3L,\
    \ 2L, 4L];\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    long[] result = numbers.dup;\n    foreach(i; 0 .. numbers.length)\n    {\n\
    \        foreach(j; i+1 .. numbers.length)\n        {\n            if(numbers[i]\
    \ == numbers[j])\n            {\n                result.remove(j);\n         \
    \   }\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(n in result)\n            continue;\n        result\
    \ ~= n;\n    }\n    return result;\n}", "{\n    auto result = new long[];\n  \
    \  foreach(number; numbers)\n    {\n        if(count(numbers, number) == 1)\n\
    \        {\n            result ~= number;\n        }\n    }\n    return result;\n\
    }", "{\n    auto result = new long[];\n    foreach(n; numbers)\n    {\n      \
    \  if(count(numbers, n) == 1)\n        {\n            result ~= n;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n\
    \    {\n        if(n in result)\n            continue;\n        result ~= n;\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n\
    \    {\n        if(n in result)\n            continue;\n        result ~= n;\n\
    \    }\n    return result;\n}", "{\n    auto result = new long[];\n    auto seen\
    \ = new bool[];\n    foreach (n; numbers) \n    {\n        if (!seen[n]) \n  \
    \      {\n            seen[n] = true;\n            result ~= n;\n        }\n \
    \   }\n    return result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n\
    \    {\n        if(n in result)\n            continue;\n        result ~= n;\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n\
    \    {\n        if(n in result)\n            continue;\n        else\n       \
    \     result ~= n;\n    }\n    return result;\n}", "{\n    auto result = new long[];\n\
    \    foreach(n; numbers)\n    {\n        if(n in result)\n            continue;\n\
    \        result ~= n;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[];\n    foreach(n; numbers)\n    {\n        if(numbers.count(n) ==\
    \ 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        else\n            result ~= n;\n    }\n    return\
    \ result;\n}", "{\n    auto result = new long[];\n    foreach(n; numbers)\n  \
    \  {\n        if(n in result)\n            continue;\n        result ~= n;\n \
    \   }\n    return result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n\
    \    {\n        if(numbers.count(n) == 1)\n        {\n            result ~= n;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result = [];\n    foreach(n;\
    \ numbers)\n    {\n        if(!result.canFind(n))\n        {\n            result\
    \ ~= n;\n        }\n    }\n    return result;\n}\n/*\n Given a list of integers,\
    \ return a list of integers where each integer is multiplied by 2.\n    >>> double_list([1L,\
    \ 2L, 3L])\n    [2L, 4L, 6L]\n*/\nlong[] double_list(long[] numbers) \n{\n   \
    \ long[] result = [];\n    foreach(n; numbers)\n    {\n        result ~= n * 2;\n\
    \    }\n    return result;\n}\n/*\n Given a list of integers, return a list of\
    \ integers where each integer is multiplied by 2.\n    >>> double_list([1L, 2L,\
    \ 3L])\n    [2L, 4L, 6L]\n*/\nlong[] double_list(long[] numbers) \n{\n    long[]\
    \ result = [];\n    foreach(n; numbers)\n    {\n        result ~= n * 2;\n   \
    \ }\n    return result;\n}\n/*\n Given a list of integers, return a list of integers\
    \ where each integer is multiplied by 2.\n    >>> double_list([1L, 2L, 3L])\n\
    \    [2L, 4L, 6L]\n*/\nlong[] double_list(long[] numbers) \n{\n    long[] result\
    \ = [];\n    foreach(n; numbers)\n    {\n        result ~= n * 2;\n    }\n   \
    \ return result;\n}\n/*\n Given a list of integers, return a list of integers\
    \ where each integer is multiplied by 2.\n    >>> double_list([1L, 2L, 3L])\n\
    \    [2L, 4L, 6L]\n*/\nlong[] double_list(long[] numbers) \n{\n    long[] result\
    \ = [];\n    foreach(n; numbers)\n    {\n        result ~= n * 2;\n    }\n   \
    \ return result;\n}\n/*\n Given a list of integers, return a list of integers\
    \ where each integer is multiplied by 2.\n    >>> double_list([1L, 2L, 3L])\n\
    \   ", "{\n    long[] result = [];\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(!result.canFind(n))\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    auto result = new long[];\n    auto seen = new long[];\n    foreach(n; numbers)\n\
    \    {\n        if(n in seen)\n            continue;\n        seen ~= n;\n   \
    \     result ~= n;\n    }\n    return result;\n}", "{\n    auto seen = new long[0];\n\
    \    auto result = new long[0];\n    foreach(n; numbers)\n    {\n        if (n\
    \ in seen)\n            continue;\n        seen ~= n;\n        result ~= n;\n\
    \    }\n    return result;\n}", "{\n    long[] result = [];\n    foreach(n; numbers)\n\
    \    {\n        if(n in result)\n            continue;\n        result ~= n;\n\
    \    }\n    return result;\n}", "{\n    auto result = new long[];\n    foreach(n;\
    \ numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n            result\
    \ ~= n;\n        }\n    }\n    return result;\n}", "{\n    auto result = new long[];\n\
    \    auto seen = new bool[];\n    foreach (n; numbers) {\n        if (seen[n])\
    \ {\n            continue;\n        }\n        seen[n] = true;\n        result\
    \ ~= n;\n    }\n    return result;\n}", "{\n    auto result = new long[];\n  \
    \  foreach(n; numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n\
    \            result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n         \
    \   continue;\n        result ~= n;\n    }\n    return result;\n}\n/*\n    Given\
    \ a list of integers, return the sum of the integers.\n    >>> sum_list([1, 2,\
    \ 3, 4])\n    10\n*/\nlong sum_list(long[] numbers)\n{\n    long sum = 0;\n  \
    \  foreach(n; numbers)\n    {\n        sum += n;\n    }\n    return sum;\n}\n\
    /*\n    Given a list of integers, return the sum of the integers.\n    >>> sum_list([1,\
    \ 2, 3, 4])\n    10\n*/\nlong sum_list_2(long[] numbers)\n{\n    return reduce!((a,\
    \ b) => a + b)(numbers);\n}\n/*\n    Given a list of integers, return the sum\
    \ of the integers.\n    >>> sum_list([1, 2, 3, 4])\n    10\n*/\nlong sum_list_3(long[]\
    \ numbers)\n{\n    return reduce!((a, b) => a + b)(numbers);\n}\n/*\n    Given\
    \ a list of integers, return the sum of the integers.\n    >>> sum_list([1, 2,\
    \ 3, 4])\n    10\n*/\nlong sum_list_4(long[] numbers)\n{\n    return reduce!((a,\
    \ b) => a + b)(numbers);\n}\n/*\n    Given a list of integers, return the sum\
    \ of the integers.\n    >>> sum_list([1, 2, 3, 4])\n    10\n*/\nlong sum_list_5(long[]\
    \ numbers)\n{\n    return reduce!((a, b) => a + b)(numbers);\n}\n/*\n    Given\
    \ a list of integers, return the sum of the integers.\n    >>> sum_list([1, 2,\
    \ 3, 4])\n    10\n*/\nlong sum_list_6(long[] numbers)\n{\n    return reduce!((a,\
    \ b) => a + b)(numbers);\n}\n/*\n    Given a list of integers, return the sum\
    \ of the integers.\n    >>> sum_list([", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n            result\
    \ ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n  \
    \  foreach(n; numbers)\n    {\n        if(n in result)\n            continue;\n\
    \        result ~= n;\n    }\n    return result;\n}", "{\n    long[] result;\n\
    \    foreach(n; numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n\
    \            result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result = [];\n    foreach(n; numbers)\n    {\n        if(count(numbers, n) ==\
    \ 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[];\n    foreach(n; numbers)\n    {\n        if(n\
    \ in result)\n            continue;\n        result ~= n;\n    }\n    return result;\n\
    }\n/*\n    Given a list of integers, return a list of the integers, omitting any\
    \ that are less than 0.\n    >>> no_negatives([1, -2])\n    [1]\n    >>> no_negatives([-3,\
    \ -3, 3, 3])\n    [3, 3]\n    >>> no_negatives([-1, -1, -1])\n    []\n*/\nlong[]\
    \ no_negatives(long[] numbers) \n{\n    long[] result = new long[];\n    foreach(n;\
    \ numbers)\n    {\n        if(n < 0)\n            continue;\n        result ~=\
    \ n;\n    }\n    return result;\n}\n/*\n    Given a list of integers, return a\
    \ list of those integers, omitting any that are less than 0.\n    >>> no_negatives([1,\
    \ -2])\n    [1]\n    >>> no_negatives([-3, -3, 3, 3])\n    [3, 3]\n    >>> no_negatives([-1,\
    \ -1, -1])\n    []\n*/\nlong[] no_negatives(long[] numbers) \n{\n    long[] result\
    \ = new long[];\n    foreach(n; numbers)\n    {\n        if(n < 0)\n         \
    \   continue;\n        result ~= n;\n    }\n    return result;\n}\n/*\n    Given\
    \ a list of integers, return a list of those integers, omitting any that are less\
    \ than 0.\n    >>> no_negatives([1, -2])\n    [1]\n    >>> no_negatives([-3, -3,\
    \ 3, 3])\n    [3, 3]\n    >>> no_negatives([-1, -1, -1])\n    []\n*/\nlong[] no_negatives(long[]\
    \ numbers) \n{\n    long[] result = new long[];\n    foreach(n; numbers)\n   \
    \ {\n        if(n < 0)\n            continue;\n        result ~=", "{\n    long[]\
    \ result;\n    foreach(n; numbers)\n    {\n        if(numbers.count(n) == 1)\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    long[] result = [];\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    auto result = new long[];\n    auto seen = new bool[];\n    foreach (number;\
    \ numbers) \n    {\n        if (seen[number]) \n        {\n            continue;\n\
    \        }\n        seen[number] = true;\n        result ~= number;\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[];\n    foreach(n; numbers)\n\
    \    {\n        if(count(numbers, n) == 1)\n        {\n            result ~= n;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n            result\
    \ ~= n;\n        }\n    }\n    return result;\n}", "{\n    //long[] result = new\
    \ long[];\n    //long[] result = new long[numbers.length];\n    //long[] result\
    \ = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long[] result = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long[] result = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long[] result = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long[] result = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long[] result = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long[] result = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long[] result = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long[] result = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long[] result = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long[] result = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long[] result = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long[] result = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long[] result = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long[] result = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long[] result = new long[numbers.length];\n    //long[] result = new long[numbers.length];\n\
    \    //long", "{\n    auto result = new long[];\n    foreach(number; numbers)\n\
    \    {\n        if(!result.canFind(number))\n        {\n            result ~=\
    \ number;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n\
    \    foreach(n; numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n\
    \            result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n         \
    \   continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n    auto\
    \ result = new long[];\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    auto result = new long[];\n    foreach(n; numbers)\n    {\n        if(!result.canFind(n))\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}\n\
    /*\n    Given a list of integers, return a list of the integers, omitting any\
    \ that are less than 0.\n    >>> no_negatives([1, -2])\n    [1]\n    >>> no_negatives([0,\
    \ 1, 2])\n    [0, 1, 2]\n    >>> no_negatives([-3, -3, 3, 3])\n    [3, 3]\n*/\n\
    long[] no_negatives(long[] numbers) \n{\n    auto result = new long[];\n    foreach(n;\
    \ numbers)\n    {\n        if(n >= 0)\n        {\n            result ~= n;\n \
    \       }\n    }\n    return result;\n}\n/*\n    Given a list of integers, return\
    \ a list of those integers, omitting any that are less than 0.\n    >>> no_negatives([1,\
    \ -2])\n    [1]\n    >>> no_negatives([0, 1, 2])\n    [0, 1, 2]\n    >>> no_negatives([-3,\
    \ -3, 3, 3])\n    [3, 3]\n*/\nlong[] no_negatives(long[] numbers) \n{\n    auto\
    \ result = new long[];\n    foreach(n; numbers)\n    {\n        if(n >= 0)\n \
    \       {\n            result ~= n;\n        }\n    }\n    return result;\n}\n\
    /*\n    Given a list of integers, return a list of those integers, omitting any\
    \ that are less than 0.\n    >>> no_negatives([1, -2])\n    [1]\n    >>> no_negatives([0,\
    \ 1, 2])\n    [0, 1, 2]\n    >>> no_negatives([-3, -3, 3, 3])\n    [3, 3]\n*/\n\
    long[] no_negatives(long[] numbers) \n{\n    auto result = new long[];\n    foreach(n;\
    \ numbers)\n    {\n       ", "{\n    long[] result = [];\n    foreach(n; numbers)\n\
    \    {\n        if(count(numbers, n) == 1)\n        {\n            result ~= n;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n            result\
    \ ~= n;\n        }\n    }\n    return result;\n}", "{\n    auto result = new long[];\n\
    \    foreach(number; numbers)\n    {\n        if(count(numbers, number) == 1)\n\
    \        {\n            result ~= number;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result = [];\n    foreach(n; numbers)\n    {\n        if(count(numbers,\
    \ n) == 1)\n        {\n            result ~= n;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n      \
    \  if(n in result)\n            continue;\n        else\n            result ~=\
    \ n;\n    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n\
    \    {\n        if(!result.canFind(n))\n        {\n            result ~= n;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n\
    \    foreach(n; numbers)\n    {\n        if(!result.canFind(n))\n        {\n \
    \           result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    foreach(n; numbers)\n    {\n        if(result.count(n) == 0)\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[];\n    foreach(n; numbers)\n    {\n    \
    \    if(numbers.count(n) == 1)\n        {\n            result ~= n;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n\
    \    {\n        if(n in result)\n            continue;\n        result ~= n;\n\
    \    }\n    return result;\n}", "{\n    auto result = new long[];\n    foreach(n;\
    \ numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n            result\
    \ ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[];\n    foreach(n; numbers)\n    {\n        if(numbers.count(n) == 1)\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    foreach(n; numbers)\n    {\n        if(!result.canFind(n))\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    long[] result = new long[];\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    auto result = new long[];\n    foreach(n; numbers)\n    {\n      \
    \  if(!result.canFind(n))\n        {\n            result ~= n;\n        }\n  \
    \  }\n    return result;\n}", "{\n    long[] result;\n    foreach(num; numbers)\n\
    \    {\n        if(!result.canFind(num))\n        {\n            result ~= num;\n\
    \        }\n    }\n    return result;\n}\n/*\n    Given a list of integers, return\
    \ a list of the integers, omitting any that are less than 0.\n    >>> no_neg([1,\
    \ -2])\n    [1]\n    >>> no_neg([-3, -3, 3, 3])\n    [3, 3]\n    >>> no_neg([-1,\
    \ -1, -1])\n    []\n*/\nlong[] no_neg(long[] numbers) \n{\n    long[] result;\n\
    \    foreach(num; numbers)\n    {\n        if(num >= 0)\n        {\n         \
    \   result ~= num;\n        }\n    }\n    return result;\n}\n/*\n    Given a list\
    \ of non-negative integers, return a list of those numbers multiplied by 2, omitting\
    \ any of the resulting numbers that end in 2.\n    >>> no_twos([1, 2, 3])\n  \
    \  [4, 6]\n    >>> no_twos([2, 6, 11])\n    [4]\n    >>> no_twos([0])\n    [0]\n\
    */\nlong[] no_twos(long[] numbers) \n{\n    long[] result;\n    foreach(num; numbers)\n\
    \    {\n        if(num * 2 % 10 != 2)\n        {\n            result ~= num *\
    \ 2;\n        }\n    }\n    return result;\n}\n/*\n    Given a list of integers,\
    \ return a list of those numbers, omitting any that are between 13 and 19 inclusive.\n\
    \    >>> no_teen([12, 13, 19, 20])\n    [12, 20]\n    >>> no_teen([1, 14, 1])\n\
    \    [1, 1]\n    >>> no_teen([15])\n    []\n*/\nlong[] no_teen(long[] numbers)\
    \ \n{\n    long[] result;\n    foreach(num; numbers)\n    {\n        if(num <\
    \ 13 || num > 19)\n        {\n            result ~= num;\n        }\n    }", "{\n\
    \    long[] result;\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result = [];\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    long[] unique;\n    unique = numbers[0..$];\n\
    \    unique.sort();\n    unique.unique();\n    foreach(n; numbers)\n    {\n  \
    \      if(unique.canFind(n))\n        {\n            result ~= n;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result = [];\n    foreach(n; numbers)\n\
    \    {\n        if(result.count(n) == 0)\n        {\n            result ~= n;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(!result.canFind(n))\n        {\n            result\
    \ ~= n;\n        }\n    }\n    return result;\n}", "{\n    auto result = new long[];\n\
    \    foreach(n; numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n\
    \            result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n         \
    \   continue;\n        result ~= n;\n    }\n    return result;\n}\n/*\n    Given\
    \ a list of integers, return a list of integers where each integer is the sum\
    \ of the integers in the list.\n    >>> sum_of_numbers([1L, 2L, 3L])\n    [1L,\
    \ 3L, 6L]\n*/\nlong[] sum_of_numbers(long[] numbers) \n{\n    long[] result;\n\
    \    long sum = 0;\n    foreach(n; numbers)\n    {\n        sum += n;\n      \
    \  result ~= sum;\n    }\n    return result;\n}\n/*\n    Given a list of integers,\
    \ return a list of integers where each integer is the sum of the integers in the\
    \ list.\n    >>> sum_of_numbers([1L, 2L, 3L])\n    [1L, 3L, 6L]\n*/\nlong[] sum_of_numbers(long[]\
    \ numbers) \n{\n    long[] result;\n    long sum = 0;\n    foreach(n; numbers)\n\
    \    {\n        sum += n;\n        result ~= sum;\n    }\n    return result;\n\
    }\n/*\n    Given a list of integers, return a list of integers where each integer\
    \ is the sum of the integers in the list.\n    >>> sum_of_numbers([1L, 2L, 3L])\n\
    \    [1L, 3L, 6L]\n*/\nlong[] sum_of_numbers(long[] numbers) \n{\n    long[] result;\n\
    \    long sum = 0;\n    foreach(n; numbers)\n    {\n        sum += n;\n      \
    \  result ~= sum;\n    }\n    return result;\n}\n/*\n    Given a list of integers,\
    \ return a list of integers where each integer is the sum of the integers in the\
    \ list.\n    >>> sum_of_numbers([1L, 2L, 3L])\n    [1L, 3L, 6L]\n*/\nlong[] sum_of_numbers(long[]\
    \ numbers) \n{\n    long[] result;\n", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(n in result)\n            continue;\n        result\
    \ ~= n;\n    }\n    return result;\n}", "{\n    auto result = new long[];\n  \
    \  auto seen = new bool[];\n    foreach (n; numbers) \n    {\n        if (seen[n])\
    \ \n        {\n            continue;\n        }\n        seen[n] = true;\n   \
    \     result ~= n;\n    }\n    return result;\n}", "{\n    long[] result;\n  \
    \  foreach(n; numbers)\n    {\n        if(n in result)\n            continue;\n\
    \        result ~= n;\n    }\n    return result;\n}", "{\n    auto result = new\
    \ long[];\n    foreach(n; numbers)\n    {\n        if(count(numbers, n) == 1)\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    auto result = new long[];\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[];\n    foreach(n; numbers)\n    {\n    \
    \    if(numbers.count(n) == 1)\n        {\n            result ~= n;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n\
    \    {\n        if(result.count(n) == 0)\n        {\n            result ~= n;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result;\n    long[]\
    \ unique;\n    foreach(n; numbers)\n    {\n        if(n in unique)\n        {\n\
    \            continue;\n        }\n        else\n        {\n            unique\
    \ ~= n;\n            result ~= n;\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    foreach(n; numbers)\n    {\n        if(result.count(n)\
    \ == 0)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[];\n    foreach(n; numbers)\n    {\n    \
    \    if(!result.canFind(n))\n        {\n            result ~= n;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[];\n    foreach(n;\
    \ numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n            result\
    \ ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[];\n    foreach(n; numbers)\n    {\n        if(n in result)\n         \
    \   continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[];\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result = [];\n    foreach(number; numbers) \n    {\n      \
    \  if(!result.canFind(number)) \n        {\n            result ~= number;\n  \
    \      }\n    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(count(numbers, n) == 1)\n        {\n           \
    \ result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n\
    \    foreach(n; numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n\
    \            result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result = [];\n    foreach(n; numbers)\n    {\n        if(n in result)\n    \
    \        continue;\n        else\n            result ~= n;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[];\n    foreach(n; numbers)\n\
    \    {\n        if(!result.canFind(n))\n        {\n            result ~= n;\n\
    \        }\n    }\n    return result;\n}", "{\n    auto set = new Set!long();\n\
    \    foreach(n; numbers)\n    {\n        set.insert(n);\n    }\n    return set.keys;\n\
    }", "{\n    long[] result = new long[];\n    foreach(n; numbers) \n    {\n   \
    \     if(n in result) continue;\n        result ~= n;\n    }\n    return result;\n\
    }", "{\n    auto result = new long[];\n    foreach(n; numbers)\n    {\n      \
    \  if(numbers.count(n) == 1)\n        {\n            result ~= n;\n        }\n\
    \    }\n    return result;\n}\n/*\n    Given a list of integers, return the sum\
    \ of the integers that are multiples of 3 or 5.\n    >>> sum_multiples_3_5(1,\
    \ 10)\n    23\n*/\nlong sum_multiples_3_5(long start, long end)\n{\n    long sum\
    \ = 0;\n    foreach(i; start..end)\n    {\n        if(i % 3 == 0 || i % 5 == 0)\n\
    \        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n/*\n\
    \    Given a list of integers, return the sum of the integers that are multiples\
    \ of 3 or 5.\n    >>> sum_multiples_3_5(1, 10)\n    23\n*/\nlong sum_multiples_3_5_2(long\
    \ start, long end)\n{\n    long sum = 0;\n    foreach(i; start..end)\n    {\n\
    \        if(i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n    \
    \    }\n    }\n    return sum;\n}\n/*\n    Given a list of integers, return the\
    \ sum of the integers that are multiples of 3 or 5.\n    >>> sum_multiples_3_5(1,\
    \ 10)\n    23\n*/\nlong sum_multiples_3_5_3(long start, long end)\n{\n    long\
    \ sum = 0;\n    foreach(i; start..end)\n    {\n        if(i % 3 == 0 || i % 5\
    \ == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n\
    }\n/*\n    Given a list of integers, return the sum of the integers that are multiples\
    \ of 3 or 5.\n    >>> sum_multiples_3_5(1, 10)\n    23\n*/\nlong sum_multiples_3_5_4(long\
    \ start, long end)\n{\n    long sum = 0;\n   ", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n            result\
    \ ~= n;\n        }\n    }\n    return result;\n}", "{\n    auto result = new long[];\n\
    \    foreach(n; numbers)\n    {\n        if(count(numbers, n) == 1)\n        {\n\
    \            result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result = [];\n    foreach(n; numbers)\n    {\n        if(numbers.count(n) ==\
    \ 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    auto result = new long[];\n    foreach(n; numbers)\n    {\n      \
    \  if(numbers.count(n) == 1)\n        {\n            result ~= n;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n\
    \    {\n        if(numbers.count(n) == 1)\n        {\n            result ~= n;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result = [];\n    foreach(n;\
    \ numbers)\n    {\n        if(!result.canFind(n))\n        {\n            result\
    \ ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n  \
    \  foreach(n; numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n\
    \            result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n         \
    \   continue;\n        else\n            result ~= n;\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[];\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result = [];\n    foreach(n; numbers)\n    {\n        if(!result.canFind(n))\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(!result.canFind(n))\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    long[] result;\n    foreach(i; numbers)\n    {\n        if(result.count(i)\
    \ == 0)\n        {\n            result ~= i;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(n in result)\n\
    \            continue;\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[];\n    foreach(n; numbers)\n    {\n    \
    \    if(numbers.count(n) == 1)\n        {\n            result ~= n;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n; numbers)\n\
    \    {\n        if(numbers.count(n) == 1)\n        {\n            result ~= n;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result;\n    foreach(n;\
    \ numbers)\n    {\n        if(numbers.count(n) == 1)\n        {\n            result\
    \ ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[0];\n    foreach(num; numbers)\n    {\n        if(result.count(num) ==\
    \ 0)\n        {\n            result ~= num;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(n; numbers)\n    {\n        if(numbers.count(n)\
    \ == 1)\n        {\n            result ~= n;\n        }\n    }\n    return result;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
