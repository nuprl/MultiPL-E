name: HumanEval_58_common
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common elements\
  \ for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
  \ 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L,\
  \ 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n"
tests: "unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
  \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
  \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
  \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L,\
  \ 8L], []) == []);\n}\nvoid main(){}"
completions: ["{\n    auto s1 = l1.sort().unique;\n    auto s2 = l2.sort().unique;\n\
    \    return s1.intersection(s2);\n}", "{\n    long[] result = [];\n    foreach(l;\
    \ l1)\n    {\n        foreach(r; l2)\n        {\n            if(l == r)\n    \
    \        {\n                result ~= l;\n            }\n        }\n    }\n  \
    \  return result.sort.uniq;\n}", "{\n    long[] result = new long[];\n    foreach(l;\
    \ l1)\n    {\n        if(l2.canFind(l))\n        {\n            result ~= l;\n\
    \        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result =\
    \ [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n     \
    \       result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n\
    \    long[] result = new long[0L];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n      \
    \  if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] result;\n    long[] l1_sorted\
    \ = sort(l1);\n    long[] l2_sorted = sort(l2);\n    long[] l1_unique = uniq(l1_sorted);\n\
    \    long[] l2_unique = uniq(l2_sorted);\n    foreach(l1_u; l1_unique) {\n   \
    \     foreach(l2_u; l2_unique) {\n            if(l1_u == l2_u) {\n           \
    \     result ~= l1_u;\n            }\n        }\n    }\n    return result;\n}",
  "{\n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n}", "{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        if(l in l2)\n        {\n         \
    \   result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n \
    \   long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n      \
    \  if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().unique;\n}", "{\n    long[] result;\n    result = l1.filter!(x\
    \ => l2.canFind(x)).sort().uniq;\n    return result;\n}", "{\n    long[] result\
    \ = new long[0L];\n    foreach (l; l1) {\n        if (l2.canFind(l)) {\n     \
    \       result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n\
    \    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result;\n    if (l1.length < l2.length) \n    {\n        result\
    \ = l1.dup;\n        foreach (e; l2) \n        {\n            if (e in result)\
    \ \n            {\n                result ~= e;\n            }\n        }\n  \
    \  } \n    else \n    {\n        result = l2.dup;\n        foreach (e; l1) \n\
    \        {\n            if (e in result) \n            {\n                result\
    \ ~= e;\n            }\n        }\n    }\n    return result.sort.uniq;\n}", "{\n\
    \    long[] result = new long[l1.length];\n    int i = 0;\n    foreach(l; l1)\n\
    \    {\n        if(l2.canFind(l))\n        {\n            result[i] = l;\n   \
    \         i++;\n        }\n    }\n    return result[0..i];\n}", "{\n    long[]\
    \ res = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n\
    \            res ~= l;\n        }\n    }\n    return res.sort().uniq;\n}", "{\n\
    \    return sort(array(uniq(l1) & uniq(l2)));\n}\n/*\nReturn sorted unique elements\
    \ for two arrays.\n    >>> union([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 7L, 9L, 34L, 121L, 653L]\n  \
    \  >>> union([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] union(long[]\
    \ l1, long[] l2) \n{\n    return sort(array(uniq(l1) | uniq(l2)));\n}\n/*\nReturn\
    \ sorted unique elements for two arrays.\n    >>> union([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 7L, 9L,\
    \ 34L, 121L, 653L]\n    >>> union([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L,\
    \ 8L]\n*/\nlong[] union(long[] l1, long[] l2) \n{\n    return sort(array(uniq(l1)\
    \ | uniq(l2)));\n}\n/*\nReturn sorted unique elements for two arrays.\n    >>>\
    \ union([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n \
    \   [1L, 2L, 3L, 4L, 5L, 7L, 9L, 34L, 121L, 653L]\n    >>> union([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L", "{\n    long[] result = [];\n    foreach(l;\
    \ l1)\n    {\n        if(l2.canFind(l))\n        {\n            result ~= l;\n\
    \        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result =\
    \ [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n     \
    \       result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n\
    \    long[] result;\n    foreach(elem; l1)\n    {\n        if(elem in l2)\n  \
    \      {\n            result ~= elem;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (l; l1) \n    {\n     \
    \   if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] result = new long[];\n   \
    \ foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n            result\
    \ ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[]\
    \ result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n\
    \    long[] l2_sorted = sort(l2);\n    long l1_len = l1_sorted.length;\n    long\
    \ l2_len = l2_sorted.length;\n    long l1_index = 0L;\n    long l2_index = 0L;\n\
    \    while (l1_index < l1_len && l2_index < l2_len)\n    {\n        if (l1_sorted[l1_index]\
    \ == l2_sorted[l2_index])\n        {\n            if (result.length == 0L || result[$\
    \ - 1L] != l1_sorted[l1_index])\n            {\n                result ~= l1_sorted[l1_index];\n\
    \            }\n            l1_index += 1L;\n            l2_index += 1L;\n   \
    \     }\n        else if (l1_sorted[l1_index] < l2_sorted[l2_index])\n       \
    \ {\n            l1_index += 1L;\n        }\n        else\n        {\n       \
    \     l2_index += 1L;\n        }\n    }\n    return result;\n}", "{\n    auto\
    \ result = new long[](0);\n    auto l1_set = new Set!long(l1);\n    foreach(e;\
    \ l2)\n    {\n        if(l1_set.contains(e))\n        {\n            result ~=\
    \ e;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            if(!result.canFind(l))\n            {\n              \
    \  result ~= l;\n            }\n        }\n    }\n    return result.sort();\n}",
  "{\n    long[] result = new long[0L];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (l; l1) {\n        if (l2.canFind(l))\
    \ {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result;\n    result = sort(l1);\n    result = sort(l2);\n \
    \   result = uniq(result);\n    return result;\n}", "{\n    long[] result = new\
    \ long[0L];\n    long[] l1_sorted = std.algorithm.sort(l1);\n    long[] l2_sorted\
    \ = std.algorithm.sort(l2);\n    long[] l1_unique = std.algorithm.uniq(l1_sorted);\n\
    \    long[] l2_unique = std.algorithm.uniq(l2_sorted);\n    long[] l1_unique_sorted\
    \ = std.algorithm.sort(l1_unique);\n    long[] l2_unique_sorted = std.algorithm.sort(l2_unique);\n\
    \    long l1_unique_sorted_len = l1_unique_sorted.length;\n    long l2_unique_sorted_len\
    \ = l2_unique_sorted.length;\n    long l1_unique_sorted_len_minus_1 = l1_unique_sorted_len\
    \ - 1L;\n    long l2_unique_sorted_len_minus_1 = l2_unique_sorted_len - 1L;\n\
    \    long i = 0L;\n    long j = 0L;\n    while (i <= l1_unique_sorted_len_minus_1\
    \ && j <= l2_unique_sorted_len_minus_1)\n    {\n        if (l1_unique_sorted[i]\
    \ == l2_unique_sorted[j])\n        {\n            result = result ~ l1_unique_sorted[i];\n\
    \            i++;\n            j++;\n        }\n        else if (l1_unique_sorted[i]\
    \ < l2_unique_sorted[j])\n        {\n            i++;\n        }\n        else\n\
    \        {\n            j++;\n        }\n    }\n    return result;\n}\n/*\nReturn\
    \ sorted unique elements for two arrays.\n    >>> union([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 7L, 9L,\
    \ 34L, 121", "{\n    long[] result;\n    result = [];\n    foreach(l; l1)\n  \
    \  {\n        if(l2.canFind(l))\n        {\n            result ~= l;\n       \
    \ }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result = [];\n\
    \    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n           \
    \ result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n   \
    \ long[] res = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            res ~= l;\n        }\n    }\n    res = res.sort();\n \
    \   res = res.uniq;\n    return res;\n}", "{\n    long[] result = [];\n    foreach(l;\
    \ l1)\n    {\n        if(l2.canFind(l))\n        {\n            result ~= l;\n\
    \        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result =\
    \ new long[0L];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l)) \n  \
    \      {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n}\n/*\nReturn\
    \ sorted unique common elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L,\
    \ 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>>\
    \ common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n    long[] result = new\
    \ long[];\n    foreach(l; l1)\n    {\n        if(l2.count(l) && !result.count(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort();\n\
    }", "{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n\
    \    long[] l2_sorted = sort(l2);\n    long i = 0L;\n    long j = 0L;\n    while\
    \ (i < l1_sorted.length && j < l2_sorted.length)\n    {\n        if (l1_sorted[i]\
    \ == l2_sorted[j])\n        {\n            result = result ~ l1_sorted[i];\n \
    \           i++;\n            j++;\n        }\n        else if (l1_sorted[i] <\
    \ l2_sorted[j])\n        {\n            i++;\n        }\n        else\n      \
    \  {\n            j++;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ res = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n\
    \            res ~= l;\n        }\n    }\n    return res.sort().uniq;\n}", "{\n\
    \    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n      \
    \  if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] ret = new long[0];\n    long[]\
    \ l1_sorted = sort(l1);\n    long[] l2_sorted = sort(l2);\n    long[] l1_unique\
    \ = unique(l1_sorted);\n    long[] l2_unique = unique(l2_sorted);\n    long[]\
    \ l1_unique_sorted = sort(l1_unique);\n    long[] l2_unique_sorted = sort(l2_unique);\n\
    \    long[] l1_unique_sorted_set = set(l1_unique_sorted);\n    long[] l2_unique_sorted_set\
    \ = set(l2_unique_sorted);\n    long[] l1_unique_sorted_set_sorted = sort(l1_unique_sorted_set);\n\
    \    long[] l2_unique_sorted_set_sorted = sort(l2_unique_sorted_set);\n    long[]\
    \ l1_unique_sorted_set_sorted_unique = unique(l1_unique_sorted_set_sorted);\n\
    \    long[] l2_unique_sorted_set_sorted_unique = unique(l2_unique_sorted_set_sorted);\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted = sort(l1_unique_sorted_set_sorted_unique);\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted = sort(l2_unique_sorted_set_sorted_unique);\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set = set(l1_unique_sorted_set_sorted_unique_sorted);\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted_set = set(l2_unique_sorted_set_sorted_unique_sorted);\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set_sorted = sort(l1_unique_sorted_set_sorted_unique_sorted_set);\n\
    \    long[] l2_unique", "{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n\
    \    long[] l2_sorted = l2.dup.sort;\n    long[] l1_unique = l1_sorted.dup.uniq;\n\
    \    long[] l2_unique = l2_sorted.dup.uniq;\n    foreach(l; l1_unique)\n    {\n\
    \        if(l2_unique.canFind(l))\n        {\n            result ~= l;\n     \
    \   }\n    }\n    return result;\n}", "{\n    long[] result = new long[0L];\n\
    \    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n         \
    \   result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n \
    \   auto result = new long[](0);\n    auto l1_sorted = l1.dup;\n    auto l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    auto l1_index = 0;\n\
    \    auto l2_index = 0;\n    while (l1_index < l1_sorted.length && l2_index <\
    \ l2_sorted.length) \n    {\n        if (l1_sorted[l1_index] < l2_sorted[l2_index])\
    \ \n        {\n            l1_index++;\n        } \n        else if (l1_sorted[l1_index]\
    \ > l2_sorted[l2_index]) \n        {\n            l2_index++;\n        } \n  \
    \      else \n        {\n            result ~= l1_sorted[l1_index];\n        \
    \    l1_index++;\n            l2_index++;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    long[] l1_sorted = sort(l1);\n    long[] l2_sorted\
    \ = sort(l2);\n    long[] l1_unique = unique(l1_sorted);\n    long[] l2_unique\
    \ = unique(l2_sorted);\n    long[] l1_set = toSet(l1_unique);\n    long[] l2_set\
    \ = toSet(l2_unique);\n    result = intersect(l1_set, l2_set);\n    return result;\n\
    }", "{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] l3 = l1.dup;\n    l3.sort;\n    long[] l4 = l2.dup;\n    l4.sort;\n\
    \    long[] l5 = l3.dup;\n    l5.length = 0;\n    foreach(l; l3)\n    {\n    \
    \    if(l4.canFind(l))\n        {\n            l5 ~= l;\n        }\n    }\n  \
    \  return l5;\n}", "{\n    auto s1 = l1.sort();\n    auto s2 = l2.sort();\n  \
    \  auto r = s1.intersect(s2);\n    return r.array;\n}", "{\n    return l1.filter!(x\
    \ => l2.canFind(x)).sort().uniq;\n}", "{\n    long[] result = [];\n    foreach(l;\
    \ l1)\n    {\n        if(l2.canFind(l))\n        {\n            result ~= l;\n\
    \        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result =\
    \ new long[0L];\n    long[] l1_sorted = sort(l1);\n    long[] l2_sorted = sort(l2);\n\
    \    long i = 0L;\n    while (i < l1_sorted.length)\n    {\n        long j = 0L;\n\
    \        while (j < l2_sorted.length)\n        {\n            if (l1_sorted[i]\
    \ == l2_sorted[j])\n            {\n                if (result.length == 0L ||\
    \ result[$ - 1L] != l1_sorted[i])\n                {\n                    result\
    \ = result ~ l1_sorted[i];\n                }\n            }\n            j +=\
    \ 1L;\n        }\n        i += 1L;\n    }\n    return result;\n}", "{\n    long[]\
    \ l3 = l1.dup;\n    l3.sort;\n    long[] l4 = l2.dup;\n    l4.sort;\n    long[]\
    \ l5 = l3.dup;\n    l5.removeDuplicates;\n    long[] l6 = l4.dup;\n    l6.removeDuplicates;\n\
    \    long[] l7 = l5.dup;\n    l7.remove(l6);\n    long[] l8 = l6.dup;\n    l8.remove(l5);\n\
    \    long[] l9 = l7.dup;\n    l9.remove(l8);\n    return l9;\n}", "{\n    long[]\
    \ result;\n    long[] temp;\n    long[] temp2;\n    long[] temp3;\n    temp =\
    \ l1.dup;\n    temp2 = l2.dup;\n    temp.sort;\n    temp2.sort;\n    temp3 = temp.intersect(temp2);\n\
    \    result = temp3.dup;\n    return result;\n}", "{\n    long[] result = [];\n\
    \    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n           \
    \ result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n   \
    \ long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (l; l1) \n    {\n     \
    \   if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] result = new long[];\n   \
    \ foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n            result\
    \ ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[]\
    \ result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (e; l1) \n    {\n     \
    \   if (e in l2) \n        {\n            result ~= e;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\n/*\nReturn sorted unique elements of two arrays.\n\
    \    >>> union([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 2L, 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> union([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] union(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    foreach (e; l1) \n    {\n      \
    \  result ~= e;\n    }\n    foreach (e; l2) \n    {\n        result ~= e;\n  \
    \  }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements of\
    \ two arrays.\n    >>> union([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L,\
    \ 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n    >>>\
    \ union([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] union(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[0L];\n    foreach (e; l1) \n\
    \    {\n        result ~= e;\n    }\n    foreach (e; l2) \n    {\n        result\
    \ ~= e;\n    }\n    return result.sort", "{\n    auto s1 = l1.sort();\n    auto\
    \ s2 = l2.sort();\n    auto r = s1.intersect(s2);\n    return r.array;\n}", "{\n\
    \    long[] result = new long[];\n    foreach(e; l1)\n    {\n        if(e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two arrays.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n    auto\
    \ result = new long[](0);\n    foreach (i; l1)\n    {\n        foreach (j; l2)\n\
    \        {\n            if (i == j)\n            {\n                result ~=\
    \ i;\n            }\n        }\n    }\n    return result.sort().uniq;\n}", "{\n\
    \    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    return sort(array(uniq(l1) & uniq(l2)));\n}", "{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (l; l1) \n    {\n     \
    \   if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] result = new long[];\n   \
    \ foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n            result\
    \ ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[]\
    \ result = new long[0L];\n    long[] l1_sorted = sort(l1);\n    long[] l2_sorted\
    \ = sort(l2);\n    long i = 0L;\n    long j = 0L;\n    while (i < l1_sorted.length\
    \ && j < l2_sorted.length)\n    {\n        if (l1_sorted[i] == l2_sorted[j])\n\
    \        {\n            result = result ~ l1_sorted[i];\n            i++;\n  \
    \          j++;\n        }\n        else if (l1_sorted[i] < l2_sorted[j])\n  \
    \      {\n            i++;\n        }\n        else\n        {\n            j++;\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for\
    \ two arrays.\n    >>> union([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L,\
    \ 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 7L, 9L, 34L, 121L, 653L]\n    >>>\
    \ union([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] union(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[0L];\n    long[] l1_sorted\
    \ = sort(l1);\n    long[] l2_sorted = sort(l2);\n    long i = 0L;\n    long j\
    \ = 0L;\n    while (i < l1_sorted.length && j < l2_sorted.length)\n    {\n   \
    \     if (l1_sorted[i] == l2_sorted[j])\n        {\n            result = result\
    \ ~ l1_sorted[i];\n            i++;\n            j++;\n        }\n        else\
    \ if (l1_sorted[i] < l2_sorted[j])\n        {\n            result = result ~ l1",
  "{\n    auto r = new long[](0);\n    auto a1 = l1.dup;\n    a1.sort;\n    auto a2\
    \ = l2.dup;\n    a2.sort;\n    auto i1 = 0;\n    auto i2 = 0;\n    while (i1 <\
    \ a1.length && i2 < a2.length) \n    {\n        if (a1[i1] == a2[i2]) \n     \
    \   {\n            r ~= a1[i1];\n            i1++;\n            i2++;\n      \
    \  }\n        else if (a1[i1] < a2[i2]) \n        {\n            i1++;\n     \
    \   }\n        else \n        {\n            i2++;\n        }\n    }\n    return\
    \ r;\n}", "{\n    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n\
    \        if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n\
    \    }\n    return result.sort().uniq;\n}", "{\n    long[] result = new long[0L];\n\
    \    foreach (l; l1) {\n        if (l2.canFind(l)) {\n            result ~= l;\n\
    \        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result;\n\
    \    long[] temp;\n    if (l1.length < l2.length) \n    {\n        temp = l1;\n\
    \        l1 = l2;\n        l2 = temp;\n    }\n    result = new long[l1.length];\n\
    \    size_t i = 0;\n    foreach (l; l1) \n    {\n        if (l in l2) \n     \
    \   {\n            result[i] = l;\n            i++;\n        }\n    }\n    return\
    \ result[0 .. i];\n}", "{\n    long[] result = new long[];\n    foreach(e; l1)\n\
    \    {\n        if(e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().uniq;\n}", "{\n    long[] result = [];\n    foreach(l;\
    \ l1)\n    {\n        foreach(r; l2)\n        {\n            if(l == r)\n    \
    \        {\n                result ~= l;\n            }\n        }\n    }\n  \
    \  return result.sort().uniq;\n}", "{\n    long[] result = new long[];\n    foreach(l;\
    \ l1)\n    {\n        if(l2.canFind(l))\n        {\n            result ~= l;\n\
    \        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result =\
    \ new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n\
    \            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}",
  "{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.dup.uniq;\n    long[] l2_unique\
    \ = l2_sorted.dup.uniq;\n    foreach(i; 0 .. l1_unique.length)\n    {\n      \
    \  foreach(j; 0 .. l2_unique.length)\n        {\n            if(l1_unique[i] ==\
    \ l2_unique[j])\n            {\n                result ~= l1_unique[i];\n    \
    \        }\n        }\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[l1.length];\n    int count = 0;\n    foreach(l; l1)\n    {\n      \
    \  if(l2.canFind(l))\n        {\n            result[count] = l;\n            count++;\n\
    \        }\n    }\n    return result[0..count];\n}", "{\n    long[] result;\n\
    \    result = l1.filter!(a => l2.canFind(a)).array;\n    result.sort;\n    result.unique;\n\
    \    return result;\n}", "{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n\
    \    long[] l2_sorted = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n\
    \    long[] l2_unique = l2_sorted.unique;\n    int l1_len = l1_unique.length;\n\
    \    int l2_len = l2_unique.length;\n    int i = 0;\n    int j = 0;\n    while\
    \ (i < l1_len && j < l2_len) \n    {\n        if (l1_unique[i] == l2_unique[j])\
    \ \n        {\n            result ~= l1_unique[i];\n            i++;\n       \
    \     j++;\n        } \n        else if (l1_unique[i] < l2_unique[j]) \n     \
    \   {\n            i++;\n        } \n        else \n        {\n            j++;\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for\
    \ two arrays.\n    >>> union([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L,\
    \ 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 7L, 9L, 34L, 121L, 653L]\n    >>>\
    \ union([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] union(long[]\
    \ l1, long[] l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n\
    \    long[] l2_sorted = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n\
    \    long[] l2_unique = l2_sorted.unique;\n    int l1_len = l1_unique.length;\n\
    \    int l2_len = l2_unique.length;\n    int i =", "{\n    long[] result = new\
    \ long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n \
    \           result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}",
  "{\n    long[] result = new long[];\n    foreach(long i; l1)\n    {\n        foreach(long\
    \ j; l2)\n        {\n            if(i == j)\n            {\n                result\
    \ ~= i;\n            }\n        }\n    }\n    return result.sort().uniq;\n}",
  "{\n    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    foreach(l; l1_unique)\n    {\n        if(l2_unique.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}",
  "{\n    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort();\n    long[]\
    \ l2_sorted = l2.dup.sort();\n    long[] l1_unique = l1_sorted.dup.uniq;\n   \
    \ long[] l2_unique = l2_sorted.dup.uniq;\n    long[] l1_unique_sorted = l1_unique.dup.sort;\n\
    \    long[] l2_unique_sorted = l2_unique.dup.sort;\n    long[] l1_unique_sorted_set\
    \ = l1_unique_sorted.dup.toSet;\n    long[] l2_unique_sorted_set = l2_unique_sorted.dup.toSet;\n\
    \    long[] l1_unique_sorted_set_intersection = l1_unique_sorted_set.dup.intersection(l2_unique_sorted_set);\n\
    \    long[] l1_unique_sorted_set_intersection_array = l1_unique_sorted_set_intersection.dup.toArray;\n\
    \    result = l1_unique_sorted_set_intersection_array.dup.sort;\n    return result;\n\
    }", "{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    foreach(l; l1_unique)\n    {\n        if(l2_unique.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}",
  "{\n    long[] l3 = l1.dup;\n    l3.sort;\n    long[] l4 = l2.dup;\n    l4.sort;\n\
    \    long[] l5 = l3.dup;\n    l5.length = 0;\n    foreach(l; l3)\n    {\n    \
    \    if(l4.canFind(l))\n        {\n            l5 ~= l;\n        }\n    }\n  \
    \  return l5;\n}\n/*\nReturn sorted unique common elements for two arrays.\n \
    \   >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]",
  "{\n    auto l3 = l1.dup;\n    l3 ~= l2;\n    l3.sort;\n    l3 = l3.uniq;\n    return\
    \ l3;\n}", "{\n    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n\
    \        if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n\
    \    }\n    return result.sort().uniq;\n}", "{\n    auto result = new long[](0);\n\
    \    auto l1_sorted = l1.dup;\n    auto l2_sorted = l2.dup;\n    l1_sorted.sort;\n\
    \    l2_sorted.sort;\n    auto l1_it = l1_sorted.front;\n    auto l2_it = l2_sorted.front;\n\
    \    while (l1_it !is null && l2_it !is null)\n    {\n        if (*l1_it == *l2_it)\n\
    \        {\n            result ~= *l1_it;\n            l1_it++;\n            l2_it++;\n\
    \        }\n        else if (*l1_it < *l2_it)\n        {\n            l1_it++;\n\
    \        }\n        else\n        {\n            l2_it++;\n        }\n    }\n\
    \    return result;\n}", "{\n    auto s1 = l1.sort();\n    auto s2 = l2.sort();\n\
    \    long[] result;\n    foreach(e; s1)\n    {\n        if(s2.canFind(e))\n  \
    \      {\n            result ~= e;\n        }\n    }\n    return result;\n}",
  "{\n    auto l = new long[](l1.length + l2.length);\n    l = l1 ~ l2;\n    l.sort();\n\
    \    return l.uniq;\n}", "{\n    long[] result = new long[0L];\n    foreach (l;\
    \ l1) \n    {\n        if (l2.canFind(l)) \n        {\n            result ~= l;\n\
    \        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result =\
    \ new long[0L];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n    \
    \    {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two arrays.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n    auto\
    \ result = new long[](max(l1.length, l2.length));\n    auto result_size = 0;\n\
    \    auto l1_size = l1.length;\n    auto l2_size = l2.length;\n    auto l1_index\
    \ = 0;\n    auto l2_index = 0;\n    while (l1_index < l1_size && l2_index < l2_size)\
    \ \n    {\n        if (l1[l1_index] == l2[l2_index]) \n        {\n           \
    \ if (result_size == 0 || result[result_size - 1] != l1[l1_index]) \n        \
    \    {\n                result[result_size] = l1[l1_index];\n                result_size++;\n\
    \            }\n            l1_index++;\n            l2_index++;\n        }\n\
    \        else if (l1[l1_index] < l2[l2_index]) \n        {\n            l1_index++;\n\
    \        }\n        else \n        {\n            l2_index++;\n        }\n   \
    \ }\n    return result[0 .. result_size];\n}", "{\n    long[] result = new long[];\n\
    \    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n           \
    \ result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n   \
    \ long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (l; l1) \n    {\n     \
    \   if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] result;\n    long[] l1_sorted\
    \ = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n    long[] l1_unique =\
    \ l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n    foreach(l1_elem;\
    \ l1_unique)\n    {\n        foreach(l2_elem; l2_unique)\n        {\n        \
    \    if(l1_elem == l2_elem)\n            {\n                result ~= l1_elem;\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[l1.length];\n    int count = 0;\n    foreach(l; l1)\n    {\n    \
    \    if(l2.canFind(l))\n        {\n            result[count] = l;\n          \
    \  count++;\n        }\n    }\n    return result[0..count];\n}", "{\n    long[]\
    \ result;\n    long[] l3 = l1.dup;\n    l3 ~= l2;\n    l3.sort;\n    l3.unique;\n\
    \    result = l3;\n    return result;\n}", "{\n    auto result = new long[](0);\n\
    \    auto l1_set = new Set!(long)(l1);\n    auto l2_set = new Set!(long)(l2);\n\
    \    foreach(l; l1_set)\n    {\n        if(l2_set.contains(l))\n        {\n  \
    \          result ~= l;\n        }\n    }\n    return result.sort();\n}", "{\n\
    \    long[] result;\n    long[] temp;\n    long[] temp2;\n    long[] temp3;\n\
    \    long[] temp4;\n    long[] temp5;\n    long[] temp6;\n    long[] temp7;\n\
    \    long[] temp8;\n    long[] temp9;\n    long[] temp10;\n    long[] temp11;\n\
    \    long[] temp12;\n    long[] temp13;\n    long[] temp14;\n    long[] temp15;\n\
    \    long[] temp16;\n    long[] temp17;\n    long[] temp18;\n    long[] temp19;\n\
    \    long[] temp20;\n    long[] temp21;\n    long[] temp22;\n    long[] temp23;\n\
    \    long[] temp24;\n    long[] temp25;\n    long[] temp26;\n    long[] temp27;\n\
    \    long[] temp28;\n    long[] temp29;\n    long[] temp30;\n    long[] temp31;\n\
    \    long[] temp32;\n    long[] temp33;\n    long[] temp34;\n    long[] temp35;\n\
    \    long[] temp36;\n    long[] temp37;\n    long[] temp38;\n    long[] temp39;\n\
    \    long[] temp40;\n    long[] temp41;\n    long[] temp42;\n    long[] temp43;\n\
    \    long[] temp44;\n    long[] temp45;\n    long[] temp46;\n    long[] temp47;\n\
    \    long[] temp48;\n    long[] temp49;\n    long[] temp50;\n    long[] temp51;\n\
    \    long[] temp52;\n    long[] temp53;\n    long[] temp54;\n    long[] temp55;\n\
    \    long[] temp56;\n    long[] temp57;\n    long[] temp58;\n    long[] temp59;\n\
    \    long[] temp60;\n    long[] temp61;\n    long[] temp62;\n    long[] temp63;\n\
    \    long[] temp64;\n    long[] temp65;\n    long[] temp66;\n    long[] temp67;\n\
    \    long[] temp68;\n    long[] temp69;\n    long[] temp70;\n    long[] temp71;\n\
    \    long[] temp72;\n", "{\n    long[] res = new long[];\n    foreach(l; l1)\n\
    \    {\n        if(l2.canFind(l))\n        {\n            res ~= l;\n        }\n\
    \    }\n    return res.sort().uniq;\n}", "{\n    long[] result = new long[0L];\n\
    \    foreach (l; l1) {\n        if (l2.canFind(l)) {\n            result ~= l;\n\
    \        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] res = [];\n\
    \    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n            res ~=\
    \ e;\n        }\n    }\n    return res.sort().uniq;\n}", "{\n    long[] res =\
    \ new long[l1.length];\n    int count = 0;\n    foreach(l; l1)\n    {\n      \
    \  if(l2.canFind(l))\n        {\n            res[count] = l;\n            count++;\n\
    \        }\n    }\n    return res[0..count];\n}", "{\n    long[] result = new\
    \ long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n \
    \           result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}",
  "{\n    long[] r = new long[];\n    foreach(long i; l1)\n    {\n        foreach(long\
    \ j; l2)\n        {\n            if(i == j)\n            {\n                r\
    \ ~= i;\n            }\n        }\n    }\n    return r.sort().uniq;\n}", "{\n\
    \    long[] l3 = l1.dup;\n    l3.sort;\n    long[] l4 = l2.dup;\n    l4.sort;\n\
    \    long[] l5 = l3.dup;\n    l5.removeDuplicates;\n    long[] l6 = l4.dup;\n\
    \    l6.removeDuplicates;\n    long[] l7 = l5.dup;\n    l7.remove(l6);\n    return\
    \ l7;\n}\n/*\nReturn sorted unique common elements for two arrays.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n    long[]\
    \ result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    foreach(l; l1_unique)\n    {\n        if(l2_unique.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}",
  "{\n    long[] result = new long[0L];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.count(l)\
    \ > 0)\n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    foreach(l1_u; l1_unique)\n    {\n        foreach(l2_u;\
    \ l2_unique)\n        {\n            if(l1_u == l2_u)\n            {\n       \
    \         result ~= l1_u;\n            }\n        }\n    }\n    return result;\n\
    }", "{\n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n}", "{\n    auto\
    \ result = new long[];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] ret = new long[0];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            ret ~= l;\n        }\n    }\n    return ret.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n      \
    \  if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] result = new long[0L];\n \
    \   foreach (i; l1) \n    {\n        if (l2.canFind(i)) \n        {\n        \
    \    result ~= i;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n\
    \    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (l; l1) \n    {\n     \
    \   if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.count(l)\
    \ > 0)\n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n      \
    \  if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] result;\n    foreach(e; l1)\n\
    \    {\n        if(e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().unique;\n}", "{\n    long[] ret = [];\n    long[]\
    \ l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n    long l1_len\
    \ = l1_sorted.length;\n    long l2_len = l2_sorted.length;\n    long i = 0L;\n\
    \    long j = 0L;\n    while (i < l1_len && j < l2_len) \n    {\n        if (l1_sorted[i]\
    \ == l2_sorted[j]) \n        {\n            ret ~= l1_sorted[i];\n           \
    \ i++;\n            j++;\n        }\n        else if (l1_sorted[i] < l2_sorted[j])\
    \ \n        {\n            i++;\n        }\n        else \n        {\n       \
    \     j++;\n        }\n    }\n    return ret;\n}", "{\n    auto s1 = l1.sort().uniq;\n\
    \    auto s2 = l2.sort().uniq;\n    long[] res;\n    foreach(e; s1)\n    {\n \
    \       if(e in s2)\n        {\n            res ~= e;\n        }\n    }\n    return\
    \ res;\n}\n/*\nReturn sorted unique common elements for two arrays.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]", "{\n    auto result = new long[](0);\n    auto\
    \ s1 = l1.sort();\n    auto s2 = l2.sort();\n    long i = 0;\n    long j = 0;\n\
    \    while (i < s1.length && j < s2.length) \n    {\n        if (s1[i] < s2[j])\
    \ \n        {\n            i++;\n        }\n        else if (s1[i] > s2[j]) \n\
    \        {\n            j++;\n        }\n        else \n        {\n          \
    \  result ~= s1[i];\n            i++;\n            j++;\n        }\n    }\n  \
    \  return result;\n}", "{\n    long[] res = new long[];\n    foreach(l; l1)\n\
    \    {\n        if(l2.canFind(l))\n        {\n            res ~= l;\n        }\n\
    \    }\n    res = res.sort().uniq;\n    return res;\n}", "{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (l; l1) {\n        if (l2.canFind(l))\
    \ {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] res = new long[0];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            res ~= l;\n        }\n    }\n    return res.sort().uniq;\n\
    }", "{\n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n}", "{\n    long[]\
    \ result;\n    long[] tmp;\n    long[] tmp2;\n    long[] tmp3;\n    long[] tmp4;\n\
    \    long[] tmp5;\n    long[] tmp6;\n    long[] tmp7;\n    long[] tmp8;\n    long[]\
    \ tmp9;\n    long[] tmp10;\n    long[] tmp11;\n    long[] tmp12;\n    long[] tmp13;\n\
    \    long[] tmp14;\n    long[] tmp15;\n    long[] tmp16;\n    long[] tmp17;\n\
    \    long[] tmp18;\n    long[] tmp19;\n    long[] tmp20;\n    long[] tmp21;\n\
    \    long[] tmp22;\n    long[] tmp23;\n    long[] tmp24;\n    long[] tmp25;\n\
    \    long[] tmp26;\n    long[] tmp27;\n    long[] tmp28;\n    long[] tmp29;\n\
    \    long[] tmp30;\n    long[] tmp31;\n    long[] tmp32;\n    long[] tmp33;\n\
    \    long[] tmp34;\n    long[] tmp35;\n    long[] tmp36;\n    long[] tmp37;\n\
    \    long[] tmp38;\n    long[] tmp39;\n    long[] tmp40;\n    long[] tmp41;\n\
    \    long[] tmp42;\n    long[] tmp43;\n    long[] tmp44;\n    long[] tmp45;\n\
    \    long[] tmp46;\n    long[] tmp47;\n    long[] tmp48;\n    long[] tmp49;\n\
    \    long[] tmp50;\n    long[] tmp51;\n    long[] tmp52;\n    long[] tmp53;\n\
    \    long[] tmp54;\n    long[] tmp55;\n    long[] tmp56;\n    long[] tmp57;\n\
    \    long[] tmp58;\n    long[] tmp59;\n    long[] tmp60;\n    long[] tmp61;\n\
    \    long[] tmp62;\n    long[] tmp63;\n    long[] tmp64;\n    long[] tmp65;\n\
    \    long[] tmp66;\n    long[] tmp67;\n    long[] tmp68;\n    long[] tmp69;\n\
    \    long[] tmp70;\n    long[] tmp71;\n    long[] tmp72;\n", "{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n   \
    \         result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}",
  "{\n    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach(l; l1) {\n        if(l2.canFind(l))\
    \ {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result;\n    long[] l1_unique = l1.unique;\n    long[] l2_unique\
    \ = l2.unique;\n    if (l1_unique.length < l2_unique.length) \n    {\n       \
    \ result = l1_unique.filter!(a => l2_unique.canFind(a));\n    } \n    else \n\
    \    {\n        result = l2_unique.filter!(a => l1_unique.canFind(a));\n    }\n\
    \    return result.sort;\n}", "{\n    auto s1 = l1.sort().uniq;\n    auto s2 =\
    \ l2.sort().uniq;\n    long[] res;\n    foreach(e; s1)\n    {\n        if(s2.canFind(e))\n\
    \        {\n            res ~= e;\n        }\n    }\n    return res;\n}", "{\n\
    \    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] res = [];\n    foreach(e; l1) \n    {\n        if(e in l2)\
    \ \n        {\n            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n\
    }", "{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    long[] l1_unique_sorted = l1_unique.sort;\n    long[]\
    \ l2_unique_sorted = l2_unique.sort;\n    long[] l1_unique_sorted_set = l1_unique_sorted.toSet;\n\
    \    long[] l2_unique_sorted_set = l2_unique_sorted.toSet;\n    long[] l1_unique_sorted_set_intersection\
    \ = l1_unique_sorted_set.intersection(l2_unique_sorted_set);\n    result = l1_unique_sorted_set_intersection.toArray;\n\
    \    return result;\n}", "{\n    long[] result;\n    long[] tmp;\n    long[] tmp2;\n\
    \    long[] tmp3;\n    long[] tmp4;\n    long[] tmp5;\n    long[] tmp6;\n    long[]\
    \ tmp7;\n    long[] tmp8;\n    long[] tmp9;\n    long[] tmp10;\n    long[] tmp11;\n\
    \    long[] tmp12;\n    long[] tmp13;\n    long[] tmp14;\n    long[] tmp15;\n\
    \    long[] tmp16;\n    long[] tmp17;\n    long[] tmp18;\n    long[] tmp19;\n\
    \    long[] tmp20;\n    long[] tmp21;\n    long[] tmp22;\n    long[] tmp23;\n\
    \    long[] tmp24;\n    long[] tmp25;\n    long[] tmp26;\n    long[] tmp27;\n\
    \    long[] tmp28;\n    long[] tmp29;\n    long[] tmp30;\n    long[] tmp31;\n\
    \    long[] tmp32;\n    long[] tmp33;\n    long[] tmp34;\n    long[] tmp35;\n\
    \    long[] tmp36;\n    long[] tmp37;\n    long[] tmp38;\n    long[] tmp39;\n\
    \    long[] tmp40;\n    long[] tmp41;\n    long[] tmp42;\n    long[] tmp43;\n\
    \    long[] tmp44;\n    long[] tmp45;\n    long[] tmp46;\n    long[] tmp47;\n\
    \    long[] tmp48;\n    long[] tmp49;\n    long[] tmp50;\n    long[] tmp51;\n\
    \    long[] tmp52;\n    long[] tmp53;\n    long[] tmp54;\n    long[] tmp55;\n\
    \    long[] tmp56;\n    long[] tmp57;\n    long[] tmp58;\n    long[] tmp59;\n\
    \    long[] tmp60;\n    long[] tmp61;\n    long[] tmp62;\n    long[] tmp63;\n\
    \    long[] tmp64;\n    long[] tmp65;\n    long[] tmp66;\n    long[] tmp67;\n\
    \    long[] tmp68;\n    long[] tmp69;\n    long[] tmp70;\n    long[] tmp71;\n\
    \    long[] tmp72;\n", "{\n    long[] result = new long[0L];\n    foreach (l;\
    \ l1) \n    {\n        if (l2.canFind(l)) \n        {\n            result ~= l;\n\
    \        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result =\
    \ new long[];\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n   \
    \         result ~= e;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    long[] temp;\n    if (l1.length < l2.length) \n    {\n        temp\
    \ = l1;\n        l1 = l2;\n        l2 = temp;\n    }\n    result = new long[l1.length];\n\
    \    int i = 0;\n    foreach (l; l1) \n    {\n        if (l2.canFind(l)) \n  \
    \      {\n            result[i] = l;\n            i++;\n        }\n    }\n   \
    \ return result[0 .. i];\n}", "{\n    long[] result;\n    auto l1_set = set(l1);\n\
    \    auto l2_set = set(l2);\n    foreach(l; l1_set)\n    {\n        if(l2_set.contains(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}",
  "{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n    long[]\
    \ l2_sorted = sort(l2);\n    long i = 0L;\n    long j = 0L;\n    while (i < l1_sorted.length\
    \ && j < l2_sorted.length)\n    {\n        if (l1_sorted[i] == l2_sorted[j])\n\
    \        {\n            result = result ~ l1_sorted[i];\n            i++;\n  \
    \          j++;\n        }\n        else if (l1_sorted[i] < l2_sorted[j])\n  \
    \      {\n            i++;\n        }\n        else\n        {\n            j++;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] l3 = l1.dup;\n    l3.sort;\n\
    \    long[] l4 = l2.dup;\n    l4.sort;\n    long[] l5 = l3.dup;\n    l5.length\
    \ = l3.length + l4.length;\n    l5[0 .. l3.length] = l3;\n    l5[l3.length ..\
    \ $] = l4;\n    l5.sort;\n    l5.length = l5.length - 1;\n    long[] l6 = l5.dup;\n\
    \    l6.length = l5.length - 1;\n    l6.sort;\n    l6.length = l6.length - 1;\n\
    \    long[] l7 = l5.dup;\n    l7.length = l5.length - 1;\n    l7.sort;\n    l7.length\
    \ = l7.length - 1;\n    long[] l8 = l5.dup;\n    l8.length = l5.length - 1;\n\
    \    l8.sort;\n    l8.length = l8.length - 1;\n    long[] l9 = l5.dup;\n    l9.length\
    \ = l5.length - 1;\n    l9.sort;\n    l9.length = l9.length - 1;\n    long[] l10\
    \ = l5.dup;\n    l10.length = l5.length - 1;\n    l10.sort;\n    l10.length =\
    \ l10.length - 1;\n    long[] l11 = l5.dup;\n    l11.length = l5.length - 1;\n\
    \    l11.sort;\n    l11.length = l11.length - 1;\n    long[] l12 = l5.dup;\n \
    \   l12.length = l5.length - 1;\n    l12.sort;\n    l12.length = l12.length -\
    \ 1;\n    long[] l13 = l5.dup;\n    l13.length = l5.length - 1;\n    l13.sort;\n\
    \    l13.length = l13.length - 1;\n    long", "{\n    long[] result = new long[];\n\
    \    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n           \
    \ result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n   \
    \ long[] result = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] res = new long[0L];\n    long[] l1_sorted = sort(l1);\n   \
    \ long[] l2_sorted = sort(l2);\n    long l1_len = l1_sorted.length;\n    long\
    \ l2_len = l2_sorted.length;\n    long i = 0L;\n    long j = 0L;\n    while (i\
    \ < l1_len && j < l2_len)\n    {\n        if (l1_sorted[i] == l2_sorted[j])\n\
    \        {\n            res ~= l1_sorted[i];\n            i++;\n            j++;\n\
    \        }\n        else if (l1_sorted[i] < l2_sorted[j])\n        {\n       \
    \     i++;\n        }\n        else\n        {\n            j++;\n        }\n\
    \    }\n    return res;\n}", "{\n    long[] result = [];\n    foreach(l; l1)\n\
    \    {\n        if(l2.canFind(l))\n        {\n            result ~= l;\n     \
    \   }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result = [];\n\
    \    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n            result\
    \ ~= e;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[]\
    \ l3 = new long[l1.length];\n    int i = 0;\n    foreach(long l; l1)\n    {\n\
    \        if(l2.find(l) != -1)\n        {\n            l3[i] = l;\n           \
    \ i++;\n        }\n    }\n    l3.length = i;\n    l3.sort();\n    l3 = l3.dup.uniq;\n\
    \    return l3;\n}", "{\n    long[] l3 = new long[l1.length + l2.length];\n  \
    \  long[] l4 = new long[l1.length + l2.length];\n    long[] l5 = new long[l1.length\
    \ + l2.length];\n    long[] l6 = new long[l1.length + l2.length];\n    long[]\
    \ l7 = new long[l1.length + l2.length];\n    long[] l8 = new long[l1.length +\
    \ l2.length];\n    long[] l9 = new long[l1.length + l2.length];\n    long[] l10\
    \ = new long[l1.length + l2.length];\n    long[] l11 = new long[l1.length + l2.length];\n\
    \    long[] l12 = new long[l1.length + l2.length];\n    long[] l13 = new long[l1.length\
    \ + l2.length];\n    long[] l14 = new long[l1.length + l2.length];\n    long[]\
    \ l15 = new long[l1.length + l2.length];\n    long[] l16 = new long[l1.length\
    \ + l2.length];\n    long[] l17 = new long[l1.length + l2.length];\n    long[]\
    \ l18 = new long[l1.length + l2.length];\n    long[] l19 = new long[l1.length\
    \ + l2.length];\n    long[] l20 = new long[l1.length + l2.length];\n    long[]\
    \ l21 = new long[l1.length + l2.length];\n    long[] l22 = new long[l1.length\
    \ + l2.length];\n    long[] l23 = new long[l1.length + l2.length];\n    long[]\
    \ l24 = new long[l1.length + l2.length];\n    long[] l25 = new long[l1.length\
    \ + l2.length];\n    long[] l26 = new long[l1.length + l2.length];\n    long[]\
    \ l27 = new long[l1.length + l2.length];\n    long[] l28 = new long[", "{\n  \
    \  long[] result = new long[];\n    foreach(l; l1) \n    {\n        if(l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    return l1.filter!(x => l2.canFind(x)).sort().unique;\n}", "{\n   \
    \ long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (l; l1) \n    {\n     \
    \   if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] result;\n    result = new\
    \ long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n \
    \           result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}",
  "{\n    long[] result;\n    auto s1 = l1.sort().unique;\n    auto s2 = l2.sort().unique;\n\
    \    foreach (e; s1) \n    {\n        if (s2.canFind(e)) \n        {\n       \
    \     result ~= e;\n        }\n    }\n    return result;\n}", "{\n    long[] l3\
    \ = l1.dup;\n    l3.sort;\n    l3.uniq;\n    long[] l4 = l2.dup;\n    l4.sort;\n\
    \    l4.uniq;\n    long[] l5 = l3.dup;\n    l5.sort;\n    long[] l6 = l4.dup;\n\
    \    l6.sort;\n    long[] l7 = l5.dup;\n    long[] l8 = l6.dup;\n    l7.removeDuplicates;\n\
    \    l8.removeDuplicates;\n    long[] l9 = l7.dup;\n    long[] l10 = l8.dup;\n\
    \    l9.sort;\n    l10.sort;\n    long[] l11 = l9.dup;\n    long[] l12 = l10.dup;\n\
    \    l11.uniq;\n    l12.uniq;\n    long[] l13 = l11.dup;\n    long[] l14 = l12.dup;\n\
    \    l13.sort;\n    l14.sort;\n    long[] l15 = l13.dup;\n    long[] l16 = l14.dup;\n\
    \    l15.removeDuplicates;\n    l16.removeDuplicates;\n    long[] l17 = l15.dup;\n\
    \    long[] l18 = l16.dup;\n    l17.sort;\n    l18.sort;\n    long[] l19 = l17.dup;\n\
    \    long[] l20 = l18.dup;\n    l19.uniq;\n    l20.uniq;\n    long[] l21 = l19.dup;\n\
    \    long[] l22 = l20.dup;\n    l21.sort;\n    l22.sort;\n    long[] l23 = l21.dup;\n\
    \    long[] l24 = l22.dup;\n    l23.removeDuplicates;\n    l24.removeDuplicates;\n\
    \    long[] l25 = l23.dup;\n    long[] l26 = l24.dup;\n    l25.sort", "{\n   \
    \ long[] result = new long[l1.length];\n    int count = 0;\n    foreach(l; l1)\n\
    \    {\n        if(l2.canFind(l))\n        {\n            result[count] = l;\n\
    \            count++;\n        }\n    }\n    return result[0..count];\n}\n/*\n\
    Return sorted unique common elements for two arrays.\n    >>> common([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n\
    \    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (l; l1) \n    {\n     \
    \   if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    auto s1 = set(l1);\n    auto s2 =\
    \ set(l2);\n    return s1.intersection(s2).array;\n}", "{\n    long[] result =\
    \ new long[0L];\n    long[] l1_sorted = sort(l1);\n    long[] l2_sorted = sort(l2);\n\
    \    long i = 0L;\n    long j = 0L;\n    while (i < l1_sorted.length && j < l2_sorted.length)\n\
    \    {\n        if (l1_sorted[i] == l2_sorted[j])\n        {\n            result\
    \ = result ~ l1_sorted[i];\n            i += 1L;\n            j += 1L;\n     \
    \   }\n        else if (l1_sorted[i] < l2_sorted[j])\n        {\n            i\
    \ += 1L;\n        }\n        else\n        {\n            j += 1L;\n        }\n\
    \    }\n    return result;\n}", "{\n    return sort(array(l1).intersect(l2));\n\
    }\n/*\nReturn sorted unique common elements for two arrays.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n    long[]\
    \ result = new long[0L];\n    foreach (e; l1) \n    {\n        if (e in l2) \n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    auto r = new long[](0);\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            r ~= l;\n        }\n    }\n    return r.sort().uniq;\n\
    }", "{\n    long[] l3 = l1.dup;\n    l3 ~= l2;\n    l3.sort;\n    l3 = l3.uniq;\n\
    \    return l3;\n}", "{\n    auto result = new long[](0);\n    auto l1_set = new\
    \ Set!(long)();\n    auto l2_set = new Set!(long)();\n    foreach(e; l1)\n   \
    \ {\n        l1_set.insert(e);\n    }\n    foreach(e; l2)\n    {\n        l2_set.insert(e);\n\
    \    }\n    foreach(e; l1_set)\n    {\n        if(l2_set.contains(e))\n      \
    \  {\n            result ~= e;\n        }\n    }\n    return result;\n}", "{\n\
    \    auto set1 = set(l1);\n    auto set2 = set(l2);\n    return set1.intersection(set2).array;\n\
    }", "{\n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n    auto common_set\
    \ = l1_set & l2_set;\n    return common_set.array;\n}", "{\n    long[] result\
    \ = new long[0L];\n    long[] l1_sorted = sort(l1);\n    long[] l2_sorted = sort(l2);\n\
    \    long i = 0L;\n    long j = 0L;\n    while (i < l1_sorted.length && j < l2_sorted.length)\n\
    \    {\n        if (l1_sorted[i] == l2_sorted[j])\n        {\n            if (result.length\
    \ == 0L || result[$ - 1L] != l1_sorted[i])\n            {\n                result\
    \ = result ~ l1_sorted[i];\n            }\n            i++;\n            j++;\n\
    \        }\n        else if (l1_sorted[i] < l2_sorted[j])\n        {\n       \
    \     i++;\n        }\n        else\n        {\n            j++;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] res = new long[];\n    foreach(l;\
    \ l1)\n    {\n        if(l2.canFind(l))\n        {\n            res ~= l;\n  \
    \      }\n    }\n    res = res.sort().uniq;\n    return res;\n}", "{\n    long[]\
    \ result = new long[l1.length];\n    int count = 0;\n    foreach(long i; l1)\n\
    \    {\n        if(l2.canFind(i))\n        {\n            result[count] = i;\n\
    \            count++;\n        }\n    }\n    return result[0..count];\n}", "{\n\
    \    long[] result;\n    result = l1.filter!(a => l2.canFind(a)).sort().uniq;\n\
    \    return result;\n}", "{ \n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
