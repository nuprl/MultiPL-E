name: HumanEval_159_eat
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(number\
    \ + need > remaining)\n    {\n        result[0] = remaining;\n        result[1]\
    \ = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - (number + need);\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n\
    \    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L,\
    \ 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L,\
    \ 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpchvjg0l9.d(58): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284fd]\\n??:? void tmpchvjg0l9.__unittest_L54_C1()\
    \ [0x427fa8]\\n??:? void tmpchvjg0l9.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5b7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b44a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306d5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b84]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430661]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b421]\\n??:? runModuleUnitTests [0x42c38d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289c0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428947]\\n??:? _d_run_main [0x4288b2]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x925ba554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return\
    \ [min(number + need, remaining), max(0L, remaining - need)];\n}\nunittest\n{\n\
    \    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n\
    \    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L,\
    \ 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L,\
    \ 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpib6v7ioh.d(39): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpib6v7ioh.d(39): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpib6v7ioh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number + need > 1000)\n    {\n        result[0]\
    \ = 1000;\n        result[1] = remaining - (1000 - number);\n    }\n    else if(number\
    \ + need > remaining)\n    {\n        result[0] = remaining;\n        result[1]\
    \ = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsnyuq9bn.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42852d]\\n??:? void tmpsnyuq9bn.__unittest_L57_C1()\
    \ [0x427fd8]\\n??:? void tmpsnyuq9bn.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5e7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b47a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430705]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430bb4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430691]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b451]\\n??:? runModuleUnitTests [0x42c3bd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428977]\\n??:? _d_run_main [0x4288e2]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0x8b586554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number >= need)\n    {\n        result[0] = number;\n\
    \        result[1] = remaining;\n    }\n    else\n    {\n        if(remaining\
    \ >= need)\n        {\n            result[0] = number + need;\n            result[1]\
    \ = remaining - need;\n        }\n        else\n        {\n            result[0]\
    \ = number + remaining;\n            result[1] = 0;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return\
    \ [min(need, remaining) + number, max(0L, remaining - need)];\n}\nunittest\n{\n\
    \    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n\
    \    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L,\
    \ 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L,\
    \ 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpirey1872.d(39): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpirey1872.d(39): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpirey1872.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining\
    \ < need)\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining >= need)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long\
    \ eaten = 0;\n    if (need > remaining)\n    {\n        eaten = remaining;\n \
    \       remaining = 0;\n    }\n    else\n    {\n        eaten = need;\n      \
    \  remaining -= need;\n    }\n    return tuple(number + eaten, remaining);\n}\n\
    unittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) ==\
    \ [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb50e9_4z.d(50): Error: cannot implicitly convert expression `tuple(number\
    \ + eaten, remaining)` of type `Tuple!(long, long)` to `long[]`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb50e9_4z.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number <= 0 || need <= 0 || remaining <= 0)\n\
    \    {\n        result[0] = 0;\n        result[1] = 0;\n        return result;\n\
    \    }\n    if(number > 1000 || need > 1000 || remaining > 1000)\n    {\n    \
    \    result[0] = 0;\n        result[1] = 0;\n        return result;\n    }\n \
    \   if(remaining >= need)\n    {\n        result[0] = number + need;\n       \
    \ result[1] = remaining - need;\n        return result;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n       \
    \ return result;\n    }\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining\
    \ < need)\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(number\
    \ + need <= remaining)\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpz0dfohwx.d(58): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284fd]\\n??:? void tmpz0dfohwx.__unittest_L54_C1()\
    \ [0x427fac]\\n??:? void tmpz0dfohwx.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5b7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b44a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306d5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b84]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430661]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b421]\\n??:? runModuleUnitTests [0x42c38d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289c0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428947]\\n??:? _d_run_main [0x4288b2]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0xd97b9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (number + need <= remaining)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0q4zsen4.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284bd]\\n??:? void tmp0q4zsen4.__unittest_L52_C1()\
    \ [0x427f6c]\\n??:? void tmp0q4zsen4.__modtest() [0x428240]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c577]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b40a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430695]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430621]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b3e1]\\n??:? runModuleUnitTests [0x42c34d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428980]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428907]\\n??:? _d_run_main [0x428872]\\n??:? main [0x428253]\\\
    n??:? __libc_start_main [0x8741c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] += result[1];\n  \
    \      result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return\
    \ [min(number + need, remaining), max(0L, remaining - (number + need))];\n}\n\
    unittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) ==\
    \ [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptfl1n112.d(39): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmptfl1n112.d(39): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmptfl1n112.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining\
    \ < need)\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n\
    \    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
    \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_8u1urcy.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284ed]\\n??:? void tmp_8u1urcy.__unittest_L52_C1()\
    \ [0x427f98]\\n??:? void tmp_8u1urcy.__modtest() [0x42826c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5a7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b43a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306c5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430651]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b411]\\n??:? runModuleUnitTests [0x42c37d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289b0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428937]\\n??:? _d_run_main [0x4288a2]\\n??:? main [0x42827f]\\\
    n??:? __libc_start_main [0xbd774554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining\
    \ == 0)\n    {\n        result[0] = number;\n        result[1] = 0;\n        return\
    \ result;\n    }\n    if(remaining < need)\n    {\n        result[0] = number\
    \ + remaining;\n        result[1] = 0;\n        return result;\n    }\n    result[0]\
    \ = number + need;\n    result[1] = remaining - need;\n    return result;\n}\n\
    unittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) ==\
    \ [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    auto\
    \ total = number + need;\n    auto left = remaining - total;\n    if (left < 0)\n\
    \    {\n        return [total, 0];\n    }\n    else\n    {\n        return [total,\
    \ left];\n    }\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwbro4ce0.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428435]\\n??:? void tmpwbro4ce0.__unittest_L50_C1()\
    \ [0x427ee0]\\n??:? void tmpwbro4ce0.__modtest() [0x4281b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c41f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b2b2]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430445]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b289]\\n??:? runModuleUnitTests [0x42c1f5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428884]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42880b]\\n??:? _d_run_main [0x428776]\\n??:? main [0x4281c7]\\\
    n??:? __libc_start_main [0x6db12554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    auto\
    \ result = tuple(number, remaining);\n    if (result[1] < need)\n    {\n     \
    \   result[0] += result[1];\n        result[1] = 0;\n    }\n    else\n    {\n\
    \        result[0] += need;\n        result[1] -= need;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
    \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz60w6zw_.d(50): Error: cannot implicitly convert expression `result`\
    \ of type `Tuple!(long, long)` to `long[]`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpz60w6zw_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining\
    \ < need)\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    //\
    \ your code here\n    long[] result = new long[2];\n    if(number >= need)\n \
    \   {\n        result[0] = number;\n        result[1] = remaining;\n    }\n  \
    \  else\n    {\n        if(remaining >= need - number)\n        {\n          \
    \  result[0] = number + need;\n            result[1] = remaining - need + number;\n\
    \        }\n        else\n        {\n            result[0] = number + remaining;\n\
    \            result[1] = 0;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n\
    \    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L,\
    \ 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L,\
    \ 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpr3mk73xc.d(65): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428525]\\n??:? void tmpr3mk73xc.__unittest_L61_C1()\
    \ [0x427fd4]\\n??:? void tmpr3mk73xc.__modtest() [0x4282a8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5df]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b472]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306fd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430bac]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430689]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b449]\\n??:? runModuleUnitTests [0x42c3b5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42896f]\\n??:? _d_run_main [0x4288da]\\n??:? main [0x4282bb]\\\
    n??:? __libc_start_main [0xea90a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number + need <= remaining)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - (number + need);\n    }\n\
    \    else\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n\
    \    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L,\
    \ 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L,\
    \ 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n   \
    \ assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6g77q095.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284bd]\\n??:? void tmp6g77q095.__unittest_L52_C1()\
    \ [0x427f6c]\\n??:? void tmp6g77q095.__modtest() [0x428240]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c577]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b40a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430695]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430621]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b3e1]\\n??:? runModuleUnitTests [0x42c34d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428980]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428907]\\n??:? _d_run_main [0x428872]\\n??:? main [0x428253]\\\
    n??:? __libc_start_main [0xf7690554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number > 1000 || need > 1000 || remaining > 1000)\n\
    \        return result;\n    else if(number < 0 || need < 0 || remaining < 0)\n\
    \        return result;\n    else if(number + need > remaining)\n    {\n     \
    \   result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n   \
    \ assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L)\
    \ == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L,\
    \ 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n   \
    \ assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpizfgnq2f.d(60): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428505]\\n??:? void tmpizfgnq2f.__unittest_L56_C1()\
    \ [0x427fb4]\\n??:? void tmpizfgnq2f.__modtest() [0x428288]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5bf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b452]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306dd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b8c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430669]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b429]\\n??:? runModuleUnitTests [0x42c395]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289c8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42894f]\\n??:? _d_run_main [0x4288ba]\\n??:? main [0x42829b]\\\
    n??:? __libc_start_main [0xedbae554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n\
    \    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
    \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpohwhgsek.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284ed]\\n??:? void tmpohwhgsek.__unittest_L52_C1()\
    \ [0x427f98]\\n??:? void tmpohwhgsek.__modtest() [0x42826c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5a7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b43a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306c5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430651]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b411]\\n??:? runModuleUnitTests [0x42c37d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289b0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428937]\\n??:? _d_run_main [0x4288a2]\\n??:? main [0x42827f]\\\
    n??:? __libc_start_main [0xc8304554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining >= need)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (number + need <= remaining)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - (number + need);\n    }\n\
    \    else\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n\
    \    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L,\
    \ 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L,\
    \ 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n   \
    \ assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxrx8ijd4.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284bd]\\n??:? void tmpxrx8ijd4.__unittest_L52_C1()\
    \ [0x427f6c]\\n??:? void tmpxrx8ijd4.__modtest() [0x428240]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c577]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b40a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430695]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430621]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b3e1]\\n??:? runModuleUnitTests [0x42c34d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428980]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428907]\\n??:? _d_run_main [0x428872]\\n??:? main [0x428253]\\\
    n??:? __libc_start_main [0x61c1e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n\
    \    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
    \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcfa2sxqo.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284ed]\\n??:? void tmpcfa2sxqo.__unittest_L52_C1()\
    \ [0x427f98]\\n??:? void tmpcfa2sxqo.__modtest() [0x42826c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5a7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b43a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306c5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430651]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b411]\\n??:? runModuleUnitTests [0x42c37d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289b0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428937]\\n??:? _d_run_main [0x4288a2]\\n??:? main [0x42827f]\\\
    n??:? __libc_start_main [0x44ca554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (number + need <= remaining)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - (number + need);\n    }\n\
    \    else\n    {\n        result[0] = remaining;\n        result[1] = 0;\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpb12cr5o6.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284bd]\\n??:? void tmpb12cr5o6.__unittest_L52_C1()\
    \ [0x427f68]\\n??:? void tmpb12cr5o6.__modtest() [0x42823c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c577]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b40a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430695]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430621]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b3e1]\\n??:? runModuleUnitTests [0x42c34d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428980]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428907]\\n??:? _d_run_main [0x428872]\\n??:? main [0x42824f]\\\
    n??:? __libc_start_main [0xe53d1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    result[0]\
    \ = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n\
    \    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number + need <= remaining)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - (number + need);\n    }\n\
    \    else\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n\
    \    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L,\
    \ 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L,\
    \ 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n   \
    \ assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp29mywip8.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284bd]\\n??:? void tmp29mywip8.__unittest_L52_C1()\
    \ [0x427f6c]\\n??:? void tmp29mywip8.__modtest() [0x428240]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c577]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b40a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430695]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430621]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b3e1]\\n??:? runModuleUnitTests [0x42c34d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428980]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428907]\\n??:? _d_run_main [0x428872]\\n??:? main [0x428253]\\\
    n??:? __libc_start_main [0xc2c22554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number + need > 1000)\n    {\n        result[0]\
    \ = 1000;\n        result[1] = remaining - (1000 - number);\n    }\n    else if(number\
    \ + need > remaining)\n    {\n        result[0] = remaining;\n        result[1]\
    \ = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpr1lejing.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42852d]\\n??:? void tmpr1lejing.__unittest_L57_C1()\
    \ [0x427fd8]\\n??:? void tmpr1lejing.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5e7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b47a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430705]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430bb4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430691]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b451]\\n??:? runModuleUnitTests [0x42c3bd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428977]\\n??:? _d_run_main [0x4288e2]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0xf901b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(need\
    \ > remaining)\n    {\n        result[0] = number + remaining;\n        result[1]\
    \ = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number <= 1000 && need <= 1000 && remaining <=\
    \ 1000)\n    {\n        if(number + need <= remaining)\n        {\n          \
    \  result[0] = number + need;\n            result[1] = remaining - (number + need);\n\
    \        }\n        else\n        {\n            result[0] = number + remaining;\n\
    \            result[1] = 0;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n\
    \    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L,\
    \ 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L,\
    \ 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpc89cj9rh.d(59): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284e5]\\n??:? void tmpc89cj9rh.__unittest_L55_C1()\
    \ [0x427f90]\\n??:? void tmpc89cj9rh.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c59f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b432]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306bd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b6c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430649]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b409]\\n??:? runModuleUnitTests [0x42c375]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289a8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42892f]\\n??:? _d_run_main [0x42889a]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0xc22ac554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining >= need)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (need <= remaining)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = result[0] + result[1];\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] += result[1];\n  \
    \      result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    auto\
    \ result = tuple(number, remaining);\n    if (result[1] < need)\n    {\n     \
    \   result[0] += result[1];\n        result[1] = 0;\n    }\n    else\n    {\n\
    \        result[0] += need;\n        result[1] -= need;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
    \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqw34e39q.d(50): Error: cannot implicitly convert expression `result`\
    \ of type `Tuple!(long, long)` to `long[]`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpqw34e39q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (need <= remaining)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] += result[1];\n  \
    \      result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number;\n    result[1] = remaining;\n\
    \    if(need > remaining)\n    {\n        result[0] += remaining;\n        result[1]\
    \ = 0;\n    }\n    else\n    {\n        result[0] += need;\n        result[1]\
    \ -= need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\
    \n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L,\
    \ 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L,\
    \ 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n   \
    \ assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return\
    \ [min(need, remaining) + number, max(0L, remaining - need)];\n}\nunittest\n{\n\
    \    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n\
    \    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L,\
    \ 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L,\
    \ 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg_xjis6q.d(39): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpg_xjis6q.d(39): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpg_xjis6q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    auto\
    \ result = tuple(0L, 0L);\n    if(number >= 0 && number <= 1000 && need >= 0 &&\
    \ need <= 1000 && remaining >= 0 && remaining <= 1000)\n    {\n        if(need\
    \ > remaining)\n        {\n            result = tuple(number + remaining, 0L);\n\
    \        }\n        else\n        {\n            result = tuple(number + need,\
    \ remaining - need);\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n\
    \    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L,\
    \ 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L,\
    \ 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8h23379o.d(51): Error: cannot implicitly convert expression `result`\
    \ of type `Tuple!(long, long)` to `long[]`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmp8h23379o.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0) {\n        result[0] = result[0] + result[1];\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(need\
    \ > remaining)\n    {\n        result[0] = number + remaining;\n        result[1]\
    \ = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining >= need)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining >= need)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0) {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n\
    \    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
    \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2uj8c5g1.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284ed]\\n??:? void tmp2uj8c5g1.__unittest_L52_C1()\
    \ [0x427f98]\\n??:? void tmp2uj8c5g1.__modtest() [0x42826c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5a7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b43a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306c5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430651]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b411]\\n??:? runModuleUnitTests [0x42c37d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289b0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428937]\\n??:? _d_run_main [0x4288a2]\\n??:? main [0x42827f]\\\
    n??:? __libc_start_main [0xb9808554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (number + need <= remaining)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - (number + need);\n    }\n\
    \    else\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n\
    \    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L,\
    \ 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L,\
    \ 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n   \
    \ assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1sxh4qi_.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284bd]\\n??:? void tmp1sxh4qi_.__unittest_L52_C1()\
    \ [0x427f6c]\\n??:? void tmp1sxh4qi_.__modtest() [0x428240]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c577]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b40a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430695]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430621]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b3e1]\\n??:? runModuleUnitTests [0x42c34d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428980]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428907]\\n??:? _d_run_main [0x428872]\\n??:? main [0x428253]\\\
    n??:? __libc_start_main [0xc9388554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return\
    \ [min(number + need, remaining), max(0L, remaining - need)];\n}\nunittest\n{\n\
    \    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n\
    \    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L,\
    \ 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L,\
    \ 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf_xllnu8.d(39): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpf_xllnu8.d(39): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpf_xllnu8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining\
    \ < need)\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need <= remaining)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if\
    \ (remaining >= need)\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    result[0]\
    \ = number + need;\n    if(result[0] > remaining)\n    {\n        result[0] =\
    \ remaining;\n        result[1] = 0;\n    }\n    else\n        result[1] = remaining\
    \ - result[0];\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\
    \n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L,\
    \ 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L,\
    \ 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n   \
    \ assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpv5t21rbx.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428535]\\n??:? void tmpv5t21rbx.__unittest_L52_C1()\
    \ [0x427fe0]\\n??:? void tmpv5t21rbx.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b482]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x43070d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430bbc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430699]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b459]\\n??:? runModuleUnitTests [0x42c3c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289f8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42897f]\\n??:? _d_run_main [0x4288ea]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x411d6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining >= need)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] += result[1];\n  \
    \      result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return\
    \ [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\n\
    unittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) ==\
    \ [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz4_a6ykd.d(39): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpz4_a6ykd.d(39): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpz4_a6ykd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining == 0)\n    {\n        result[0] = number;\n\
    \        result[1] = 0;\n    }\n    else if(need > remaining)\n    {\n       \
    \ result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n \
    \   {\n        result[0] = number + need;\n        result[1] = remaining - need;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n   \
    \ assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L)\
    \ == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L,\
    \ 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n   \
    \ assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number > 1000 || need > 1000 || remaining > 1000)\n\
    \        return result;\n    else if(number < 0 || need < 0 || remaining < 0)\n\
    \        return result;\n    else if(number == 0 && need == 0 && remaining ==\
    \ 0)\n        return result;\n    else\n    {\n        if(need > remaining)\n\
    \        {\n            result[0] = number + remaining;\n            result[1]\
    \ = 0;\n        }\n        else\n        {\n            result[0] = number + need;\n\
    \            result[1] = remaining - need;\n        }\n        return result;\n\
    \    }\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number > 1000 || need > 1000 || remaining > 1000)\n\
    \        return result;\n    if(number < 0 || need < 0 || remaining < 0)\n   \
    \     return result;\n    if(need > remaining)\n    {\n        result[0] = number\
    \ + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
    \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number >= 0 && number <= 1000 && need >= 0 &&\
    \ need <= 1000 && remaining >= 0 && remaining <= 1000)\n    {\n        if(remaining\
    \ >= need)\n        {\n            result[0] = number + need;\n            result[1]\
    \ = remaining - need;\n        }\n        else\n        {\n            result[0]\
    \ = number + remaining;\n            result[1] = 0;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long\
    \ total = number + need;\n    long left = remaining - total;\n    if (left < 0)\n\
    \    {\n        total = total + left;\n        left = 0;\n    }\n    return tuple(total,\
    \ left);\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf7mk0rrs.d(46): Error: cannot implicitly convert expression `tuple(total,\
    \ left)` of type `Tuple!(long, long)` to `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpf7mk0rrs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (number + need > 1000)\n    {\n        result[0]\
    \ = 1000;\n        result[1] = remaining - (1000 - number);\n    }\n    else if\
    \ (number + need > remaining)\n    {\n        result[0] = remaining;\n       \
    \ result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n\
    \        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n\
    \    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L,\
    \ 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L,\
    \ 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprqwrl8ml.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42852d]\\n??:? void tmprqwrl8ml.__unittest_L57_C1()\
    \ [0x427fd8]\\n??:? void tmprqwrl8ml.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5e7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b47a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430705]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430bb4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430691]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b451]\\n??:? runModuleUnitTests [0x42c3bd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428977]\\n??:? _d_run_main [0x4288e2]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0x94643554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return\
    \ [min(number + need, remaining), max(0L, remaining - (number + need))];\n}\n\
    unittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) ==\
    \ [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd_ezsk_9.d(39): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpd_ezsk_9.d(39): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpd_ezsk_9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return\
    \ [min(number + need, remaining), max(0L, remaining - (number + need))];\n}\n\
    unittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) ==\
    \ [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp76h3pi5s.d(39): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmp76h3pi5s.d(39): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp76h3pi5s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number;\n    result[1] = remaining;\n\
    \    if (remaining < need)\n    {\n        result[0] += remaining;\n        result[1]\
    \ = 0;\n    }\n    else\n    {\n        result[0] += need;\n        result[1]\
    \ -= need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\
    \n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L,\
    \ 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L,\
    \ 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n   \
    \ assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0) {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    //\
    \ your code here\n    long[] result = new long[2];\n    if(number >= need)\n \
    \   {\n        result[0] = number;\n        result[1] = remaining;\n    }\n  \
    \  else\n    {\n        if(need - number <= remaining)\n        {\n          \
    \  result[0] = number + need - number;\n            result[1] = remaining - (need\
    \ - number);\n        }\n        else\n        {\n            result[0] = number\
    \ + remaining;\n            result[1] = 0;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
    \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxhdmdvma.d(65): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42852d]\\n??:? void tmpxhdmdvma.__unittest_L61_C1()\
    \ [0x427fd8]\\n??:? void tmpxhdmdvma.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5e7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b47a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430705]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430bb4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430691]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b451]\\n??:? runModuleUnitTests [0x42c3bd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428977]\\n??:? _d_run_main [0x4288e2]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0xb82fc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0) {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n\
    \    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
    \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpypio05rh.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284ed]\\n??:? void tmpypio05rh.__unittest_L52_C1()\
    \ [0x427f98]\\n??:? void tmpypio05rh.__modtest() [0x42826c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5a7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b43a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306c5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430651]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b411]\\n??:? runModuleUnitTests [0x42c37d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289b0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428937]\\n??:? _d_run_main [0x4288a2]\\n??:? main [0x42827f]\\\
    n??:? __libc_start_main [0x1d6ff554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining >= need)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (number > 1000 || need > 1000 || remaining > 1000)\n\
    \        return result;\n    if (number < 0 || need < 0 || remaining < 0)\n  \
    \      return result;\n    if (remaining < need)\n    {\n        result[0] = number\
    \ + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
    \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n\
    \    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
    \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmposa_wqzt.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284ed]\\n??:? void tmposa_wqzt.__unittest_L52_C1()\
    \ [0x427f98]\\n??:? void tmposa_wqzt.__modtest() [0x42826c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5a7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b43a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306c5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430651]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b411]\\n??:? runModuleUnitTests [0x42c37d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289b0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428937]\\n??:? _d_run_main [0x4288a2]\\n??:? main [0x42827f]\\\
    n??:? __libc_start_main [0x12e73554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    auto\
    \ result = tuple(number + need, remaining - need);\n    if (result[1] < 0) \n\
    \    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_gj0trxu.d(45): Error: cannot implicitly convert expression `result`\
    \ of type `Tuple!(long, long)` to `long[]`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmp_gj0trxu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] += result[1];\n  \
    \      result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    //\
    \ your code here\n    long[] result = new long[2];\n    if(number < 0 || need\
    \ < 0 || remaining < 0)\n        return result;\n    if(number > 1000 || need\
    \ > 1000 || remaining > 1000)\n        return result;\n    if(remaining < need)\n\
    \    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    else\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\
    \n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L,\
    \ 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L,\
    \ 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n   \
    \ assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining >= need)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining < need)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need > remaining)\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n      \
    \  result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return\
    \ [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\n\
    unittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) ==\
    \ [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsfdhp8md.d(39): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpsfdhp8md.d(39): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpsfdhp8md.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number + need <= remaining)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - (number + need);\n    }\n\
    \    else\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n\
    \    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L,\
    \ 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L,\
    \ 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n   \
    \ assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8dv4efoz.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284bd]\\n??:? void tmp8dv4efoz.__unittest_L52_C1()\
    \ [0x427f6c]\\n??:? void tmp8dv4efoz.__modtest() [0x428240]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c577]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b40a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430695]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430621]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b3e1]\\n??:? runModuleUnitTests [0x42c34d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428980]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428907]\\n??:? _d_run_main [0x428872]\\n??:? main [0x428253]\\\
    n??:? __libc_start_main [0xb8d57554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number >= 0 && number <= 1000 && need >= 0 &&\
    \ need <= 1000 && remaining >= 0 && remaining <= 1000)\n    {\n        if(need\
    \ > remaining)\n        {\n            result[0] = number + remaining;\n     \
    \       result[1] = 0;\n        }\n        else\n        {\n            result[0]\
    \ = number + need;\n            result[1] = remaining - need;\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return\
    \ [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\n\
    unittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) ==\
    \ [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpao5g69l3.d(39): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpao5g69l3.d(39): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpao5g69l3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    //\
    \ Your code here\n    long[] result = new long[2];\n    if(remaining < need)\n\
    \    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    else\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\
    \n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L,\
    \ 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L,\
    \ 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n   \
    \ assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number > 1000 || need > 1000 || remaining > 1000)\n\
    \        return result;\n    if(number < 0 || need < 0 || remaining < 0)\n   \
    \     return result;\n    if(remaining < need)\n    {\n        result[0] = number\
    \ + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
    \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
    \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n\
    \    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L,\
    \ 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need\
    \ > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if(need <= remaining)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    if (remaining >= need)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L,\
    \ 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n \
    \   assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L,\
    \ 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L,\
    \ 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n    but now you need\
    \ to eat more carrots to complete the day's meals.\n    you should return an array\
    \ of [ total number of eaten carrots after your meals,\n                     \
    \               the number of carrots left after your meals ]\n    if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n    \n    Example:\n    >>> eat(5L, 6L)\n    [11L, 4L]\n    >>>\
    \ eat(4L, 8L)\n    [12L, 1L]\n    >>> eat(1L, 10L)\n    [11L, 0L]\n    >>> eat(2L,\
    \ 11L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun\
    \ :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if (result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L,\
    \ 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n\
    \    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L,\
    \ 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
