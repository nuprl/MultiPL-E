name: HumanEval_156_int_to_mini_roman
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static\
    \ long[] values = [1, 5, 10, 50, 100, 500, 1000];\n    string result = \"\";\n\
    \    long remainder = number;\n    long index = roman.length - 1;\n    while (remainder\
    \ > 0) {\n        long value = values[index];\n        long count = remainder\
    \ / value;\n        remainder %= value;\n        if (count == 4) {\n         \
    \   result ~= roman[index] ~ roman[index + 1];\n        } else {\n           \
    \ result ~= roman[index] * count;\n        }\n        index -= 2;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpybqipsas.d(32): Error: incompatible types for `(roman[cast(ulong)index])\
    \ * (count)`: `string` and `long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpybqipsas.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_digits = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic_digits\
    \ = [1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n   \
    \ string result = \"\";\n    foreach(i, roman_digit; roman_digits) \n    {\n \
    \       while(number >= arabic_digits[i]) \n        {\n            number -= arabic_digits[i];\n\
    \            result ~= roman_digit;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    long[] values = [1000L, 900L, 500L, 400L, 100L, 90L, 50L,\
    \ 40L, 10L, 9L, 5L, 4L, 1L];\n    string[] numerals = [\"m\", \"cm\", \"d\", \"\
    cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n  \
    \  foreach(i, value; values)\n    {\n        while(number >= value)\n        {\n\
    \            result ~= numerals[i];\n            number -= value;\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] ones = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\"];\n    static string[10] tens = [\"\", \"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10] hundreds\
    \ = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"\
    cm\"];\n    static string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n   \
    \ return thousands[number / 1000] ~ hundreds[(number / 100) % 10] ~ tens[(number\
    \ / 10) % 10] ~ ones[number % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] decimal_numerals\
    \ = [1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n   \
    \ string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n\
    \        while(number >= decimal_numerals[i])\n        {\n            result ~=\
    \ roman_numeral;\n            number -= decimal_numerals[i];\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto roman_numerals = [\n        tuple(1L, \"i\"),\n        tuple(4L,\
    \ \"iv\"),\n        tuple(5L, \"v\"),\n        tuple(9L, \"ix\"),\n        tuple(10L,\
    \ \"x\"),\n        tuple(40L, \"xl\"),\n        tuple(50L, \"l\"),\n        tuple(90L,\
    \ \"xc\"),\n        tuple(100L, \"c\"),\n        tuple(400L, \"cd\"),\n      \
    \  tuple(500L, \"d\"),\n        tuple(900L, \"cm\"),\n        tuple(1000L, \"\
    m\")\n    ];\n    foreach(i; roman_numerals) \n    {\n        auto numeral = i[1];\n\
    \        auto value = i[0];\n        while(number >= value) \n        {\n    \
    \        result ~= numeral;\n            number -= value;\n        }\n    }\n\
    \    return result;\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpli1sbbtc.d(48): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpli1sbbtc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    const\
    \ int[] roman_numerals = [\n        [1000, \"m\"],\n        [900, \"cm\"],\n \
    \       [500, \"d\"],\n        [400, \"cd\"],\n        [100, \"c\"],\n       \
    \ [90, \"xc\"],\n        [50, \"l\"],\n        [40, \"xl\"],\n        [10, \"\
    x\"],\n        [9, \"ix\"],\n        [5, \"v\"],\n        [4, \"iv\"],\n     \
    \   [1, \"i\"]\n    ];\n    string result = \"\";\n    foreach(int[] pair; roman_numerals)\
    \ {\n        while(number >= pair[0]) {\n            result ~= pair[1];\n    \
    \        number -= pair[0];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpchpzakp1.d(21): Error: incompatible types for `(1000) : (\"m\"\
    )`: `int` and `string`\\n/tmp/tmpchpzakp1.d(22): Error: incompatible types for\
    \ `(900) : (\"cm\")`: `int` and `string`\\n/tmp/tmpchpzakp1.d(23): Error: incompatible\
    \ types for `(500) : (\"d\")`: `int` and `string`\\n/tmp/tmpchpzakp1.d(24): Error:\
    \ incompatible types for `(400) : (\"cd\")`: `int` and `string`\\n/tmp/tmpchpzakp1.d(25):\
    \ Error: incompatible types for `(100) : (\"c\")`: `int` and `string`\\n/tmp/tmpchpzakp1.d(26):\
    \ Error: incompatible types for `(90) : (\"xc\")`: `int` and `string`\\n/tmp/tmpchpzakp1.d(27):\
    \ Error: incompatible types for `(50) : (\"l\")`: `int` and `string`\\n/tmp/tmpchpzakp1.d(28):\
    \ Error: incompatible types for `(40) : (\"xl\")`: `int` and `string`\\n/tmp/tmpchpzakp1.d(29):\
    \ Error: incompatible types for `(10) : (\"x\")`: `int` and `string`\\n/tmp/tmpchpzakp1.d(30):\
    \ Error: incompatible types for `(9) : (\"ix\")`: `int` and `string`\\n/tmp/tmpchpzakp1.d(31):\
    \ Error: incompatible types for `(5) : (\"v\")`: `int` and `string`\\n/tmp/tmpchpzakp1.d(32):\
    \ Error: incompatible types for `(4) : (\"iv\")`: `int` and `string`\\n/tmp/tmpchpzakp1.d(33):\
    \ Error: incompatible types for `(1) : (\"i\")`: `int` and `string`\\n/tmp/tmpchpzakp1.d(36):\
    \ Error: cannot implicitly convert expression `__r73[__key74]` of type `const(int)`\
    \ to `int[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpchpzakp1.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    // TODO: implement\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8jnhcfj6.d(28): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428135]\\n??:? void tmp8jnhcfj6.__unittest_L24_C1()\
    \ [0x427abc]\\n??:? void tmp8jnhcfj6.__modtest() [0x427eb8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bddf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42acee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fe05]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4302b4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fd91]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42acc5]\\n??:? runModuleUnitTests [0x42bbb5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428584]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42850b]\\n??:? _d_run_main [0x428476]\\n??:? main [0x427ecb]\\\
    n??:? __libc_start_main [0xb8c8b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tens_of_thousands = [\n       \
    \ \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_thousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_tens_of_millions = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n\
    \    static string[4] roman_hundreds_of_millions = [\n        \"c\", \"cc\", \"\
    ccc\", \"cd\"\n    ];\n    static string[4] roman_billions = [\n        \"m\"\
    , \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_tens_of_billions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_billions\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0sv45qqq.d(60): Error: found `unittest` when expecting `]`\\\
    n/tmp/tmp0sv45qqq.d(61): Error: no identifier for declarator `string[4]`\\n/tmp/tmp0sv45qqq.d(79):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0sv45qqq.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"\
    v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(1 <= number && number <= 1000);\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_digits[number % 10];\n}\n/*\nunittest\n{\n \
    \   alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmzzegruv.d(38): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmzzegruv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\n        \"i\", \"ii\", \"\
    iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static\
    \ string[10] roman_tens = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"\
    lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\"\
    , \"cm\", \"m\"\n    ];\n    static string[4] roman_thousands = [\n        \"\
    m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    if (number > 0 && number <= 1000)\
    \ {\n        if (number < 10) {\n            result = roman_numerals[number -\
    \ 1];\n        } else if (number < 100) {\n            result = roman_tens[number\
    \ / 10 - 1];\n            if (number % 10 != 0) {\n                result ~= roman_numerals[number\
    \ % 10 - 1];\n            }\n        } else if (number < 1000) {\n           \
    \ result = roman_hundreds[number / 100 - 1];\n            if (number % 100 !=\
    \ 0) {\n                result ~= roman_tens[(number % 100) / 10 - 1];\n     \
    \           if (number % 10 != 0) {\n                    result ~= roman_numerals[number\
    \ % 10 - 1];\n                }\n            }\n        } else {\n           \
    \ result = roman_thousands[number / 1000 - 1];\n            if (number % 1000\
    \ != 0) {\n                result ~= roman_hundreds[(number % 1000) / 100 - 1];\n\
    \                if (number % 100 != 0) {\n                    result ~= roman_tens[(number\
    \ % 100) / 10 - 1];\n                    if (number % 10 != 0) {\n           \
    \             result ~= roman_numerals[number % 10 - 1];\n                   \
    \ }\n                }\n            }\n        }\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptki6j1b3.d(61): Error: found `unittest` instead of statement\\\
    n/tmp/tmptki6j1b3.d(80): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptki6j1b3.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    auto roman = tuple(\n        tuple(\"m\", 1000L),\n    \
    \    tuple(\"d\", 500L),\n        tuple(\"c\", 100L),\n        tuple(\"l\", 50L),\n\
    \        tuple(\"x\", 10L),\n        tuple(\"v\", 5L),\n        tuple(\"i\", 1L)\n\
    \    );\n    foreach(i, ref roman_digit; roman)\n    {\n        auto roman_letter\
    \ = roman_digit[0];\n        auto roman_value = roman_digit[1];\n        auto\
    \ count = number / roman_value;\n        number %= roman_value;\n        if (count\
    \ == 4)\n        {\n            if (i + 1 < roman.length)\n            {\n   \
    \             auto next_roman_letter = roman[i + 1][0];\n                result\
    \ ~= roman_letter ~ next_roman_letter;\n            }\n            else\n    \
    \        {\n                result ~= roman_letter;\n            }\n        }\n\
    \        else\n        {\n            result ~= repeat(roman_letter, count);\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu579_0jt.d(50): Error: undefined identifier `repeat`\\n/tmp/tmpu579_0jt.d(50):\
    \ Error: undefined identifier `repeat`\\n/tmp/tmpu579_0jt.d(50): Error: undefined\
    \ identifier `repeat`\\n/tmp/tmpu579_0jt.d(50): Error: undefined identifier `repeat`\\\
    n/tmp/tmpu579_0jt.d(50): Error: undefined identifier `repeat`\\n/tmp/tmpu579_0jt.d(50):\
    \ Error: undefined identifier `repeat`\\n/tmp/tmpu579_0jt.d(40): Error: array\
    \ index `[7]` is outside array bounds `[0 .. 7]`\\n/tmp/tmpu579_0jt.d(50): Error:\
    \ undefined identifier `repeat`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpu579_0jt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\n/*\nunittest\n{\n  \
    \  alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdm2hjvnp.d(33): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdm2hjvnp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number\
    \ >= numbers[i])\n        {\n            result ~= roman_numeral;\n          \
    \  number -= numbers[i];\n        }\n    }\n    return result;\n}\n/*\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1kph0_jy.d(33): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1kph0_jy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvqa9p6y7.d(31): Error: expression expected, not `unittest`\\\
    n/tmp/tmpvqa9p6y7.d(32): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmpvqa9p6y7.d(50): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmpvqa9p6y7.d(50): Error: semicolon expected, not `main`\\\
    n/tmp/tmpvqa9p6y7.d(50): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvqa9p6y7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    int[] nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10,\
    \ 9, 5, 4, 1];\n    string[] romans = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    for (int i = 0;\
    \ i < nums.length; i++) \n    {\n        while (number >= nums[i]) \n        {\n\
    \            result += romans[i];\n            number -= nums[i];\n        }\n\
    \    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp364b2cf1.d(33): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp364b2cf1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    string result = \"\";\n    if (number > 0) {\n        result\
    \ ~= roman_thousands[cast(int)floor(number / 1000)];\n        number %= 1000;\n\
    \        result ~= roman_hundreds[cast(int)floor(number / 100)];\n        number\
    \ %= 100;\n        result ~= roman_tens[cast(int)floor(number / 10)];\n      \
    \  number %= 10;\n        result ~= roman_numerals[cast(int)number];\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5i3101ag.d(34): Error: `std.math.floor` called with argument\
    \ types `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4394):\
    \     `std.math.floor(real x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4487):\
    \     `std.math.floor(float x)`\\n/tmp/tmp5i3101ag.d(36): Error: `std.math.floor`\
    \ called with argument types `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4394):\
    \     `std.math.floor(real x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4487):\
    \     `std.math.floor(float x)`\\n/tmp/tmp5i3101ag.d(38): Error: `std.math.floor`\
    \ called with argument types `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4394):\
    \     `std.math.floor(real x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4487):\
    \     `std.math.floor(float x)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp5i3101ag.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    long[] digits = [1000L, 900L, 500L, 400L, 100L, 90L, 50L,\
    \ 40L, 10L, 9L, 5L, 4L, 1L];\n    string[] roman = [\"m\", \"cm\", \"d\", \"cd\"\
    , \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    foreach(i,\
    \ digit; digits)\n    {\n        while(number >= digit)\n        {\n         \
    \   result ~= roman[i];\n            number -= digit;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp09q1xqq0.d(31): Error: expression expected, not `unittest`\\\
    n/tmp/tmp09q1xqq0.d(32): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmp09q1xqq0.d(50): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmp09q1xqq0.d(50): Error: semicolon expected, not `main`\\\
    n/tmp/tmp09q1xqq0.d(50): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp09q1xqq0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\"i\", \"x\", \"c\", \"m\", \"v\", \"l\", \"d\"];\n\
    \    string result = \"\";\n    int i = 0;\n    while (number > 0) {\n       \
    \ int digit = number % 10;\n        if (digit == 9) {\n            result = roman_digits[i]\
    \ ~ roman_digits[i + 2] ~ result;\n        } else if (digit == 4) {\n        \
    \    result = roman_digits[i] ~ roman_digits[i + 1] ~ result;\n        } else\
    \ {\n            if (digit >= 5) {\n                result = roman_digits[i +\
    \ 1] ~ result;\n                digit -= 5;\n            }\n            result\
    \ = repeat(roman_digits[i], digit) ~ result;\n        }\n        number /= 10;\n\
    \        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmu5b25hg.d(34): Error: undefined identifier `repeat`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmu5b25hg.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"\
    v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(1 <= number && number <= 1000);\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_digits[number % 10];\n}\n/*\nunittest\n{\n \
    \   alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0s1vtvi1.d(38): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0s1vtvi1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    static string[] roman_numerals = [\"m\", \"cm\", \"d\",\
    \ \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n\
    \    static long[] numbers = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5,\
    \ 4, 1];\n    for (size_t i = 0; i < numbers.length; i++) \n    {\n        while\
    \ (number >= numbers[i]) \n        {\n            result ~= roman_numerals[i];\n\
    \            number -= numbers[i];\n        }\n    }\n    return result;\n}\n\
    /*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplrf2smdg.d(33): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplrf2smdg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ decimal_numerals = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5,\
    \ 4, 1\n    ];\n    string result = \"\";\n    foreach(i, numeral; roman_numerals)\
    \ {\n        while(number >= decimal_numerals[i]) {\n            result ~= numeral;\n\
    \            number -= decimal_numerals[i];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tens_of_thousands = [\n       \
    \ \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_thousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_tens_of_millions = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n\
    \    static string[4] roman_hundreds_of_millions = [\n        \"c\", \"cc\", \"\
    ccc\", \"cd\"\n    ];\n    static string[4] roman_billions = [\n        \"m\"\
    , \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_tens_of_billions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_billions\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmy3mbn6f.d(60): Error: found `unittest` when expecting `]`\\\
    n/tmp/tmpmy3mbn6f.d(61): Error: no identifier for declarator `string[4]`\\n/tmp/tmpmy3mbn6f.d(79):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmy3mbn6f.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [ \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"\
    l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\" ];\n    static long[] decimal_numerals\
    \ = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ];\n    string result\
    \ = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number\
    \ >= decimal_numerals[i])\n        {\n            result ~= roman_numeral;\n \
    \           number -= decimal_numerals[i];\n        }\n    }\n    return result;\n\
    }\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3hthvqi3.d(33): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3hthvqi3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] roman_numerals_values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] roman_numerals_values_sorted\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] roman_numerals_values_sorted_reversed\
    \ = [1000, 500, 100, 50, 10, 5, 1];\n    static const int[] roman_numerals_values_sorted_reversed_length\
    \ = [1, 1, 2, 2, 3, 3, 4];\n    static const string[] roman_numerals_sorted_reversed\
    \ = [\"m\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\"\
    , \"iv\", \"i\"];\n    static const string[] roman_numerals_sorted_reversed_length\
    \ = [\"m\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\"\
    , \"iv\", \"i\"];\n    static const int[] roman_numerals_values_sorted_reversed_length_reversed\
    \ = [4, 3, 3, 2, 2, 1, 1];\n    static const string[] roman_numerals_sorted_reversed_length_reversed\
    \ = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\"\
    , \"d\", \"m\"];\n    static const string[] roman_numerals_sorted_reversed_length_reversed_length\
    \ = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\"\
    , \"d\", \"m\"];\n    static const int[] roman_numerals_values_sorted_reversed_length_reversed_length\
    \ = [1, 1, 2, 2, 3, 3, 4];\n    static const string[] roman_numerals_sorted_\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptmcvfyh5.d(32): Error: semicolon expected, not `unittest`\\n/tmp/tmptmcvfyh5.d(32):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmptmcvfyh5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string roman_numerals = \"ivxlcdm\";\n    static int[] values = [1, 5, 10, 50,\
    \ 100, 500, 1000];\n    static string[] numerals = [\"i\", \"v\", \"x\", \"l\"\
    , \"c\", \"d\", \"m\"];\n    static int[] numeral_values = [1, 5, 10, 50, 100,\
    \ 500, 1000];\n    static string[] numeral_strings = [\"i\", \"v\", \"x\", \"\
    l\", \"c\", \"d\", \"m\"];\n    static int[] numeral_values = [1, 5, 10, 50, 100,\
    \ 500, 1000];\n    static string[] numeral_strings = [\"i\", \"v\", \"x\", \"\
    l\", \"c\", \"d\", \"m\"];\n    static int[] numeral_values = [1, 5, 10, 50, 100,\
    \ 500, 1000];\n    static string[] numeral_strings = [\"i\", \"v\", \"x\", \"\
    l\", \"c\", \"d\", \"m\"];\n    static int[] numeral_values = [1, 5, 10, 50, 100,\
    \ 500, 1000];\n    static string[] numeral_strings = [\"i\", \"v\", \"x\", \"\
    l\", \"c\", \"d\", \"m\"];\n    static int[] numeral_values = [1, 5, 10, 50, 100,\
    \ 500, 1000];\n    static string[] numeral_strings = [\"i\", \"v\", \"x\", \"\
    l\", \"c\", \"d\", \"m\"];\n    static int[] numeral_values = [1, 5, 10, 50, 100,\
    \ 500, 1000];\n    static string[] numeral_strings = [\"i\", \"v\", \"x\", \"\
    l\", \"c\", \"d\", \"m\"];\n    static int[] numeral_values = [1, 5, 10, 50, 100,\
    \ 500, 1000];\n    static string[] numeral_strings = [\"i\", \"v\", \"x\", \"\
    l\", \"c\", \"d\", \"m\"];\n    static int[] numeral_values = [1, 5, 10, 50, 100,\
    \ 500, 1000];\n    static string[] numeral_strings = [\"i\", \"v\",\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfmiuy4tw.d(39): Error: expression expected, not `unittest`\\\
    n/tmp/tmpfmiuy4tw.d(40): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmpfmiuy4tw.d(58): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmpfmiuy4tw.d(58): Error: semicolon expected, not `main`\\\
    n/tmp/tmpfmiuy4tw.d(58): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmiuy4tw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ immutable int[] values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4,\
    \ 1];\n    static immutable string[] numerals = [\"m\", \"cm\", \"d\", \"cd\"\
    , \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    string\
    \ result = \"\";\n    foreach(i, v; values)\n    {\n        while(number >= v)\n\
    \        {\n            result ~= numerals[i];\n            number -= v;\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    for (int i = 0; i < values.length; i++)\n    {\n        while (number >=\
    \ values[i])\n        {\n            number -= values[i];\n            result\
    \ ~= roman_numerals[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [ \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"\
    l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\" ];\n    static long[] decimal_numerals\
    \ = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ];\n    string result\
    \ = \"\";\n    foreach(i, numeral; zip(decimal_numerals, roman_numerals))\n  \
    \  {\n        while(number >= numeral[0])\n        {\n            result ~= numeral[1];\n\
    \            number -= numeral[0];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9od4cj2q.d(23): Error: undefined identifier `zip`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9od4cj2q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    auto roman_numerals = tuple(\n        tuple(\"m\", 1000L),\n\
    \        tuple(\"d\", 500L),\n        tuple(\"c\", 100L),\n        tuple(\"l\"\
    , 50L),\n        tuple(\"x\", 10L),\n        tuple(\"v\", 5L),\n        tuple(\"\
    i\", 1L)\n    );\n    foreach(i, roman_numeral; roman_numerals)\n    {\n     \
    \   auto numeral = roman_numeral[0];\n        auto value = roman_numeral[1];\n\
    \        auto quotient = number / value;\n        if(quotient > 0)\n        {\n\
    \            result ~= numeral ~= repeat(numeral, quotient - 1);\n           \
    \ number -= quotient * value;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyrklie38.d(37): Error: undefined identifier `repeat`\\n/tmp/tmpyrklie38.d(37):\
    \ Error: undefined identifier `repeat`\\n/tmp/tmpyrklie38.d(37): Error: undefined\
    \ identifier `repeat`\\n/tmp/tmpyrklie38.d(37): Error: undefined identifier `repeat`\\\
    n/tmp/tmpyrklie38.d(37): Error: undefined identifier `repeat`\\n/tmp/tmpyrklie38.d(37):\
    \ Error: undefined identifier `repeat`\\n/tmp/tmpyrklie38.d(37): Error: undefined\
    \ identifier `repeat`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyrklie38.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[int] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[int] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[int] roman_hundreds = [\n        \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static\
    \ string[int] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n  \
    \  static string[int] roman_ten_thousands = [\n        \"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static string[int]\
    \ roman_hundred_thousands = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\",\
    \ \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[int] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n    static string[int] roman_ten_millions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[int] roman_hundred_millions = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n\
    \    static string[int] roman_billions = [\n        \"m\", \"mm\", \"mmm\"\n \
    \   ];\n    static string[int] roman_ten_billions = [\n        \"x\", \"xx\",\
    \ \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[int] roman_hundred_billions\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplp9ww5dz.d(54): Error: semicolon expected, not `unittest`\\n/tmp/tmplp9ww5dz.d(54):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmplp9ww5dz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_digits = \"ixcm\";\n    static const string roman_fives =\
    \ \"vld\";\n    static const string roman_tens = \"xlcdm\";\n    static const\
    \ string roman_fifties = \"vld\";\n    static const string roman_hundreds = \"\
    xcml\";\n    static const string roman_five_hundreds = \"vld\";\n    static const\
    \ string roman_thousands = \"mxcl\";\n    static const string roman_five_thousands\
    \ = \"vld\";\n    static const string roman_tens_of_thousands = \"xlcdm\";\n \
    \   static const string roman_fifties_of_thousands = \"vld\";\n    static const\
    \ string roman_hundreds_of_thousands = \"xcml\";\n    static const string roman_five_hundreds_of_thousands\
    \ = \"vld\";\n    static const string roman_millions = \"mxcl\";\n    static const\
    \ string roman_five_millions = \"vld\";\n    static const string roman_tens_of_millions\
    \ = \"xlcdm\";\n    static const string roman_fifties_of_millions = \"vld\";\n\
    \    static const string roman_hundreds_of_millions = \"xcml\";\n    static const\
    \ string roman_five_hundreds_of_millions = \"vld\";\n    static const string roman_billions\
    \ = \"mxcl\";\n    static const string roman_five_billions = \"vld\";\n    static\
    \ const string roman_tens_of_billions = \"xlcdm\";\n    static const string roman_fifties_of_billions\
    \ = \"vld\";\n    static const string roman_hundreds_of_billions = \"xcml\";\n\
    \    static const string roman_five_hundreds_of_billions = \"vld\";\n    static\
    \ const string roman_trillions = \"mxcl\";\n    static const string roman_five_trillions\
    \ = \"vld\";\n    static const string roman_tens_of_trillions = \"xlcdm\";\n \
    \   static const string roman_fift\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7t1c8gng.d(48): Error: semicolon expected, not `unittest`\\n/tmp/tmp7t1c8gng.d(48):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp7t1c8gng.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[long] roman_numerals = [\n        1L: \"i\",\n        4L: \"iv\",\n \
    \       5L: \"v\",\n        9L: \"ix\",\n        10L: \"x\",\n        40L: \"\
    xl\",\n        50L: \"l\",\n        90L: \"xc\",\n        100L: \"c\",\n     \
    \   400L: \"cd\",\n        500L: \"d\",\n        900L: \"cm\",\n        1000L:\
    \ \"m\"\n    ];\n    static long[] roman_numerals_keys = roman_numerals.keys.array;\n\
    \    static long[] roman_numerals_keys_sorted = roman_numerals_keys.sort;\n  \
    \  static long[] roman_numerals_keys_sorted_reversed = roman_numerals_keys_sorted.reverse;\n\
    \    static long[] roman_numerals_keys_sorted_reversed_without_1000 = roman_numerals_keys_sorted_reversed[0..$-1];\n\
    \    static long[] roman_numerals_keys_sorted_reversed_without_1000_and_500 =\
    \ roman_numerals_keys_sorted_reversed_without_1000[0..$-1];\n    static long[]\
    \ roman_numerals_keys_sorted_reversed_without_1000_and_500_and_100 = roman_numerals_keys_sorted_reversed_without_1000_and_500[0..$-1];\n\
    \    static long[] roman_numerals_keys_sorted_reversed_without_1000_and_500_and_100_and_50\
    \ = roman_numerals_keys_sorted_reversed_without_1000_and_500_and_100[0..$-1];\n\
    \    static long[] roman_numerals_keys_sorted_reversed_without_1000_and_500_and_100_and_50_and_10\
    \ = roman_numerals_keys_sorted_reversed_without_1000_and_\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzzl3p6c5.d(43): Error: semicolon expected, not `unittest`\\n/tmp/tmpzzl3p6c5.d(43):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpzzl3p6c5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    string result = \"\";\n    if (number > 1000)\n    {\n\
    \        result ~= roman_thousands[number / 1000 - 1];\n        number %= 1000;\n\
    \    }\n    if (number > 100)\n    {\n        result ~= roman_hundreds[number\
    \ / 100 - 1];\n        number %= 100;\n    }\n    if (number > 10)\n    {\n  \
    \      result ~= roman_tens[number / 10 - 1];\n        number %= 10;\n    }\n\
    \    if (number > 0)\n    {\n        result ~= roman_numerals[number - 1];\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\n/*\nunittest\n{\n  \
    \  alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc0cy_rtp.d(33): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc0cy_rtp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, r; roman)\n    {\n        while(number >= arabic[i])\n        {\n\
    \            number -= arabic[i];\n            result ~= r;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] values =\
    \ [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const string[] numerals =\
    \ [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const string[]\
    \ numerals_4 = [\"iv\", \"xl\", \"cd\"];\n    static const string[] numerals_9\
    \ = [\"ix\", \"xc\", \"cm\"];\n    static const string[] numerals_40 = [\"xl\"\
    , \"cd\"];\n    static const string[] numerals_90 = [\"xc\", \"cm\"];\n    static\
    \ const string[] numerals_400 = [\"cd\"];\n    static const string[] numerals_900\
    \ = [\"cm\"];\n    static const long[] values_4 = [4L, 40L, 400L];\n    static\
    \ const long[] values_9 = [9L, 90L, 900L];\n    static const long[] values_40\
    \ = [40L, 400L];\n    static const long[] values_90 = [90L, 900L];\n    static\
    \ const long[] values_400 = [400L];\n    static const long[] values_900 = [900L];\n\
    \    static const long[] values_4_9 = [4L, 9L, 40L, 90L, 400L, 900L];\n    static\
    \ const long[] values_4_9_40 = [4L, 9L, 40L, 90L, 400L];\n    static const long[]\
    \ values_4_9_40_90 = [4L, 9L, 40L, 90L];\n    static const long[] values_4_9_40_90_400\
    \ = [4L, 9L, 40L, 90L, 400L];\n    static const long[] values_4_9_40_90_400_900\
    \ = [4L, 9L, 40L, 90L, 400L, 900L];\n    static const long[] values_4_9_40_90_400_900_1000\
    \ = [4L, 9L, 40L, 90L, 400L, 900L, 1000L];\n    static const long[] values_4_9\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppw_r34cu.d(42): Error: semicolon expected, not `unittest`\\n/tmp/tmppw_r34cu.d(42):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppw_r34cu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpph0entzp.d(31): Error: expression expected, not `unittest`\\\
    n/tmp/tmpph0entzp.d(32): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmpph0entzp.d(50): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmpph0entzp.d(50): Error: semicolon expected, not `main`\\\
    n/tmp/tmpph0entzp.d(50): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpph0entzp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[4] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_tens_of_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_hundreds_of_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_millions =\
    \ [\"m\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_tens_of_millions\
    \ = [\"m\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_hundreds_of_millions\
    \ = [\"m\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_billions =\
    \ [\"m\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_tens_of_billions\
    \ = [\"m\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_hundreds_of_billions\
    \ = [\"m\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_trillions\
    \ = [\"m\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_tens_of_trillions\
    \ = [\"m\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_hundreds_of_trillions\
    \ = [\"m\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_quadrillion\
    \ = [\"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_t9_u7ho.d(35): Error: unterminated string constant starting\
    \ at /tmp/tmp_t9_u7ho.d(53)\\n/tmp/tmp_t9_u7ho.d(40): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmp_t9_u7ho.d(40): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmp_t9_u7ho.d(41):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmp_t9_u7ho.d(42):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmp_t9_u7ho.d(43):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmp_t9_u7ho.d(44):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmp_t9_u7ho.d(45):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmp_t9_u7ho.d(46):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmp_t9_u7ho.d(47):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmp_t9_u7ho.d(48):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmp_t9_u7ho.d(49):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmp_t9_u7ho.d(50):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmp_t9_u7ho.d(51):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp_t9_u7ho.d(52):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmp_t9_u7ho.d(53):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp_t9_u7ho.d(55):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmp_t9_u7ho.d(55):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_t9_u7ho.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.conv : to;\n    import std.range : iota;\n    import std.algorithm : map;\n\
    \    import std.array : array;\n    import std.string : format;\n    import std.math\
    \ : pow;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tupleOf;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n   \nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd8kg3a9q.d(72): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd8kg3a9q.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] values =\
    \ [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] divisors = [1L,\
    \ 10L, 100L, 1000L];\n    static const long[] multipliers = [1L, 10L, 100L, 1000L];\n\
    \    static const string[] roman_digits = [\"i\", \"v\", \"x\", \"l\", \"c\",\
    \ \"d\", \"m\"];\n    static const string[] roman_fives = [\"v\", \"l\", \"d\"\
    ];\n    static const string[] roman_tens = [\"x\", \"c\", \"m\"];\n    static\
    \ const string[] roman_fifties = [\"l\", \"d\", \"m\"];\n    static const string[]\
    \ roman_hundreds = [\"c\", \"m\", \"m\"];\n    static const string[] roman_five_hundreds\
    \ = [\"d\", \"m\", \"m\"];\n    static const string[] roman_thousands = [\"m\"\
    , \"m\", \"m\"];\n    static const string[] roman_five_thousands = [\"m\", \"\
    m\", \"m\"];\n    static const string[] roman_tens_of_thousands = [\"m\", \"m\"\
    , \"m\"];\n    static const string[] roman_fifties_of_thousands = [\"m\", \"m\"\
    , \"m\"];\n    static const string[] roman_hundreds_of_thousands = [\"m\", \"\
    m\", \"m\"];\n    static const string[] roman_five_hundreds_of_thousands = [\"\
    m\", \"m\", \"m\"];\n    static const string[] roman_millions = [\"m\", \"m\"\
    , \"m\"];\n    static const string[] roman_five_millions = [\"m\", \"m\", \"m\"\
    ];\n    static const string[] roman_tens_of_millions = [\"m\", \"m\", \"m\"];\n\
    \    static const string[] roman_fifties_of_millions = [\"m\", \"m\", \"m\"];\n\
    \    static const string[] roman_hundreds\nunittest\n{\n    alias candidate =\
    \ int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp72kbrdgi.d(41): Error: semicolon expected, not `unittest`\\n/tmp/tmp72kbrdgi.d(41):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp72kbrdgi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ decimal_numerals = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L,\
    \ 10L, 9L, 5L, 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, numeral;\
    \ roman_numerals) {\n        while(number >= decimal_numerals[i]) {\n        \
    \    result ~= numeral;\n            number -= decimal_numerals[i];\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"\
    iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10]\
    \ roman_tens = [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"];\n    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10]\
    \ roman_thousands = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"\
    vmmm\", \"mx\", \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n   \
    \ static string[10] roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_millions = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_billions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_billions = [\"x\", \"\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppknd_gw7.d(31): Error: unterminated string constant starting\
    \ at /tmp/tmppknd_gw7.d(49)\\n/tmp/tmppknd_gw7.d(36): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmppknd_gw7.d(36): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmppknd_gw7.d(37):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmppknd_gw7.d(38):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmppknd_gw7.d(39):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmppknd_gw7.d(40):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmppknd_gw7.d(41):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmppknd_gw7.d(42):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmppknd_gw7.d(43):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmppknd_gw7.d(44):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmppknd_gw7.d(45):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmppknd_gw7.d(46):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmppknd_gw7.d(47):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmppknd_gw7.d(48):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmppknd_gw7.d(49):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmppknd_gw7.d(51):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmppknd_gw7.d(51):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppknd_gw7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[10] roman_tenthousands = [\n        \"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n \
    \   ];\n    static string[10] roman_hundredthousands = [\n        \"c\", \"cc\"\
    , \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n \
    \   static string[10] roman_millions = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\
    , \"mmmmm\", \"mmmmmm\", \"mmmmmmm\", \"mmmmmmmm\", \"mmmmmmmmm\", \"mmmmmmmmmm\"\
    \n    ];\n    static string[10] roman_tenmillions = [\n        \"x\", \"xx\",\
    \ \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n \
    \   static string[10] roman_hundredmillions = [\n        \"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static\
    \ string[10] roman_billions = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\", \"\
    mmmmm\", \"mmmmmm\", \"mmmmmmm\", \"mmmmmmmm\", \"mmmm\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwpjn32sr.d(47): Error: unterminated string constant starting\
    \ at /tmp/tmpwpjn32sr.d(66)\\n/tmp/tmpwpjn32sr.d(53): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmpwpjn32sr.d(53): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmpwpjn32sr.d(54):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmpwpjn32sr.d(55):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmpwpjn32sr.d(56):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmpwpjn32sr.d(57):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmpwpjn32sr.d(58):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmpwpjn32sr.d(59):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmpwpjn32sr.d(60):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmpwpjn32sr.d(61):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmpwpjn32sr.d(62):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmpwpjn32sr.d(63):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmpwpjn32sr.d(64):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpwpjn32sr.d(65):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmpwpjn32sr.d(66):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpwpjn32sr.d(68):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmpwpjn32sr.d(68):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwpjn32sr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman; roman_numerals)\n    {\n        while(number >= values[i])\n\
    \        {\n            result ~= roman;\n            number -= values[i];\n \
    \       }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    assert(number >= 1 && number <= 1000);\n\
    \    return roman_thousands[number / 1000] ~ roman_hundreds[(number / 100) % 10]\
    \ ~ roman_tens[(number / 10) % 10] ~ roman_numerals[number % 10];\n}\n/*\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp76n11nv2.d(27): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp76n11nv2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n\
    \    static long[] values = [1, 5, 10, 50, 100, 500, 1000];\n    static long[]\
    \ divisors = [1, 10, 100, 1000];\n    static long[] multipliers = [1, 10, 100,\
    \ 1000];\n    string result = \"\";\n    foreach(index, divisor; divisors)\n \
    \   {\n        long digit = (number / divisor) % 10;\n        if(digit == 0) continue;\n\
    \        long multiplier = multipliers[index];\n        long value = digit * multiplier;\n\
    \        if(value == 4 * multiplier)\n        {\n            result ~= roman_numerals[index\
    \ * 2];\n            result ~= roman_numerals[index * 2 + 1];\n        }\n   \
    \     else if(value == 9 * multiplier)\n        {\n            result ~= roman_numerals[index\
    \ * 2];\n            result ~= roman_numerals[index * 2 + 2];\n        }\n   \
    \     else\n        {\n            if(value >= 5 * multiplier)\n            {\n\
    \                result ~= roman_numerals[index * 2 + 1];\n                value\
    \ -= 5 * multiplier;\n            }\n            for(long i = 0; i < value / multiplier;\
    \ i++)\n            {\n                result ~= roman_numerals[index * 2];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpw6uppvcr.d(60): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286ed]\\n??:? void tmpw6uppvcr.__unittest_L56_C1()\
    \ [0x428074]\\n??:? void tmpw6uppvcr.__modtest() [0x428470]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cea7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bdb6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306dd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b8c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430669]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42bd8d]\\n??:? runModuleUnitTests [0x42cc7d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bb0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b37]\\n??:? _d_run_main [0x428aa2]\\n??:? main [0x428483]\\\
    n??:? __libc_start_main [0xe3924554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    string result = \"\";\n    if (number >= 1000) {\n   \
    \     result ~= roman_thousands[number / 1000];\n        number %= 1000;\n   \
    \ }\n    if (number >= 100) {\n        result ~= roman_hundreds[number / 100];\n\
    \        number %= 100;\n    }\n    if (number >= 10) {\n        result ~= roman_tens[number\
    \ / 10];\n        number %= 10;\n    }\n    if (number > 0) {\n        result\
    \ ~= roman_numerals[number];\n    }\n    return result;\n}\n/*\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcxs205b0.d(50): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcxs205b0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tenthousands = [\n        \"x\"\
    , \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundredthousands\
    \ = [\n        \"l\", \"lx\", \"lxx\", \"lxxx\"\n    ];\n    static string[4]\
    \ roman_millions = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static\
    \ string[4] roman_tenmillions = [\n        \"d\", \"dc\", \"dcc\", \"dccc\"\n\
    \    ];\n    static string[4] roman_hundredmillions = [\n        \"m\", \"mm\"\
    , \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_billions = [\n       \
    \ \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_tenbillions\
    \ = [\n        \"l\", \"lx\", \"lxx\", \"lxxx\"\n    ];\n    static string[4]\
    \ roman_hundredbillions = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n\
    \    static string[4] roman_trillions = [\n        \"d\", \"dc\", \"dcc\", \"\
    dccc\"\n    ];\n    static string[4] roman_tentrillions = [\n\nunittest\n{\n \
    \   alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplhcev1ss.d(61): Error: expression expected, not `unittest`\\\
    n/tmp/tmplhcev1ss.d(62): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmplhcev1ss.d(80): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmplhcev1ss.d(80): Error: semicolon expected, not `main`\\\
    n/tmp/tmplhcev1ss.d(80): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplhcev1ss.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    long[] numbers = [1L, 4L, 5L, 9L, 10L, 40L, 50L, 90L, 100L,\
    \ 400L, 500L, 900L, 1000L];\n    string[] letters = [\"i\", \"iv\", \"v\", \"\
    ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n  \
    \  int i = numbers.length - 1;\n    while (number > 0) \n    {\n        while\
    \ (number < numbers[i]) \n        {\n            i--;\n        }\n        result\
    \ ~= letters[i];\n        number -= numbers[i];\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkrocwbkl.d(23): Error: cannot implicitly convert expression `numbers.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpkrocwbkl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_digits = \"ivxlcdm\";\n    static const long[] roman_values\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const string[] roman_symbols\
    \ = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const long[]\
    \ roman_symbol_values = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const\
    \ string[] roman_symbol_pairs = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"\
    ];\n    static const long[] roman_symbol_pair_values = [4L, 9L, 40L, 90L, 400L,\
    \ 900L];\n    static const string[] roman_symbol_triples = [\"iii\", \"vii\",\
    \ \"xxi\", \"lxx\", \"cxx\", \"dcc\", \"mcc\"];\n    static const long[] roman_symbol_triple_values\
    \ = [3L, 7L, 21L, 70L, 120L, 300L, 1200L];\n    static const string[] roman_symbol_quads\
    \ = [\"iiii\", \"viii\", \"xxxx\", \"lxxx\", \"cccc\", \"dddd\", \"mmmm\"];\n\
    \    static const long[] roman_symbol_quad_values = [4L, 8L, 40L, 80L, 400L, 800L,\
    \ 4000L];\n    static const string[] roman_symbol_quints = [\"iiiii\", \"viiii\"\
    , \"xxxxx\", \"lxxxx\", \"ccccc\", \"ddddd\", \"mmmmm\"];\n    static const long[]\
    \ roman_symbol_quint_values = [5L, 9L, 50L, 90L, 500L, 900L, 5000L];\n    static\
    \ const string[] roman_symbol_sexts = [\"iiiiii\", \"viiiii\", \"xxxxxx\", \"\
    lxxxxx\", \"cccccc\", \"dddddd\", \"mmmmm\"];\n    static const long[] roman_symbol_sext_values\
    \ = [6L\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy26n247a.d(34): Error: comma expected separating array initializers,\
    \ not `unittest`\\n/tmp/tmpy26n247a.d(35): Error: semicolon expected, not `{`\\\
    n/tmp/tmpy26n247a.d(53): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy26n247a.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"\
    iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10]\
    \ roman_tens = [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"];\n    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10]\
    \ roman_thousands = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"\
    vmmm\", \"mx\", \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n   \
    \ static string[10] roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_millions = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_billions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_billions = [\"x\", \"\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7yrewj_c.d(31): Error: unterminated string constant starting\
    \ at /tmp/tmp7yrewj_c.d(49)\\n/tmp/tmp7yrewj_c.d(36): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmp7yrewj_c.d(36): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmp7yrewj_c.d(37):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmp7yrewj_c.d(38):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmp7yrewj_c.d(39):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmp7yrewj_c.d(40):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmp7yrewj_c.d(41):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmp7yrewj_c.d(42):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmp7yrewj_c.d(43):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmp7yrewj_c.d(44):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmp7yrewj_c.d(45):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmp7yrewj_c.d(46):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmp7yrewj_c.d(47):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp7yrewj_c.d(48):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmp7yrewj_c.d(49):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp7yrewj_c.d(51):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmp7yrewj_c.d(51):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7yrewj_c.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] roman_values\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const string[] roman_symbols\
    \ = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const string[]\
    \ roman_subtractives = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n   \
    \ static const long[] subtractive_values = [4L, 9L, 40L, 90L, 400L, 900L];\n \
    \   static const long[] subtractive_indices = [0L, 0L, 2L, 2L, 4L, 4L];\n    static\
    \ const long[] subtractive_lengths = [2L, 2L, 2L, 2L, 2L, 2L];\n    static const\
    \ long[] subtractive_symbol_indices = [0L, 0L, 2L, 2L, 4L, 4L];\n    static const\
    \ long[] subtractive_symbol_lengths = [1L, 1L, 1L, 1L, 1L, 1L];\n    static const\
    \ long[] subtractive_symbol_values = [1L, 1L, 10L, 10L, 100L, 100L];\n    static\
    \ const long[] subtractive_symbol_values_2 = [1L, 1L, 1L, 1L, 1L, 1L];\n    static\
    \ const long[] subtractive_symbol_values_3 = [0L, 0L, 0L, 0L, 0L, 0L];\n    static\
    \ const long[] subtractive_symbol_values_4 = [0L, 0L, 0L, 0L, 0L, 0L];\n    static\
    \ const long[] subtractive_symbol_values_5 = [0L, 0L, 0L, 0L, 0L, 0L];\n    static\
    \ const long[] subtractive_symbol_values_6 = [0L, 0L, 0L, 0L, 0L, 0L];\n    static\
    \ const long[] subtractive_symbol_values_7 = [0L, 0\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3tfo3pe9.d(36): Error: comma expected separating array initializers,\
    \ not `unittest`\\n/tmp/tmp3tfo3pe9.d(37): Error: semicolon expected, not `{`\\\
    n/tmp/tmp3tfo3pe9.d(55): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3tfo3pe9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, num; numbers)\n    {\n        while(number >= num)\n\
    \        {\n            result ~= roman_numerals[i];\n            number -= num;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[long] roman_numerals = [\n        1L: \"i\",\n        4L: \"iv\",\n \
    \       5L: \"v\",\n        9L: \"ix\",\n        10L: \"x\",\n        40L: \"\
    xl\",\n        50L: \"l\",\n        90L: \"xc\",\n        100L: \"c\",\n     \
    \   400L: \"cd\",\n        500L: \"d\",\n        900L: \"cm\",\n        1000L:\
    \ \"m\"\n    ];\n    static long[] roman_numerals_keys = roman_numerals.keys;\n\
    \    static long[] roman_numerals_keys_sorted = roman_numerals_keys.sort;\n  \
    \  static long[] roman_numerals_keys_sorted_reversed = roman_numerals_keys_sorted.reverse;\n\
    \    static long[] roman_numerals_keys_sorted_reversed_filtered = roman_numerals_keys_sorted_reversed.filter!(x\
    \ => x <= number);\n    static long[] roman_numerals_keys_sorted_reversed_filtered_sorted\
    \ = roman_numerals_keys_sorted_reversed_filtered.sort;\n    static long[] roman_numerals_keys_sorted_reversed_filtered_sorted_reversed\
    \ = roman_numerals_keys_sorted_reversed_filtered_sorted.reverse;\n    static long[]\
    \ roman_numerals_keys_sorted_reversed_filtered_sorted_reversed_filtered = roman_numerals_keys_sorted_reversed_filtered_sorted_reversed.filter!(x\
    \ => x <= number);\n    static long[] roman_numerals_keys_sorted_reversed_filtered_sorted_reversed_filtered_sorted\
    \ = roman_numerals_keys_sorted_reversed_filtered_sorted_reversed_filtered.sort;\n\
    \    static long[] roman_numerals_\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps4jbpgiq.d(44): Error: semicolon expected, not `unittest`\\n/tmp/tmps4jbpgiq.d(44):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmps4jbpgiq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string roman_numerals = \"ixcm\";\n    static long[] roman_values = [1L, 10L,\
    \ 100L, 1000L];\n    static string[] roman_subtractives = [\"iv\", \"xl\", \"\
    cd\", \"m\"];\n    static long[] roman_subtractive_values = [4L, 40L, 400L, 4000L];\n\
    \    static string[] roman_additives = [\"v\", \"l\", \"d\", \"m\"];\n    static\
    \ long[] roman_additive_values = [5L, 50L, 500L, 5000L];\n    static string[]\
    \ roman_multipliers = [\"i\", \"x\", \"c\", \"m\"];\n    static long[] roman_multiplier_values\
    \ = [1L, 10L, 100L, 1000L];\n    static string[] roman_divisors = [\"v\", \"l\"\
    , \"d\", \"m\"];\n    static long[] roman_divisor_values = [5L, 50L, 500L, 5000L];\n\
    \    static string[] roman_subtractive_divisors = [\"iv\", \"xl\", \"cd\", \"\
    m\"];\n    static long[] roman_subtractive_divisor_values = [4L, 40L, 400L, 4000L];\n\
    \    static string[] roman_additive_divisors = [\"ix\", \"xc\", \"cm\", \"m\"\
    ];\n    static long[] roman_additive_divisor_values = [9L, 90L, 900L, 9000L];\n\
    \    static string[] roman_subtractive_multipliers = [\"i\", \"x\", \"c\", \"\
    m\"];\n    static long[] roman_subtractive_multiplier_values = [1L, 10L, 100L,\
    \ 1000L];\n    static string[] roman_additive_multipliers = [\"v\", \"l\", \"\
    d\", \"m\"];\n    static long[] roman_additive_multiplier_values = [5L, 50L, 500L,\
    \ 5000L];\n    static string[] roman_subtractive_additives = [\"iv\", \"xl\",\
    \ \"cd\", \"m\"];\n    static long\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqlwufisk.d(40): Error: no identifier for declarator `long`\\\
    n/tmp/tmpqlwufisk.d(40): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqlwufisk.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] decimal_numerals\
    \ = [1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n   \
    \ string result = \"\";\n    foreach(index, numeral; roman_numerals)\n    {\n\
    \        while(number >= decimal_numerals[index])\n        {\n            result\
    \ ~= numeral;\n            number -= decimal_numerals[index];\n        }\n   \
    \ }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3dw38rj3.d(33): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3dw38rj3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ numbers = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L,\
    \ 5L, 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, num; numbers)\n\
    \    {\n        while(number >= num)\n        {\n            result ~= roman_numerals[i];\n\
    \            number -= num;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n\
    \    static const string[] numerals = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"\
    xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    string result\
    \ = \"\";\n    int i = values.length - 1;\n    while (number > 0) {\n        while\
    \ (number < values[i]) {\n            i--;\n        }\n        result ~= numerals[i];\n\
    \        number -= values[i];\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg0v6vl6g.d(23): Error: cannot implicitly convert expression `values.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpg0v6vl6g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const string[] roman_numerals_groups\
    \ = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"\
    ix\"];\n    static const string[] roman_numerals_groups_10 = [\"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static\
    \ const string[] roman_numerals_groups_100 = [\"\", \"c\", \"cc\", \"ccc\", \"\
    cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static const string[] roman_numerals_groups_1000\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    static const long[] roman_numerals_groups_values\
    \ = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    static const long[] roman_numerals_groups_10_values\
    \ = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90];\n    static const long[] roman_numerals_groups_100_values\
    \ = [0, 100, 200, 300, 400, 500, 600, 700, 800, 900];\n    static const long[]\
    \ roman_numerals_groups_1000_values = [0, 1000, 2000, 3000];\n    static const\
    \ long[] roman_numerals_groups_values_reverse = [0, 9, 8, 7, 6, 5, 4, 3, 2, 1];\n\
    \    static const long[] roman_numerals_groups_10_values_reverse = [0, 90, 80,\
    \ 70, 60, 50, 40, 30, 20, 10];\n    static const long[] roman_numerals_groups_100_values_reverse\
    \ = [0, 900, 800, 700, 600, 500, 400, 300, 200, 100];\n    static const long[]\
    \ roman_numerals_groups_1000_values_reverse = [0, 3000, 2000, 1000];\n    static\
    \ const long[] roman_numerals_\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppe7v3nky.d(34): Error: semicolon expected, not `unittest`\\n/tmp/tmppe7v3nky.d(34):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppe7v3nky.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    assert(number > 0 && number <= 1000);\n\
    \    return roman_thousands[number / 1000] ~\n           roman_hundreds[(number\
    \ / 100) % 10] ~\n           roman_tens[(number / 10) % 10] ~\n           roman_numerals[number\
    \ % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[int] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\"\
    , \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static\
    \ int[int] arabic_numerals = [\n        1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral;\
    \ roman_numerals) {\n        while(number >= arabic_numerals[i]) {\n         \
    \   result ~= roman_numeral;\n            number -= arabic_numerals[i];\n    \
    \    }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmncnh4wm.d(20): Error: not an associative array initializer\\\
    n/tmp/tmpmncnh4wm.d(23): Error: not an associative array initializer\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmncnh4wm.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_digits = [\n        \"i\", \"ii\", \"iii\"\
    , \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static\
    \ string[10] roman_tens = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"\
    lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\"\
    , \"cm\", \"m\"\n    ];\n    static string[10] roman_thousands = [\n        \"\
    m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n\
    \    ];\n    static string[10] roman_tens_of_thousands = [\n        \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n\
    \    static string[10] roman_hundreds_of_thousands = [\n        \"c\", \"cc\"\
    , \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n \
    \   static string[10] roman_millions = [\n        \"m\", \"mm\", \"mmm\", \"mv\"\
    , \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    static string[10]\
    \ roman_tens_of_millions = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"\
    lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds_of_millions\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\"\
    , \"cm\", \"m\"\n    ];\n    static string[10] roman_billions\nunittest\n{\n \
    \   alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoaxjqlpz.d(49): Error: semicolon expected, not `unittest`\\n/tmp/tmpoaxjqlpz.d(49):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpoaxjqlpz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] values =\
    \ [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] special_values\
    \ = [4L, 9L, 40L, 90L, 400L, 900L];\n    static const string[] special_strings\
    \ = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n    static const long[]\
    \ special_values_sorted = [4L, 9L, 40L, 90L, 400L, 900L];\n    static const string[]\
    \ special_strings_sorted = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n\
    \    static const long[] values_sorted = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n\
    \    static const string roman_numerals_sorted = \"ivxlcdm\";\n    static const\
    \ long[] values_sorted_reversed = [1000L, 500L, 100L, 50L, 10L, 5L, 1L];\n   \
    \ static const string roman_numerals_sorted_reversed = \"mcdlxvi\";\n    static\
    \ const long[] special_values_sorted_reversed = [900L, 400L, 90L, 40L, 9L, 4L];\n\
    \    static const string[] special_strings_sorted_reversed = [\"cm\", \"cd\",\
    \ \"xc\", \"xl\", \"ix\", \"iv\"];\n    static const string[] special_strings_sorted_reversed_reversed\
    \ = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n    static const long[]\
    \ special_values_sorted_reversed_reversed = [4L, 9L, 40L, 90L, 400L, 900L];\n\
    \    static const long[] values_sorted_reversed_reversed = [1L, 5L, 10L, 50L,\
    \ 100L, 500L, 1000L];\n    static const string roman_numerals_sorted_reversed_reversed\
    \ = \"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj08cv3ds.d(40): Error: semicolon expected, not `xix`\\n/tmp/tmpj08cv3ds.d(40):\
    \ Error: found `\");\\\\x0a    assert(candidate(152L) == \"c` when expecting `;`\
    \ following statement\\n/tmp/tmpj08cv3ds.d(41): Error: found `\");\\\\x0a    assert(candidate(251L)\
    \ == \"c` when expecting `;` following statement\\n/tmp/tmpj08cv3ds.d(42): Error:\
    \ found `\");\\\\x0a    assert(candidate(426L) == \"c` when expecting `;` following\
    \ statement\\n/tmp/tmpj08cv3ds.d(43): Error: found `\");\\\\x0a    assert(candidate(500L)\
    \ == \"d` when expecting `;` following statement\\n/tmp/tmpj08cv3ds.d(45): Error:\
    \ found `i` when expecting `;` following statement\\n/tmp/tmpj08cv3ds.d(46): Error:\
    \ found `iv` when expecting `;` following statement\\n/tmp/tmpj08cv3ds.d(47):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmpj08cv3ds.d(48):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmpj08cv3ds.d(49):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmpj08cv3ds.d(50):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmpj08cv3ds.d(51):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpj08cv3ds.d(52):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmpj08cv3ds.d(53):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpj08cv3ds.d(53):\
    \ Error: unterminated string constant starting at /tmp/tmpj08cv3ds.d(53)\\n/tmp/tmpj08cv3ds.d(55):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmpj08cv3ds.d(55):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj08cv3ds.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, r; roman)\n    {\n        while(number >= values[i])\n        {\n\
    \            number -= values[i];\n            result ~= r;\n        }\n    }\n\
    \    return result;\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe2ui06r8.d(33): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe2ui06r8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] decimal = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ for (size_t i = 0; i < roman.length; i++) {\n        while (number >= decimal[i])\
    \ {\n            number -= decimal[i];\n            result ~= roman[i];\n    \
    \    }\n    }\n    return result;\n}\n/*\n    Given a positive integer, obtain\
    \ its roman numeral equivalent as a string,\n    and return it in uppercase.\n\
    \    Restrictions: 1 <= num <= 1000\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjus40iob.d(31): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjus40iob.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] radix = [0, 0, 1, 1,\
    \ 2, 2, 2, 3, 3, 4];\n    static const int[] numerals = [0, 1, 1, 2, 2, 3, 3,\
    \ 4, 4, 5];\n    static const int[] subtractors = [0, 0, 0, 1, 1, 1, 2, 2, 3,\
    \ 3];\n    static const int[] subtractor_values = [0, 0, 0, 1, 1, 1, 10, 10, 100,\
    \ 100];\n    static const int[] subtractor_numerals = [0, 0, 0, 1, 1, 1, 2, 2,\
    \ 4, 4];\n    static const int[] subtractor_radix = [0, 0, 0, 0, 0, 0, 0, 0, 1,\
    \ 1];\n    static const int[] subtractor_numerals_2 = [0, 0, 0, 0, 0, 0, 0, 0,\
    \ 1, 1];\n    static const int[] subtractor_radix_2 = [0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0];\n    static const int[] subtractor_numerals_3 = [0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0];\n    static const int[] subtractor_radix_3 = [0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0];\n    static const int[] subtractor_numerals_4 = [0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0];\n    static const int[] subtractor_radix_4 = [0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0];\n    static const int[] subtractor_numerals_5 = [0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0];\n    static const int[] subtractor_radix_5 = [0, 0, 0, 0, 0,\
    \ 0, 0, 0\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6ry9cbaw.d(36): Error: comma expected separating array initializers,\
    \ not `unittest`\\n/tmp/tmp6ry9cbaw.d(37): Error: semicolon expected, not `{`\\\
    n/tmp/tmp6ry9cbaw.d(55): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6ry9cbaw.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.algorithm;\n    import std.conv;\n    import std.range;\n    import std.string;\n\
    \    import std.typecons;\n    import std.math;\n    import std.array;\n    import\
    \ std.stdio;\n    import std.range;\n    import std.typecons;\n    import std.math;\n\
    \    import std.array;\n    import std.stdio;\n    import std.range;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.array;\n    import std.stdio;\n\
    \    import std.range;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.array;\n    import std.stdio;\n    import std.range;\n    import std.typecons;\n\
    \    import std.math;\n    import std.array;\n    import std.stdio;\n    import\
    \ std.range;\n    import std.typecons;\n    import std.math;\n    import std.array;\n\
    \    import std.stdio;\n    import std.range;\n    import std.typecons;\n    import\
    \ std.math;\n    import std.array;\n    import std.stdio;\n    import std.range;\n\
    \    import std.typecons;\n    import std.math;\n    import std.array;\n    import\
    \ std.stdio;\n    import std.range;\n    import std.typecons;\n    import std.math;\n\
    \    import std.array;\n    import std.stdio;\n    import std.range;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.array;\n    import std.stdio;\n\
    \    import std.range;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.array;\n    import std.stdio;\n    import std.range;\n    import std.typecons;\n\
    \    import std.math;\n    import std.array;\n    import std.stdio;\n    import\
    \ std.range;\n    import std.typecons;\n    import std.math;\n    import std.array;\n\
    \    import std.stdio;\n    import std.range;\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0ku5lq91.d(89): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0ku5lq91.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_digits = \"ivxlcdm\";\n    static const long[] roman_values\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const string[] roman_symbols\
    \ = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const long[]\
    \ roman_subtractors = [1L, 10L, 100L];\n    static const string[] roman_subtractor_symbols\
    \ = [\"i\", \"x\", \"c\"];\n    static const long[] roman_multipliers = [1L, 10L,\
    \ 100L];\n    static const string[] roman_multiplier_symbols = [\"i\", \"x\",\
    \ \"c\"];\n    static const long[] roman_divisors = [1L, 2L, 5L, 10L];\n    static\
    \ const string[] roman_divisor_symbols = [\"i\", \"v\", \"x\", \"l\"];\n    static\
    \ const long[] roman_divisor_subtractors = [1L, 10L, 100L];\n    static const\
    \ string[] roman_divisor_subtractor_symbols = [\"i\", \"x\", \"c\"];\n    static\
    \ const long[] roman_divisor_multipliers = [1L, 10L, 100L];\n    static const\
    \ string[] roman_divisor_multiplier_symbols = [\"i\", \"x\", \"c\"];\n    static\
    \ const long[] roman_divisor_divisors = [1L, 2L, 5L, 10L];\n    static const string[]\
    \ roman_divisor_divisor_symbols = [\"i\", \"v\", \"x\", \"l\"];\n    static const\
    \ long[] roman_divisor_divisor_subtractors = [1L, 10L, 100L];\n    static const\
    \ string[] roman_divisor_divisor_subtractor_symbols = [\"i\", \"x\", \"c\"];\n\
    \    static const long[] roman_divisor_divisor_multipliers = [1L\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwzifflco.d(38): Error: comma expected separating array initializers,\
    \ not `unittest`\\n/tmp/tmpwzifflco.d(39): Error: semicolon expected, not `{`\\\
    n/tmp/tmpwzifflco.d(57): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwzifflco.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"\
    l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[] decimal\
    \ = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L,\
    \ 1L\n    ];\n    string result = \"\";\n    foreach(i, romanNumeral; roman) {\n\
    \        while(number >= decimal[i]) {\n            number -= decimal[i];\n  \
    \          result ~= romanNumeral;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplyfistgv.d(31): Error: expression expected, not `unittest`\\\
    n/tmp/tmplyfistgv.d(32): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmplyfistgv.d(50): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmplyfistgv.d(50): Error: semicolon expected, not `main`\\\
    n/tmp/tmplyfistgv.d(50): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplyfistgv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n\
    \    static long[] decimal_numerals = [1, 5, 10, 50, 100, 500, 1000];\n    static\
    \ long[] decimal_numerals_rev = decimal_numerals.dup.reverse;\n    static string[]\
    \ roman_numerals_rev = roman_numerals.dup.reverse;\n    static string[] roman_numerals_rev_2\
    \ = roman_numerals_rev.dup.reverse;\n    static string[] roman_numerals_rev_3\
    \ = roman_numerals_rev_2.dup.reverse;\n    static string[] roman_numerals_rev_4\
    \ = roman_numerals_rev_3.dup.reverse;\n    static string[] roman_numerals_rev_5\
    \ = roman_numerals_rev_4.dup.reverse;\n    static string[] roman_numerals_rev_6\
    \ = roman_numerals_rev_5.dup.reverse;\n    static string[] roman_numerals_rev_7\
    \ = roman_numerals_rev_6.dup.reverse;\n    static string[] roman_numerals_rev_8\
    \ = roman_numerals_rev_7.dup.reverse;\n    static string[] roman_numerals_rev_9\
    \ = roman_numerals_rev_8.dup.reverse;\n    static string[] roman_numerals_rev_10\
    \ = roman_numerals_rev_9.dup.reverse;\n    static string[] roman_numerals_rev_11\
    \ = roman_numerals_rev_10.dup.reverse;\n    static string[] roman_numerals_rev_12\
    \ = roman_numerals_rev_11.dup.reverse;\n    static string[] roman_numerals_rev_13\
    \ = roman_numerals_rev_12.dup.reverse;\n    static string[] roman_numerals_rev_14\
    \ = roman\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1l3tcqdz.d(37): Error: semicolon expected, not `unittest`\\n/tmp/tmp1l3tcqdz.d(37):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp1l3tcqdz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ decimal_numerals = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L,\
    \ 10L, 9L, 5L, 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral;\
    \ roman_numerals)\n    {\n        while(number >= decimal_numerals[i])\n     \
    \   {\n            result ~= roman_numeral;\n            number -= decimal_numerals[i];\n\
    \        }\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpye0_7zyg.d(37): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpye0_7zyg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    string result = \"\";\n    if (number > 0) {\n       \
    \ if (number >= 1000) {\n            result ~= roman_thousands[number / 1000];\n\
    \            number %= 1000;\n        }\n        if (number >= 100) {\n      \
    \      result ~= roman_hundreds[number / 100];\n            number %= 100;\n \
    \       }\n        if (number >= 10) {\n            result ~= roman_tens[number\
    \ / 10];\n            number %= 10;\n        }\n        if (number > 0) {\n  \
    \          result ~= roman_numerals[number];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2rcehvpr.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284ed]\\n??:? void tmp2rcehvpr.__unittest_L52_C1()\
    \ [0x427e70]\\n??:? void tmp2rcehvpr.__modtest() [0x42826c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cca7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bbb6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4304dd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43098c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430469]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42bb8d]\\n??:? runModuleUnitTests [0x42ca7d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289b0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428937]\\n??:? _d_run_main [0x4288a2]\\n??:? main [0x42827f]\\\
    n??:? __libc_start_main [0x10a8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_tenthousands =\
    \ [\"\", \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundredthousands\
    \ = [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_millions =\
    \ [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_tenmillions = [\"\
    \", \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundredmillions =\
    \ [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_billions = [\"\
    \", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_tenbillions = [\"\",\
    \ \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundredbillions = [\"\
    \", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_trillions = [\"\"\
    , \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_tentrillions = [\"\", \"\
    xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundredtrillions = [\"\"\
    , \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_quadrillions = [\"\"\
    , \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoorejw61.d(37): Error: semicolon expected, not `unittest`\\n/tmp/tmpoorejw61.d(37):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpoorejw61.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    string result = \"\";\n    while (number\
    \ > 0) {\n        result ~= roman_numerals[number % 10];\n        number /= 10;\n\
    \    }\n    return result.dup.reverse;\n}\nunittest\n{\n    alias candidate =\
    \ int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps7guqdr_.d(26): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(char[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmps7guqdr_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] digits = [0, 1, 2, 3,\
    \ 2, 1, 2, 3, 4, 2];\n    string result;\n    int digit;\n    int index;\n   \
    \ int num;\n    int next;\n    int value;\n    int next_value;\n    int limit;\n\
    \    int pos;\n    int repeat;\n    int i;\n    int j;\n    int k;\n    int l;\n\
    \    int m;\n    int n;\n    int o;\n    int p;\n    int q;\n    int r;\n    int\
    \ s;\n    int t;\n    int u;\n    int v;\n    int w;\n    int x;\n    int y;\n\
    \    int z;\n    int aa;\n    int ab;\n    int ac;\n    int ad;\n    int ae;\n\
    \    int af;\n    int ag;\n    int ah;\n    int ai;\n    int aj;\n    int ak;\n\
    \    int al;\n    int am;\n    int an;\n    int ao;\n    int ap;\n    int aq;\n\
    \    int ar;\n    int as;\n    int at;\n    int au;\n    int av;\n    int aw;\n\
    \    int ax;\n    int ay;\n    int az;\n    int ba;\n    int bb;\n    int bc;\n\
    \    int bd;\n    int be;\n    int bf;\n    int bg;\n    int bh;\n    int bi;\n\
    \    int bj;\n    int bk;\n    int bl;\n    int bm;\n    int bn;\n    int bo;\n\
    \    int bp;\n    int bq;\n    int br;\n    int bs;\n    int bt;\n    int bu;\n\
    \    int bv;\n    int bw;\n    int bx;\n    int by;\n    int bz;\n    int ca;\n\
    \    int cb;\n    int\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbm1pfc69.d(106): Error: no identifier for declarator `int`\\\
    n/tmp/tmpbm1pfc69.d(106): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbm1pfc69.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, num; numbers)\n    {\n        while(number >= num)\n\
    \        {\n            result ~= roman_numerals[i];\n            number -= num;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9rp77y7n.d(31): Error: expression expected, not `unittest`\\\
    n/tmp/tmp9rp77y7n.d(32): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmp9rp77y7n.d(50): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmp9rp77y7n.d(50): Error: semicolon expected, not `main`\\\
    n/tmp/tmp9rp77y7n.d(50): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9rp77y7n.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] values =\
    \ [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] divisors = [1L,\
    \ 10L, 100L, 1000L];\n    static const long[] multipliers = [1L, 10L, 100L, 1000L];\n\
    \    static const long[] subtractors = [1L, 2L, 2L, 4L];\n    static const long[]\
    \ subtractor_values = [1L, 10L, 100L, 1000L];\n    static const long[] subtractor_multipliers\
    \ = [1L, 10L, 100L, 1000L];\n    static const long[] subtractor_divisors = [1L,\
    \ 10L, 100L, 1000L];\n    static const long[] subtractor_indexes = [1L, 2L, 2L,\
    \ 4L];\n    static const long[] subtractor_index_multipliers = [1L, 10L, 100L,\
    \ 1000L];\n    static const long[] subtractor_index_divisors = [1L, 10L, 100L,\
    \ 1000L];\n    static const long[] subtractor_index_subtractors = [1L, 2L, 2L,\
    \ 4L];\n    static const long[] subtractor_index_subtractor_values = [1L, 10L,\
    \ 100L, 1000L];\n    static const long[] subtractor_index_subtractor_multipliers\
    \ = [1L, 10L, 100L, 1000L];\n    static const long[] subtractor_index_subtractor_divisors\
    \ = [1L, 10L, 100L, 1000L];\n    static const long[] subtractor_index_subtractor_indexes\
    \ = [1L, 2L, 2L, 4L];\n    static const long[] subtractor_index_subtractor_index_multipliers\
    \ = [1L, 10L, 100L, 1000L];\n    static const long[] subtractor_index_subtractor_index_divisors\
    \ = [1L, 10L, 100L, 1000L];\n    static const long[] subtractor_index_subtractor_index_subt\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbqbaxbgv.d(39): Error: semicolon expected, not `unittest`\\n/tmp/tmpbqbaxbgv.d(39):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpbqbaxbgv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    return roman_thousands[number / 1000] ~\n           roman_hundreds[(number\
    \ / 100) % 10] ~\n           roman_tens[(number / 10) % 10] ~\n           roman_numerals[number\
    \ % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] roman_values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] roman_subtractors\
    \ = [1, 10, 100];\n    static const string[] roman_subtraction_strings = [\"iv\"\
    , \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n    static const string[] roman_addition_strings\
    \ = [\"ii\", \"iii\", \"v\", \"vi\", \"vii\", \"viii\", \"xx\", \"xxi\", \"xxii\"\
    , \"xxiii\", \"xxiv\", \"xxv\", \"xxvi\", \"xxvii\", \"xxviii\", \"xxix\", \"\
    xxx\", \"xxxi\", \"xxxii\", \"xxxiii\", \"xxxiv\", \"xxxv\", \"xxxvi\", \"xxxvii\"\
    , \"xxxviii\", \"xxxix\", \"xl\", \"xli\", \"xlii\", \"xliii\", \"xliv\", \"xlv\"\
    , \"xlvi\", \"xlvii\", \"xlviii\", \"xlix\", \"l\", \"li\", \"lii\", \"liii\"\
    , \"liv\", \"lv\", \"lvi\", \"lvii\", \"lviii\", \"lix\", \"lx\", \"lxi\", \"\
    lxii\", \"lxiii\", \"lxiv\", \"lxv\", \"lxvi\", \"lxvii\", \"lxviii\", \"lxix\"\
    , \"lxx\", \"lxxi\", \"lxxii\", \"lxxiii\", \"lxxiv\", \"lxxv\", \"lxxvi\", \"\
    lxxvii\", \"lxxviii\", \"lxxix\", \"lxxx\", \"lxxxi\", \"lxxxii\", \"lxxxiii\"\
    , \"lxxxiv\", \"lxxxv\", \"lxxxvi\", \"lxxxvii\", \"lxxxviii\", \"lxxxix\", \"\
    xc\", \"xci\", \"xcii\", \"xciii\", \"xciv\", \"xcv\", \"xcvi\", \"xcvii\", \"\
    xcviii\", \"xcix\", \"c\", \"ci\", \"cii\", \"ciii\", \"c\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgyoq73wj.d(24): Error: unterminated string constant starting\
    \ at /tmp/tmpgyoq73wj.d(42)\\n/tmp/tmpgyoq73wj.d(29): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmpgyoq73wj.d(29): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmpgyoq73wj.d(30):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmpgyoq73wj.d(31):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmpgyoq73wj.d(32):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmpgyoq73wj.d(33):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmpgyoq73wj.d(34):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmpgyoq73wj.d(35):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmpgyoq73wj.d(36):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmpgyoq73wj.d(37):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmpgyoq73wj.d(38):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmpgyoq73wj.d(39):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmpgyoq73wj.d(40):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpgyoq73wj.d(41):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmpgyoq73wj.d(42):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpgyoq73wj.d(44):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmpgyoq73wj.d(44):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgyoq73wj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[10] roman10 = [\"\", \"x\", \"xx\"\
    , \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10]\
    \ roman100 = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"];\n    static string[4] roman1000 = [\"\", \"m\", \"mm\", \"mmm\"\
    ];\n    string result = \"\";\n    if (number >= 1000)\n    {\n        result\
    \ ~= roman1000[number / 1000];\n        number %= 1000;\n    }\n    if (number\
    \ >= 100)\n    {\n        result ~= roman100[number / 100];\n        number %=\
    \ 100;\n    }\n    if (number >= 10)\n    {\n        result ~= roman10[number\
    \ / 10];\n        number %= 10;\n    }\n    result ~= roman[number];\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[int] roman_numerals = [\n        \"i\", \"v\", \"x\", \"l\", \"c\", \"\
    d\", \"m\"\n    ];\n    static int[int] roman_values = [\n        1, 5, 10, 50,\
    \ 100, 500, 1000\n    ];\n    static int[int] roman_values_sorted = [\n      \
    \  1, 5, 10, 50, 100, 500, 1000\n    ];\n    static string[int] roman_numerals_sorted\
    \ = [\n        \"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"\n    ];\n    static\
    \ int[int] roman_values_sorted_reversed = [\n        1000, 500, 100, 50, 10, 5,\
    \ 1\n    ];\n    static string[int] roman_numerals_sorted_reversed = [\n     \
    \   \"m\", \"d\", \"c\", \"l\", \"x\", \"v\", \"i\"\n    ];\n    static int[int]\
    \ roman_values_sorted_reversed_with_zeros = [\n        1000, 500, 100, 50, 10,\
    \ 5, 1, 0\n    ];\n    static string[int] roman_numerals_sorted_reversed_with_zeros\
    \ = [\n        \"m\", \"d\", \"c\", \"l\", \"x\", \"v\", \"i\", \"z\"\n    ];\n\
    \    static int[int] roman_values_sorted_with_zeros = [\n        1, 5, 10, 50,\
    \ 100, 500, 1000, 0\n    ];\n    static string[int] roman_numerals_sorted_with_zeros\
    \ = [\n        \"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\", \"z\"\n    ];\n\
    \    static int[int] roman_values_sorted_reversed_with_zeros_and_negatives = [\n\
    \        1000, 500, 100, 50, 10, 5, 1, 0, -1, -5, -10, -50, -100, -500, -1000\n\
    \    ];\n    static string[int] roman\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqvtoueuf.d(54): Error: semicolon expected, not `unittest`\\n/tmp/tmpqvtoueuf.d(54):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpqvtoueuf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tens_of_thousands = [\n       \
    \ \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_thousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_tens_of_millions = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n\
    \    static string[4] roman_hundreds_of_millions = [\n        \"c\", \"cc\", \"\
    ccc\", \"cd\"\n    ];\n    static string[4] roman_billions = [\n        \"m\"\
    , \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_tens_of_billions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_billions\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd458rcxi.d(60): Error: found `unittest` when expecting `]`\\\
    n/tmp/tmpd458rcxi.d(61): Error: no identifier for declarator `string[4]`\\n/tmp/tmpd458rcxi.d(79):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd458rcxi.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ixcm\";\n    static const long[] values = [1L,\
    \ 10L, 100L, 1000L];\n    static const long[] divisors = [1L, 2L, 2L, 4L];\n \
    \   static const string[] numerals = [\"i\", \"x\", \"c\", \"m\"];\n    static\
    \ const string[] fives = [\"v\", \"l\", \"d\", \"\"];\n    static const string[]\
    \ tens = [\"x\", \"c\", \"m\", \"\"];\n    static const string[] hundreds = [\"\
    c\", \"m\", \"\", \"\"];\n    static const string[] thousands = [\"m\", \"\",\
    \ \"\", \"\"];\n    static const string[][] numerals_by_position = [numerals,\
    \ fives, tens, hundreds, thousands];\n    static const string[][] numerals_by_position_2\
    \ = [numerals, fives, tens, hundreds, thousands];\n    static const string[][]\
    \ numerals_by_position_3 = [numerals, fives, tens, hundreds, thousands];\n   \
    \ static const string[][] numerals_by_position_4 = [numerals, fives, tens, hundreds,\
    \ thousands];\n    static const string[][] numerals_by_position_5 = [numerals,\
    \ fives, tens, hundreds, thousands];\n    static const string[][] numerals_by_position_6\
    \ = [numerals, fives, tens, hundreds, thousands];\n    static const string[][]\
    \ numerals_by_position_7 = [numerals, fives, tens, hundreds, thousands];\n   \
    \ static const string[][] numerals_by_position_8 = [numerals, fives, tens, hundreds,\
    \ thousands];\n    static const string[][] numerals_by_position_9 = [numerals,\
    \ fives, tens, hundreds, thousands];\n    static const string[][] numerals_by_position_10\
    \ = [numerals, fives, tens, hundreds, thousands];\n    static const string[][]\
    \ numerals_by_position_11 = [numerals, fives, tens, hundreds, thousands];\n  \
    \  static const string[][] numerals_by_position_12 = [numerals, f\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr1l0u385.d(40): Error: comma expected separating array initializers,\
    \ not `unittest`\\n/tmp/tmpr1l0u385.d(41): Error: semicolon expected, not `{`\\\
    n/tmp/tmpr1l0u385.d(59): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr1l0u385.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    string result = \"\";\n    if (number > 0) {\n       \
    \ if (number >= 1000) {\n            result ~= roman_thousands[number / 1000];\n\
    \            number %= 1000;\n        }\n        if (number >= 100) {\n      \
    \      result ~= roman_hundreds[number / 100];\n            number %= 100;\n \
    \       }\n        if (number >= 10) {\n            result ~= roman_tens[number\
    \ / 10];\n            number %= 10;\n        }\n        if (number > 0) {\n  \
    \          result ~= roman_numerals[number];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmph1e2n8lo.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284ed]\\n??:? void tmph1e2n8lo.__unittest_L52_C1()\
    \ [0x427e70]\\n??:? void tmph1e2n8lo.__modtest() [0x42826c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cca7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bbb6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4304dd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43098c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430469]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42bb8d]\\n??:? runModuleUnitTests [0x42ca7d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289b0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428937]\\n??:? _d_run_main [0x4288a2]\\n??:? main [0x42827f]\\\
    n??:? __libc_start_main [0xf31fe554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\n/*\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu2c64lgg.d(37): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu2c64lgg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tens_of_thousands = [\n       \
    \ \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_thousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_tens_of_millions = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n\
    \    static string[4] roman_hundreds_of_millions = [\n        \"c\", \"cc\", \"\
    ccc\", \"cd\"\n    ];\n    static string[4] roman_billions = [\n        \"m\"\
    , \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_tens_of_billions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_billions\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoifjn5o6.d(60): Error: found `unittest` when expecting `]`\\\
    n/tmp/tmpoifjn5o6.d(61): Error: no identifier for declarator `string[4]`\\n/tmp/tmpoifjn5o6.d(79):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoifjn5o6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[int] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\"\
    , \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static\
    \ int[int] decimal_numerals = [\n        1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral;\
    \ roman_numerals)\n    {\n        while(number >= decimal_numerals[i])\n     \
    \   {\n            result ~= roman_numeral;\n            number -= decimal_numerals[i];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprj889yi0.d(20): Error: not an associative array initializer\\\
    n/tmp/tmprj889yi0.d(23): Error: not an associative array initializer\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprj889yi0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static int[] roman_numerals = [\n        [1000, \"m\"],\n     \
    \   [900, \"cm\"],\n        [500, \"d\"],\n        [400, \"cd\"],\n        [100,\
    \ \"c\"],\n        [90, \"xc\"],\n        [50, \"l\"],\n        [40, \"xl\"],\n\
    \        [10, \"x\"],\n        [9, \"ix\"],\n        [5, \"v\"],\n        [4,\
    \ \"iv\"],\n        [1, \"i\"]\n    ];\n    foreach(int[] numeral; roman_numerals)\n\
    \    {\n        while(number >= numeral[0])\n        {\n            result ~=\
    \ numeral[1];\n            number -= numeral[0];\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyh1zpa7k.d(22): Error: cannot use array to initialize `int`\\\
    n/tmp/tmpyh1zpa7k.d(23): Error: cannot use array to initialize `int`\\n/tmp/tmpyh1zpa7k.d(24):\
    \ Error: cannot use array to initialize `int`\\n/tmp/tmpyh1zpa7k.d(25): Error:\
    \ cannot use array to initialize `int`\\n/tmp/tmpyh1zpa7k.d(26): Error: cannot\
    \ use array to initialize `int`\\n/tmp/tmpyh1zpa7k.d(27): Error: cannot use array\
    \ to initialize `int`\\n/tmp/tmpyh1zpa7k.d(28): Error: cannot use array to initialize\
    \ `int`\\n/tmp/tmpyh1zpa7k.d(29): Error: cannot use array to initialize `int`\\\
    n/tmp/tmpyh1zpa7k.d(30): Error: cannot use array to initialize `int`\\n/tmp/tmpyh1zpa7k.d(31):\
    \ Error: cannot use array to initialize `int`\\n/tmp/tmpyh1zpa7k.d(32): Error:\
    \ cannot use array to initialize `int`\\n/tmp/tmpyh1zpa7k.d(33): Error: cannot\
    \ use array to initialize `int`\\n/tmp/tmpyh1zpa7k.d(34): Error: cannot use array\
    \ to initialize `int`\\n/tmp/tmpyh1zpa7k.d(36): Error: cannot implicitly convert\
    \ expression `__r73[__key74]` of type `int` to `int[]`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpyh1zpa7k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string roman_numerals = \"ivxlcdm\";\n    static int[] roman_values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static int[] roman_values_len = [1, 1,\
    \ 1, 1, 1, 1, 1];\n    static int[] roman_values_len_max = [3, 1, 1, 1, 1, 1,\
    \ 1];\n    static int[] roman_values_len_min = [1, 1, 1, 1, 1, 1, 1];\n    static\
    \ int[] roman_values_len_min_next = [1, 1, 1, 1, 1, 1, 1];\n    static int[] roman_values_len_min_next_next\
    \ = [1, 1, 1, 1, 1, 1, 1];\n    static int[] roman_values_len_min_next_next_next\
    \ = [1, 1, 1, 1, 1, 1, 1];\n    static int[] roman_values_len_min_next_next_next_next\
    \ = [1, 1, 1, 1, 1, 1, 1];\n    static int[] roman_values_len_min_next_next_next_next_next\
    \ = [1, 1, 1, 1, 1, 1, 1];\n    static int[] roman_values_len_min_next_next_next_next_next_next\
    \ = [1, 1, 1, 1, 1, 1, 1];\n    static int[] roman_values_len_min_next_next_next_next_next_next_next\
    \ = [1, 1, 1, 1, 1, 1, 1];\n    static int[] roman_values_len_min_next_next_next_next_next_next_next_next\
    \ = [1, 1, 1, 1, 1, 1, 1];\n    static int[] roman_values_len_min_next_next_next_next_next_next_next_next_next\
    \ = [1, 1, 1, 1, 1, 1, 1];\n    static int[] roman_values_len_min_next_next_next_next_next_next_\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprt7en_vs.d(36): Error: semicolon expected, not `unittest`\\n/tmp/tmprt7en_vs.d(36):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmprt7en_vs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tens_of_thousands = [\n       \
    \ \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_thousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_tens_of_millions = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n\
    \    static string[4] roman_hundreds_of_millions = [\n        \"c\", \"cc\", \"\
    ccc\", \"cd\"\n    ];\n    static string[4] roman_billions = [\n        \"m\"\
    , \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_tens_of_billions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_billions\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyks40xgq.d(60): Error: found `unittest` when expecting `]`\\\
    n/tmp/tmpyks40xgq.d(61): Error: no identifier for declarator `string[4]`\\n/tmp/tmpyks40xgq.d(79):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyks40xgq.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, v; values)\n    {\n        while(number >= v)\n        {\n      \
    \      result ~= roman[i];\n            number -= v;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    string result = \"\";\n    if (number < 1 || number > 1000)\
    \ {\n        return result;\n    }\n    if (number >= 1000) {\n        result\
    \ ~= roman_thousands[number / 1000];\n        number %= 1000;\n    }\n    if (number\
    \ >= 100) {\n        result ~= roman_hundreds[number / 100];\n        number %=\
    \ 100;\n    }\n    if (number >= 10) {\n        result ~= roman_tens[number /\
    \ 10];\n        number %= 10;\n    }\n    result ~= roman_numerals[number];\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numbers = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[10] roman_thousands = [\n        \"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    static\
    \ string[10] roman_ten_thousands = [\n        \"x\", \"xx\", \"xxx\", \"xl\",\
    \ \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10]\
    \ roman_hundred_thousands = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\",\
    \ \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static string[10] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\"\
    , \"mx\", \"x\"\n    ];\n    static string[10] roman_ten_millions = [\n      \
    \  \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"\
    c\"\n    ];\n    static string[10] roman_hundred_millions = [\n        \"c\",\
    \ \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n \
    \   ];\n    static string[10] roman_billions = [\n        \"m\", \"mm\", \"mmm\"\
    , \"m\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp87idpjud.d(47): Error: unterminated string constant starting\
    \ at /tmp/tmp87idpjud.d(66)\\n/tmp/tmp87idpjud.d(53): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmp87idpjud.d(53): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmp87idpjud.d(54):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmp87idpjud.d(55):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmp87idpjud.d(56):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmp87idpjud.d(57):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmp87idpjud.d(58):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmp87idpjud.d(59):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmp87idpjud.d(60):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmp87idpjud.d(61):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmp87idpjud.d(62):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmp87idpjud.d(63):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmp87idpjud.d(64):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp87idpjud.d(65):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmp87idpjud.d(66):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp87idpjud.d(68):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmp87idpjud.d(68):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp87idpjud.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] values =\
    \ [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] exceptions =\
    \ [4L, 9L, 40L, 90L, 400L, 900L];\n    static const string[] exception_strings\
    \ = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n    string result = \"\"\
    ;\n    long remainder = number;\n    long index = roman_numerals.length - 1;\n\
    \    long value = values[index];\n    long exception_index = 0;\n    while (remainder\
    \ > 0) {\n        if (exception_index < exceptions.length && remainder >= exceptions[exception_index])\
    \ {\n            result ~= exception_strings[exception_index];\n            remainder\
    \ -= exceptions[exception_index];\n            exception_index += 2;\n       \
    \ } else {\n            long count = remainder / value;\n            if (count\
    \ > 0) {\n                result ~= roman_numerals[index].repeat(count);\n   \
    \             remainder -= count * value;\n            }\n            index -=\
    \ 1;\n            value = values[index];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_n_hulqg.d(37): Error: no property `repeat` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_n_hulqg.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.conv;\n    import std.string;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.stdio;\n    import std.traits;\n    import std.meta;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.typecons;\n\
    \    import std.math;\n    import std.stdio;\n    import std.traits;\n    import\
    \ std.meta;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.typecons;\n    import std.math;\n    import std.stdio;\n    import\
    \ std.traits;\n    import std.meta;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.stdio;\n    import std.traits;\n    import std.meta;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.typecons;\n\
    \    import std.math;\n    import std.stdio;\n    import std.traits;\n    import\
    \ std.meta;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.typecons;\n    import std.math;\n    import std.stdio;\n    import\
    \ std.traits;\n    import std.meta;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.stdio;\n    import std.traits;\n    import std.meta;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.typecons;\n\
    \    import std.math;\n    import std.stdio;\n    import std.traits;\n    import\
    \ std.meta;\n    import std.range;\n    import std.algorithm;\n\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpff199ejc.d(89): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpff199ejc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[10] roman_thousands = [\n        \"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    static\
    \ string[10] roman_tenthousands = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10] roman_hundredthousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\"\
    , \"cm\", \"m\"\n    ];\n    static string[10] roman_millions = [\n        \"\
    m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n\
    \    ];\n    static string[10] roman_tenmillions = [\n        \"x\", \"xx\", \"\
    xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static\
    \ string[10] roman_hundredmillions = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static string[10]\
    \ roman_billions = [\n        \"m\", \"mm\", \"mmm\", \"mv\", \"\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4f8t4nz6.d(47): Error: unterminated string constant starting\
    \ at /tmp/tmp4f8t4nz6.d(66)\\n/tmp/tmp4f8t4nz6.d(53): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmp4f8t4nz6.d(53): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmp4f8t4nz6.d(54):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmp4f8t4nz6.d(55):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmp4f8t4nz6.d(56):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmp4f8t4nz6.d(57):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmp4f8t4nz6.d(58):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmp4f8t4nz6.d(59):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmp4f8t4nz6.d(60):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmp4f8t4nz6.d(61):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmp4f8t4nz6.d(62):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmp4f8t4nz6.d(63):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmp4f8t4nz6.d(64):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp4f8t4nz6.d(65):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmp4f8t4nz6.d(66):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp4f8t4nz6.d(68):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmp4f8t4nz6.d(68):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4f8t4nz6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[10] roman_thousands = [\n        \"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    static\
    \ string[10] roman_tens_of_thousands = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\
    , \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10]\
    \ roman_hundreds_of_thousands = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static string[10] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\"\
    , \"mx\", \"x\"\n    ];\n    static string[10] roman_tens_of_millions = [\n  \
    \      \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\
    , \"c\"\n    ];\n    static string[10] roman_hundreds_of_millions = [\n      \
    \  \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"\
    m\"\n    ];\n    static string[10] roman_billions = [\n       \nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9uqg0o_n.d(49): Error: expression expected, not `unittest`\\\
    n/tmp/tmp9uqg0o_n.d(50): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmp9uqg0o_n.d(68): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmp9uqg0o_n.d(68): Error: semicolon expected, not `main`\\\
    n/tmp/tmp9uqg0o_n.d(68): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9uqg0o_n.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"x\", \"xx\",\
    \ \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10]\
    \ roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"];\n    static string[4] roman_thousands = [\"m\", \"mm\", \"mmm\"\
    , \"mv\"];\n    static string[4] roman_ten_thousands = [\"v\", \"vv\", \"vvv\"\
    , \"vm\"];\n    static string[4] roman_hundred_thousands = [\"m\", \"mm\", \"\
    mmm\", \"mv\"];\n    static string[4] roman_millions = [\"v\", \"vv\", \"vvv\"\
    , \"vm\"];\n    static string[4] roman_ten_millions = [\"m\", \"mm\", \"mmm\"\
    , \"mv\"];\n    static string[4] roman_hundred_millions = [\"v\", \"vv\", \"vvv\"\
    , \"vm\"];\n    static string[4] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\"];\n    static string[4] roman_ten_billions = [\"v\", \"vv\", \"vvv\", \"\
    vm\"];\n    static string[4] roman_hundred_billions = [\"m\", \"mm\", \"mmm\"\
    , \"mv\"];\n    static string[4] roman_trillions = [\"v\", \"vv\", \"vvv\", \"\
    vm\"];\n    static string[4] roman_ten_trillions = [\"m\", \"mm\", \"mmm\", \"\
    mv\"];\n    static string[4] roman_hundred_trillions = [\"v\", \"vv\", \"vvv\"\
    , \"vm\"];\n    static string[4] roman_quadrillions = [\"m\", \"mm\", \"mmm\"\
    , \"mv\"];\n    static string[\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp95qpwtu0.d(37): Error: expression expected, not `unittest`\\\
    n/tmp/tmp95qpwtu0.d(38): Error: found `{` when expecting `]`\\n/tmp/tmp95qpwtu0.d(39):\
    \ Error: no identifier for declarator `string[0]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp95qpwtu0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    // TODO: implement\n    return result;\n}\n/*\n    Given\
    \ a string representing a roman numeral, return its integer value.\n    Restrictions:\
    \ 1 <= num <= 1000\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8q4qbuyc.d(24): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8q4qbuyc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    string result = \"\";\n    if (number >= 1000) {\n   \
    \     result ~= roman_thousands[number / 1000];\n        number %= 1000;\n   \
    \ }\n    if (number >= 100) {\n        result ~= roman_hundreds[number / 100];\n\
    \        number %= 100;\n    }\n    if (number >= 10) {\n        result ~= roman_tens[number\
    \ / 10];\n        number %= 10;\n    }\n    if (number > 0) {\n        result\
    \ ~= roman_numerals[number];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_x46hajo.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284e5]\\n??:? void tmp_x46hajo.__unittest_L50_C1()\
    \ [0x427e68]\\n??:? void tmp_x46hajo.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cc9f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bbae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4304d5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430984]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430461]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42bb85]\\n??:? runModuleUnitTests [0x42ca75]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289a8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42892f]\\n??:? _d_run_main [0x42889a]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x1cfd3554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] ones = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\"];\n    static string[10] tens = [\"\", \"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10] hundreds\
    \ = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"\
    cm\"];\n    static string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n   \
    \ string result = \"\";\n    result ~= thousands[number / 1000];\n    result ~=\
    \ hundreds[(number % 1000) / 100];\n    result ~= tens[(number % 100) / 10];\n\
    \    result ~= ones[number % 10];\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\"\
    , \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens\
    \ = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"\
    xc\"];\n    static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\",\
    \ \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    int thousands = cast(int)(number / 1000);\n\
    \    int hundreds = cast(int)((number % 1000) / 100);\n    int tens = cast(int)((number\
    \ % 100) / 10);\n    int ones = cast(int)(number % 10);\n    result ~= roman_thousands[thousands];\n\
    \    result ~= roman_hundreds[hundreds];\n    result ~= roman_tens[tens];\n  \
    \  result ~= roman_numerals[ones];\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\"\
    , \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static\
    \ long[] numbers = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n \
    \   foreach(i, num; numbers)\n    {\n        while(number >= num)\n        {\n\
    \            result ~= roman_numerals[i];\n            number -= num;\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n\
    \    static const string[] numerals = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"\
    xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    string result\
    \ = \"\";\n    int i = values.length - 1;\n    while (number > 0) {\n        while\
    \ (number < values[i]) {\n            i--;\n        }\n        result ~= numerals[i];\n\
    \        number -= values[i];\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5bqlhz9p.d(23): Error: cannot implicitly convert expression `values.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp5bqlhz9p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[10] roman_tenthousands\
    \ = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"\
    xc\"];\n    static string[10] roman_hundredthousands = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[10]\
    \ roman_millions = [\"\", \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\"\
    , \"vmmm\", \"mx\"];\n    static string[10] roman_tenmillions = [\"\", \"x\",\
    \ \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static\
    \ string[10] roman_hundredmillions = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[10] roman_billions\
    \ = [\"\", \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"\
    mx\"];\n    static string[10] roman_tenbillions = [\"\", \"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10] roman_h\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa6241u6s.d(32): Error: semicolon expected, not `unittest`\\n/tmp/tmpa6241u6s.d(32):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpa6241u6s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] roman_values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] roman_subtractors\
    \ = [1, 10, 100];\n    static const string[] roman_subtractors_symbols = [\"i\"\
    , \"x\", \"c\"];\n    static const string[] roman_subtractors_symbols_5 = [\"\
    v\", \"l\", \"d\"];\n    static const string[] roman_subtractors_symbols_10 =\
    \ [\"x\", \"c\", \"m\"];\n    static const int[] roman_subtractors_values = [1,\
    \ 10, 100];\n    static const int[] roman_subtractors_values_5 = [5, 50, 500];\n\
    \    static const int[] roman_subtractors_values_10 = [10, 100, 1000];\n    static\
    \ const int[] roman_subtractors_values_4 = [4, 40, 400];\n    static const int[]\
    \ roman_subtractors_values_9 = [9, 90, 900];\n    static const int[] roman_subtractors_values_40\
    \ = [40, 400];\n    static const int[] roman_subtractors_values_90 = [90, 900];\n\
    \    static const int[] roman_subtractors_values_400 = [400];\n    static const\
    \ int[] roman_subtractors_values_900 = [900];\n    static const string[] roman_subtractors_symbols_4\
    \ = [\"iv\", \"xl\", \"cd\"];\n    static const string[] roman_subtractors_symbols_9\
    \ = [\"ix\", \"xc\", \"cm\"];\n    static const string[] roman_subtractors_symbols_40\
    \ = [\"xl\", \"cd\"];\n    static const string[] roman_subtractors_symbols_90\
    \ = [\"xc\", \"cm\"];\n    static const string[] roman_subtractors_symbols_400\
    \ = [\"cd\"];\n    static const string\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzqmc6_zj.d(41): Error: no identifier for declarator `string`\\\
    n/tmp/tmpzqmc6_zj.d(41): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzqmc6_zj.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] ones = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\"];\n    static string[10] tens = [\"\", \"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10] hundreds\
    \ = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"\
    cm\"];\n    static string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n   \
    \ string result = \"\";\n    if (number >= 1000)\n    {\n        result ~= thousands[number\
    \ / 1000];\n        number %= 1000;\n    }\n    if (number >= 100)\n    {\n  \
    \      result ~= hundreds[number / 100];\n        number %= 100;\n    }\n    if\
    \ (number >= 10)\n    {\n        result ~= tens[number / 10];\n        number\
    \ %= 10;\n    }\n    result ~= ones[number];\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwdm2jbkd.d(31): Error: expression expected, not `unittest`\\\
    n/tmp/tmpwdm2jbkd.d(32): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmpwdm2jbkd.d(50): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmpwdm2jbkd.d(50): Error: semicolon expected, not `main`\\\
    n/tmp/tmpwdm2jbkd.d(50): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwdm2jbkd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    long[] nums = [1L, 4L, 5L, 9L, 10L, 40L, 50L, 90L, 100L,\
    \ 400L, 500L, 900L, 1000L];\n    string[] romans = [\"i\", \"iv\", \"v\", \"ix\"\
    , \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    for\
    \ (int i = nums.length - 1; i >= 0; i--) {\n        while (number >= nums[i])\
    \ {\n            result ~= romans[i];\n            number -= nums[i];\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx9nz55ut.d(23): Error: cannot implicitly convert expression `nums.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpx9nz55ut.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman = \"ivxlcdm\";\n    static const long[] values = [1L, 5L,\
    \ 10L, 50L, 100L, 500L, 1000L];\n    static const long[] thresholds = [1L, 4L,\
    \ 5L, 9L, 10L, 40L, 50L, 90L, 100L, 400L, 500L, 900L, 1000L];\n    static const\
    \ string[] symbols = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\"\
    , \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    static const long[] digits = [0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L];\n    static const long[] powers\
    \ = [0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L];\n    static const long[]\
    \ divisors = [0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L];\n    static\
    \ const long[] remainders = [0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L];\n\
    \    static const long[] quotients = [0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L];\n    static const long[] roman_numerals = [0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L];\n    static const string[] roman_symbols =\
    \ [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    ];\n    static const string[] roman_numerals_string = [\"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp626_iak1.d(31): Error: unterminated string constant starting\
    \ at /tmp/tmp626_iak1.d(49)\\n/tmp/tmp626_iak1.d(36): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmp626_iak1.d(36): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmp626_iak1.d(37):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmp626_iak1.d(38):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmp626_iak1.d(39):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmp626_iak1.d(40):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmp626_iak1.d(41):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmp626_iak1.d(42):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmp626_iak1.d(43):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmp626_iak1.d(44):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmp626_iak1.d(45):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmp626_iak1.d(46):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmp626_iak1.d(47):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp626_iak1.d(48):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmp626_iak1.d(49):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp626_iak1.d(51):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmp626_iak1.d(51):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp626_iak1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic_numerals\
    \ = [1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n   \
    \ string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n\
    \        while(number >= arabic_numerals[i])\n        {\n            result ~=\
    \ roman_numeral;\n            number -= arabic_numerals[i];\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd3zkazp9.d(31): Error: expression expected, not `unittest`\\\
    n/tmp/tmpd3zkazp9.d(32): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmpd3zkazp9.d(50): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmpd3zkazp9.d(50): Error: semicolon expected, not `main`\\\
    n/tmp/tmpd3zkazp9.d(50): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd3zkazp9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    long[] values = [1L, 4L, 5L, 9L, 10L, 40L, 50L, 90L, 100L,\
    \ 400L, 500L, 900L, 1000L];\n    string[] numerals = [\"i\", \"iv\", \"v\", \"\
    ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n  \
    \  foreach(i; 0 .. values.length)\n    {\n        while(number >= values[i])\n\
    \        {\n            result ~= numerals[i];\n            number -= values[i];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptpnw756x.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429225]\\n??:? void tmptpnw756x.__unittest_L33_C1()\
    \ [0x428094]\\n??:? void tmptpnw756x.__modtest() [0x428490]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e817]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428f7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b4bd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b54c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b449]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428f55]\\n??:? runModuleUnitTests [0x42e5ed]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4296e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42966f]\\n??:? _d_run_main [0x4295da]\\n??:? main [0x4284a3]\\\
    n??:? __libc_start_main [0x53ac4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    auto roman_numerals = [\"i\", \"v\", \"x\", \"l\", \"c\"\
    , \"d\", \"m\"];\n    auto roman_numerals_map = [\"i\": 1, \"v\": 5, \"x\": 10,\
    \ \"l\": 50, \"c\": 100, \"d\": 500, \"m\": 1000];\n    auto roman_numerals_map_reverse\
    \ = [\"i\": 1, \"v\": 5, \"x\": 10, \"l\": 50, \"c\": 100, \"d\": 500, \"m\":\
    \ 1000];\n    auto roman_numerals_map_reverse_keys = [\"i\", \"v\", \"x\", \"\
    l\", \"c\", \"d\", \"m\"];\n    auto roman_numerals_map_reverse_values = [1, 5,\
    \ 10, 50, 100, 500, 1000];\n    auto roman_numerals_map_reverse_values_sorted\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    auto roman_numerals_map_reverse_values_sorted_reversed\
    \ = [1000, 500, 100, 50, 10, 5, 1];\n    auto roman_numerals_map_reverse_values_sorted_reversed_length\
    \ = 7;\n    auto roman_numerals_map_reverse_values_sorted_reversed_length_minus_1\
    \ = 6;\n    auto roman_numerals_map_reverse_values_sorted_reversed_length_minus_2\
    \ = 5;\n    auto roman_numerals_map_reverse_values_sorted_reversed_length_minus_3\
    \ = 4;\n    auto roman_numerals_map_reverse_values_sorted_reversed_length_minus_4\
    \ = 3;\n    auto roman_numerals_map_reverse_values_sorted_reversed_length_minus_5\
    \ = 2;\n    auto roman_numerals_map_reverse_values_sorted_reversed_length_minus_6\
    \ = 1;\n    auto roman_numerals_map_reverse_values_sorted_revers\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprcwhzu_o.d(36): Error: no identifier for declarator `roman_numerals_map_reverse_values_sorted_revers`\\\
    n/tmp/tmprcwhzu_o.d(36): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprcwhzu_o.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number\
    \ >= numbers[i])\n        {\n            result ~= roman_numeral;\n          \
    \  number -= numbers[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static const string roman_numerals = \"ixcm\";\n    static const\
    \ long[] roman_values = [1L, 10L, 100L, 1000L];\n    foreach (i, roman_value;\
    \ roman_values) {\n        long num = number / roman_value;\n        if (num >\
    \ 0) {\n            result ~= repeat(roman_numerals[i], num);\n            number\
    \ -= num * roman_value;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpct159aw3.d(26): Error: undefined identifier `repeat`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpct159aw3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[int] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\"\
    , \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static\
    \ int[int] values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5,\
    \ 4, 1\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\n/*\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu8vqlor7.d(37): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu8vqlor7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    assert(number > 0 && number <= 1000);\n\
    \    return roman_thousands[number / 1000] ~\n           roman_hundreds[(number\
    \ / 100) % 10] ~\n           roman_tens[(number / 10) % 10] ~\n           roman_numerals[number\
    \ % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0vgugmkj.d(31): Error: expression expected, not `unittest`\\\
    n/tmp/tmp0vgugmkj.d(32): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmp0vgugmkj.d(50): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmp0vgugmkj.d(50): Error: semicolon expected, not `main`\\\
    n/tmp/tmp0vgugmkj.d(50): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0vgugmkj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    string\
    \ result = \"\";\n    long i = 0;\n    while (number > 0) \n    {\n        long\
    \ digit = number % 10;\n        if (digit == 4) \n        {\n            result\
    \ = roman[i] ~ roman[i + 1] ~ result;\n        } \n        else if (digit == 9)\
    \ \n        {\n            result = roman[i] ~ roman[i + 2] ~ result;\n      \
    \  } \n        else \n        {\n            string temp = \"\";\n           \
    \ if (digit >= 5) \n            {\n                temp = roman[i + 1];\n    \
    \            digit -= 5;\n            }\n            temp ~= repeat(roman[i],\
    \ digit);\n            result = temp ~ result;\n        }\n        number /= 10;\n\
    \        i += 2;\n    }\n    return result;\n}\n/*\n    Given a roman numeral\
    \ in lowercase, return its integer value.\n    Restrictions: 1 <= num <= 1000\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmk03m2dj.d(50): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmk03m2dj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[10] roman_thousands = [\n        \"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    string\
    \ result = \"\";\n    long thousands = number / 1000;\n    long hundreds = (number\
    \ % 1000) / 100;\n    long tens = (number % 100) / 10;\n    long ones = number\
    \ % 10;\n    if (thousands > 0) {\n        result ~= roman_thousands[thousands\
    \ - 1];\n    }\n    if (hundreds > 0) {\n        result ~= roman_hundreds[hundreds\
    \ - 1];\n    }\n    if (tens > 0) {\n        result ~= roman_tens[tens - 1];\n\
    \    }\n    if (ones > 0) {\n        result ~= roman_numerals[ones - 1];\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    enum numeral { I, V, X, L, C, D, M };\n    enum numeral[] numerals\
    \ = [I, V, X, L, C, D, M];\n    enum numeral[] numerals_5 = [V, L, D];\n    enum\
    \ numeral[] numerals_10 = [X, C, M];\n    enum numeral[] numerals_50 = [L, D,\
    \ M];\n    enum numeral[] numerals_100 = [C, M];\n    enum numeral[] numerals_500\
    \ = [D, M];\n    enum numeral[] numerals_1000 = [M];\n    enum numeral[] numerals_5000\
    \ = [M];\n    enum numeral[] numerals_10000 = [M];\n    enum numeral[] numerals_50000\
    \ = [M];\n    enum numeral[] numerals_100000 = [M];\n    enum numeral[] numerals_500000\
    \ = [M];\n    enum numeral[] numerals_1000000 = [M];\n    enum numeral[] numerals_5000000\
    \ = [M];\n    enum numeral[] numerals_10000000 = [M];\n    enum numeral[] numerals_50000000\
    \ = [M];\n    enum numeral[] numerals_100000000 = [M];\n    enum numeral[] numerals_500000000\
    \ = [M];\n    enum numeral[] numerals_1000000000 = [M];\n    enum numeral[] numerals_5000000000\
    \ = [M];\n    enum numeral[] numerals_10000000000 = [M];\n    enum numeral[] numerals_50000000000\
    \ = [M];\n    enum numeral[] numerals_100000000000 = [M];\n    enum numeral[]\
    \ numerals_500000000000 = [M];\n    enum numeral[] numerals_1000000000000 = [M];\n\
    \    enum numeral[] numerals_5000000000000 = [M];\n    enum numeral[] numerals_10000000000000\
    \ = [M];\n    enum numeral[] numerals_50000000000000 = [M];\n    enum numeral[]\
    \ numerals_100000000000000 = [M];\n    enum numeral[] numerals_500000000000000\
    \ = [M];\n    enum numeral[]\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8awt9a4x.d(21): Deprecation: use `{ }` for an empty statement,\
    \ not `;`\\n/tmp/tmp8awt9a4x.d(53): Error: no identifier for declarator `numeral[]`\\\
    n/tmp/tmp8awt9a4x.d(53): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8awt9a4x.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprd0x9dtd.d(31): Error: expression expected, not `unittest`\\\
    n/tmp/tmprd0x9dtd.d(32): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmprd0x9dtd.d(50): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmprd0x9dtd.d(50): Error: semicolon expected, not `main`\\\
    n/tmp/tmprd0x9dtd.d(50): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprd0x9dtd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto roman_numerals = tuple(\n        tuple(\"i\", \"v\", \"x\"\
    ),\n        tuple(\"x\", \"l\", \"c\"),\n        tuple(\"c\", \"d\", \"m\"),\n\
    \        tuple(\"m\", \"v\", \"x\")\n    );\n    foreach(i, roman_numerals)\n\
    \    {\n        auto numeral = roman_numerals[i];\n        auto digit = number\
    \ % 10;\n        if (digit == 0)\n        {\n            number /= 10;\n     \
    \       continue;\n        }\n        if (digit < 4)\n        {\n            result\
    \ = repeat(numeral[0], digit) ~ result;\n        }\n        else if (digit ==\
    \ 4)\n        {\n            result = numeral[0] ~ numeral[1] ~ result;\n    \
    \    }\n        else if (digit < 9)\n        {\n            result = numeral[1]\
    \ ~ repeat(numeral[0], digit - 5) ~ result;\n        }\n        else\n       \
    \ {\n            result = numeral[0] ~ numeral[2] ~ result;\n        }\n     \
    \   number /= 10;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp88_h6l_c.d(27): Error: no identifier for declarator `roman_numerals`\\\
    n/tmp/tmp88_h6l_c.d(27): Error: found `)` when expecting `;`\\n/tmp/tmp88_h6l_c.d(54):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmp88_h6l_c.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[10] roman_ten_thousands = [\n        \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n\
    \    ];\n    static string[10] roman_hundred_thousands = [\n        \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n\
    \    static string[10] roman_millions = [\n        \"m\", \"mm\", \"mmm\", \"\
    mmmm\", \"mmmmm\", \"mmmmmm\", \"mmmmmmm\", \"mmmmmmmm\", \"mmmmmmmmm\", \"mmmmmmmmmm\"\
    \n    ];\n    static string[10] roman_ten_millions = [\n        \"x\", \"xx\"\
    , \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n \
    \   static string[10] roman_hundred_millions = [\n        \"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static\
    \ string[10] roman_billions = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\", \"\
    mmmmm\", \"mmmmmm\", \"mmmmmmm\", \"mmmm\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpolrf64c0.d(47): Error: unterminated string constant starting\
    \ at /tmp/tmpolrf64c0.d(66)\\n/tmp/tmpolrf64c0.d(53): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmpolrf64c0.d(53): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmpolrf64c0.d(54):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmpolrf64c0.d(55):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmpolrf64c0.d(56):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmpolrf64c0.d(57):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmpolrf64c0.d(58):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmpolrf64c0.d(59):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmpolrf64c0.d(60):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmpolrf64c0.d(61):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmpolrf64c0.d(62):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmpolrf64c0.d(63):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmpolrf64c0.d(64):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpolrf64c0.d(65):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmpolrf64c0.d(66):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpolrf64c0.d(68):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmpolrf64c0.d(68):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpolrf64c0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number\
    \ >= numbers[i])\n        {\n            result ~= roman_numeral;\n          \
    \  number -= numbers[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[4] roman_digits = [ \"i\", \"v\", \"x\", \"l\" ];\n    static long[4]\
    \ roman_values = [ 1, 5, 10, 50 ];\n    static long[4] roman_values_next = [ 5,\
    \ 10, 50, 100 ];\n    static long[4] roman_values_prev = [ 0, 1, 5, 10 ];\n  \
    \  static string[4] roman_digits_next = [ \"v\", \"x\", \"l\", \"c\" ];\n    static\
    \ string[4] roman_digits_prev = [ \"\", \"i\", \"v\", \"x\" ];\n    static string[4]\
    \ roman_digits_prev_next = [ \"\", \"iv\", \"ix\", \"xl\" ];\n    static string[4]\
    \ roman_digits_next_next = [ \"\", \"vi\", \"xv\", \"lx\" ];\n    static string[4]\
    \ roman_digits_next_next_next = [ \"\", \"vii\", \"xvii\", \"lxvii\" ];\n    static\
    \ string[4] roman_digits_next_next_next_next = [ \"\", \"viii\", \"xviii\", \"\
    lxviii\" ];\n    static string[4] roman_digits_next_next_next_next_next = [ \"\
    \", \"ix\", \"xx\", \"lxx\" ];\n    static string[4] roman_digits_next_next_next_next_next_next\
    \ = [ \"\", \"x\", \"xx\", \"lxx\" ];\n    static string[4] roman_digits_next_next_next_next_next_next_next\
    \ = [ \"\", \"xi\", \"xxi\", \"lxxi\" ];\n    static string[4] roman_digits_next_next_next_next_next_next_next_next\
    \ = [ \"\", \"xii\", \"xxii\", \"lxxii\" ];\n    static string[4] roman_digits_next_next_next_next_next_next_next_next_next\
    \ = [ \"\", \"xiii\", \"xxiii\", \"lxxiii\" ];\n    static string[\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2v4ur9fl.d(36): Error: expression expected, not `unittest`\\\
    n/tmp/tmp2v4ur9fl.d(37): Error: found `{` when expecting `]`\\n/tmp/tmp2v4ur9fl.d(38):\
    \ Error: no identifier for declarator `string[0]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp2v4ur9fl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    long[] digits = [1000L, 900L, 500L, 400L, 100L, 90L, 50L,\
    \ 40L, 10L, 9L, 5L, 4L, 1L];\n    string[] roman = [\"m\", \"cm\", \"d\", \"cd\"\
    , \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    for\
    \ (int i = 0; i < digits.length; i++) \n    {\n        while (number >= digits[i])\
    \ \n        {\n            result ~= roman[i];\n            number -= digits[i];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(num; numbers)\n    {\n        while(number >= num)\n  \
    \      {\n            result ~= roman_numerals[numbers.indexOf(num)];\n      \
    \      number -= num;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4j1pclxz.d(27): Error: no property `indexOf` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4j1pclxz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] roman_values\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] roman_values_sorted\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const string[] roman_numerals_sorted\
    \ = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const string[]\
    \ roman_numerals_sorted_reversed = [\"m\", \"d\", \"c\", \"l\", \"x\", \"v\",\
    \ \"i\"];\n    static const long[] roman_values_sorted_reversed = [1000L, 500L,\
    \ 100L, 50L, 10L, 5L, 1L];\n    static const int[] roman_values_sorted_reversed_index\
    \ = [6, 5, 4, 3, 2, 1, 0];\n    static const int[] roman_values_sorted_index =\
    \ [0, 1, 2, 3, 4, 5, 6];\n    static const int[] roman_values_sorted_index_reversed\
    \ = [6, 5, 4, 3, 2, 1, 0];\n    static const int[] roman_values_sorted_index_reversed_reversed\
    \ = [0, 1, 2, 3, 4, 5, 6];\n    static const int[] roman_values_sorted_index_reversed_reversed_reversed\
    \ = [6, 5, 4, 3, 2, 1, 0];\n    static const int[] roman_values_sorted_index_reversed_reversed_reversed_reversed\
    \ = [0, 1, 2, 3, 4, 5, 6];\n    static const int[] roman_values_sorted_index_reversed_reversed_reversed_reversed_reversed\
    \ = [6, 5, 4, 3, 2, 1, 0];\n    static const int[] roman_values_sorted_index_reversed_re\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphad_cpvq.d(34): Error: semicolon expected, not `unittest`\\n/tmp/tmphad_cpvq.d(34):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmphad_cpvq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    long[] roman_numbers = [1L, 4L, 5L, 9L, 10L, 40L, 50L, 90L,\
    \ 100L, 400L, 500L, 900L, 1000L];\n    string[] roman_letters = [\"i\", \"iv\"\
    , \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"\
    m\"];\n    while (number > 0) \n    {\n        long index = roman_numbers.length\
    \ - 1;\n        while (roman_numbers[index] > number) \n        {\n          \
    \  index--;\n        }\n        result ~= roman_letters[index];\n        number\
    \ -= roman_numbers[index];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] values =\
    \ [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] decimal_values\
    \ = [1L, 10L, 100L, 1000L];\n    static const string[] roman_digits = [\"i\",\
    \ \"x\", \"c\", \"m\"];\n    static const string[] roman_fives = [\"v\", \"l\"\
    , \"d\"];\n    static const string[] roman_tens = [\"x\", \"c\", \"m\"];\n   \
    \ static const string[] roman_fifties = [\"l\", \"d\", \"m\"];\n    static const\
    \ string[] roman_hundreds = [\"c\", \"m\", \"m\"];\n    static const string[]\
    \ roman_five_hundreds = [\"d\", \"m\", \"m\"];\n    static const string[] roman_thousands\
    \ = [\"m\", \"m\", \"m\"];\n    static const string[] roman_five_thousands = [\"\
    m\", \"m\", \"m\"];\n    static const string[] roman_tens_of_thousands = [\"m\"\
    , \"m\", \"m\"];\n    static const string[] roman_fifties_of_thousands = [\"m\"\
    , \"m\", \"m\"];\n    static const string[] roman_hundreds_of_thousands = [\"\
    m\", \"m\", \"m\"];\n    static const string[] roman_five_hundreds_of_thousands\
    \ = [\"m\", \"m\", \"m\"];\n    static const string[] roman_millions = [\"m\"\
    , \"m\", \"m\"];\n    static const string[] roman_five_millions = [\"m\", \"m\"\
    , \"m\"];\n    static const string[] roman_tens_of_millions = [\"m\", \"m\", \"\
    m\"];\n    static const string[] roman_fifties_of_millions = [\"m\", \"m\", \"\
    m\"];\n    static const string[] roman_hundreds_of_millions = [\"m\", \"m\", \"\
    m\"];\n    static const string[] roman_five_hundreds_of\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_z7ru8my.d(41): Error: semicolon expected, not `unittest`\\n/tmp/tmp_z7ru8my.d(41):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp_z7ru8my.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] radix = [1, 10, 100,\
    \ 1000];\n    static const string[] roman_digits = [\"i\", \"v\", \"x\", \"l\"\
    , \"c\", \"d\", \"m\"];\n    static const string[] roman_fives = [\"\", \"v\"\
    , \"l\", \"d\"];\n    static const string[] roman_tens = [\"x\", \"c\", \"m\"\
    ];\n    static const string[] roman_fifties = [\"\", \"l\", \"d\"];\n    static\
    \ const string[] roman_hundreds = [\"c\", \"m\"];\n    static const string[] roman_five_hundreds\
    \ = [\"\", \"d\"];\n    static const string[] roman_thousands = [\"m\"];\n   \
    \ static const string[] roman_five_thousands = [\"\"];\n    static const string[]\
    \ roman_tens_of_thousands = [\"\"];\n    static const string[] roman_fifties_of_thousands\
    \ = [\"\"];\n    static const string[] roman_hundreds_of_thousands = [\"\"];\n\
    \    static const string[] roman_five_hundreds_of_thousands = [\"\"];\n    static\
    \ const string[] roman_millions = [\"\"];\n    static const string[] roman_five_millions\
    \ = [\"\"];\n    static const string[] roman_tens_of_millions = [\"\"];\n    static\
    \ const string[] roman_fifties_of_millions = [\"\"];\n    static const string[]\
    \ roman_hundreds_of_millions = [\"\"];\n    static const string[] roman_five_hundreds_of_millions\
    \ = [\"\"];\n    static const string[] roman_billions = [\"\"];\n    static const\
    \ string[] roman_five_billions = [\"\"];\n    static const string[] roman_tens_of_billions\
    \ = [\"\"];\n    static const string[] roman_fifties_of_billions = [\"\"];\n \
    \   static const string\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcnkfo_v5.d(46): Error: no identifier for declarator `string`\\\
    n/tmp/tmpcnkfo_v5.d(46): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcnkfo_v5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic_numerals\
    \ = [1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n   \
    \ string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n\
    \        while(number >= arabic_numerals[i])\n        {\n            result ~=\
    \ roman_numeral;\n            number -= arabic_numerals[i];\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"\
    v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(1 <= number && number <= 1000);\n    auto digits\
    \ = number.digits;\n    return roman_thousands[digits[3]] ~\n           roman_hundreds[digits[2]]\
    \ ~\n           roman_tens[digits[1]] ~\n           roman_digits[digits[0]];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvlhua7fp.d(33): Error: no property `digits` for type `long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvlhua7fp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tens_of_thousands = [\n       \
    \ \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_thousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_tens_of_millions = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n\
    \    static string[4] roman_hundreds_of_millions = [\n        \"c\", \"cc\", \"\
    ccc\", \"cd\"\n    ];\n    static string[4] roman_billions = [\n        \"m\"\
    , \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_tens_of_billions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_billions\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphxy11go5.d(60): Error: found `unittest` when expecting `]`\\\
    n/tmp/tmphxy11go5.d(61): Error: no identifier for declarator `string[4]`\\n/tmp/tmphxy11go5.d(79):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphxy11go5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[int] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\"\
    , \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static\
    \ int[int] decimal_numerals = [\n        1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1\n    ];\n    string result = \"\";\n    foreach(i, roman; roman_numerals)\
    \ {\n        while(number >= decimal_numerals[i]) {\n            result ~= roman;\n\
    \            number -= decimal_numerals[i];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_kogcrdy.d(20): Error: not an associative array initializer\\\
    n/tmp/tmp_kogcrdy.d(23): Error: not an associative array initializer\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_kogcrdy.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    string result = \"\";\n    if (number > 0) {\n       \
    \ if (number >= 1000) {\n            result ~= roman_thousands[number / 1000];\n\
    \            number %= 1000;\n        }\n        if (number >= 100) {\n      \
    \      result ~= roman_hundreds[number / 100];\n            number %= 100;\n \
    \       }\n        if (number >= 10) {\n            result ~= roman_tens[number\
    \ / 10];\n            number %= 10;\n        }\n        if (number > 0) {\n  \
    \          result ~= roman_numerals[number];\n        }\n    }\n    return result;\n\
    }\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppjgz30uf.d(52): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppjgz30uf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] units = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[10] tens = [\"\", \"x\", \"xx\",\
    \ \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10]\
    \ hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"];\n    static string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"\
    ];\n    return thousands[number / 1000] ~ hundreds[(number / 100) % 10] ~ tens[(number\
    \ / 10) % 10] ~ units[number % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, num; numbers)\n    {\n        while(number >= num)\n\
    \        {\n            result ~= roman_numerals[i];\n            number -= num;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] digits = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\"];\n    static string[10] tens = [\"x\", \"xx\", \"xxx\", \"\
    xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10] hundreds\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    ];\n    static string[4] thousands = [\"m\", \"mm\", \"mmm\", \"mmmmm\"];\n  \
    \  string result = \"\";\n    if (number >= 1000) \n    {\n        result ~= thousands[number\
    \ / 1000];\n        number %= 1000;\n    }\n    if (number >= 100) \n    {\n \
    \       result ~= hundreds[number / 100];\n        number %= 100;\n    }\n   \
    \ if (number >= 10) \n    {\n        result ~= tens[number / 10];\n        number\
    \ %= 10;\n    }\n    if (number > 0) \n    {\n        result ~= digits[number];\n\
    \    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9nmeclxy.d(46): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9nmeclxy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    int[] values = [1000, 900, 500, 400, 100, 90, 50, 40, 10,\
    \ 9, 5, 4, 1];\n    string[] numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\",\
    \ \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    foreach(i,\
    \ v; values)\n    {\n        while(number >= v)\n        {\n            result\
    \ ~= numerals[i];\n            number -= v;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] decimal_values = [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400,\
    \ 500, 600, 700, 800, 900, 1000];\n    static const string[] roman_values = [\"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n   \
    \ static const int[] decimal_values_2 = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400,\
    \ 500, 900, 1000];\n    static const string[] roman_values_2 = [\"i\", \"iv\"\
    , \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"\
    m\"];\n    static const int[] decimal_values_3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\
    \ 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500, 600, 700, 800, 900,\
    \ 1000];\n    static const string[] roman_values_3 = [\"i\", \"ii\", \"iii\",\
    \ \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\", \"xx\", \"xxx\", \"\
    xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static const int[] decimal_values_4\
    \ = [1, 4, 5, 9, 10, 40,\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4vo3bbn5.d(29): Error: expression expected, not `unittest`\\\
    n/tmp/tmp4vo3bbn5.d(30): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmp4vo3bbn5.d(48): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmp4vo3bbn5.d(48): Error: semicolon expected, not `main`\\\
    n/tmp/tmp4vo3bbn5.d(48): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4vo3bbn5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    string result = \"\";\n    if (number > 0) {\n        result\
    \ ~= roman_thousands[number / 1000];\n        number %= 1000;\n        result\
    \ ~= roman_hundreds[number / 100];\n        number %= 100;\n        result ~=\
    \ roman_tens[number / 10];\n        number %= 10;\n        result ~= roman_numerals[number];\n\
    \    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp95j0bzy6.d(44): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp95j0bzy6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, num; numbers)\n    {\n        while(number >= num)\n\
    \        {\n            result ~= roman_numerals[i];\n            number -= num;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] romans = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\", \"x\"];\n    static string[10] romans_tens = [\"x\", \"xx\"\
    , \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static\
    \ string[10] romans_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\"\
    , \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] romans_thousands =\
    \ [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"\
    x\"];\n    static string[4] romans_powers = [\"\", \"\", \"\", \"\"];\n    static\
    \ string[4] romans_powers_tens = [\"\", \"\", \"\", \"\"];\n    static string[4]\
    \ romans_powers_hundreds = [\"\", \"\", \"\", \"\"];\n    static string[4] romans_powers_thousands\
    \ = [\"\", \"\", \"\", \"\"];\n    static string[4] romans_powers_tenthousands\
    \ = [\"\", \"\", \"\", \"\"];\n    static string[4] romans_powers_hundredthousands\
    \ = [\"\", \"\", \"\", \"\"];\n    static string[4] romans_powers_millions = [\"\
    \", \"\", \"\", \"\"];\n    static string[4] romans_powers_tens_millions = [\"\
    \", \"\", \"\", \"\"];\n    static string[4] romans_powers_hundreds_millions =\
    \ [\"\", \"\", \"\", \"\"];\n    static string[4] romans_powers_billions = [\"\
    \", \"\", \"\", \"\"];\n    static string[4] romans_powers_tens_billions = [\"\
    \", \"\", \"\", \"\"];\n    static string[4] romans_powers_hundreds_billions =\
    \ [\"\", \"\", \"\", \"\"];\n    static string[4] romans_powers_trillions = [\"\
    \", \"\", \"\", \"\"];\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzy4mlhx5.d(37): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzy4mlhx5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    string result = \"\";\n    while (number\
    \ > 0) {\n        result ~= roman_numerals[number % 10];\n        number /= 10;\n\
    \    }\n    return result.reverse;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4cauoxqk.d(26): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(string)`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp4cauoxqk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.algorithm;\n    import std.range;\n    import std.conv;\n    import std.string;\n\
    \    import std.math;\n    import std.typecons;\n    import std.array;\n    import\
    \ std.range;\n    import std.algorithm;\n    import std.typecons;\n    import\
    \ std.math;\n    import std.conv;\n    import std.string;\n    import std.array;\n\
    \    import std.range;\n    import std.algorithm;\n    import std.typecons;\n\
    \    import std.math;\n    import std.conv;\n    import std.string;\n    import\
    \ std.array;\n    import std.range;\n    import std.algorithm;\n    import std.typecons;\n\
    \    import std.math;\n    import std.conv;\n    import std.string;\n    import\
    \ std.array;\n    import std.range;\n    import std.algorithm;\n    import std.typecons;\n\
    \    import std.math;\n    import std.conv;\n    import std.string;\n    import\
    \ std.array;\n    import std.range;\n    import std.algorithm;\n    import std.typecons;\n\
    \    import std.math;\n    import std.conv;\n    import std.string;\n    import\
    \ std.array;\n    import std.range;\n    import std.algorithm;\n    import std.typecons;\n\
    \    import std.math;\n    import std.conv;\n    import std.string;\n    import\
    \ std.array;\n    import std.range;\n    import std.algorithm;\n    import std.typecons;\n\
    \    import std.math;\n    import std.conv;\n    import std.string;\n    import\
    \ std.array;\n    import std.range;\n    import std.algorithm;\n    import std.typecons;\n\
    \    import std.math;\n    import std.conv;\n    import std.string;\n    import\
    \ std.array;\n    import std.range;\n    import std.algorithm;\n    import std.typecons;\n\
    \    import std.math;\n    import std.conv;\n    import std.string;\n    import\
    \ std.array;\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpymrhe85x.d(90): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpymrhe85x.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto roman_numerals = tuple(\n        tuple(\"m\", 1000L),\n  \
    \      tuple(\"cm\", 900L),\n        tuple(\"d\", 500L),\n        tuple(\"cd\"\
    , 400L),\n        tuple(\"c\", 100L),\n        tuple(\"xc\", 90L),\n        tuple(\"\
    l\", 50L),\n        tuple(\"xl\", 40L),\n        tuple(\"x\", 10L),\n        tuple(\"\
    ix\", 9L),\n        tuple(\"v\", 5L),\n        tuple(\"iv\", 4L),\n        tuple(\"\
    i\", 1L)\n    );\n    foreach(roman_numeral; roman_numerals) {\n        auto roman_numeral_str\
    \ = roman_numeral[0];\n        auto roman_numeral_val = roman_numeral[1];\n  \
    \      while(number >= roman_numeral_val) {\n            result ~= roman_numeral_str;\n\
    \            number -= roman_numeral_val;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, num; numbers)\n    {\n        while(number >= num)\n\
    \        {\n            result ~= roman_numerals[i];\n            number -= num;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ immutable roman_numerals = [\n        tuple(1L, \"i\"),\n        tuple(5L, \"\
    v\"),\n        tuple(10L, \"x\"),\n        tuple(50L, \"l\"),\n        tuple(100L,\
    \ \"c\"),\n        tuple(500L, \"d\"),\n        tuple(1000L, \"m\")\n    ];\n\
    \    static immutable roman_numerals_map = roman_numerals.map!(a => a[0]).array;\n\
    \    static immutable roman_numerals_map_rev = roman_numerals_map.dup.reverse;\n\
    \    static immutable roman_numerals_dict = roman_numerals.assocArray;\n    static\
    \ immutable roman_numerals_dict_rev = roman_numerals.map!(a => tuple(a[0], a[1].dup.reverse)).assocArray;\n\
    \    static immutable roman_numerals_dict_rev_keys = roman_numerals_dict_rev.keys.array;\n\
    \    static immutable roman_numerals_dict_rev_keys_rev = roman_numerals_dict_rev_keys.dup.reverse;\n\
    \    static immutable roman_numerals_dict_rev_keys_rev_map = roman_numerals_dict_rev_keys_rev.map!(a\
    \ => a.dup.reverse).array;\n    static immutable roman_numerals_dict_rev_keys_rev_map_rev\
    \ = roman_numerals_dict_rev_keys_rev_map.dup.reverse;\n    static immutable roman_numerals_dict_rev_keys_rev_map_rev_dict\
    \ = roman_numerals_dict_rev_keys_rev_map_rev.assocArray;\n    static immutable\
    \ roman_numerals_dict_rev_keys_rev_map_rev_dict_rev = roman_numerals_dict_rev_keys_rev_map_rev_dict.map!(a\
    \ => tuple(a[0], a[1].dup.reverse)).assocArray;\n    static immutable roman_numerals_\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu304cc__.d(40): Error: no identifier for declarator `roman_numerals_`\\\
    n/tmp/tmpu304cc__.d(40): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu304cc__.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqz7dg4e0.d(31): Error: expression expected, not `unittest`\\\
    n/tmp/tmpqz7dg4e0.d(32): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmpqz7dg4e0.d(50): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmpqz7dg4e0.d(50): Error: semicolon expected, not `main`\\\
    n/tmp/tmpqz7dg4e0.d(50): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqz7dg4e0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    static string[] roman_numerals = [\"m\", \"cm\", \"d\",\
    \ \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n\
    \    static long[] numbers = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5,\
    \ 4, 1];\n    foreach(i, num; numbers)\n    {\n        while(number >= num)\n\
    \        {\n            result ~= roman_numerals[i];\n            number -= num;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, num; numbers)\n    {\n        while(number >= num)\n\
    \        {\n            result ~= roman_numerals[i];\n            number -= num;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= roman;\n    \
    \        number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.conv;\n    import std.string;\n    import std.algorithm;\n    import std.range;\n\
    \    import std.array;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.traits;\n    import std.meta;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.traits;\n    import std.meta;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.traits;\n    import std.meta;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.traits;\n    import std.meta;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.traits;\n    import std.meta;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.traits;\n    import std.meta;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.traits;\n    import std.meta;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.traits;\n    import std.meta;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.traits;\n    import std.meta;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.math\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcy53cb2_.d(89): Error: `;` expected\\n/tmp/tmpcy53cb2_.d(108):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcy53cb2_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ numbers = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L,\
    \ 5L, 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, num; numbers)\
    \ {\n        while(number >= num) {\n            result ~= roman_numerals[i];\n\
    \            number -= num;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ixcm\";\n    static const long[] roman_values\
    \ = [1L, 10L, 100L, 1000L];\n    static const string[] roman_subtractives = [\"\
    iv\", \"xl\", \"cd\", \"m\"];\n    static const long[] roman_subtractive_values\
    \ = [4L, 40L, 400L, 4000L];\n    static const string[] roman_subtractive_pairs\
    \ = [\"ix\", \"xl\", \"cd\", \"m\"];\n    static const long[] roman_subtractive_pair_values\
    \ = [9L, 90L, 900L, 9000L];\n    static const string[] roman_subtractive_triples\
    \ = [\"ivx\", \"xlc\", \"cdm\", \"m\"];\n    static const long[] roman_subtractive_triple_values\
    \ = [49L, 490L, 4900L, 49000L];\n    static const string[] roman_subtractive_quadruples\
    \ = [\"ivxl\", \"xlcd\", \"cdm\", \"m\"];\n    static const long[] roman_subtractive_quadruple_values\
    \ = [499L, 4990L, 49900L, 499000L];\n    static const string[] roman_subtractive_quintuples\
    \ = [\"ivxlc\", \"xlc\", \"cdm\", \"m\"];\n    static const long[] roman_subtractive_quintuple_values\
    \ = [4999L, 49990L, 499900L, 4999000L];\n    static const string[] roman_subtractive_sextuples\
    \ = [\"ivxlcd\", \"xlcd\", \"cdm\", \"m\"];\n    static const long[] roman_subtractive_sextuple_values\
    \ = [49999L, 499990L, 4999900L, 49999000L];\n    static const string[] roman_subtractive_septuples\
    \ = [\"ivxlc\", \"xlcdm\", \"cdm\", \"m\"];\n    static const long[] roman_subtractive_septuple_values\
    \ = [49999L, 499990L, 4999900L, 4\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprk81fy99.d(36): Error: comma expected separating array initializers,\
    \ not `unittest`\\n/tmp/tmprk81fy99.d(37): Error: semicolon expected, not `{`\\\
    n/tmp/tmprk81fy99.d(55): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprk81fy99.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] romans = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\", \"x\"];\n    static string[10] romans_tens = [\"x\", \"xx\"\
    , \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static\
    \ string[10] romans_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\"\
    , \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] romans_thousands =\
    \ [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"\
    x\"];\n    static string[10] romans_ten_thousands = [\"x\", \"xx\", \"xxx\", \"\
    xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ romans_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] romans_millions = [\"\
    m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\
    ];\n    static string[10] romans_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\"\
    , \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] romans_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] romans_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ romans_ten_billions = [\"x\", \"xx\", \"xxx\", \"xl\",\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp62zcm8ek.d(31): Error: expression expected, not `unittest`\\\
    n/tmp/tmp62zcm8ek.d(32): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmp62zcm8ek.d(50): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmp62zcm8ek.d(50): Error: semicolon expected, not `main`\\\
    n/tmp/tmp62zcm8ek.d(50): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp62zcm8ek.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"\
    v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(1 <= number && number <= 1000);\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_digits[number % 10];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, val; values) {\n \
    \       while(number >= val) {\n            result ~= roman_numerals[i];\n   \
    \         number -= val;\n        }\n    }\n    return result;\n}\n/*\n    Given\
    \ a positive integer, obtain its roman numeral equivalent as a string,\n    and\
    \ return it in uppercase.\n    Restrictions: 1 <= num <= 3999\nunittest\n{\n \
    \   alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx1txu8z7.d(35): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx1txu8z7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ arabic_numerals = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L,\
    \ 9L, 5L, 4L, 1L\n    ];\n    string result = \"\";\n    foreach(index, numeral;\
    \ roman_numerals)\n    {\n        while(number >= arabic_numerals[index])\n  \
    \      {\n            result ~= numeral;\n            number -= arabic_numerals[index];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    string result = \"\";\n    if (number > 1000) {\n     \
    \   result ~= roman_thousands[number / 1000];\n        number %= 1000;\n    }\n\
    \    if (number > 100) {\n        result ~= roman_hundreds[number / 100];\n  \
    \      number %= 100;\n    }\n    if (number > 10) {\n        result ~= roman_tens[number\
    \ / 10];\n        number %= 10;\n    }\n    result ~= roman_numerals[number];\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmprthh67l9.d(38): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x42858e]\\n??:? immutable(char)[] tmprthh67l9.int_to_mini_roman(long)\
    \ [0x427cea]\\n??:? void tmprthh67l9.__unittest_L48_C1() [0x428176]\\n??:? void\
    \ tmprthh67l9.__modtest() [0x42825c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cc97]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bba6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4304cd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43097c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430459]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42bb7d]\\n??:? runModuleUnitTests [0x42ca6d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289a0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428927]\\n??:? _d_run_main [0x428892]\\n??:? main [0x42826f]\\\
    n??:? __libc_start_main [0x65ffe554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_tenthousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundredthousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_tenmillions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundredmillions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_tenbillions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiuujktzl.d(30): Error: unterminated string constant starting\
    \ at /tmp/tmpiuujktzl.d(48)\\n/tmp/tmpiuujktzl.d(35): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmpiuujktzl.d(35): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmpiuujktzl.d(36):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmpiuujktzl.d(37):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmpiuujktzl.d(38):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmpiuujktzl.d(39):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmpiuujktzl.d(40):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmpiuujktzl.d(41):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmpiuujktzl.d(42):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmpiuujktzl.d(43):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmpiuujktzl.d(44):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmpiuujktzl.d(45):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmpiuujktzl.d(46):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpiuujktzl.d(47):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmpiuujktzl.d(48):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpiuujktzl.d(50):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmpiuujktzl.d(50):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiuujktzl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    auto roman_numerals = [\"i\", \"v\", \"x\", \"l\", \"c\"\
    , \"d\", \"m\"];\n    auto roman_numerals_len = roman_numerals.length;\n    auto\
    \ roman_numerals_len_minus_1 = roman_numerals_len - 1;\n    auto roman_numerals_len_minus_2\
    \ = roman_numerals_len - 2;\n    auto roman_numerals_len_minus_3 = roman_numerals_len\
    \ - 3;\n    auto roman_numerals_len_minus_4 = roman_numerals_len - 4;\n    auto\
    \ roman_numerals_len_minus_5 = roman_numerals_len - 5;\n    auto roman_numerals_len_minus_6\
    \ = roman_numerals_len - 6;\n    auto roman_numerals_len_minus_7 = roman_numerals_len\
    \ - 7;\n    auto roman_numerals_len_minus_8 = roman_numerals_len - 8;\n    auto\
    \ roman_numerals_len_minus_9 = roman_numerals_len - 9;\n    auto roman_numerals_len_minus_10\
    \ = roman_numerals_len - 10;\n    auto roman_numerals_len_minus_11 = roman_numerals_len\
    \ - 11;\n    auto roman_numerals_len_minus_12 = roman_numerals_len - 12;\n   \
    \ auto roman_numerals_len_minus_13 = roman_numerals_len - 13;\n    auto roman_numerals_len_minus_14\
    \ = roman_numerals_len - 14;\n    auto roman_numerals_len_minus_15 = roman_numerals_len\
    \ - 15;\n    auto roman_numerals_len_minus_16 = roman_numerals_len - 16;\n   \
    \ auto roman_numerals_len_minus_17 = roman\nunittest\n{\n    alias candidate =\
    \ int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd0gsrgjm.d(40): Error: semicolon expected following auto declaration,\
    \ not `unittest`\\n/tmp/tmpd0gsrgjm.d(40): Error: found `unittest` instead of\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd0gsrgjm.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, num; numbers)\n    {\n        while(number >= num)\n\
    \        {\n            result ~= roman_numerals[i];\n            number -= num;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens = [\n\
    \        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\", \"c\"\
    , \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n\
    \    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\", \"mmm\"\
    \n    ];\n    static string[4] roman_ten_thousands = [\n        \"\", \"x\", \"\
    xx\", \"xxx\"\n    ];\n    static string[4] roman_hundred_thousands = [\n    \
    \    \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_millions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundred_millions\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_billions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_billions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundred_billions\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_trillions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp31a_f5j9.d(63): Error: semicolon expected, not `unittest`\\n/tmp/tmp31a_f5j9.d(63):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp31a_f5j9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[10] roman_thousands = [\n        \"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    static\
    \ string[10] roman_ten_thousands = [\n        \"x\", \"xx\", \"xxx\", \"xl\",\
    \ \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10]\
    \ roman_hundred_thousands = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\",\
    \ \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static string[10] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\"\
    , \"mx\", \"x\"\n    ];\n    static string[10] roman_ten_millions = [\n      \
    \  \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"\
    c\"\n    ];\n    static string[10] roman_hundred_millions = [\n        \"c\",\
    \ \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n \
    \   ];\n    static string[10] roman_billions = [\n        \"m\", \"mm\", \"mmm\"\
    , \"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn66lmo9v.d(47): Error: unterminated string constant starting\
    \ at /tmp/tmpn66lmo9v.d(66)\\n/tmp/tmpn66lmo9v.d(53): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmpn66lmo9v.d(53): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmpn66lmo9v.d(54):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmpn66lmo9v.d(55):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmpn66lmo9v.d(56):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmpn66lmo9v.d(57):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmpn66lmo9v.d(58):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmpn66lmo9v.d(59):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmpn66lmo9v.d(60):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmpn66lmo9v.d(61):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmpn66lmo9v.d(62):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmpn66lmo9v.d(63):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmpn66lmo9v.d(64):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpn66lmo9v.d(65):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmpn66lmo9v.d(66):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpn66lmo9v.d(68):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmpn66lmo9v.d(68):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn66lmo9v.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] roman_numbers\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] roman_numbers_len\
    \ = [1L, 1L, 1L, 1L, 1L, 1L, 1L];\n    static const long[] roman_numbers_len_sum\
    \ = [1L, 2L, 3L, 4L, 5L, 6L, 7L];\n    static const long[] roman_numbers_len_sum_rev\
    \ = [7L, 6L, 5L, 4L, 3L, 2L, 1L];\n    static const long[] roman_numbers_len_sum_rev_minus_one\
    \ = [6L, 5L, 4L, 3L, 2L, 1L, 0L];\n    static const long[] roman_numbers_len_sum_rev_minus_two\
    \ = [5L, 4L, 3L, 2L, 1L, 0L, 0L];\n    static const long[] roman_numbers_len_sum_rev_minus_three\
    \ = [4L, 3L, 2L, 1L, 0L, 0L, 0L];\n    static const long[] roman_numbers_len_sum_rev_minus_four\
    \ = [3L, 2L, 1L, 0L, 0L, 0L, 0L];\n    static const long[] roman_numbers_len_sum_rev_minus_five\
    \ = [2L, 1L, 0L, 0L, 0L, 0L, 0L];\n    static const long[] roman_numbers_len_sum_rev_minus_six\
    \ = [1L, 0L, 0L, 0L, 0L, 0L, 0L];\n    static const long[] roman_numbers_len_sum_rev_minus_seven\
    \ = [0L, 0L, 0L, 0L, 0L, 0L, 0L];\n    static const long[] roman_numbers_len_sum_rev_minus_eight\
    \ = [0L, 0L, 0L, 0L,\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp58g5httx.d(33): Error: expression expected, not `unittest`\\\
    n/tmp/tmp58g5httx.d(34): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmp58g5httx.d(52): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmp58g5httx.d(52): Error: semicolon expected, not `main`\\\
    n/tmp/tmp58g5httx.d(52): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp58g5httx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ decimal_numerals = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L,\
    \ 10L, 9L, 5L, 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral;\
    \ roman_numerals) {\n        while(number >= decimal_numerals[i]) {\n        \
    \    result ~= roman_numeral;\n            number -= decimal_numerals[i];\n  \
    \      }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] values =\
    \ [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] digits = [1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L];\n    static const long[] roman_digits = [1L, 2L, 3L,\
    \ 1L, 0L, 1L, 2L];\n    static const long[] roman_digits_5 = [0L, 0L, 0L, 1L,\
    \ 1L, 1L, 2L];\n    static const long[] roman_digits_10 = [0L, 0L, 0L, 2L, 2L,\
    \ 2L, 3L];\n    static const long[] roman_digits_50 = [0L, 0L, 0L, 1L, 1L, 1L,\
    \ 2L];\n    static const long[] roman_digits_100 = [0L, 0L, 0L, 2L, 2L, 2L, 3L];\n\
    \    static const long[] roman_digits_500 = [0L, 0L, 0L, 1L, 1L, 1L, 2L];\n  \
    \  static const long[] roman_digits_1000 = [0L, 0L, 0L, 2L, 2L, 2L, 3L];\n   \
    \ static const long[] roman_digits_5000 = [0L, 0L, 0L, 1L, 1L, 1L, 2L];\n    static\
    \ const long[] roman_digits_10000 = [0L, 0L, 0L, 2L, 2L, 2L, 3L];\n    static\
    \ const long[] roman_digits_50000 = [0L, 0L, 0L, 1L, 1L, 1L, 2L];\n    static\
    \ const long[] roman_digits_100000 = [0L, 0L, 0L, 2L, 2L, 2L, 3L];\n    static\
    \ const long[] roman_digits_500000 = [0L, 0L, 0L, 1L, 1L, 1L, 2\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyb3r5xt7.d(35): Error: comma expected separating array initializers,\
    \ not `unittest`\\n/tmp/tmpyb3r5xt7.d(36): Error: semicolon expected, not `{`\\\
    n/tmp/tmpyb3r5xt7.d(54): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyb3r5xt7.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    auto roman_numerals = tuple(\n        tuple(\"m\", 1000L),\n\
    \        tuple(\"cm\", 900L),\n        tuple(\"d\", 500L),\n        tuple(\"cd\"\
    , 400L),\n        tuple(\"c\", 100L),\n        tuple(\"xc\", 90L),\n        tuple(\"\
    l\", 50L),\n        tuple(\"xl\", 40L),\n        tuple(\"x\", 10L),\n        tuple(\"\
    ix\", 9L),\n        tuple(\"v\", 5L),\n        tuple(\"iv\", 4L),\n        tuple(\"\
    i\", 1L)\n    );\n    foreach(roman_numeral; roman_numerals)\n    {\n        auto\
    \ numeral = roman_numeral[0];\n        auto value = roman_numeral[1];\n      \
    \  auto count = number / value;\n        result ~= repeat(numeral, count);\n \
    \       number %= value;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm8s877jk.d(41): Error: undefined identifier `repeat`\\n/tmp/tmpm8s877jk.d(41):\
    \ Error: undefined identifier `repeat`\\n/tmp/tmpm8s877jk.d(41): Error: undefined\
    \ identifier `repeat`\\n/tmp/tmpm8s877jk.d(41): Error: undefined identifier `repeat`\\\
    n/tmp/tmpm8s877jk.d(41): Error: undefined identifier `repeat`\\n/tmp/tmpm8s877jk.d(41):\
    \ Error: undefined identifier `repeat`\\n/tmp/tmpm8s877jk.d(41): Error: undefined\
    \ identifier `repeat`\\n/tmp/tmpm8s877jk.d(41): Error: undefined identifier `repeat`\\\
    n/tmp/tmpm8s877jk.d(41): Error: undefined identifier `repeat`\\n/tmp/tmpm8s877jk.d(41):\
    \ Error: undefined identifier `repeat`\\n/tmp/tmpm8s877jk.d(41): Error: undefined\
    \ identifier `repeat`\\n/tmp/tmpm8s877jk.d(41): Error: undefined identifier `repeat`\\\
    n/tmp/tmpm8s877jk.d(41): Error: undefined identifier `repeat`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm8s877jk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(n; numbers)\n    {\n        while(number >= n)\n      \
    \  {\n            result ~= roman_numerals[numbers.indexOf(n)];\n            number\
    \ -= n;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_oyytoex.d(27): Error: no property `indexOf` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_oyytoex.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] digits = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[10] tens = [\"\", \"x\", \"xx\",\
    \ \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10]\
    \ hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"];\n    static string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"\
    ];\n    string result = \"\";\n    result ~= thousands[number / 1000];\n    result\
    \ ~= hundreds[(number % 1000) / 100];\n    result ~= tens[(number % 100) / 10];\n\
    \    result ~= digits[number % 10];\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number\
    \ >= numbers[i])\n        {\n            result ~= roman_numeral;\n          \
    \  number -= numbers[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, num; numbers)\n    {\n        while(number >= num)\n\
    \        {\n            result ~= roman_numerals[i];\n            number -= num;\n\
    \        }\n    }\n    return result;\n}\n/*\n    Given a string, return a new\
    \ string with the order of the characters reversed.\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnbdjaioq.d(33): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnbdjaioq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n\
    \    static long[] roman_values = [1, 5, 10, 50, 100, 500, 1000];\n    static\
    \ long[] divisors = [1, 10, 100, 1000];\n    static long[] multipliers = [1, 10,\
    \ 100, 1000];\n    static long[] roman_additive_values = [1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9];\n    static string[] roman_additive_symbols = [\"i\", \"ii\", \"iii\"\
    , \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static long[] roman_subtractive_values\
    \ = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    static string[] roman_subtractive_symbols\
    \ = [\"i\", \"x\", \"c\", \"m\"];\n    static string[] roman_subtractive_symbols_2\
    \ = [\"x\", \"c\", \"m\"];\n    static string[] roman_subtractive_symbols_3 =\
    \ [\"c\", \"m\"];\n    static string[] roman_subtractive_symbols_4 = [\"m\"];\n\
    \    static string[] roman_subtractive_symbols_5 = [\"i\", \"x\", \"c\", \"m\"\
    ];\n    static string[] roman_subtractive_symbols_6 = [\"x\", \"c\", \"m\"];\n\
    \    static string[] roman_subtractive_symbols_7 = [\"c\", \"m\"];\n    static\
    \ string[] roman_subtractive_symbols_8 = [\"m\"];\n    static string[] roman_subtractive_symbols_9\
    \ = [\"i\", \"x\", \"c\", \"m\"];\n    static string[] roman_subtractive_symbols_10\
    \ = [\"x\", \"c\", \"m\"];\n    static string[] roman_subtractive_symbols_11 =\
    \ [\"c\", \"m\"];\n    static string[] roman_subtractive_\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuzrs2836.d(39): Error: semicolon expected, not `unittest`\\n/tmp/tmpuzrs2836.d(39):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpuzrs2836.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptv_746ml.d(31): Error: expression expected, not `unittest`\\\
    n/tmp/tmptv_746ml.d(32): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmptv_746ml.d(50): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmptv_746ml.d(50): Error: semicolon expected, not `main`\\\
    n/tmp/tmptv_746ml.d(50): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptv_746ml.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static const string roman_numerals = \"ivxlcdm\";\n    static const\
    \ long[] values = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const string[]\
    \ numerals = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const\
    \ long[] subtractives = [1L, 10L, 100L];\n    static const string[] subtractive_numerals\
    \ = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n    static const long[]\
    \ subtractive_values = [4L, 9L, 40L, 90L, 400L, 900L];\n    static const string[]\
    \ subtractive_numerals_2 = [\"i\", \"x\", \"c\"];\n    static const long[] subtractive_values_2\
    \ = [1L, 10L, 100L];\n    static const string[] subtractive_numerals_3 = [\"i\"\
    , \"x\", \"c\"];\n    static const long[] subtractive_values_3 = [1L, 10L, 100L];\n\
    \    static const string[] subtractive_numerals_4 = [\"i\", \"x\", \"c\"];\n \
    \   static const long[] subtractive_values_4 = [1L, 10L, 100L];\n    static const\
    \ string[] subtractive_numerals_5 = [\"i\", \"x\", \"c\"];\n    static const long[]\
    \ subtractive_values_5 = [1L, 10L, 100L];\n    static const string[] subtractive_numerals_6\
    \ = [\"i\", \"x\", \"c\"];\n    static const long[] subtractive_values_6 = [1L,\
    \ 10L, 100L];\n    static const string[] subtractive_numerals_7 = [\"i\", \"x\"\
    , \"c\"];\n    static const long[] subtractive_values_7 = [1L, 10L, 100L];\n \
    \   static const string[] subtractive_numerals_8 = [\"i\", \"x\", \"c\"];\n  \
    \  static const long[] subtractive_values_8 = [1L, 10L, 100L];\n    static const\
    \ string[] subtract\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppjk9jxdy.d(42): Error: semicolon expected, not `unittest`\\n/tmp/tmppjk9jxdy.d(42):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppjk9jxdy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_thousands\
    \ = [\"\", \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_thousands\
    \ = [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_millions =\
    \ [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_millions = [\"\
    \", \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_millions =\
    \ [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_billions = [\"\
    \", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_billions = [\"\"\
    , \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_billions = [\"\
    \", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_trillions = [\"\"\
    , \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_trillions = [\"\",\
    \ \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_trillions =\
    \ [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_quadrillion =\
    \ [\"\", \"m\", \"mm\", \"mmm\"];\n    static string\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_e66m5n2.d(37): Error: no identifier for declarator `string`\\\
    n/tmp/tmp_e66m5n2.d(37): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_e66m5n2.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, r; roman)\n    {\n        while(number >= values[i])\n        {\n\
    \            number -= values[i];\n            result ~= r;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] decimal = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, r; roman)\n    {\n        while(number >= decimal[i])\n        {\n\
    \            number -= decimal[i];\n            result ~= r;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ immutable string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\"\
    , \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n\
    \    static immutable int[] values = [\n        1000, 900, 500, 400, 100, 90,\
    \ 50, 40, 10, 9, 5, 4, 1\n    ];\n    string result = \"\";\n    foreach(i, numeral;\
    \ roman_numerals)\n    {\n        while(number >= values[i])\n        {\n    \
    \        result ~= numeral;\n            number -= values[i];\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
