name: HumanEval_49_modp
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n / 2, p);\n    r = (r * r) % p;\n    if (n\
    \ % 2 == 1)\n        r = (r * 2) % p;\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\n/*\nReturn the number of digits of n in base b.\n\
    \    >>> digits(0L, 10L)\n    1L\n    >>> digits(1L, 10L)\n    1L\n    >>> digits(10L,\
    \ 10L)\n    2L\n    >>> digits(100L, 10L)\n    3L\n    >>> digits(1000L, 10L)\n\
    \    4L\n    >>> digits(123456789L, 10L)\n    9L\n    >>> digits(123456789L, 2L)\n\
    \    31L\n    >>> digits(123456789L, 8L)\n    12L\n    >>> digits(123456789L,\
    \ 16L)\n    8L\n    >>> digits(123456789L, 32L)\n    7L\n    >>> digits(123456789L,\
    \ 36L)\n    7L\n    >>> digits(123456789L, 62L)\n    6L\n    >>> digits(123456789L,\
    \ 64L)\n    6L\n*/\nlong digits(long n, long b) \n{\n    long res = 0L;\n    while\
    \ (n > 0L) \n    {\n        res += 1L;\n        n = n / b;\n    }\n    return\
    \ res;\n}\n/*\nReturn the number of digits of n in base b.\n    >>> digits(0L,\
    \ 10L)\n    1L\n    >>> digits(1L, 10L)\n    1L\n    >>> digits(10L, 10L)\n  \
    \  2L\n    >>> digits(100L, 10L)\n    3L\n    >>> digits(1000L, 10L)\n    4L\n\
    \    >>> digits(123456789L, 10L)\n    9L\n    >>> digits(123456789L, 2L)\n   \
    \ 31L\n    >>> digits(123456789L,\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptu3pq182.d(70): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptu3pq182.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow = n;\n    while (p != 0L) \n    {\n        if ((p & 1L) != 0L) \n\
    \        {\n            result = (result * pow) % p;\n        }\n        pow =\
    \ (pow * pow) % p;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwh7lxk67.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmpwh7lxk67.__unittest_L32_C1()\
    \ [0x427a79]\\n??:? void tmpwh7lxk67.__modtest() [0x427b74]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b87]\\\
    n??:? __libc_start_main [0xedfc7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n != 0L) {\n        if (n & 1L) {\n            result = (result *\
    \ n) % p;\n        }\n        n = n >> 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd8khohn4.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427de5]\\n??:? void tmpd8khohn4.__unittest_L28_C1()\
    \ [0x427a93]\\n??:? void tmpd8khohn4.__modtest() [0x427b68]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb0b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a99e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb31]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a975]\\n??:? runModuleUnitTests [0x42b8e1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428234]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281bb]\\n??:? _d_run_main [0x428126]\\n??:? main [0x427b7b]\\\
    n??:? __libc_start_main [0x81d5d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            r = (r * b) % p;\n        }\n        n >>= 1L;\n     \
    \   b = (b * b) % p;\n    }\n    return r;\n}\n/*\nReturn the Jacobi symbol (a/b),\
    \ b > 0 odd.\n    >>> jacobi(1, 3)\n    1\n    >>> jacobi(2, 3)\n    -1\n    >>>\
    \ jacobi(3, 3)\n    0\n    >>> jacobi(4, 3)\n    -1\n    >>> jacobi(5, 3)\n  \
    \  -1\n    >>> jacobi(6, 3)\n    0\n    >>> jacobi(7, 3)\n    -1\n    >>> jacobi(8,\
    \ 3)\n    1\n    >>> jacobi(9, 3)\n    0\n    >>> jacobi(10, 3)\n    1\n    >>>\
    \ jacobi(11, 3)\n    -1\n    >>> jacobi(12, 3)\n    0\n    >>> jacobi(13, 3)\n\
    \    -1\n    >>> jacobi(14, 3)\n    1\n    >>> jacobi(15, 3)\n    1\n    >>> jacobi(16,\
    \ 3)\n    1\n    >>> jacobi(17, 3)\n    -1\n    >>> jacobi(18, 3)\n    0\n   \
    \ >>> jacobi(19, 3)\n    -1\n    >>> jacobi(20, 3)\n    1\n    >>> jacobi(21,\
    \ 3)\n    1\n    >>> jacobi(22, 3)\n    0\n    >>> jacobi(23, 3)\n    -1\n   \
    \ >>> jacobi(24, 3)\n    0\n    >>> jacobi(25, 3)\n    1\n    >>> jacobi(26, 3)\n\
    \    1\n    >>> jacobi(27, 3)\n    0\n    >>> jacobi(28, 3)\n    0\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmos83s3s.d(32): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmos83s3s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpoceskeo4.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e6d]\\n??:? void tmpoceskeo4.__unittest_L28_C1()\
    \ [0x427b17]\\n??:? void tmpoceskeo4.__modtest() [0x427bec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fbb9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9fd]\\n??:? runModuleUnitTests [0x42b969]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428243]\\n??:? _d_run_main [0x4281ae]\\n??:? main [0x427bff]\\\
    n??:? __libc_start_main [0x51f45554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * a) % p;\n        }\n        a = (a * a) % p;\n      \
    \  n = n / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) return\
    \ 1;\n    long r = modp(n >> 1, p);\n    r = (r * r) % p;\n    if (n & 1) r =\
    \ (r * 2) % p;\n    return r;\n}\n/*\nReturn the number of digits in n.\n    >>>\
    \ numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(2L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n    5\n    >>>\
    \ numdigits(123456789L)\n    9\n*/\nlong numdigits(long n) \n{\n    if (n == 0)\
    \ return 1;\n    return cast(long) floor(log(n) / log(10)) + 1;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(2L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n*/\nlong numdigits(long n) \n{\n\
    \    if (n == 0) return 1;\n    return cast(long) floor(log(n) / log(10)) + 1;\n\
    }\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>>\
    \ numdigits(1L)\n    1\n    >>> numdigits(2L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(123456789L)\n    9\n\
    */\nlong numdigits(long n) \n{\n    if (n == 0) return 1;\n    return cast(long)\
    \ floor(log(n) / log(10)) + 1;\n}\n/*\nReturn the number of digits in n.\n   \
    \ >>> numdigits(0L)\n    1\n\nunittest\n{\n    alias candidate = modp;\n\n   \
    \ assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplklfmep9.d(85): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplklfmep9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow = n;\n    while (pow > 0L) \n    {\n        if ((pow & 1L) != 0L)\
    \ \n        {\n            result = (result * pow) % p;\n        }\n        pow\
    \ = pow >> 1L;\n        pow = (pow * pow) % p;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = n;\n    while (p > 0L) {\n        if (p & 1L) {\n            result\
    \ = (result * x) % n;\n        }\n        p >>= 1L;\n        x = (x * x) % n;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\n  \
    \  assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpr2oqfea8.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmpr2oqfea8.__unittest_L30_C1()\
    \ [0x427a7d]\\n??:? void tmpr2oqfea8.__modtest() [0x427b78]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b8b]\\\
    n??:? __libc_start_main [0xd890c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(100L)\n\
    \    3\n    >>> numdigits(1000L)\n    4\n    >>> numdigits(10000L)\n    5\n  \
    \  >>> numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n*/\nlong numdigits(long n) \n{\n    long r = 1L;\n    while (n >= 10L)\
    \ {\n        n = n / 10L;\n        r = r + 1L;\n    }\n    return r;\n}\n/*\n\
    Return the nth digit of n, where the rightmost digit is 0.\n    >>> nthdigit(1L,\
    \ 0L)\n    1L\n    >>> nthdigit(1L, 1L)\n    0L\n    >>> nthdigit(123456789L,\
    \ 0L)\n    9L\n    >>> nthdigit(123456789L, 1L)\n    8L\n    >>> nthdigit(123456789L,\
    \ 2L)\n    7L\n    >>> nthdigit(123456789L, 3L)\n    6L\n    >>> nthdigit(123456789L,\
    \ 4L)\n    5L\n    >>> nthdigit(123456789L, 5L)\n    4L\n    >>> nthdigit(123456789L,\
    \ 6L)\n    3L\n    >>> nthdigit(123456789L, 7L)\n    2L\n    >>> nthdigit(123456789L,\
    \ 8L)\n    1L\n    >>> nthdigit\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo7emogbb.d(58): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo7emogbb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = n;\n    while (p > 0L) {\n        if (p & 1L) {\n            result\
    \ = (result * x) % n;\n        }\n        p >>= 1L;\n        x = (x * x) % n;\n\
    \    }\n    return result;\n}\n/*\nReturn the smallest prime factor of n.\n  \
    \  >>> smallest_prime_factor(1L)\n    1L\n    >>> smallest_prime_factor(2L)\n\
    \    2L\n    >>> smallest_prime_factor(3L)\n    3L\n    >>> smallest_prime_factor(4L)\n\
    \    2L\n    >>> smallest_prime_factor(5L)\n    5L\n    >>> smallest_prime_factor(6L)\n\
    \    2L\n    >>> smallest_prime_factor(7L)\n    7L\n    >>> smallest_prime_factor(8L)\n\
    \    2L\n    >>> smallest_prime_factor(9L)\n    3L\n    >>> smallest_prime_factor(10L)\n\
    \    2L\n    >>> smallest_prime_factor(11L)\n    11L\n    >>> smallest_prime_factor(12L)\n\
    \    2L\n    >>> smallest_prime_factor(13L)\n    13L\n    >>> smallest_prime_factor(14L)\n\
    \    2L\n    >>> smallest_prime_factor(15L)\n    3L\n    >>> smallest_prime_factor(16L)\n\
    \    2L\n    >>> smallest_prime_factor(17L)\n    17L\n    >>> smallest_prime_factor(18L)\n\
    \    2L\n    >>> smallest_prime_factor(19L)\n    19L\n    >>> smallest_prime_factor(20L)\n\
    \    2L\n    >>> smallest_prime_factor(21L)\n    3L\n    >>> smallest_prime_factor(22L)\n\
    \    2L\n    >>> smallest_prime_factor(23L)\n    23L\n    >>> smallest_prime_factor(24L)\n\
    \    2L\n    >>> smallest_prime_factor(25L)\n    5L\n    >>> smallest_prime_factor(26L)\n\
    \    2L\n    >>>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpajfe9clr.d(30): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpajfe9clr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphyuoeq1j.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e6d]\\n??:? void tmphyuoeq1j.__unittest_L28_C1()\
    \ [0x427b17]\\n??:? void tmphyuoeq1j.__modtest() [0x427bec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fbb9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9fd]\\n??:? runModuleUnitTests [0x42b969]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428243]\\n??:? _d_run_main [0x4281ae]\\n??:? main [0x427bff]\\\
    n??:? __libc_start_main [0xfd5b6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * b) % p;\n        }\n        n >>= 1L;\n        b =\
    \ (b * b) % p;\n    }\n    return result;\n}\n/*\nReturn the Jacobi symbol (a/b)\
    \ (be aware of numerics).\n    >>> jacobi(1L, 1L)\n    1\n    >>> jacobi(2L, 1L)\n\
    \    1\n    >>> jacobi(2L, 3L)\n    -1\n    >>> jacobi(3L, 2L)\n    -1\n    >>>\
    \ jacobi(4L, 3L)\n    0\n    >>> jacobi(4L, 5L)\n    -1\n    >>> jacobi(5L, 4L)\n\
    \    1\n    >>> jacobi(6L, 7L)\n    -1\n    >>> jacobi(7L, 6L)\n    1\n    >>>\
    \ jacobi(8L, 7L)\n    0\n    >>> jacobi(8L, 11L)\n    1\n    >>> jacobi(11L, 8L)\n\
    \    1\n    >>> jacobi(9L, 11L)\n    -1\n    >>> jacobi(11L, 9L)\n    -1\n   \
    \ >>> jacobi(10L, 11L)\n    0\n    >>> jacobi(11L, 10L)\n    0\n    >>> jacobi(11L,\
    \ 13L)\n    1\n    >>> jacobi(13L, 11L)\n    1\n    >>> jacobi(12L, 13L)\n   \
    \ -1\n    >>> jacobi(13L, 12L)\n    -1\n    >>> jacobi(13L, 14L)\n    0\n    >>>\
    \ jacobi(14L, 13L)\n    0\n    >>> jacobi(15L, 16L)\n    1\n    >>> jacobi(16L,\
    \ 15L)\n    1\n    >>> jacobi(17L, 16L)\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp41u7ib22.d(30): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp41u7ib22.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * a) % p;\n        }\n        a = (a * a) % p;\n      \
    \  n = n / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * b) % p;\n        }\n        n >>= 1L;\n        b =\
    \ (b * b) % p;\n    }\n    return result;\n}\n/*\nReturn the number of digits\
    \ in the decimal representation of n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(2L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n\
    \    5\n    >>> digits(10**40)\n    41\n*/\nlong digits(long n) \n{\n    long\
    \ result = 1L;\n    while (n >= 10L) {\n        n /= 10L;\n        result += 1L;\n\
    \    }\n    return result;\n}\n/*\nReturn the number of digits in the decimal\
    \ representation of n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n\
    \    >>> digits(2L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n\
    \    5\n    >>> digits(10**40)\n    41\n*/\nlong digits(long n) \n{\n    long\
    \ result = 1L;\n    while (n >= 10L) {\n        n /= 10L;\n        result += 1L;\n\
    \    }\n    return result;\n}\n/*\nReturn the number of digits in the decimal\
    \ representation of n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n\
    \    >>> digits(2L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n\
    \    5\n    >>> digits(10**40)\n    41\n*/\nlong digits(long n) \n{\n    long\
    \ result = 1L;\n    while (n >= 10L) {\n        n /= 10L;\n        result += 1L;\n\
    \    }\n    return result;\n}\n/*\nReturn the number of digits in the decimal\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnvv2eqry.d(102): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnvv2eqry.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow = n;\n    while (p != 0L) \n    {\n        if ((p & 1L) != 0L) \n\
    \        {\n            result = (result * pow) % p;\n        }\n        pow =\
    \ (pow * pow) % p;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpewl0xbf3.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmpewl0xbf3.__unittest_L32_C1()\
    \ [0x427a79]\\n??:? void tmpewl0xbf3.__modtest() [0x427b74]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b87]\\\
    n??:? __libc_start_main [0x6af05554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n % 2L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n /= 2L;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        n\
    \ >>= 1L;\n        base = (base * base) % p;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(10L)\n    2\n    >>> digits(100L)\n    3\n    >>> digits(12345L)\n\
    \    5\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    long r = 1L;\n    while (n >= 10L) \n    {\n        n = n / 10L;\n\
    \        r = r + 1L;\n    }\n    return r;\n}\n/*\nReturn the nth digit of n (0-based).\n\
    \    >>> nthdigit(0L, 0L)\n    0\n    >>> nthdigit(0L, 1L)\n    0\n    >>> nthdigit(1L,\
    \ 0L)\n    1\n    >>> nthdigit(1L, 1L)\n    0\n    >>> nthdigit(12345L, 0L)\n\
    \    5\n    >>> nthdigit(12345L, 1L)\n    4\n    >>> nthdigit(12345L, 2L)\n  \
    \  3\n    >>> nthdigit(12345L, 3L)\n    2\n    >>> nthdigit(12345L, 4L)\n    1\n\
    \    >>> nthdigit(12345L, 5L)\n    0\n    >>> nthdigit(12345L, 6L)\n    0\n*/\n\
    long nthdigit(long n, long i) \n{\n    long r = 0L;\n    while (i > 0L) \n   \
    \ {\n        n = n / 10L;\n        i = i - 1L;\n    }\n    return n % 10L;\n}\n\
    /*\nReturn the sum of the digits of n.\n    >>> sumdigits(0L)\n   \nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppqht_ewe.d(90): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppqht_ewe.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            res = (res * a) % p;\n        }\n        a = (a * a) %\
    \ p;\n        n >>= 1L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n   \
    \     {\n            r = (r * b) % p;\n        }\n        n = n / 2L;\n      \
    \  b = (b * b) % p;\n    }\n    return r;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789012345L)\n    15\n\
    \    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n) \n{\n \
    \   long d = 1L;\n    while (n >= 10L) \n    {\n        n = n / 10L;\n       \
    \ d = d + 1L;\n    }\n    return d;\n}\n/*\nReturn the sum of the digits in n.\n\
    \    >>> digit_sum(0L)\n    0\n    >>> digit_sum(1L)\n    1\n    >>> digit_sum(10L)\n\
    \    1\n    >>> digit_sum(12345L)\n    15\n    >>> digit_sum(123456789012345L)\n\
    \    45\n    >>> digit_sum(1234567890123456789L)\n    81\n*/\nlong digit_sum(long\
    \ n) \n{\n    long s = 0L;\n    while (n > 0L) \n    {\n        s = s + n % 10L;\n\
    \        n = n / 10L;\n    }\n    return s;\n}\n/*\nReturn the sum of the digits\
    \ in n.\n    >>> digit_sum(0L)\n    0\n    >>> digit_sum(1L)\n    1\n    >>> digit_sum(10L)\n\
    \    1\n    >>> digit_sum(12345L)\n    15\n    >>> digit_sum(123456789012345L)\n\
    \    45\n    >>> digit_sum(12345678901\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcrcucdbn.d(82): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcrcucdbn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else if (n == 1)\n    {\n        return 2;\n\
    \    }\n    else if (n == 2)\n    {\n        return 4;\n    }\n    else if (n\
    \ == 3)\n    {\n        return 8;\n    }\n    else if (n == 4)\n    {\n      \
    \  return 16;\n    }\n    else if (n == 5)\n    {\n        return 32;\n    }\n\
    \    else if (n == 6)\n    {\n        return 64;\n    }\n    else if (n == 7)\n\
    \    {\n        return 128;\n    }\n    else if (n == 8)\n    {\n        return\
    \ 256;\n    }\n    else if (n == 9)\n    {\n        return 512;\n    }\n    else\
    \ if (n == 10)\n    {\n        return 1024;\n    }\n    else if (n == 11)\n  \
    \  {\n        return 2048;\n    }\n    else if (n == 12)\n    {\n        return\
    \ 4096;\n    }\n    else if (n == 13)\n    {\n        return 8192;\n    }\n  \
    \  else if (n == 14)\n    {\n        return 16384;\n    }\n    else if (n == 15)\n\
    \    {\n        return 32768;\n    }\n    else if (n == 16)\n    {\n        return\
    \ 65536;\n    }\n    else if (n == 17)\n    {\n        return 131072;\n    }\n\
    \    else if (n == 18)\n    {\n        return 262144;\n    }\n    else if (n ==\
    \ 19)\n    {\n        return 524288;\n    }\n    else if (n == 20)\n    {\n  \
    \      return 1048576;\n    }\n    else if (n == 21)\n    {\n        return 2097152;\n\
    \    }\n    else if (n == 22)\n    {\n        return 4194304;\n    }\n    else\
    \ if (n == 23)\n    {\n        return 8388608;\n    }\n    else if (n == 24)\n\
    \    {\n       \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpck6vbm37.d(118): Error: found `unittest` instead of statement\\\
    n/tmp/tmpck6vbm37.d(130): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpck6vbm37.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(123456789012345L)\n    15\n    \n*/\nlong numdigits(long\
    \ n) \n{\n    if (n == 0)\n        return 1;\n    else\n        return (long)log10(n)\
    \ + 1;\n}\n/*\nReturn the sum of the digits in n.\n    >>> sumdigits(0L)\n   \
    \ 0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(12345L)\n    15\n    >>>\
    \ sumdigits(10L)\n    1\n    >>> sumdigits(123456789012345L)\n    45\n    \n*/\n\
    long sumdigits(long n) \n{\n    if (n == 0)\n        return 0;\n    else\n   \
    \     return sumdigits(n / 10) + n % 10;\n}\n/*\nReturn the number of digits in\
    \ n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(10L)\n    2\n    >>> numdigits(123456789012345L)\n \
    \   15\n    \n*/\nlong numdigits(long n) \n{\n    if (n == 0)\n        return\
    \ 1;\n    else\n        return (long)log10(n) + 1;\n}\n/*\nReturn the sum of the\
    \ digits in n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjsknb6qe.d(45): Error: C style cast illegal, use `cast(long)log10(n)`\\\
    n/tmp/tmpjsknb6qe.d(87): Error: C style cast illegal, use `cast(long)log10(n)`\\\
    n/tmp/tmpjsknb6qe.d(89): Error: unterminated /* */ comment\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjsknb6qe.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       r = (r * b) % p;\n        }\n        n >>= 1L;\n        b = (b * b) %\
    \ p;\n    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n  \
    \  assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the nth Lucas number.\n    >>> lucas(0L)\n    2L\n    >>> lucas(1L)\n\
    \    1L\n    >>> lucas(2L)\n    3L\n    >>> lucas(3L)\n    4L\n    >>> lucas(4L)\n\
    \    7L\n    >>> lucas(5L)\n    11L\n    >>> lucas(6L)\n    18L\n    >>> lucas(7L)\n\
    \    29L\n    >>> lucas(8L)\n    47L\n    >>> lucas(9L)\n    76L\n    >>> lucas(10L)\n\
    \    123L\n    >>> lucas(11L)\n    199L\n    >>> lucas(12L)\n    322L\n    >>>\
    \ lucas(13L)\n    521L\n    >>> lucas(14L)\n    843L\n    >>> lucas(15L)\n   \
    \ 1364L\n    >>> lucas(16L)\n    2207L\n    >>> lucas(17L)\n    3571L\n    >>>\
    \ lucas(18L)\n    5778L\n    >>> lucas(19L)\n    9349L\n    >>> lucas(20L)\n \
    \   15127L\n    >>> lucas(21L)\n    24476L\n    >>> lucas(22L)\n    39603L\n \
    \   >>> lucas(23L)\n    64079L\n    >>> lucas(24L)\n    103682L\n    >>> lucas(25L)\n\
    \    167761L\n    >>> lucas(26L)\n    271443L\n    >>> lucas(27L)\n    439204L\n\
    \    >>> lucas(28L)\n    710647L\n    >>> lucas(29L)\n    1149851L\n    >>> lucas(30L)\n\
    \    1860498L\n\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpazgqdq08.d(30): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpazgqdq08.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long res = modp(n /\
    \ 2, p);\n        res = (res * res) % p;\n        if (n % 2 == 1) \n        {\n\
    \            res = (res * 2) % p;\n        }\n        return res;\n    }\n}\n\
    /*\nReturn the number of digits of n in base b.\n    >>> digits(0L, 2L)\n    1L\n\
    \    >>> digits(0L, 10L)\n    1L\n    >>> digits(5L, 10L)\n    1L\n    >>> digits(12345L,\
    \ 10L)\n    5L\n    >>> digits(66L, 2L)\n    6L\n    >>> digits(66L, 8L)\n   \
    \ 3L\n    >>> digits(66L, 16L)\n    2L\n    >>> digits(66L, 26L)\n    2L\n   \
    \ >>> digits(123456789L, 10L)\n    9L\n    >>> digits(123456789L, 16L)\n    8L\n\
    \    >>> digits(123456789L, 26L)\n    7L\n    >>> digits(123456789L, 36L)\n  \
    \  7L\n*/\nlong digits(long n, long b) \n{\n    if (n == 0) \n    {\n        return\
    \ 1;\n    }\n    else \n    {\n        return 1 + digits(n / b, b);\n    }\n}\n\
    /*\nReturn the sum of the digits of n in base b.\n    >>> sumdigits(0L, 2L)\n\
    \    0L\n    >>> sumdigits(0L, 10L)\n    0L\n    >>> sumdigits(5L, 10L)\n    5L\n\
    \    >>> sumdigits(12345L, 10L)\n    15L\n    >>> sumdigits(66L, 2L)\n    6L\n\
    \    >>> sumdigits(66L, 8L)\n    8L\n    >>> sumdigits(66L, 16L)\n    12L\n  \
    \  >>> sumdigits(66L, 26L)\n    13\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpozv1cdug.d(72): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpozv1cdug.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n == 1)\n        return n % p;\n    if (n % 2 == 0)\n\
    \        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n        return\
    \ modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n\
    \    2\n    >>> digits(123)\n    3\n    >>> digits(12345)\n    5\n    >>> digits(123456789)\n\
    \    9\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n    else\n\
    \        return (long)log10(n) + 1;\n}\n/*\nReturn the sum of the digits of n.\n\
    \    >>> sum_digits(0)\n    0\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(10)\n\
    \    1\n    >>> sum_digits(123)\n    6\n    >>> sum_digits(12345)\n    15\n  \
    \  >>> sum_digits(123456789)\n    45\n*/\nlong sum_digits(long n) \n{\n    if\
    \ (n == 0)\n        return 0;\n    else\n        return n % 10 + sum_digits(n\
    \ / 10);\n}\n/*\nReturn the sum of the digits of n.\n    >>> sum_digits(0)\n \
    \   0\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(10)\n    1\n    >>> sum_digits(123)\n\
    \    6\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(123456789)\n   \
    \ 45\n*/\nlong sum_digits(long n) \n{\n    if (n == 0)\n        return 0;\n  \
    \  else\n        return n % 10 + sum_digits(n / 10);\n}\n/*\nReturn the sum of\
    \ the digits of\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpafgsdhh9.d(48): Error: C style cast illegal, use `cast(long)log10(n)`\\\
    n/tmp/tmpafgsdhh9.d(94): Error: unterminated /* */ comment\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpafgsdhh9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 0) \n  \
    \  {\n        return p - modp(-n, p);\n    }\n    long result = 1L;\n    long\
    \ factor = 2L;\n    while (n > 0) \n    {\n        if (n % 2 == 1) \n        {\n\
    \            result = (result * factor) % p;\n        }\n        factor = (factor\
    \ * factor) % p;\n        n /= 2;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else\n    {\n\
    \        long half = modp(n / 2, p);\n        long half2 = (half * half) % p;\n\
    \        if (n % 2 == 0)\n            return half2;\n        else\n          \
    \  return (half2 * n) % p;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcaoayaze.d(38): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e25]\\n??:? void tmpcaoayaze.__unittest_L33_C1()\
    \ [0x427acf]\\n??:? void tmpcaoayaze.__modtest() [0x427ba4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb4b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb71]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430020]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fafd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9b5]\\n??:? runModuleUnitTests [0x42b921]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428274]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281fb]\\n??:? _d_run_main [0x428166]\\n??:? main [0x427bb7]\\\
    n??:? __libc_start_main [0x16401554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * a) % p;\n        }\n        a = (a * a) % p;\n      \
    \  n = n / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long res = 1;\n    while (n > 0)\n    {\n        if (n &\
    \ 1)\n            res = (res * n) % p;\n        n = n >> 1;\n        n = (n *\
    \ n) % p;\n    }\n    return res;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n\
    \    >>> digits(10**100)\n    101\n    >>> digits(10**1000)\n    1001\n*/\nlong\
    \ digits(long n) \n{\n    if (n == 0)\n        return 1;\n    long res = 0;\n\
    \    while (n > 0)\n    {\n        n = n / 10;\n        res++;\n    }\n    return\
    \ res;\n}\n/*\nReturn the sum of the digits of n.\n    >>> sum_digits(0)\n   \
    \ 0\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(10)\n    1\n    >>> sum_digits(10**100)\n\
    \    1\n    >>> sum_digits(12345678901234567890)\n    90\n*/\nlong sum_digits(long\
    \ n) \n{\n    if (n == 0)\n        return 0;\n    long res = 0;\n    while (n\
    \ > 0)\n    {\n        res += n % 10;\n        n = n / 10;\n    }\n    return\
    \ res;\n}\n/*\nReturn the sum of the digits of n in base b.\n    >>> sum_digits_base(0,\
    \ 2)\n    0\n    >>> sum_digits_base(1, 2)\n    1\n    >>> sum_digits_base(10,\
    \ 2)\n    1\n    >>> sum_digits_base(10**100, 2)\n    1\n    >>> sum_digits_base(12345678901234567890,\
    \ 10)\n    90\n    >>> sum_digits_base(12345678901234567890, 16)\n    136\n*/\n\
    long\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpedeuv7up.d(97): Error: no identifier for declarator `long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpedeuv7up.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow = n;\n    while (p > 0L) \n    {\n        if ((p & 1L) != 0L) \n\
    \        {\n            result = (result * pow) % p;\n        }\n        pow =\
    \ (pow * pow) % p;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjv7h4chw.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmpjv7h4chw.__unittest_L32_C1()\
    \ [0x427a79]\\n??:? void tmpjv7h4chw.__modtest() [0x427b74]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b87]\\\
    n??:? __libc_start_main [0x84348554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(1234567890123456789L)\n    19\n    \n*/\nlong numdigits(long\
    \ n) \n{\n    long r = 1L;\n    while (n >= 10L) {\n        n = n / 10L;\n   \
    \     r = r + 1L;\n    }\n    return r;\n}\n/*\nReturn the number of digits in\
    \ n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n    \n*/\nlong numdigits(long n) \n{\n    long r = 1L;\n    while (n\
    \ >= 10L) {\n        n = n / 10L;\n        r = r + 1L;\n    }\n    return r;\n\
    }\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>>\
    \ numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(1234567890123456789L)\n    19\n    \n*/\nlong numdigits(long\
    \ n) \n{\n    long r = 1L;\n    while (n >= 10L) {\n        n = n / 10L;\n   \
    \     r\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp96xfm62i.d(96): Error: found `unittest` when expecting `;` following\
    \ statement\\n/tmp/tmp96xfm62i.d(108): Error: found `End of File` when expecting\
    \ `}` following compound statement\\n/tmp/tmp96xfm62i.d(108): Error: found `End\
    \ of File` when expecting `}` following compound statement\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp96xfm62i.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else\n    {\n        long r = modp(n / 2, p);\n        r\
    \ = (r * r) % p;\n        if (n % 2 == 1)\n            r = (r * 2) % p;\n    \
    \    return r;\n    }\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n\
    \    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n\
    \    5\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    if (n == 0)\n        return 1;\n    else\n        return (long)floor(log10(n))\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n\
    \    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n\
    \    5\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    if (n == 0)\n        return 1;\n    else\n        return (long)floor(log10(n))\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n\
    \    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n\
    \    5\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    if (n == 0)\n        return 1;\n    else\n        return (long)floor(log10(n))\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n\
    \    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n\
    \    5\n    >>> digits(1234567890123456789\nunittest\n{\n    alias candidate =\
    \ modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L)\
    \ == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L)\
    \ == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpequ96fwt.d(48): Error: C style cast illegal, use `cast(long)floor(log10(n))`\\\
    n/tmp/tmpequ96fwt.d(68): Error: C style cast illegal, use `cast(long)floor(log10(n))`\\\
    n/tmp/tmpequ96fwt.d(88): Error: C style cast illegal, use `cast(long)floor(log10(n))`\\\
    n/tmp/tmpequ96fwt.d(90): Error: unterminated /* */ comment\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpequ96fwt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n == 1)\n        return n % p;\n    if (n % 2 == 0)\n\
    \        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n        return\
    \ modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpogztutdt.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e6d]\\n??:? void tmpogztutdt.__unittest_L28_C1()\
    \ [0x427b17]\\n??:? void tmpogztutdt.__modtest() [0x427bec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fbb9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9fd]\\n??:? runModuleUnitTests [0x42b969]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428243]\\n??:? _d_run_main [0x4281ae]\\n??:? main [0x427bff]\\\
    n??:? __libc_start_main [0x9750a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n) {\n        r = (r * 2L) % p;\n    }\n    return r;\n}\n\
    /*\nReturn the number of bits in the binary representation of n.\n    >>> bits(0L)\n\
    \    0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n \
    \   2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n    3\n    >>> bits(6L)\n  \
    \  3\n    >>> bits(7L)\n    3\n    >>> bits(8L)\n    4\n    >>> bits(9L)\n   \
    \ 4\n    >>> bits(10L)\n    4\n    >>> bits(11L)\n    4\n    >>> bits(12L)\n \
    \   4\n    >>> bits(13L)\n    4\n    >>> bits(14L)\n    4\n    >>> bits(15L)\n\
    \    4\n    >>> bits(16L)\n    5\n    >>> bits(17L)\n    5\n    >>> bits(18L)\n\
    \    5\n    >>> bits(19L)\n    5\n    >>> bits(20L)\n    5\n    >>> bits(21L)\n\
    \    5\n    >>> bits(22L)\n    5\n    >>> bits(23L)\n    5\n    >>> bits(24L)\n\
    \    5\n    >>> bits(25L)\n    5\n    >>> bits(26L)\n    5\n    >>> bits(27L)\n\
    \    5\n    >>> bits(28L)\n    5\n    >>> bits(29L)\n    5\n    >>> bits(30L)\n\
    \    5\n    >>> bits(31L)\n    5\n    >>> bits(32L)\n    6\n    >>> bits(33L)\n\
    \    6\n    >>> bits(34L)\n    6\n    >>> bits(35L)\n    6\n    >>> bits(36L)\n\
    \    6\n    >>> bits(37L)\n    6\n    >>> bits(38L)\n    6\n    >>> bits(39L)\n\
    \    6\n    >>> bits(40L)\n    6\n\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_8t9m7f4.d(25): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_8t9m7f4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            res = (res * a) % p;\n        }\n        a = (a * a) %\
    \ p;\n        n >>= 1L;\n    }\n    return res;\n}\n/*\nReturn the number of bits\
    \ in n.\n    >>> bitlength(0L)\n    0\n    >>> bitlength(1L)\n    1\n    >>> bitlength(2L)\n\
    \    2\n    >>> bitlength(3L)\n    2\n    >>> bitlength(4L)\n    3\n    >>> bitlength(5L)\n\
    \    3\n    >>> bitlength(6L)\n    3\n    >>> bitlength(7L)\n    3\n    >>> bitlength(8L)\n\
    \    4\n    >>> bitlength(9L)\n    4\n    >>> bitlength(10L)\n    4\n    >>> bitlength(11L)\n\
    \    4\n    >>> bitlength(12L)\n    4\n    >>> bitlength(13L)\n    4\n    >>>\
    \ bitlength(14L)\n    4\n    >>> bitlength(15L)\n    4\n    >>> bitlength(16L)\n\
    \    5\n    >>> bitlength(17L)\n    5\n    >>> bitlength(18L)\n    5\n    >>>\
    \ bitlength(19L)\n    5\n    >>> bitlength(20L)\n    5\n    >>> bitlength(21L)\n\
    \    5\n    >>> bitlength(22L)\n    5\n    >>> bitlength(23L)\n    5\n    >>>\
    \ bitlength(24L)\n    5\n    >>> bitlength(25L)\n    5\n    >>> bitlength(26L)\n\
    \    5\n    >>> bitlength(27L)\n    5\n    >>> bitlength(28L)\n    5\n    >>>\
    \ bitlength(29L)\n    5\n    >>> bitlength(30L)\n    5\n    >>> bitlength(31L)\n\
    \    5\n    >>> bitlength(32L)\n    6\n    >>> bitlength(33L)\n    6\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp472r328l.d(32): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp472r328l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n  \
    \      {\n            result = (result * a) % p;\n        }\n        a = (a *\
    \ a) % p;\n        n = n / 2L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else\n    {\n        long r = modp(n >> 1,\
    \ p);\n        r = (r * r) % p;\n        if (n & 1)\n        {\n            r\
    \ = (r * 2) % p;\n        }\n        return r;\n    }\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n\
    \    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(123456789012345L)\n\
    \    15\n*/\nlong numdigits(long n) \n{\n    if (n == 0)\n    {\n        return\
    \ 1;\n    }\n    else\n    {\n        return (long)floor(log10(n)) + 1;\n    }\n\
    }\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>>\
    \ numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789012345L)\n    15\n*/\nlong numdigits(long n)\
    \ \n{\n    if (n == 0)\n    {\n        return 1;\n    }\n    else\n    {\n   \
    \     return (long)floor(log10(n)) + 1;\n    }\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(123456789012345L)\n\
    \    15\n*/\nlong numdigits(long n) \n{\n    if (n == 0)\n    {\n        return\
    \ 1;\n    }\n    else\n    {\n        return (long)floor(log10(n)) + 1\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2l85z0kx.d(55): Error: C style cast illegal, use `cast(long)floor(log10(n))`\\\
    n/tmp/tmp2l85z0kx.d(79): Error: C style cast illegal, use `cast(long)floor(log10(n))`\\\
    n/tmp/tmp2l85z0kx.d(103): Error: C style cast illegal, use `cast(long)floor(log10(n))`\\\
    n/tmp/tmp2l85z0kx.d(104): Error: found `unittest` when expecting `;` following\
    \ `return` statement\\n/tmp/tmp2l85z0kx.d(116): Error: found `End of File` when\
    \ expecting `}` following compound statement\\n/tmp/tmp2l85z0kx.d(116): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2l85z0kx.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n   \
    \     {\n            r = (r * b) % p;\n        }\n        n = n / 2L;\n      \
    \  b = (b * b) % p;\n    }\n    return r;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * b) % p;\n        }\n        n >>= 1L;\n        b =\
    \ (b * b) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n  \
    \      {\n            result = (result * a) % p;\n        }\n        a = (a *\
    \ a) % p;\n        n = n / 2L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else\n    {\n        long r = modp(n / 2, p);\n        r\
    \ = (r * r) % p;\n        if (n % 2 == 1)\n            r = (r * 2) % p;\n    \
    \    return r;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\n/*\nReturn the\
    \ nth Fibonacci number.\n    >>> fib(0)\n    0\n    >>> fib(1)\n    1\n    >>>\
    \ fib(2)\n    1\n    >>> fib(3)\n    2\n    >>> fib(4)\n    3\n    >>> fib(5)\n\
    \    5\n    >>> fib(6)\n    8\n    >>> fib(100)\n    354224848179261915075\n \
    \   >>> fib(101)\n    573147844013817084101\n    >>> fib(102)\n    927372692193078999176\n\
    \    >>> fib(103)\n    1500520536206896083277\n    >>> fib(104)\n    2427893228399975082453\n\
    \    >>> fib(105)\n    3928413764606871165730\n    >>> fib(106)\n    6356306993006846248183\n\
    \    >>> fib(107)\n    10284720757613717413913\n    >>> fib(108)\n    16641027750620563662096\n\
    \    >>> fib(109)\n    26925748508234281076009\n    >>> fib(110)\n    43566776258854844738105\n\
    \    >>> fib(111)\n    70492524767089125814114\n    >>> fib(112)\n    114059301025943970552219\n\
    \    >>> fib(113)\n    184551825793033096366333\n    >>> fib(114)\n    298611126818977066918552\n\
    \    >>> fib(115)\n    483162952612010163284885\n    >>> fib(116)\n    781774079430987230203437\n\
    \    >>> fib(117\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt9ulxg4p.d(28): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9ulxg4p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = n;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n   \
    \     {\n            result = (result * x) % p;\n        }\n        x = (x * x)\
    \ % p;\n        n = n / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpl96gmqul.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e15]\\n??:? void tmpl96gmqul.__unittest_L32_C1()\
    \ [0x427a99]\\n??:? void tmpl96gmqul.__modtest() [0x427b94]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb3b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb61]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430010]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9a5]\\n??:? runModuleUnitTests [0x42b911]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428264]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281eb]\\n??:? _d_run_main [0x428156]\\n??:? main [0x427ba7]\\\
    n??:? __libc_start_main [0x88d16554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * a) % p;\n        }\n        a = (a * a) % p;\n      \
    \  n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n\
    \    20\n    \n*/\nlong digits(long n) \n{\n    long result = 1L;\n    while (n\
    \ >= 10L) {\n        n = n / 10L;\n        result = result + 1L;\n    }\n    return\
    \ result;\n}\n/*\nReturn the nth digit of n, counting from the right.\n    >>>\
    \ nthdigit(0L, 0L)\n    0\n    >>> nthdigit(0L, 1L)\n    0\n    >>> nthdigit(0L,\
    \ 2L)\n    0\n    >>> nthdigit(12345L, 0L)\n    5\n    >>> nthdigit(12345L, 1L)\n\
    \    4\n    >>> nthdigit(12345L, 2L)\n    3\n    >>> nthdigit(12345L, 3L)\n  \
    \  2\n    >>> nthdigit(12345L, 4L)\n    1\n    >>> nthdigit(12345L, 5L)\n    0\n\
    \    \n*/\nlong nthdigit(long n, long d) \n{\n    while (d > 0L) {\n        n\
    \ = n / 10L;\n        d = d - 1L;\n    }\n    return n % 10L;\n}\n/*\nReturn the\
    \ number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n\
    \    >>> digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(1234567\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2ym3go_8.d(83): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2ym3go_8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       r = (r * b) % p;\n        }\n        n >>= 1L;\n        b = (b * b) %\
    \ p;\n    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n  \
    \  assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in the decimal representation of n.\n\
    \    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n\
    \    >>> digits(10**100)\n    101\n    >>> digits(10**1000)\n    1001\n*/\nlong\
    \ digits(long n) \n{\n    if (n == 0)\n        return 1;\n    return cast(long)floor(log(n)\
    \ / log(10)) + 1;\n}\n/*\nReturn the number of digits in the decimal representation\
    \ of n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n\
    \    2\n    >>> digits(10**100)\n    101\n    >>> digits(10**1000)\n    1001\n\
    */\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n    return cast(long)floor(log(n)\
    \ / log(10)) + 1;\n}\n/*\nReturn the number of digits in the decimal representation\
    \ of n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n\
    \    2\n    >>> digits(10**100)\n    101\n    >>> digits(10**1000)\n    1001\n\
    */\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n    return cast(long)floor(log(n)\
    \ / log(10)) + 1;\n}\n/*\nReturn the number of digits in the decimal representation\
    \ of n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n\
    \    2\n    >>> digits(10**100)\n    101\n    >>> digits(10**1000)\n    1001\n\
    */\nlong digits(\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2c6huwie.d(97): Error: basic type expected, not `unittest`\\\
    n/tmp/tmp2c6huwie.d(97): Error: found `unittest` when expecting `)`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2c6huwie.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * x) % p;\n        }\n        n >>= 1L;\n        x =\
    \ (x * x) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    long i = p - 2L;\n    while (i > 0L) \n    {\n     \
    \   if (i % 2L == 1L) \n        {\n            result = (result * power) % p;\n\
    \        }\n        power = (power * power) % p;\n        i = i / 2L;\n    }\n\
    \    return result;\n}\n/*\nReturn the number of elements in the group of integers\
    \ modulo p.\n    >>> group_size(5L)\n    4L\n    >>> group_size(7L)\n    6L\n\
    \    >>> group_size(11L)\n    10L\n    >>> group_size(13L)\n    12L\n    >>> group_size(17L)\n\
    \    16L\n    >>> group_size(19L)\n    18L\n    >>> group_size(23L)\n    22L\n\
    \    >>> group_size(29L)\n    28L\n    >>> group_size(31L)\n    30L\n    >>> group_size(37L)\n\
    \    36L\n    >>> group_size(41L)\n    40L\n    >>> group_size(43L)\n    42L\n\
    \    >>> group_size(47L)\n    46L\n    >>> group_size(53L)\n    52L\n    >>> group_size(59L)\n\
    \    58L\n    >>> group_size(61L)\n    60L\n    >>> group_size(67L)\n    66L\n\
    \    >>> group_size(71L)\n    70L\n    >>> group_size(73L)\n    72L\n    >>> group_size(79L)\n\
    \    78L\n    >>> group_size(83L)\n    82L\n    >>> group_size(89L)\n    88L\n\
    \    >>> group_size(97L)\n    96L\n    >>> group_size(101L)\n    100L\n*/\nlong\
    \ group_size(long p) \n{\n    return p - 1L;\n}\n/*\nReturn the order of a modulo\
    \ p.\n    >>> order(2L, 5L)\n    4L\n    >>> order(3\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7vjwxizd.d(88): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7vjwxizd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else\n    {\n\
    \        long half = modp(n / 2, p);\n        long result = (half * half) % p;\n\
    \        if (n % 2 == 1)\n            result = (result * 2) % p;\n        return\
    \ result;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwteclmkg.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e1d]\\n??:? void tmpwteclmkg.__unittest_L32_C1()\
    \ [0x427aa5]\\n??:? void tmpwteclmkg.__modtest() [0x427ba0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb43]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9d6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb69]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430018]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faf5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9ad]\\n??:? runModuleUnitTests [0x42b919]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42826c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281f3]\\n??:? _d_run_main [0x42815e]\\n??:? main [0x427bb3]\\\
    n??:? __libc_start_main [0x98a03554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n        {\n\
    \            result = (result * x) % n;\n        }\n        p >>= 1L;\n      \
    \  x = (x * x) % n;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpg4slhryn.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmpg4slhryn.__unittest_L32_C1()\
    \ [0x427a7d]\\n??:? void tmpg4slhryn.__modtest() [0x427b78]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b8b]\\\
    n??:? __libc_start_main [0xecd82554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1o3k2_o8.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dfd]\\n??:? void tmp1o3k2_o8.__unittest_L30_C1()\
    \ [0x427a81]\\n??:? void tmp1o3k2_o8.__modtest() [0x427b7c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb23]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9b6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb49]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fad5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a98d]\\n??:? runModuleUnitTests [0x42b8f9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42824c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281d3]\\n??:? _d_run_main [0x42813e]\\n??:? main [0x427b8f]\\\
    n??:? __libc_start_main [0x6ffc6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n  \
    \      {\n            result = (result * x) % p;\n        }\n        n = n / 2L;\n\
    \        x = (x * x) % p;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of integers in the range [1, n] that are coprime to n.\n    >>> euler(1L)\n\
    \    1L\n    >>> euler(2L)\n    1L\n    >>> euler(3L)\n    2L\n    >>> euler(4L)\n\
    \    2L\n    >>> euler(5L)\n    4L\n    >>> euler(6L)\n    2L\n    >>> euler(7L)\n\
    \    6L\n    >>> euler(8L)\n    4L\n    >>> euler(9L)\n    6L\n    >>> euler(10L)\n\
    \    4L\n    >>> euler(11L)\n    10L\n    >>> euler(12L)\n    4L\n    >>> euler(13L)\n\
    \    12L\n    >>> euler(14L)\n    6L\n    >>> euler(15L)\n    8L\n    >>> euler(16L)\n\
    \    8L\n    >>> euler(17L)\n    16L\n    >>> euler(18L)\n    6L\n    >>> euler(19L)\n\
    \    18L\n    >>> euler(20L)\n    8L\n    >>> euler(21L)\n    12L\n    >>> euler(22L)\n\
    \    10L\n    >>> euler(23L)\n    22L\n    >>> euler(24L)\n    8L\n    >>> euler(25L)\n\
    \    20L\n    >>> euler(26L)\n    12L\n    >>> euler(27L)\n    18L\n    >>> euler(28L)\n\
    \    12L\n    >>> euler(29L)\n    28L\n    >>> euler(30L)\n    8L\n    >>> euler\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwb2wyr4a.d(32): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwb2wyr4a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            r = (r\
    \ * n) % p;\n        }\n        n >>= 1L;\n    }\n    return r;\n}\n/*\nReturn\
    \ the number of digits of n in base b.\n    >>> digits(0L, 10L)\n    1L\n    >>>\
    \ digits(1L, 10L)\n    1L\n    >>> digits(10L, 10L)\n    2L\n    >>> digits(100L,\
    \ 10L)\n    3L\n    >>> digits(1000L, 10L)\n    4L\n    >>> digits(123456789L,\
    \ 10L)\n    9L\n    >>> digits(123456789L, 2L)\n    31L\n    >>> digits(123456789L,\
    \ 8L)\n    12L\n    >>> digits(123456789L, 16L)\n    8L\n    >>> digits(123456789L,\
    \ 32L)\n    7L\n    >>> digits(123456789L, 36L)\n    7L\n    >>> digits(123456789L,\
    \ 62L)\n    6L\n    >>> digits(123456789L, 64L)\n    6L\n    >>> digits(123456789L,\
    \ 66L)\n    6L\n    >>> digits(123456789L, 100L)\n    6L\n    >>> digits(123456789L,\
    \ 123L)\n    6L\n    >>> digits(123456789L, 1000L)\n    5L\n    >>> digits(123456789L,\
    \ 10000L)\n    5L\n    >>> digits(123456789L, 100000L)\n    5L\n    >>> digits(123456789L,\
    \ 1000000L)\n    5L\n    >>> digits(123456789L, 10000000L)\n    5L\n    >>> digits(123456789L,\
    \ 100000000L)\n    5L\n    >>> digits(123456789L, 1000000000L)\n    5L\n    >>>\
    \ digits(123456789L, 10000000000L)\n    5L\n    >>> digits(123\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe6tob4_v.d(30): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe6tob4_v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) {\n        if ((n % 2L) == 1L) {\n  \
    \          result = (result * base) % p;\n        }\n        n = n / 2L;\n   \
    \     base = (base * base) % p;\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow = n;\n    while (p > 0L) \n    {\n        if ((p & 1L) != 0L) \n\
    \        {\n            result = (result * pow) % p;\n        }\n        pow =\
    \ (pow * pow) % p;\n        p >>= 1L;\n    }\n    return result;\n}\n/*\nReturn\
    \ the greatest common divisor of a and b.\n    >>> gcd(2L, 3L)\n    1L\n    >>>\
    \ gcd(6L, 9L)\n    3L\n    >>> gcd(6L, 3L)\n    3L\n    >>> gcd(3L, 6L)\n    3L\n\
    \    >>> gcd(3L, 3L)\n    3L\n    >>> gcd(3L, 0L)\n    3L\n    >>> gcd(0L, 3L)\n\
    \    3L\n    >>> gcd(0L, 0L)\n    0L\n*/\nlong gcd(long a, long b) \n{\n    if\
    \ (a == 0L) \n    {\n        return b;\n    }\n    if (b == 0L) \n    {\n    \
    \    return a;\n    }\n    long r;\n    while ((r = a % b) != 0L) \n    {\n  \
    \      a = b;\n        b = r;\n    }\n    return b;\n}\n/*\nReturn the least common\
    \ multiple of a and b.\n    >>> lcm(2L, 3L)\n    6L\n    >>> lcm(6L, 9L)\n   \
    \ 18L\n    >>> lcm(6L, 3L)\n    6L\n    >>> lcm(3L, 6L)\n    6L\n    >>> lcm(3L,\
    \ 3L)\n    3L\n    >>> lcm(3L, 0L)\n    0L\n    >>> lcm(0L, 3L)\n    0L\n    >>>\
    \ lcm(0L, 0L)\n    0L\n*/\nlong lcm(long a, long b) \n{\n    if (a == 0L || b\
    \ == 0L) \n\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3st11kfw.d(92): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3st11kfw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\n\
    Return the number of bits in the binary representation of n.\n    >>> bits(0L)\n\
    \    0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n \
    \   2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n    3\n    >>> bits(6L)\n  \
    \  3\n    >>> bits(7L)\n    3\n    >>> bits(8L)\n    4\n    >>> bits(9L)\n   \
    \ 4\n    >>> bits(10L)\n    4\n    >>> bits(11L)\n    4\n    >>> bits(15L)\n \
    \   4\n    >>> bits(16L)\n    5\n    >>> bits(17L)\n    5\n    >>> bits(31L)\n\
    \    5\n    >>> bits(32L)\n    6\n    >>> bits(1023L)\n    10\n    >>> bits(1024L)\n\
    \    11\n    >>> bits(1025L)\n    11\n    >>> bits(65535L)\n    16\n    >>> bits(65536L)\n\
    \    17\n*/\nlong bits(long n) \n{\n    long result = 0L;\n    while (n > 0L)\
    \ \n    {\n        result += 1L;\n        n >>= 1L;\n    }\n    return result;\n\
    }\n/*\nReturn the number of bits in the binary representation of n.\n    >>> bits(0L)\n\
    \    0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n \
    \   2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n    3\n    >>> bits(6L)\n  \
    \  3\n    >>> bits(7L)\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiidyg9z_.d(89): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiidyg9z_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return n % p * modp(n - 1, p) % p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd145bbr2.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e5d]\\n??:? void tmpd145bbr2.__unittest_L28_C1()\
    \ [0x427b0b]\\n??:? void tmpd145bbr2.__modtest() [0x427be0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa16]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fba9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430058]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9ed]\\n??:? runModuleUnitTests [0x42b959]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428233]\\n??:? _d_run_main [0x42819e]\\n??:? main [0x427bf3]\\\
    n??:? __libc_start_main [0xe723554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            r = (r * b) % p;\n        }\n        n >>= 1L;\n     \
    \   b = (b * b) % p;\n    }\n    return r;\n}\n/*\nReturn the greatest common\
    \ divisor of a and b.\n    >>> gcd(12L, 8L)\n    4L\n    >>> gcd(8L, 12L)\n  \
    \  4L\n    >>> gcd(0L, 12L)\n    12L\n    >>> gcd(12L, 0L)\n    12L\n    >>> gcd(3L,\
    \ 7L)\n    1L\n    >>> gcd(35L, 49L)\n    7L\n    >>> gcd(49L, 35L)\n    7L\n\
    \    >>> gcd(21L, 6L)\n    3L\n    >>> gcd(6L, 21L)\n    3L\n*/\nlong gcd(long\
    \ a, long b) \n{\n    if (a == 0L) \n    {\n        return b;\n    }\n    if (b\
    \ == 0L) \n    {\n        return a;\n    }\n    long shift = 0L;\n    while (((a\
    \ | b) & 1L) == 0L) \n    {\n        a >>= 1L;\n        b >>= 1L;\n        shift++;\n\
    \    }\n    while ((a & 1L) == 0L) \n    {\n        a >>= 1L;\n    }\n    do \n\
    \    {\n        while ((b & 1L) == 0L) \n        {\n            b >>= 1L;\n  \
    \      }\n        if (a > b) \n        {\n            long t = b;\n          \
    \  b = a;\n            a = t;\n        }\n        b = b - a;\n    }\n    while\
    \ (b != 0L);\n    return a << shift;\n}\n/*\nReturn the least common multiple\
    \ of a and b.\n    >>> lcm(12L, 8L\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0zzlr24s.d(91): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0zzlr24s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n)\n        r = (r * 2L) % p;\n    return r;\n}\n/*\nReturn\
    \ the number of bits in the binary representation of n.\n    >>> bits(0L)\n  \
    \  0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n   \
    \ 2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n    3\n    >>> bits(6L)\n    3\n\
    \    >>> bits(7L)\n    3\n    >>> bits(8L)\n    4\n    >>> bits(9L)\n    4\n \
    \   >>> bits(10L)\n    4\n    >>> bits(11L)\n    4\n    >>> bits(12L)\n    4\n\
    \    >>> bits(13L)\n    4\n    >>> bits(14L)\n    4\n    >>> bits(15L)\n    4\n\
    \    >>> bits(16L)\n    5\n    >>> bits(17L)\n    5\n    >>> bits(18L)\n    5\n\
    \    >>> bits(19L)\n    5\n    >>> bits(20L)\n    5\n    >>> bits(21L)\n    5\n\
    \    >>> bits(22L)\n    5\n    >>> bits(23L)\n    5\n    >>> bits(24L)\n    5\n\
    \    >>> bits(25L)\n    5\n    >>> bits(26L)\n    5\n    >>> bits(27L)\n    5\n\
    \    >>> bits(28L)\n    5\n    >>> bits(29L)\n    5\n    >>> bits(30L)\n    5\n\
    \    >>> bits(31L)\n    5\n    >>> bits(32L)\n    6\n    >>> bits(33L)\n    6\n\
    \    >>> bits(34L)\n    6\n    >>> bits(35L)\n    6\n    >>> bits(36L)\n    6\n\
    \    >>> bits(37L)\n    6\n    >>> bits(38L)\n    6\n    >>> bits(39L)\n    6\n\
    \    >>> bits(40L)\n    6\n    >>> bits(\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl1jkd7td.d(24): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl1jkd7td.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow = n;\n    while (p > 0L) \n    {\n        if ((p & 1L) != 0L) \n\
    \        {\n            result = (result * pow) % p;\n        }\n        pow =\
    \ (pow * pow) % p;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprpwfr_ye.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmprpwfr_ye.__unittest_L32_C1()\
    \ [0x427a79]\\n??:? void tmprpwfr_ye.__modtest() [0x427b74]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b87]\\\
    n??:? __libc_start_main [0xa96a2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\n/*\nReturn the\
    \ number of digits of n.\n    >>> ndigits(0L)\n    1\n    >>> ndigits(1L)\n  \
    \  1\n    >>> ndigits(10L)\n    2\n    >>> ndigits(101L)\n    3\n    >>> ndigits(123456789L)\n\
    \    9\n    >>> ndigits(1234567890123456789L)\n    19\n*/\nlong ndigits(long n)\
    \ \n{\n    if (n == 0)\n        return 1;\n    else\n        return (long)floor(log10(n))\
    \ + 1;\n}\n/*\nReturn the number of digits of n.\n    >>> ndigits(0L)\n    1\n\
    \    >>> ndigits(1L)\n    1\n    >>> ndigits(10L)\n    2\n    >>> ndigits(101L)\n\
    \    3\n    >>> ndigits(123456789L)\n    9\n    >>> ndigits(1234567890123456789L)\n\
    \    19\n*/\nlong ndigits(long n) \n{\n    if (n == 0)\n        return 1;\n  \
    \  else\n        return (long)floor(log10(n)) + 1;\n}\n/*\nReturn the number of\
    \ digits of n.\n    >>> ndigits(0L)\n    1\n    >>> ndigits(1L)\n    1\n    >>>\
    \ ndigits(10L)\n    2\n    >>> ndigits(101L)\n    3\n    >>> ndigits(123456789L)\n\
    \    9\n    >>> ndigits(1234567890123456789L)\n    19\n*/\nlong ndigits(long n)\
    \ \n{\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjdtakexv.d(48): Error: C style cast illegal, use `cast(long)floor(log10(n))`\\\
    n/tmp/tmpjdtakexv.d(70): Error: C style cast illegal, use `cast(long)floor(log10(n))`\\\
    n/tmp/tmpjdtakexv.d(89): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjdtakexv.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            result\
    \ = (result * n) % p;\n        }\n        n >>= 1L;\n        n = (n * n) % p;\n\
    \    }\n    return result;\n}\n/*\nReturn the number of digits in n.\n    >>>\
    \ digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n \
    \   >>> digits(123L)\n    3\n    >>> digits(1234567890123456789L)\n    19\n*/\n\
    long digits(long n) \n{\n    long result = 1L;\n    while (n >= 10L) \n    {\n\
    \        n /= 10L;\n        result += 1L;\n    }\n    return result;\n}\n/*\n\
    Return the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(10L)\n    2\n    >>> digits(123L)\n    3\n    >>> digits(1234567890123456789L)\n\
    \    19\n*/\nlong digits(long n) \n{\n    long result = 1L;\n    while (n >= 10L)\
    \ \n    {\n        n /= 10L;\n        result += 1L;\n    }\n    return result;\n\
    }\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(10L)\n    2\n    >>> digits(123L)\n    3\n    >>> digits(1234567890123456789L)\n\
    \    19\n*/\nlong digits(long n) \n{\n    long result = 1L;\n    while (n >= 10L)\
    \ \n    {\n        n /= 10L;\n        result += 1L;\n    }\n    return result;\n\
    }\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n   \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp47ljy8g_.d(100): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp47ljy8g_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpctixbx9e.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e6d]\\n??:? void tmpctixbx9e.__unittest_L28_C1()\
    \ [0x427b17]\\n??:? void tmpctixbx9e.__modtest() [0x427bec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fbb9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9fd]\\n??:? runModuleUnitTests [0x42b969]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428243]\\n??:? _d_run_main [0x4281ae]\\n??:? main [0x427bff]\\\
    n??:? __libc_start_main [0xeeb85554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long res = modp(n >> 1, p);\n    res = (res * res) % p;\n\
    \    if (n & 1)\n        res = (res * 2) % p;\n    return res;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long x = modp(n / 2, p);\n    x = (x * x) % p;\n    if (n\
    \ % 2 == 1)\n        x = (x * 2) % p;\n    return x;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n >> 1, p);\n    r = (r * r) % p;\n    if\
    \ (n & 1)\n        r = (r * 2) % p;\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) {\n        if (p & 1L) {\n          \
    \  result = (result * power) % n;\n        }\n        power = (power * power)\
    \ % n;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpffiiuqpw.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmpffiiuqpw.__unittest_L30_C1()\
    \ [0x427a7d]\\n??:? void tmpffiiuqpw.__modtest() [0x427b78]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b8b]\\\
    n??:? __libc_start_main [0x428a4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) {\n        if (p & 1L) {\n          \
    \  result = (result * power) % n;\n        }\n        power = (power * power)\
    \ % n;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpq_zh3mzp.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmpq_zh3mzp.__unittest_L30_C1()\
    \ [0x427a7d]\\n??:? void tmpq_zh3mzp.__modtest() [0x427b78]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b8b]\\\
    n??:? __libc_start_main [0x7a32c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpb407o2e0.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dfd]\\n??:? void tmpb407o2e0.__unittest_L30_C1()\
    \ [0x427a81]\\n??:? void tmpb407o2e0.__modtest() [0x427b7c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb23]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9b6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb49]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fad5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a98d]\\n??:? runModuleUnitTests [0x42b8f9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42824c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281d3]\\n??:? _d_run_main [0x42813e]\\n??:? main [0x427b8f]\\\
    n??:? __libc_start_main [0xcbac9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n)\n        r = (r * 2L) % p;\n    return r;\n}\n/*\nReturn\
    \ the number of digits in the decimal representation of n.\n    >>> digits(0L)\n\
    \    1\n    >>> digits(1L)\n    1\n    >>> digits(2L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789012345L)\n    15\n\
    */\nlong digits(long n) \n{\n    long r = 1L;\n    while (n >= 10L)\n    {\n \
    \       n /= 10L;\n        r += 1L;\n    }\n    return r;\n}\n/*\nReturn the number\
    \ of digits in the binary representation of n.\n    >>> bits(0L)\n    1\n    >>>\
    \ bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(10L)\n    4\n    >>>\
    \ bits(12345L)\n    13\n    >>> bits(123456789012345L)\n    43\n*/\nlong bits(long\
    \ n) \n{\n    long r = 1L;\n    while (n >= 2L)\n    {\n        n /= 2L;\n   \
    \     r += 1L;\n    }\n    return r;\n}\n/*\nReturn the number of digits in the\
    \ hexadecimal representation of n.\n    >>> hexdigits(0L)\n    1\n    >>> hexdigits(1L)\n\
    \    1\n    >>> hexdigits(2L)\n    1\n    >>> hexdigits(10L)\n    2\n    >>> hexdigits(12345L)\n\
    \    4\n    >>> hexdigits(123456789012345L)\n    8\n*/\nlong hexdigits(long n)\
    \ \n{\n    long r = 1L;\n    while (n >= 16L)\n    {\n        n /= 16L;\n    \
    \    r += 1L;\n    }\n    return r;\n}\n/*\nReturn the number of digits in the\
    \ octal representation of n.\n    >>>\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplbhg9egz.d(99): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplbhg9egz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 0)\n   \
    \ {\n        return modp(-n, p);\n    }\n    else if (n == 0)\n    {\n       \
    \ return 1L;\n    }\n    else if (n == 1)\n    {\n        return n;\n    }\n \
    \   else\n    {\n        long m = modp(n / 2L, p);\n        if (n % 2L == 0)\n\
    \        {\n            return (m * m) % p;\n        }\n        else\n       \
    \ {\n            return (m * m * n) % p;\n        }\n    }\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5kqp_ynz.d(49): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e2d]\\n??:? void tmp5kqp_ynz.__unittest_L44_C1()\
    \ [0x427adb]\\n??:? void tmp5kqp_ynz.__modtest() [0x427bb0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb53]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9e6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb79]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430028]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb05]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9bd]\\n??:? runModuleUnitTests [0x42b929]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42827c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428203]\\n??:? _d_run_main [0x42816e]\\n??:? main [0x427bc3]\\\
    n??:? __libc_start_main [0x13fd4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0l6g543q.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e6d]\\n??:? void tmp0l6g543q.__unittest_L28_C1()\
    \ [0x427b17]\\n??:? void tmp0l6g543q.__modtest() [0x427bec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fbb9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9fd]\\n??:? runModuleUnitTests [0x42b969]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428243]\\n??:? _d_run_main [0x4281ae]\\n??:? main [0x427bff]\\\
    n??:? __libc_start_main [0x10473554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 0)\n   \
    \     return modp(-n, p);\n    else if (n == 0)\n        return 1;\n    else if\
    \ (n == 1)\n        return 0;\n    else if (n % 2 == 0)\n        return modp(n\
    \ / 2, p) * (1 + modp(n / 2, p)) % p;\n    else\n        return modp(n - 1, p)\
    \ * (1 + modp(n - 1, p)) % p;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1h11l_i0.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e5d]\\n??:? void tmp1h11l_i0.__unittest_L30_C1()\
    \ [0x427ae5]\\n??:? void tmp1h11l_i0.__modtest() [0x427be0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa16]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fba9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430058]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9ed]\\n??:? runModuleUnitTests [0x42b959]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428233]\\n??:? _d_run_main [0x42819e]\\n??:? main [0x427bf3]\\\
    n??:? __libc_start_main [0x8a263554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\n/*\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L,\
    \ 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n\
    \    >>> modp(100L, 101L)\n    1L\n*/\nlong modp(long n, long p) \n{\n    long\
    \ res = 1L;\n    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n   \
    \         res = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n\
    \ * n) % p;\n    }\n    return res;\n}\n/*\n    >>> modp(3L, 5L)\n    3L\n   \
    \ >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L,\
    \ 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n*/\nlong modp(long n, long p)\
    \ \n{\n    long res = 1L;\n    while (n > 0L) \n    {\n        if (n & 1L) \n\
    \        {\n            res = (res * n) % p;\n        }\n        n = n >> 1L;\n\
    \        n = (n * n) % p;\n    }\n    return res;\n}\n/*\n    >>> modp(3L, 5L)\n\
    \    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n \
    \   >>> modp(3L, 11L)\n    8L\n    >>> modp\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxd48401u.d(83): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxd48401u.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\n/*\nReturn the greatest common divisor of a and b.\n\
    \    >>> gcd(12L, 15L)\n    3L\n    >>> gcd(3L, 7L)\n    1L\n    >>> gcd(4L, 6L)\n\
    \    2L\n    >>> gcd(4L, 12L)\n    4L\n    >>> gcd(0L, 1L)\n    1L\n    >>> gcd(1L,\
    \ 0L)\n    1L\n    >>> gcd(0L, 0L)\n    0L\n*/\nlong gcd(long a, long b) \n{\n\
    \    if (a == 0L) \n    {\n        return b;\n    }\n    if (b == 0L) \n    {\n\
    \        return a;\n    }\n    while (b != 0L) \n    {\n        long t = b;\n\
    \        b = a % b;\n        a = t;\n    }\n    return a;\n}\n/*\nReturn the least\
    \ common multiple of a and b.\n    >>> lcm(12L, 15L)\n    60L\n    >>> lcm(3L,\
    \ 7L)\n    21L\n    >>> lcm(4L, 6L)\n    12L\n    >>> lcm(4L, 12L)\n    12L\n\
    \    >>> lcm(0L, 1L)\n    0L\n    >>> lcm(1L, 0L)\n    0L\n    >>> lcm(0L, 0L)\n\
    \    0L\n*/\nlong lcm(long a, long b) \n{\n    if (a == 0L || b == 0L) \n    {\n\
    \        return 0L;\n    }\n    return (a / gcd(a, b)) * b;\n}\n/*\nReturn the\
    \ number of integers in the range [1, n\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyxcu3woo.d(91): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyxcu3woo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else\n    {\n        long x = modp(n / 2, p);\n        if\
    \ (n % 2 == 0)\n            return (x * x) % p;\n        else\n            return\
    \ (x * x * 2) % p;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n   \
    \ assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long x = modp(n >>\
    \ 1, p);\n        x = (x * x) % p;\n        if (n & 1) \n        {\n         \
    \   x = (x * 2) % p;\n        }\n        return x;\n    }\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n)\n    {\n        r = (r * 2L) % p;\n    }\n    return r;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) {\n        if (n % 2L == 1L) {\n            r = (r * 2L) %\
    \ p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_0ehum31.d(32): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dfd]\\n??:? void tmp_0ehum31.__unittest_L28_C1()\
    \ [0x427a81]\\n??:? void tmp_0ehum31.__modtest() [0x427b7c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb23]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9b6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb49]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fad5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a98d]\\n??:? runModuleUnitTests [0x42b8f9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42824c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281d3]\\n??:? _d_run_main [0x42813e]\\n??:? main [0x427b8f]\\\
    n??:? __libc_start_main [0x369d3554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n / 2, p);\n    r = (r * r) % p;\n    if (n\
    \ % 2 == 1)\n        r = (r * 2) % p;\n    return r;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n\
    \    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(123456789L)\n\
    \    9\n    >>> numdigits(1234567890123456789L)\n    19\n*/\nlong numdigits(long\
    \ n) \n{\n    if (n == 0)\n        return 1;\n    return (long)floor(log10(n))\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n*/\nlong numdigits(long n) \n{\n    if (n == 0)\n        return 1;\n\
    \    return (long)floor(log10(n)) + 1;\n}\n/*\nReturn the number of digits in\
    \ n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(123456789L)\n    9\n\
    \    >>> numdigits(1234567890123456789L)\n    19\n*/\nlong numdigits(long n) \n\
    {\n    if (n == 0)\n        return 1;\n    return (long)floor(log10(n)) + 1;\n\
    }\n/*\nReturn\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4eqc_2i9.d(46): Error: C style cast illegal, use `cast(long)floor(log10(n))`\\\
    n/tmp/tmp4eqc_2i9.d(67): Error: C style cast illegal, use `cast(long)floor(log10(n))`\\\
    n/tmp/tmp4eqc_2i9.d(88): Error: C style cast illegal, use `cast(long)floor(log10(n))`\\\
    n/tmp/tmp4eqc_2i9.d(90): Error: unterminated /* */ comment\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4eqc_2i9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long result = 1;\n    while (n > 0)\n    {\n        if (n\
    \ % 2 == 1)\n            result = (result * 2) % p;\n        n /= 2;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzl6bsirg.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e05]\\n??:? void tmpzl6bsirg.__unittest_L30_C1()\
    \ [0x427a8d]\\n??:? void tmpzl6bsirg.__modtest() [0x427b88]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb2b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9be]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb51]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430000]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fadd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a995]\\n??:? runModuleUnitTests [0x42b901]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428254]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281db]\\n??:? _d_run_main [0x428146]\\n??:? main [0x427b9b]\\\
    n??:? __libc_start_main [0x37c3a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the number of bits in the binary representation of n.\n    >>> bits(0L)\n\
    \    0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n \
    \   2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n    3\n*/\nlong bits(long n)\
    \ \n{\n    long b = 0L;\n    while (n > 0L) \n    {\n        b += 1L;\n      \
    \  n = n / 2L;\n    }\n    return b;\n}\n/*\nReturn the number of bits in the\
    \ binary representation of n.\n    >>> bits(0L)\n    0\n    >>> bits(1L)\n   \
    \ 1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n    2\n    >>> bits(4L)\n    3\n\
    \    >>> bits(5L)\n    3\n*/\nlong bits(long n) \n{\n    long b = 0L;\n    while\
    \ (n > 0L) \n    {\n        b += 1L;\n        n = n / 2L;\n    }\n    return b;\n\
    }\n/*\nReturn the number of bits in the binary representation of n.\n    >>> bits(0L)\n\
    \    0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n \
    \   2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n    3\n*/\nlong bits(long n)\
    \ \n{\n    long b = 0L;\n    while (n > 0L) \n    {\n        b += 1L;\n      \
    \  n = n / 2L;\n    }\n    return b;\n}\n/*\nReturn the number of bits in the\
    \ binary representation of n.\n    >>>\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2sxavi74.d(105): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2sxavi74.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9597s30a.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dfd]\\n??:? void tmp9597s30a.__unittest_L30_C1()\
    \ [0x427a81]\\n??:? void tmp9597s30a.__modtest() [0x427b7c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb23]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9b6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb49]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fad5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a98d]\\n??:? runModuleUnitTests [0x42b8f9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42824c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281d3]\\n??:? _d_run_main [0x42813e]\\n??:? main [0x427b8f]\\\
    n??:? __libc_start_main [0x764df554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\n\
    Return the number of bits in the binary representation of n.\n    >>> bit_length(0L)\n\
    \    0\n    >>> bit_length(1L)\n    1\n    >>> bit_length(2L)\n    2\n    >>>\
    \ bit_length(3L)\n    2\n    >>> bit_length(4L)\n    3\n    >>> bit_length(5L)\n\
    \    3\n    >>> bit_length(6L)\n    3\n    >>> bit_length(7L)\n    3\n    >>>\
    \ bit_length(8L)\n    4\n    >>> bit_length(9L)\n    4\n    >>> bit_length(10L)\n\
    \    4\n    >>> bit_length(11L)\n    4\n    >>> bit_length(12L)\n    4\n    >>>\
    \ bit_length(13L)\n    4\n    >>> bit_length(14L)\n    4\n    >>> bit_length(15L)\n\
    \    4\n    >>> bit_length(16L)\n    5\n    >>> bit_length(17L)\n    5\n    >>>\
    \ bit_length(18L)\n    5\n    >>> bit_length(19L)\n    5\n    >>> bit_length(20L)\n\
    \    5\n    >>> bit_length(21L)\n    5\n    >>> bit_length(22L)\n    5\n    >>>\
    \ bit_length(23L)\n    5\n    >>> bit_length(24L)\n    5\n    >>> bit_length(25L)\n\
    \    5\n    >>> bit_length(26L)\n    5\n    >>> bit_length(27L)\n    5\n    >>>\
    \ bit_length(28L)\n    5\n    >>> bit_length(29L)\n    5\n    >>> bit_length(30L)\n\
    \    5\n\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu905s2xs.d(32): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu905s2xs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n  \
    \      {\n            result = (result * a) % p;\n        }\n        a = (a *\
    \ a) % p;\n        n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>>\
    \ digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n\
    \    20\n*/\nlong digits(long n) \n{\n    long result = 1L;\n    while (n >= 10L)\
    \ \n    {\n        n = n / 10L;\n        result = result + 1L;\n    }\n    return\
    \ result;\n}\n/*\nReturn the nth digit of n.\n    >>> nthdigit(0L, 0L)\n    0\n\
    \    >>> nthdigit(0L, 1L)\n    0\n    >>> nthdigit(12345L, 0L)\n    5\n    >>>\
    \ nthdigit(12345L, 1L)\n    4\n    >>> nthdigit(12345L, 2L)\n    3\n    >>> nthdigit(12345L,\
    \ 3L)\n    2\n    >>> nthdigit(12345L, 4L)\n    1\n    >>> nthdigit(12345L, 5L)\n\
    \    0\n    >>> nthdigit(12345L, 6L)\n    0\n*/\nlong nthdigit(long n, long d)\
    \ \n{\n    long result = 0L;\n    while (d > 0L) \n    {\n        result = n %\
    \ 10L;\n        n = n / 10L;\n        d = d - 1L;\n    }\n    return result;\n\
    }\n/*\nReturn the sum of the digits of n.\n    >>> sumdigits(0L)\n    0\n    >>>\
    \ sumdigits(1L)\n    1\n    >>> sumdigits(123\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf0wtaow9.d(87): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf0wtaow9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n  \
    \      {\n            result = (result * a) % p;\n        }\n        a = (a *\
    \ a) % p;\n        n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn the greatest\
    \ common divisor of a and b.\n    >>> gcd(2L, 3L)\n    1L\n    >>> gcd(2L, 4L)\n\
    \    2L\n    >>> gcd(12L, 8L)\n    4L\n    >>> gcd(12L, 9L)\n    3L\n    >>> gcd(12L,\
    \ 12L)\n    12L\n    >>> gcd(15L, 12L)\n    3L\n    >>> gcd(15L, 15L)\n    15L\n\
    \    >>> gcd(2L * 3L * 5L * 11L * 17L,\n    ...     3L * 7L * 11L * 13L * 19L)\n\
    \    3L * 11L\n    >>> gcd(2L * 3L * 5L * 11L * 17L,\n    ...     3L * 7L * 11L\
    \ * 13L * 19L * 23L)\n    3L * 11L\n    >>> gcd(2L * 3L * 5L * 11L * 17L * 23L,\n\
    \    ...     3L * 7L * 11L * 13L * 19L)\n    3L * 11L\n    >>> gcd(2L * 3L * 5L\
    \ * 11L * 17L * 23L,\n    ...     3L * 7L * 11L * 13L * 19L * 23L)\n    3L * 11L\
    \ * 23L\n*/\nlong gcd(long a, long b) \n{\n    while (b != 0L) \n    {\n     \
    \   long t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n\
    /*\nReturn the least common multiple of a and b.\n    >>> lcm(2L, 3L)\n    6L\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp10co5_kb.d(71): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp10co5_kb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in a number.\n    >>> digits(0)\n   \
    \ 1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n\
    \    101\n    >>> digits(10**1000)\n    1001\n    >>> digits(10**10000)\n    10001\n\
    */\nlong digits(long n) \n{\n    return n == 0 ? 1 : cast(long)floor(log(n) /\
    \ log(10)) + 1;\n}\n/*\nReturn the number of digits in a number.\n    >>> digits(0)\n\
    \    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n\
    \    101\n    >>> digits(10**1000)\n    1001\n    >>> digits(10**10000)\n    10001\n\
    */\nlong digits(long n) \n{\n    return n == 0 ? 1 : cast(long)floor(log(n) /\
    \ log(10)) + 1;\n}\n/*\nReturn the number of digits in a number.\n    >>> digits(0)\n\
    \    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n\
    \    101\n    >>> digits(10**1000)\n    1001\n    >>> digits(10**10000)\n    10001\n\
    */\nlong digits(long n) \n{\n    return n == 0 ? 1 : cast(long)floor(log(n) /\
    \ log(10)) + 1;\n}\n/*\nReturn the number of digits in a number.\n    >>> digits(0)\n\
    \    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n\
    \    101\n    >>> digits(10**1000)\n    100\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9zst3_4l.d(83): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9zst3_4l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n   \
    \     {\n            r = (r * b) % p;\n        }\n        n = n / 2L;\n      \
    \  b = (b * b) % p;\n    }\n    return r;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789012345L)\n    15\n\
    */\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long sq = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n        {\n\
    \            result = (result * sq) % n;\n        }\n        sq = (sq * sq) %\
    \ n;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpr5yie61e.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmpr5yie61e.__unittest_L32_C1()\
    \ [0x427a7d]\\n??:? void tmpr5yie61e.__modtest() [0x427b78]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b8b]\\\
    n??:? __libc_start_main [0x39436554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            r = (r\
    \ * 2L) % p;\n        }\n        n >>= 1L;\n    }\n    return r;\n}\n/*\nReturn\
    \ the number of bits in the binary representation of n.\n    >>> bitlen(0L)\n\
    \    0\n    >>> bitlen(1L)\n    1\n    >>> bitlen(2L)\n    2\n    >>> bitlen(3L)\n\
    \    2\n    >>> bitlen(4L)\n    3\n    >>> bitlen(5L)\n    3\n    >>> bitlen(6L)\n\
    \    3\n    >>> bitlen(7L)\n    3\n    >>> bitlen(8L)\n    4\n    >>> bitlen(9L)\n\
    \    4\n    >>> bitlen(10L)\n    4\n    >>> bitlen(11L)\n    4\n    >>> bitlen(12L)\n\
    \    4\n    >>> bitlen(13L)\n    4\n    >>> bitlen(14L)\n    4\n    >>> bitlen(15L)\n\
    \    4\n    >>> bitlen(16L)\n    5\n    >>> bitlen(17L)\n    5\n    >>> bitlen(18L)\n\
    \    5\n    >>> bitlen(19L)\n    5\n    >>> bitlen(20L)\n    5\n    >>> bitlen(21L)\n\
    \    5\n    >>> bitlen(22L)\n    5\n    >>> bitlen(23L)\n    5\n    >>> bitlen(24L)\n\
    \    5\n    >>> bitlen(25L)\n    5\n    >>> bitlen(26L)\n    5\n    >>> bitlen(27L)\n\
    \    5\n    >>> bitlen(28L)\n    5\n    >>> bitlen(29L)\n    5\n    >>> bitlen(30L)\n\
    \    5\n    >>> bitlen(31L)\n    5\n    >>> bitlen(32L)\n    6\n    >>> bitlen(33L)\n\
    \    6\n    >>> bitlen(34L)\n    6\n    >>> bitlen(35\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq_grvp87.d(30): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq_grvp87.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n % 2L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        n\
    \ /= 2L;\n        base = (base * base) % p;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else if (n == 1)\n    {\n        return 2;\n\
    \    }\n    else if (n == 2)\n    {\n        return 4;\n    }\n    else if (n\
    \ == 3)\n    {\n        return 8;\n    }\n    else if (n == 4)\n    {\n      \
    \  return 16;\n    }\n    else if (n == 5)\n    {\n        return 32;\n    }\n\
    \    else if (n == 6)\n    {\n        return 64;\n    }\n    else if (n == 7)\n\
    \    {\n        return 128;\n    }\n    else if (n == 8)\n    {\n        return\
    \ 256;\n    }\n    else if (n == 9)\n    {\n        return 512;\n    }\n    else\
    \ if (n == 10)\n    {\n        return 1024;\n    }\n    else if (n == 11)\n  \
    \  {\n        return 2048;\n    }\n    else if (n == 12)\n    {\n        return\
    \ 4096;\n    }\n    else if (n == 13)\n    {\n        return 8192;\n    }\n  \
    \  else if (n == 14)\n    {\n        return 16384;\n    }\n    else if (n == 15)\n\
    \    {\n        return 32768;\n    }\n    else if (n == 16)\n    {\n        return\
    \ 65536;\n    }\n    else if (n == 17)\n    {\n        return 131072;\n    }\n\
    \    else if (n == 18)\n    {\n        return 262144;\n    }\n    else if (n ==\
    \ 19)\n    {\n        return 524288;\n    }\n    else if (n == 20)\n    {\n  \
    \      return 1048576;\n    }\n    else if (n == 21)\n    {\n        return 2097152;\n\
    \    }\n    else if (n == 22)\n    {\n        return 4194304;\n    }\n    else\
    \ if (n == 23)\n    {\n        return 8388608;\n    }\n    else if (n == 24)\n\
    \    {\n       \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp542ihtp6.d(118): Error: found `unittest` instead of statement\\\
    n/tmp/tmp542ihtp6.d(130): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp542ihtp6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p != 0L) \n    {\n        if ((p & 1L) != 0L)\
    \ \n        {\n            result = (result * power) % n;\n        }\n       \
    \ power = (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n\
    }\n/*\nReturn the greatest common divisor of a and b.\n    >>> gcd(2L, 3L)\n \
    \   1L\n    >>> gcd(6L, 9L)\n    3L\n    >>> gcd(3L, 3L)\n    3L\n    >>> gcd(3L,\
    \ 6L)\n    3L\n    >>> gcd(7L, 11L)\n    1L\n    >>> gcd(14L, 21L)\n    7L\n \
    \   >>> gcd(14L, 28L)\n    14L\n    >>> gcd(14L, 35L)\n    7L\n    >>> gcd(28L,\
    \ 42L)\n    14L\n    >>> gcd(35L, 49L)\n    7L\n    >>> gcd(21L, 35L)\n    7L\n\
    \    >>> gcd(35L, 35L)\n    35L\n    >>> gcd(35L, 70L)\n    35L\n    >>> gcd(70L,\
    \ 105L)\n    35L\n    >>> gcd(105L, 140L)\n    35L\n    >>> gcd(140L, 175L)\n\
    \    35L\n    >>> gcd(175L, 210L)\n    35L\n    >>> gcd(210L, 245L)\n    35L\n\
    \    >>> gcd(245L, 280L)\n    35L\n    >>> gcd(280L, 315L)\n    35L\n    >>> gcd(315L,\
    \ 350L)\n    35L\n    >>> gcd(350L, 385L)\n    35L\n    >>> gcd(385L, 420L)\n\
    \    35L\n    >>> gcd(420L, 455L)\n    35L\n    >>> gcd(455L, 490L)\n    35L\n\
    \    >>> gcd\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpykiobxfi.d(32): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpykiobxfi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long rec = modp(n /\
    \ 2, p);\n        long result = (rec * rec) % p;\n        if (n % 2 == 1) \n \
    \       {\n            result = (result * 2) % p;\n        }\n        return result;\n\
    \    }\n}\n/*\nReturn the number of digits in n.\n    >>> num_digits(12345)\n\
    \    5\n    >>> num_digits(0)\n    1\n    >>> num_digits(-12345)\n    5\n*/\n\
    long num_digits(long n) \n{\n    if (n == 0) \n    {\n        return 1;\n    }\n\
    \    else \n    {\n        return 1 + num_digits(n / 10);\n    }\n}\n/*\nReturn\
    \ the sum of the digits in n.\n    >>> sum_digits(10) # 1 + 0 = 1\n    1\n   \
    \ >>> sum_digits(4224) # 4 + 2 + 2 + 4 = 12\n    12\n    >>> sum_digits(1234567890)\n\
    \    45\n    >>> a = sum_digits(123) # make sure that you are using return rather\
    \ than print\n    >>> a\n    6\n*/\nlong sum_digits(long n) \n{\n    if (n ==\
    \ 0) \n    {\n        return 0;\n    }\n    else \n    {\n        return n % 10\
    \ + sum_digits(n / 10);\n    }\n}\n/*\nReturn the largest digit in n.\n    >>>\
    \ largest_digit(1309) # 9\n    9\n    >>> largest_digit(30) # 3\n    3\n    >>>\
    \ largest_digit(9876543210) # 9\n    9\n    >>> largest_digit(0) # There is no\
    \ largest digit for 0\n    0\n*/\nlong largest_digit(long n) \n{\n    if (n ==\
    \ 0) \n    {\n        return 0;\n    }\n    else \n    {\n        long last =\
    \ n % 10;\n        long rest = largest_digit(n / 10);\n\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1clui_kb.d(99): Error: found `unittest` instead of statement\\\
    n/tmp/tmp1clui_kb.d(111): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1clui_kb.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = n;\n    while (p > 0L) \n    {\n        if (p % 2L == 1L) \n   \
    \     {\n            result = (result * x) % n;\n        }\n        x = (x * x)\
    \ % n;\n        p = p / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphazx8w1r.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e15]\\n??:? void tmphazx8w1r.__unittest_L32_C1()\
    \ [0x427a99]\\n??:? void tmphazx8w1r.__modtest() [0x427b94]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb3b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb61]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430010]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9a5]\\n??:? runModuleUnitTests [0x42b911]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428264]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281eb]\\n??:? _d_run_main [0x428156]\\n??:? main [0x427ba7]\\\
    n??:? __libc_start_main [0x3c593554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * a) % p;\n        }\n        a = (a * a) % p;\n      \
    \  n = n / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 0L) \n \
    \   {\n        return modp(-n, p);\n    }\n    if (n == 0L) \n    {\n        return\
    \ 1L;\n    }\n    if (n == 1L) \n    {\n        return 2L % p;\n    }\n    if\
    \ (n % 2L == 0L) \n    {\n        return (modp(n / 2L, p) * modp(n / 2L, p)) %\
    \ p;\n    }\n    else \n    {\n        return (2L * modp(n / 2L, p) * modp(n /\
    \ 2L, p)) % p;\n    }\n}\n/*\nReturn the nth Lucas number.\n    >>> lucas(0)\n\
    \    2\n    >>> lucas(1)\n    1\n    >>> lucas(2)\n    3\n    >>> lucas(3)\n \
    \   4\n    >>> lucas(4)\n    7\n    >>> lucas(5)\n    11\n    >>> lucas(6)\n \
    \   18\n    >>> lucas(7)\n    29\n    >>> lucas(8)\n    47\n    >>> lucas(9)\n\
    \    76\n    >>> lucas(10)\n    123\n    >>> lucas(11)\n    199\n    >>> lucas(12)\n\
    \    322\n    >>> lucas(13)\n    521\n    >>> lucas(14)\n    843\n    >>> lucas(15)\n\
    \    1364\n    >>> lucas(16)\n    2207\n    >>> lucas(17)\n    3571\n    >>> lucas(18)\n\
    \    5778\n    >>> lucas(19)\n    9349\n    >>> lucas(20)\n    15127\n    >>>\
    \ lucas(21)\n    24476\n    >>> lucas(22)\n    39603\n    >>> lucas(23)\n    64079\n\
    \    >>> lucas(24)\n    103682\n    >>> lucas(25)\n    167761\n    >>> lucas(26)\n\
    \    271443\n    >>> lucas(27)\n    439204\n    >>> lucas(28)\n    7\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr2afvudb.d(40): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr2afvudb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p != 0L) \n    {\n        if ((p & 1L) != 0L)\
    \ \n        {\n            result = (result * power) % n;\n        }\n       \
    \ power = (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpf_2bc8xi.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmpf_2bc8xi.__unittest_L32_C1()\
    \ [0x427a7d]\\n??:? void tmpf_2bc8xi.__modtest() [0x427b78]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b8b]\\\
    n??:? __libc_start_main [0x748ec554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L)\n            res = (res * n)\
    \ % p;\n        n = n >> 1L;\n        n = (n * n) % p;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    if (n % 2 == 0) \n    {\n        return modp(n\
    \ / 2, p) * modp(n / 2, p) % p;\n    }\n    else \n    {\n        return modp(n\
    \ / 2, p) * modp(n / 2, p) * 2 % p;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n) {\n        r = (r * 2L) % p;\n    }\n    return r;\n}\n\
    /*\nReturn the number of bits in the binary representation of n.\n    >>> bits(0L)\n\
    \    0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n \
    \   2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n    3\n    >>> bits(6L)\n  \
    \  3\n    >>> bits(7L)\n    3\n    >>> bits(8L)\n    4\n    >>> bits(9L)\n   \
    \ 4\n    >>> bits(10L)\n    4\n    >>> bits(11L)\n    4\n    >>> bits(12L)\n \
    \   4\n    >>> bits(13L)\n    4\n    >>> bits(14L)\n    4\n    >>> bits(15L)\n\
    \    4\n    >>> bits(16L)\n    5\n    >>> bits(123456789L)\n    31\n*/\nlong bits(long\
    \ n) \n{\n    long b = 0L;\n    while (n > 0L) {\n        n >>= 1L;\n        b\
    \ += 1L;\n    }\n    return b;\n}\n/*\nReturn the number of bits in the binary\
    \ representation of n.\n    >>> bits(0L)\n    0\n    >>> bits(1L)\n    1\n   \
    \ >>> bits(2L)\n    2\n    >>> bits(3L)\n    2\n    >>> bits(4L)\n    3\n    >>>\
    \ bits(5L)\n    3\n    >>> bits(6L)\n    3\n    >>> bits(7L)\n    3\n    >>> bits(8L)\n\
    \    4\n    >>> bits(9L)\n    4\n    >>> bits(10L)\n    4\n    >>> bits(11L)\n\
    \    4\n    >>> bits(12L)\n    4\n    >>> bits(13L)\n    4\n    >>> bits(14L)\n\
    \    4\n    >>> bits(15L)\n    4\n    >>> bits(\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0n_ucr02.d(73): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0n_ucr02.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = n;\n    while (p > 0L) {\n        if (p % 2L == 1L) {\n        \
    \    result = (result * x) % n;\n        }\n        x = (x * x) % n;\n       \
    \ p = p / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptcl_qcr5.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e15]\\n??:? void tmptcl_qcr5.__unittest_L30_C1()\
    \ [0x427a99]\\n??:? void tmptcl_qcr5.__modtest() [0x427b94]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb3b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb61]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430010]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9a5]\\n??:? runModuleUnitTests [0x42b911]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428264]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281eb]\\n??:? _d_run_main [0x428156]\\n??:? main [0x427ba7]\\\
    n??:? __libc_start_main [0xc999f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            result\
    \ = (result * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) %\
    \ p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow = n;\n    while (p != 0L) {\n        if ((p & 1L) != 0L) {\n   \
    \         result = (result * pow) % p;\n        }\n        pow = (pow * pow) %\
    \ p;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpf1t9mbhc.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmpf1t9mbhc.__unittest_L30_C1()\
    \ [0x427a79]\\n??:? void tmpf1t9mbhc.__modtest() [0x427b74]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b87]\\\
    n??:? __libc_start_main [0xf014f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long res = 1;\n    while (n > 0) {\n        if (n & 1)\n\
    \            res = (res * n) % p;\n        n >>= 1;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzvtzqvwd.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427ded]\\n??:? void tmpzvtzqvwd.__unittest_L29_C1()\
    \ [0x427a9b]\\n??:? void tmpzvtzqvwd.__modtest() [0x427b70]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb13]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9a6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb39]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fac5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a97d]\\n??:? runModuleUnitTests [0x42b8e9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42823c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281c3]\\n??:? _d_run_main [0x42812e]\\n??:? main [0x427b83]\\\
    n??:? __libc_start_main [0x2e6d5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7beftng9.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e6d]\\n??:? void tmp7beftng9.__unittest_L28_C1()\
    \ [0x427b17]\\n??:? void tmp7beftng9.__modtest() [0x427bec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fbb9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9fd]\\n??:? runModuleUnitTests [0x42b969]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428243]\\n??:? _d_run_main [0x4281ae]\\n??:? main [0x427bff]\\\
    n??:? __libc_start_main [0xb53f1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits of n in base b.\n    >>> digits(0L, 2L)\n    1L\n    >>> digits(1L,\
    \ 2L)\n    1L\n    >>> digits(2L, 2L)\n    2L\n    >>> digits(11L, 2L)\n    4L\n\
    \    >>> digits(100L, 2L)\n    7L\n    >>> digits(101L, 2L)\n    7L\n    >>> digits(0L,\
    \ 10L)\n    1L\n    >>> digits(1L, 10L)\n    1L\n    >>> digits(2L, 10L)\n   \
    \ 1L\n    >>> digits(11L, 10L)\n    2L\n    >>> digits(100L, 10L)\n    3L\n  \
    \  >>> digits(101L, 10L)\n    3L\n    >>> digits(0L, 16L)\n    1L\n    >>> digits(1L,\
    \ 16L)\n    1L\n    >>> digits(2L, 16L)\n    1L\n    >>> digits(11L, 16L)\n  \
    \  2L\n    >>> digits(100L, 16L)\n    2L\n    >>> digits(101L, 16L)\n    2L\n\
    \    >>> digits(0L, 8L)\n    1L\n    >>> digits(1L, 8L)\n    1L\n    >>> digits(2L,\
    \ 8L)\n    1L\n    >>> digits(11L, 8L)\n    2L\n    >>> digits(100L, 8L)\n   \
    \ 3L\n    >>> digits(101L, 8L)\n    3L\n*/\nlong digits(long n, long b) \n{\n\
    \    long result = 1L;\n    while (n >= b) \n    {\n        n /= b;\n        result\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1_a6xvtm.d(90): Error: found `unittest` when expecting `;` following\
    \ statement\\n/tmp/tmp1_a6xvtm.d(102): Error: found `End of File` when expecting\
    \ `}` following compound statement\\n/tmp/tmp1_a6xvtm.d(102): Error: found `End\
    \ of File` when expecting `}` following compound statement\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1_a6xvtm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else\n    {\n        long t = modp(n / 2, p);\n        if\
    \ (n % 2 == 0)\n            return (t * t) % p;\n        else\n            return\
    \ (((t * t) % p) * 2) % p;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            r = (r\
    \ * 2L) % p;\n        }\n        n >>= 1L;\n    }\n    return r;\n}\n/*\nReturn\
    \ the number of bits in the binary representation of n.\n    >>> bit_length(0L)\n\
    \    0\n    >>> bit_length(1L)\n    1\n    >>> bit_length(2L)\n    2\n    >>>\
    \ bit_length(3L)\n    2\n    >>> bit_length(4L)\n    3\n    >>> bit_length(5L)\n\
    \    3\n    >>> bit_length(6L)\n    3\n    >>> bit_length(7L)\n    3\n    >>>\
    \ bit_length(8L)\n    4\n    >>> bit_length(9L)\n    4\n    >>> bit_length(10L)\n\
    \    4\n    >>> bit_length(11L)\n    4\n    >>> bit_length(12L)\n    4\n    >>>\
    \ bit_length(13L)\n    4\n    >>> bit_length(14L)\n    4\n    >>> bit_length(15L)\n\
    \    4\n    >>> bit_length(16L)\n    5\n    >>> bit_length(17L)\n    5\n    >>>\
    \ bit_length(18L)\n    5\n    >>> bit_length(19L)\n    5\n    >>> bit_length(20L)\n\
    \    5\n    >>> bit_length(21L)\n    5\n    >>> bit_length(22L)\n    5\n    >>>\
    \ bit_length(23L)\n    5\n    >>> bit_length(24L)\n    5\n    >>> bit_length(25L)\n\
    \    5\n    >>> bit_length(26L)\n    5\n    >>> bit_length(27L)\n    5\n    >>>\
    \ bit_length(28L)\n    5\n    >>> bit_length(29L)\n    5\n    >>> bit_length(30L)\n\
    \    5\n    >>> bit_length(31L)\n    5\n    >>> bit_length(32L)\n\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgx9qyikq.d(30): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgx9qyikq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    long i = p - 2L;\n    while (i > 0L) \n    {\n     \
    \   if (i % 2L == 1L) \n        {\n            result = (result * power) % p;\n\
    \        }\n        power = (power * power) % p;\n        i /= 2L;\n    }\n  \
    \  return result;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n\
    \    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n    \n*/\nlong digits(long\
    \ n) \n{\n    long result = 1L;\n    while (n >= 10L) \n    {\n        n /= 10L;\n\
    \        result += 1L;\n    }\n    return result;\n}\n/*\nReturn the sum of the\
    \ digits in n.\n    >>> digit_sum(0L)\n    0\n    >>> digit_sum(1L)\n    1\n \
    \   >>> digit_sum(10L)\n    1\n    >>> digit_sum(123456789L)\n    45\n    >>>\
    \ digit_sum(1234567890123456789L)\n    90\n    \n*/\nlong digit_sum(long n) \n\
    {\n    long result = 0L;\n    while (n > 0L) \n    {\n        result += n % 10L;\n\
    \        n /= 10L;\n    }\n    return result;\n}\n/*\nReturn the sum of the digits\
    \ in n, modulo p.\n    >>> digit_sum_modp(0L, 5L)\n    0L\n    >>> digit_sum_modp(1L,\
    \ 5L)\n    1L\n    >>> digit_sum_modp(10L, 5L)\n    1L\n    >>> digit_sum_modp(123456789L,\
    \ 5L)\n    0L\n    >>> digit_sum_modp(1234567890123456789L, 5L\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5b104syv.d(81): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5b104syv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n / 2, p);\n    r = r * r % p;\n    if (n\
    \ % 2 == 1)\n        r = r * 2 % p;\n    return r;\n}\n/*\nReturn the number of\
    \ elements of the finite field GF(p)\n*/\nlong gf_card(long p) \n{\n    return\
    \ p - 1;\n}\n/*\nReturn the order of a in GF(p).\n    >>> gf_order(2L, 11L)\n\
    \    5L\n    >>> gf_order(3L, 11L)\n    10L\n    >>> gf_order(4L, 11L)\n    10L\n\
    \    >>> gf_order(5L, 11L)\n    10L\n    >>> gf_order(6L, 11L)\n    5L\n    >>>\
    \ gf_order(7L, 11L)\n    10L\n    >>> gf_order(8L, 11L)\n    5L\n    >>> gf_order(9L,\
    \ 11L)\n    10L\n    >>> gf_order(10L, 11L)\n    5L\n*/\nlong gf_order(long a,\
    \ long p) \n{\n    long n = 1;\n    long r = a;\n    while (r != 1) \n    {\n\
    \        n++;\n        r = r * a % p;\n    }\n    return n;\n}\n/*\nReturn the\
    \ order of a in GF(p) or 0 if a is 0.\n*/\nlong gf_order_0(long a, long p) \n\
    {\n    if (a == 0)\n        return 0;\n    return gf_order(a, p);\n}\n/*\nReturn\
    \ the order of a in GF(p) or -1 if a is 0.\n*/\nlong gf_order_m1(long a, long\
    \ p) \n{\n    if (a == 0)\n        return -1;\n    return gf_order(a, p);\n}\n\
    /*\nReturn the order of a in GF(p) or p if a is 0.\n*/\nlong gf\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpenj4c6e0.d(88): Error: semicolon expected, not `unittest`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpenj4c6e0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else\n    {\n\
    \        long a = modp(n / 2, p);\n        long b = modp(n - n / 2, p);\n    \
    \    return (a * b) % p;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnvhfzr16.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e15]\\n??:? void tmpnvhfzr16.__unittest_L30_C1()\
    \ [0x427a9d]\\n??:? void tmpnvhfzr16.__modtest() [0x427b98]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb3b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb61]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430010]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9a5]\\n??:? runModuleUnitTests [0x42b911]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428264]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281eb]\\n??:? _d_run_main [0x428156]\\n??:? main [0x427bab]\\\
    n??:? __libc_start_main [0xd0031554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n == 1)\n        return n % p;\n    long half = modp(n\
    \ / 2, p);\n    long result = (half * half) % p;\n    if (n % 2 == 1)\n      \
    \  result = (result * 2) % p;\n    return result;\n}\n/*\nReturn the number of\
    \ digits in n.\n    >>> ndigits(0)\n    1\n    >>> ndigits(1)\n    1\n    >>>\
    \ ndigits(10)\n    2\n    >>> ndigits(12345)\n    5\n    >>> ndigits(123456789)\n\
    \    9\n*/\nlong ndigits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ return (long)log10(n) + 1;\n}\n/*\nReturn the number of digits in n.\n    >>>\
    \ ndigits(0)\n    1\n    >>> ndigits(1)\n    1\n    >>> ndigits(10)\n    2\n \
    \   >>> ndigits(12345)\n    5\n    >>> ndigits(123456789)\n    9\n*/\nlong ndigits(long\
    \ n) \n{\n    if (n == 0)\n        return 1;\n    return (long)log10(n) + 1;\n\
    }\n/*\nReturn the number of digits in n.\n    >>> ndigits(0)\n    1\n    >>> ndigits(1)\n\
    \    1\n    >>> ndigits(10)\n    2\n    >>> ndigits(12345)\n    5\n    >>> ndigits(123456789)\n\
    \    9\n*/\nlong ndigits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ return (long)log10(n) + 1;\n}\n/*\nReturn the number of digits in n.\n    >>>\
    \ ndigits(0)\n    1\n    >>> ndigits(1)\n    1\n    >>> ndigits(10)\n    2\n \
    \   >>> ndigits(12345)\n    5\n    >>> ndigits(123456789)\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu3rvuyej.d(46): Error: C style cast illegal, use `cast(long)log10(n)`\\\
    n/tmp/tmpu3rvuyej.d(65): Error: C style cast illegal, use `cast(long)log10(n)`\\\
    n/tmp/tmpu3rvuyej.d(84): Error: C style cast illegal, use `cast(long)log10(n)`\\\
    n/tmp/tmpu3rvuyej.d(86): Error: unterminated /* */ comment\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu3rvuyej.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) {\n        if (n & 1L) {\n            r = (r * n) % p;\n  \
    \      }\n        n = n >> 1L;\n    }\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpckew04vj.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427de5]\\n??:? void tmpckew04vj.__unittest_L28_C1()\
    \ [0x427a93]\\n??:? void tmpckew04vj.__modtest() [0x427b68]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb0b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a99e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb31]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a975]\\n??:? runModuleUnitTests [0x42b8e1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428234]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281bb]\\n??:? _d_run_main [0x428126]\\n??:? main [0x427b7b]\\\
    n??:? __libc_start_main [0x8eb01554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow = n;\n    while (pow > 0L) {\n        if ((pow & 1L) == 1L) {\n\
    \            result = (result * n) % p;\n        }\n        pow >>= 1L;\n    \
    \    n = (n * n) % p;\n    }\n    return result;\n}\n/*\nReturn the number of\
    \ digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n \
    \   >>> numdigits(10L)\n    2\n    >>> numdigits(101L)\n    3\n    >>> numdigits(123456789L)\n\
    \    9\n    >>> numdigits(1234567890123456789L)\n    19\n*/\nlong numdigits(long\
    \ n) \n{\n    long result = 1L;\n    while (n >= 10L) {\n        n /= 10L;\n \
    \       result += 1L;\n    }\n    return result;\n}\n/*\nReturn the nth digit\
    \ of n.\n    >>> nthdigit(0L, 0L)\n    0L\n    >>> nthdigit(0L, 1L)\n    0L\n\
    \    >>> nthdigit(0L, 2L)\n    0L\n    >>> nthdigit(1L, 0L)\n    1L\n    >>> nthdigit(1L,\
    \ 1L)\n    0L\n    >>> nthdigit(1L, 2L)\n    0L\n    >>> nthdigit(10L, 0L)\n \
    \   0L\n    >>> nthdigit(10L, 1L)\n    1L\n    >>> nthdigit(10L, 2L)\n    0L\n\
    \    >>> nthdigit(101L, 0L)\n    1L\n    >>> nthdigit(101L, 1L)\n    0L\n    >>>\
    \ nthdigit(101L, 2L)\n    1L\n    >>> nthdigit(123456789L, 0L)\n    9L\n    >>>\
    \ nthdigit(123456789L, 1L)\n    8L\n    >>> nthdigit(123456789L\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp517qu4_g.d(54): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp517qu4_g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else\n    {\n\
    \        long half = modp(n / 2, p);\n        if (n % 2 == 0)\n            return\
    \ (half * half) % p;\n        else\n            return (half * half * n) % p;\n\
    \    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6qgz1gbc.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e2d]\\n??:? void tmp6qgz1gbc.__unittest_L32_C1()\
    \ [0x427ad7]\\n??:? void tmp6qgz1gbc.__modtest() [0x427bac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb53]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9e6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb79]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430028]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb05]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9bd]\\n??:? runModuleUnitTests [0x42b929]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42827c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428203]\\n??:? _d_run_main [0x42816e]\\n??:? main [0x427bbf]\\\
    n??:? __libc_start_main [0xffc33554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_8kldxwn.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e6d]\\n??:? void tmp_8kldxwn.__unittest_L28_C1()\
    \ [0x427b17]\\n??:? void tmp_8kldxwn.__modtest() [0x427bec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fbb9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9fd]\\n??:? runModuleUnitTests [0x42b969]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428243]\\n??:? _d_run_main [0x4281ae]\\n??:? main [0x427bff]\\\
    n??:? __libc_start_main [0xea613554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) return\
    \ 1;\n    long r = modp(n >> 1, p);\n    r = (r * r) % p;\n    if (n & 1) r =\
    \ (r * 2) % p;\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n /= 2L;\n        if (n > 0L) \n    \
    \    {\n            r = (r * r) % p;\n        }\n    }\n    return r;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdzaa5xe6.d(39): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e15]\\n??:? void tmpdzaa5xe6.__unittest_L34_C1()\
    \ [0x427abf]\\n??:? void tmpdzaa5xe6.__modtest() [0x427b94]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb3b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb61]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430010]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9a5]\\n??:? runModuleUnitTests [0x42b911]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428264]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281eb]\\n??:? _d_run_main [0x428156]\\n??:? main [0x427ba7]\\\
    n??:? __libc_start_main [0x6159f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long res = modp(n / 2, p);\n    res = (res * res) % p;\n\
    \    if (n % 2 == 1)\n        res = (res * 2) % p;\n    return res;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n  \
    \  1\n    >>> digits(2)\n    1\n    >>> digits(10)\n    2\n    >>> digits(12345)\n\
    \    5\n*/\nlong digits(long n) \n{\n    long res = 0;\n    while (n > 0) \n \
    \   {\n        res++;\n        n /= 10;\n    }\n    return res;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n  \
    \  1\n    >>> digits(2)\n    1\n    >>> digits(10)\n    2\n    >>> digits(12345)\n\
    \    5\n*/\nlong digits(long n) \n{\n    long res = 0;\n    while (n > 0) \n \
    \   {\n        res++;\n        n /= 10;\n    }\n    return res;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n  \
    \  1\n    >>> digits(2)\n    1\n    >>> digits(10)\n    2\n    >>> digits(12345)\n\
    \    5\n*/\nlong digits(long n) \n{\n    long res = 0;\n    while (n > 0) \n \
    \   {\n        res++;\n        n /= 10;\n    }\n    return res;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n  \
    \  1\n    >>> digits(2)\n    1\n    >>> digits(10)\n    2\n    >>> digits(12345)\n\
    \    5\n*/\nlong digits(long n) \n{\n    long res = 0;\n    while (n > 0) \n \
    \   {\n        res++;\n        n\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3lhozaqa.d(116): Error: found `unittest` when expecting `;` following\
    \ statement\\n/tmp/tmp3lhozaqa.d(128): Error: found `End of File` when expecting\
    \ `}` following compound statement\\n/tmp/tmp3lhozaqa.d(128): Error: found `End\
    \ of File` when expecting `}` following compound statement\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3lhozaqa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n\
    \    1\n    >>> digits(1L)\n    1\n    >>> digits(2L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(100L)\n    3\n    >>> digits(123456789L)\n    9\n*/\nlong\
    \ digits(long n) \n{\n    long d = 1L;\n    while (n >= 10L) {\n        n = n\
    \ / 10L;\n        d = d + 1L;\n    }\n    return d;\n}\n/*\nReturn the nth digit\
    \ of n (0-based).\n    >>> nthdigit(123456789L, 0L)\n    9\n    >>> nthdigit(123456789L,\
    \ 1L)\n    8\n    >>> nthdigit(123456789L, 2L)\n    7\n    >>> nthdigit(123456789L,\
    \ 3L)\n    6\n    >>> nthdigit(123456789L, 4L)\n    5\n    >>> nthdigit(123456789L,\
    \ 5L)\n    4\n    >>> nthdigit(123456789L, 6L)\n    3\n    >>> nthdigit(123456789L,\
    \ 7L)\n    2\n    >>> nthdigit(123456789L, 8L)\n    1\n*/\nlong nthdigit(long\
    \ n, long d) \n{\n    long p = pow(10L, d);\n    return (n / p) % 10L;\n}\n/*\n\
    Return the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(2L)\n    1\n    >>> digits(10L)\n    2\n    >>>\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwgeqdpjl.d(80): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwgeqdpjl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = 2L;\n    while (n != 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * x) % p;\n        }\n        n >>= 1L;\n\
    \        x = (x * x) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcczqxvsi.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e6d]\\n??:? void tmpcczqxvsi.__unittest_L28_C1()\
    \ [0x427b17]\\n??:? void tmpcczqxvsi.__modtest() [0x427bec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fbb9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9fd]\\n??:? runModuleUnitTests [0x42b969]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428243]\\n??:? _d_run_main [0x4281ae]\\n??:? main [0x427bff]\\\
    n??:? __libc_start_main [0x685f1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n)\n        r = (r * 2L) % p;\n    return r;\n}\n/*\nReturn\
    \ the number of digits in the decimal representation of n.\n    >>> digits(0L)\n\
    \    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(100L)\n\
    \    3\n    >>> digits(123456789L)\n    9\n    >>> digits(1234567890123456789L)\n\
    \    19\n*/\nlong digits(long n) \n{\n    long r = 1L;\n    foreach (i; 0 .. n)\n\
    \        r = (r * 10L) % n;\n    return r;\n}\n/*\nReturn the number of digits\
    \ in the decimal representation of n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(10L)\n    2\n    >>> digits(100L)\n    3\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    long r = 1L;\n    foreach (i; 0 .. n)\n        r = (r * 10L) % n;\n\
    \    return r;\n}\n/*\nReturn the number of digits in the decimal representation\
    \ of n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(100L)\n    3\n    >>> digits(123456789L)\n    9\n    >>>\
    \ digits(1234567890123456789L)\n    19\n*/\nlong digits(long n) \n{\n    long\
    \ r = 1L;\n    foreach (i; 0 .. n)\n        r = (r * 10L) % n;\n    return r;\n\
    }\n/*\nReturn the number of digits in the decimal representation of n.\n    >>>\
    \ digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbwl4fja_.d(90): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbwl4fja_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p != 0L) \n    {\n        if ((p & 1L) != 0L)\
    \ \n        {\n            result = (result * power) % n;\n        }\n       \
    \ power = (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpo9azc4cg.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmpo9azc4cg.__unittest_L32_C1()\
    \ [0x427a7d]\\n??:? void tmpo9azc4cg.__modtest() [0x427b78]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b8b]\\\
    n??:? __libc_start_main [0xffc3c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) return\
    \ 1;\n    if (n == 1) return n % p;\n    if (n % 2 == 0) return modp(n / 2, p)\
    \ * modp(n / 2, p) % p;\n    return modp(n / 2, p) * modp(n / 2, p) * n % p;\n\
    }\n/*\nReturn the number of digits of n in base b.\n    >>> digits(0L, 10L)\n\
    \    1L\n    >>> digits(1L, 10L)\n    1L\n    >>> digits(2L, 10L)\n    1L\n  \
    \  >>> digits(10L, 10L)\n    2L\n    >>> digits(11L, 10L)\n    2L\n    >>> digits(100L,\
    \ 10L)\n    3L\n    >>> digits(101L, 10L)\n    3L\n    >>> digits(123456789L,\
    \ 10L)\n    9L\n    >>> digits(123456789L, 2L)\n    31L\n    >>> digits(123456789L,\
    \ 8L)\n    11L\n    >>> digits(123456789L, 16L)\n    8L\n    >>> digits(123456789L,\
    \ 32L)\n    7L\n    >>> digits(123456789L, 36L)\n    7L\n    >>> digits(123456789L,\
    \ 62L)\n    6L\n    >>> digits(123456789L, 64L)\n    6L\n    >>> digits(123456789L,\
    \ 100L)\n    6L\n    >>> digits(123456789L, 1000L)\n    5L\n    >>> digits(123456789L,\
    \ 10000L)\n    5L\n    >>> digits(123456789L, 100000L)\n    5L\n    >>> digits(123456789L,\
    \ 1000000L)\n    5L\n    >>> digits(123456789L, 10000000L)\n    5L\n    >>> digits(123456789L,\
    \ 100000000L)\n    5L\n    >>> digits(123456789L, 1000000000L)\n    5L\n    >>>\
    \ digits(123456789L, 100\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe1yiwvu7.d(24): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe1yiwvu7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * x) % p;\n        }\n        n = n >> 1L;\n       \
    \ x = (x * x) % p;\n    }\n    return result;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(123456789L)\n    9\n    >>> digits(1234567890123456789L)\n\
    \    19\n*/\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * a) % p;\n        }\n        a = (a * a) % p;\n      \
    \  n = n / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       result = (result * a) % p;\n        }\n        a = (a * a) % p;\n    \
    \    n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long x = modp(n >>\
    \ 1, p);\n        x = (x * x) % p;\n        if (n & 1) \n        {\n         \
    \   x = (x * 2) % p;\n        }\n        return x;\n    }\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n        if (n > 0L) \n \
    \       {\n            r = (r * r) % p;\n        }\n    }\n    return r;\n}\n\
    /*\nReturn the number of digits in n.\n    >>> ndigits(0L)\n    1\n    >>> ndigits(1L)\n\
    \    1\n    >>> ndigits(10L)\n    2\n    >>> ndigits(12345L)\n    5\n    >>> ndigits(123456789012345L)\n\
    \    15\n    >>> ndigits(1234567890123456789L)\n    19\n    \n*/\nlong ndigits(long\
    \ n) \n{\n    long r = 1L;\n    while (n > 9L) \n    {\n        n = n / 10L;\n\
    \        r = r + 1L;\n    }\n    return r;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> ndigits(0L)\n    1\n    >>> ndigits(1L)\n    1\n    >>> ndigits(10L)\n\
    \    2\n    >>> ndigits(12345L)\n    5\n    >>> ndigits(123456789012345L)\n  \
    \  15\n    >>> ndigits(1234567890123456789L)\n    19\n    \n*/\nlong ndigits(long\
    \ n) \n{\n    long r = 1L;\n    while (n > 9L) \n    {\n        n = n / 10L;\n\
    \        r = r + 1L;\n    }\n    return r;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> ndigits(0L)\n    1\n    >>> ndigits(1L)\n    1\n    >>> ndigits(10L)\n\
    \    2\n    >>> ndigits(12345L)\n    5\n    >>> ndigits(123\nunittest\n{\n   \
    \ alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm9_5bc4t.d(86): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm9_5bc4t.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) {\n        if (n % 2L == 1L) {\n            result = (result\
    \ * n) % p;\n        }\n        n = n / 2L;\n    }\n    return result;\n}\n/*\n\
    Return the number of digits in n.\n    >>> ndigits(0L)\n    1\n    >>> ndigits(1L)\n\
    \    1\n    >>> ndigits(10L)\n    2\n    >>> ndigits(12345L)\n    5\n    >>> ndigits(123456789123456789L)\n\
    \    18\n*/\nlong ndigits(long n) \n{\n    long result = 1L;\n    while (n >=\
    \ 10L) {\n        n = n / 10L;\n        result = result + 1L;\n    }\n    return\
    \ result;\n}\n/*\nReturn the nth digit of n, counting from the right.\n    >>>\
    \ nthdigit(0L, 0L)\n    0\n    >>> nthdigit(1L, 0L)\n    1\n    >>> nthdigit(10L,\
    \ 0L)\n    0\n    >>> nthdigit(10L, 1L)\n    1\n    >>> nthdigit(12345L, 0L)\n\
    \    5\n    >>> nthdigit(12345L, 1L)\n    4\n    >>> nthdigit(12345L, 2L)\n  \
    \  3\n    >>> nthdigit(12345L, 3L)\n    2\n    >>> nthdigit(12345L, 4L)\n    1\n\
    \    >>> nthdigit(123456789123456789L, 0L)\n    9\n    >>> nthdigit(123456789123456789L,\
    \ 1L)\n    8\n    >>> nthdigit(123456789123456789L, 2L)\n    7\n    >>> nthdigit(123456789123456789L,\
    \ 3L)\n    6\n    >>> nthdigit(123456789123456789L, 4L)\n    5\n    >>> nthdigit(123456789123456789L,\
    \ 5L)\n\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkwo15hch.d(50): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwo15hch.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpozugrwir.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e6d]\\n??:? void tmpozugrwir.__unittest_L28_C1()\
    \ [0x427b17]\\n??:? void tmpozugrwir.__modtest() [0x427bec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fbb9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9fd]\\n??:? runModuleUnitTests [0x42b969]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428243]\\n??:? _d_run_main [0x4281ae]\\n??:? main [0x427bff]\\\
    n??:? __libc_start_main [0xd8867554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long res = 1;\n    while (n > 0)\n    {\n        if (n &\
    \ 1)\n            res = (res * n) % p;\n        n = n >> 1;\n        n = (n *\
    \ n) % p;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpw18_jexx.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e6d]\\n??:? void tmpw18_jexx.__unittest_L28_C1()\
    \ [0x427b17]\\n??:? void tmpw18_jexx.__modtest() [0x427bec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fbb9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9fd]\\n??:? runModuleUnitTests [0x42b969]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428243]\\n??:? _d_run_main [0x4281ae]\\n??:? main [0x427bff]\\\
    n??:? __libc_start_main [0x325bc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) ^ 2 % p;\n\
    \    else\n        return modp(n - 1, p) * 2 % p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpc03imq0f.d(30): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e15]\\n??:? void tmpc03imq0f.__unittest_L26_C1()\
    \ [0x427a9d]\\n??:? void tmpc03imq0f.__modtest() [0x427b98]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb3b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb61]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430010]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9a5]\\n??:? runModuleUnitTests [0x42b911]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428264]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281eb]\\n??:? _d_run_main [0x428156]\\n??:? main [0x427bab]\\\
    n??:? __libc_start_main [0xc03ac554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp02jxxq9t.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e6d]\\n??:? void tmp02jxxq9t.__unittest_L28_C1()\
    \ [0x427b17]\\n??:? void tmp02jxxq9t.__modtest() [0x427bec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fbb9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9fd]\\n??:? runModuleUnitTests [0x42b969]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428243]\\n??:? _d_run_main [0x4281ae]\\n??:? main [0x427bff]\\\
    n??:? __libc_start_main [0xab36e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n   \
    \     {\n            r = (r * b) % p;\n        }\n        n = n / 2L;\n      \
    \  b = (b * b) % p;\n    }\n    return r;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(123456789L)\n    9\n\
    */\nlong numdigits(long n) \n{\n    long num = 0L;\n    while (n > 0L) \n    {\n\
    \        num = num + 1L;\n        n = n / 10L;\n    }\n    return num;\n}\n/*\n\
    Return the nth digit of n.\n    >>> digit(0L, 0L)\n    0\n    >>> digit(0L, 1L)\n\
    \    0\n    >>> digit(1L, 0L)\n    1\n    >>> digit(12345L, 0L)\n    5\n    >>>\
    \ digit(12345L, 1L)\n    4\n    >>> digit(12345L, 2L)\n    3\n    >>> digit(12345L,\
    \ 3L)\n    2\n    >>> digit(12345L, 4L)\n    1\n    >>> digit(12345L, 5L)\n  \
    \  0\n*/\nlong digit(long n, long i) \n{\n    long num = numdigits(n);\n    if\
    \ (i >= num) \n    {\n        return 0L;\n    }\n    return n / pow(10L, num -\
    \ i - 1L) % 10L;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \   \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprj55rcbl.d(85): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprj55rcbl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       r = (r * b) % p;\n        }\n        n >>= 1L;\n        b = (b * b) %\
    \ p;\n    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n  \
    \  assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n     \
    \   {\n            result = (result * power) % n;\n        }\n        power =\
    \ (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmppmc74n_w.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmppmc74n_w.__unittest_L32_C1()\
    \ [0x427a7d]\\n??:? void tmppmc74n_w.__modtest() [0x427b78]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b8b]\\\
    n??:? __libc_start_main [0xf7c69554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n) \n    {\n        r = (r * 2L) % p;\n    }\n    return\
    \ r;\n}\n/*\nReturn the number of bits in the binary representation of n.\n  \
    \  >>> bit_length(0L)\n    0\n    >>> bit_length(1L)\n    1\n    >>> bit_length(2L)\n\
    \    2\n    >>> bit_length(3L)\n    2\n    >>> bit_length(4L)\n    3\n    >>>\
    \ bit_length(5L)\n    3\n    >>> bit_length(6L)\n    3\n    >>> bit_length(7L)\n\
    \    3\n    >>> bit_length(8L)\n    4\n    >>> bit_length(9L)\n    4\n    >>>\
    \ bit_length(10L)\n    4\n    >>> bit_length(11L)\n    4\n    >>> bit_length(12L)\n\
    \    4\n    >>> bit_length(13L)\n    4\n    >>> bit_length(14L)\n    4\n    >>>\
    \ bit_length(15L)\n    4\n    >>> bit_length(16L)\n    5\n    >>> bit_length(17L)\n\
    \    5\n    >>> bit_length(18L)\n    5\n    >>> bit_length(19L)\n    5\n    >>>\
    \ bit_length(20L)\n    5\n    >>> bit_length(21L)\n    5\n    >>> bit_length(22L)\n\
    \    5\n    >>> bit_length(23L)\n    5\n    >>> bit_length(24L)\n    5\n    >>>\
    \ bit_length(25L)\n    5\n    >>> bit_length(26L)\n    5\n    >>> bit_length(27L)\n\
    \    5\n    >>> bit_length(28L)\n    5\n    >>> bit_length(29L)\n    5\n    >>>\
    \ bit_length(30L)\n    5\n    >>> bit_length(31L)\n    5\n    >>> bit_length(32L)\n\
    \    6\n    >>> bit_length(33L)\n    6\n    >>> bit_length(\nunittest\n{\n   \
    \ alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgi37y45u.d(26): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgi37y45u.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\n/*\nReturn the greatest common divisor of a and b.\n\
    \    >>> gcd(2L, 3L)\n    1L\n    >>> gcd(6L, 9L)\n    3L\n    >>> gcd(9L, 6L)\n\
    \    3L\n    >>> gcd(3L, 3L)\n    3L\n    >>> gcd(0L, 3L)\n    3L\n    >>> gcd(3L,\
    \ 0L)\n    3L\n    >>> gcd(0L, 0L)\n    0L\n*/\nlong gcd(long a, long b) \n{\n\
    \    if (a == 0L) \n    {\n        return b;\n    }\n    if (b == 0L) \n    {\n\
    \        return a;\n    }\n    if (a > b) \n    {\n        return gcd(a % b, b);\n\
    \    }\n    else \n    {\n        return gcd(a, b % a);\n    }\n}\n/*\nReturn\
    \ the least common multiple of a and b.\n    >>> lcm(2L, 3L)\n    6L\n    >>>\
    \ lcm(6L, 9L)\n    18L\n    >>> lcm(9L, 6L)\n    18L\n    >>> lcm(3L, 3L)\n  \
    \  3L\n    >>> lcm(0L, 3L)\n    0L\n    >>> lcm(3L, 0L)\n    0L\n    >>> lcm(0L,\
    \ 0L)\n    0L\n*/\nlong lcm(long a, long b) \n{\n    if (a == 0L || b == 0L) \n\
    \    {\n        return 0L;\n    }\n    return (a * b) / gcd(a, b);\n}\n/*\nReturn\
    \ the number of digits\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpypnikhuo.d(92): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpypnikhuo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * a) % p;\n        }\n        a = (a * a) % p;\n      \
    \  n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn the number of elements\
    \ in the finite field with p elements.\n    >>> p = 101L\n    >>> len(field(p))\n\
    \    101L\n    >>> p = 11L\n    >>> len(field(p))\n    11L\n    >>> p = 2L\n \
    \   >>> len(field(p))\n    2L\n    >>> p = 3L\n    >>> len(field(p))\n    3L\n\
    \    >>> p = 5L\n    >>> len(field(p))\n    5L\n    >>> p = 7L\n    >>> len(field(p))\n\
    \    7L\n    >>> p = 13L\n    >>> len(field(p))\n    13L\n*/\nlong[] field(long\
    \ p) \n{\n    long[] result = new long[p];\n    foreach (i; 0L .. p) {\n     \
    \   result[i] = i;\n    }\n    return result;\n}\n/*\nReturn the list of elements\
    \ in the finite field with p elements.\n    >>> p = 101L\n    >>> field(p)\n \
    \   [0L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L, 12L, 13L, 14L, 15L, 16L,\
    \ 17L, 18L, 19L, 20L, 21L, 22L, 23L, 24L, 25L, 26L, 27L, 28L, 29L, 30L, 31L, 32L,\
    \ 33L, 34L, 35L, 36L, 37L, 38L, 39L, 40L, 41L, 42L, 43L, 44L, 45L, 46L, 47L, 48L,\
    \ 49L, 50L, 51L, 52L, 53L, 54L, 55L, 56L, 57L, 58L, 59L,\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_9nrp_xs.d(62): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_9nrp_xs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            result\
    \ = (result * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) %\
    \ p;\n    }\n    return result;\n}\n/*\nReturn the number of digits in the decimal\
    \ representation of n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n \
    \   >>> digits(10)\n    2\n    >>> digits(12345)\n    5\n    >>> digits(10**100)\n\
    \    101\n*/\nlong digits(long n) \n{\n    long result = 1L;\n    while (n >=\
    \ 10L) \n    {\n        n = n / 10L;\n        result = result + 1L;\n    }\n \
    \   return result;\n}\n/*\nReturn the number of digits in the decimal representation\
    \ of n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n\
    \    2\n    >>> digits(12345)\n    5\n    >>> digits(10**100)\n    101\n*/\nlong\
    \ digits(long n) \n{\n    long result = 1L;\n    while (n >= 10L) \n    {\n  \
    \      n = n / 10L;\n        result = result + 1L;\n    }\n    return result;\n\
    }\n/*\nReturn the number of digits in the decimal representation of n.\n    >>>\
    \ digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>>\
    \ digits(12345)\n    5\n    >>> digits(10**100)\n    101\n*/\nlong digits(long\
    \ n) \n{\n    long result = 1L;\n    while (n >= 10L) \n    {\n        n = n /\
    \ 10L;\n        result = result + 1L;\n    }\n    return result;\n}\n/*\nReturn\
    \ the number of digits in the decimal representation of n.\n    >>> digits(0)\n\
    \    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfv89fy86.d(100): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfv89fy86.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpabbxe1qu.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dfd]\\n??:? void tmpabbxe1qu.__unittest_L30_C1()\
    \ [0x427a81]\\n??:? void tmpabbxe1qu.__modtest() [0x427b7c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb23]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9b6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb49]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fad5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a98d]\\n??:? runModuleUnitTests [0x42b8f9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42824c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281d3]\\n??:? _d_run_main [0x42813e]\\n??:? main [0x427b8f]\\\
    n??:? __libc_start_main [0xbfb65554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_8211ayu.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e6d]\\n??:? void tmp_8211ayu.__unittest_L28_C1()\
    \ [0x427b17]\\n??:? void tmp_8211ayu.__modtest() [0x427bec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fbb9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9fd]\\n??:? runModuleUnitTests [0x42b969]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428243]\\n??:? _d_run_main [0x4281ae]\\n??:? main [0x427bff]\\\
    n??:? __libc_start_main [0x8aa50554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) {\n        if (n & 1L) {\n            res = (res * n) % p;\n\
    \        }\n        n = n >> 1L;\n        n = (n * n) % p;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    long i = p - 2L;\n    while (i > 0L) \n    {\n     \
    \   if (i % 2L == 1L) \n        {\n            result = (result * power) % p;\n\
    \        }\n        power = (power * power) % p;\n        i /= 2L;\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzo2joh7v.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e15]\\n??:? void tmpzo2joh7v.__unittest_L33_C1()\
    \ [0x427a9d]\\n??:? void tmpzo2joh7v.__modtest() [0x427b98]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb3b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb61]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430010]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9a5]\\n??:? runModuleUnitTests [0x42b911]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428264]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281eb]\\n??:? _d_run_main [0x428156]\\n??:? main [0x427bab]\\\
    n??:? __libc_start_main [0x8ec22554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\n/*\nReturn the greatest\
    \ common divisor of a and b.\n    >>> gcd(12, 8)\n    4\n    >>> gcd(8, 12)\n\
    \    4\n    >>> gcd(0, 12)\n    12\n    >>> gcd(12, 0)\n    12\n    >>> gcd(3,\
    \ 5)\n    1\n    >>> gcd(5, 3)\n    1\n    >>> gcd(24, 60)\n    12\n    >>> gcd(60,\
    \ 24)\n    12\n    >>> gcd(24, 20)\n    4\n    >>> gcd(20, 24)\n    4\n    >>>\
    \ gcd(2**100-1, 10**9+7)\n    1\n*/\nlong gcd(long a, long b) \n{\n    if (a ==\
    \ 0)\n        return b;\n    else if (b == 0)\n        return a;\n    else\n \
    \       return gcd(b, a % b);\n}\n/*\nReturn the least common multiple of a and\
    \ b.\n    >>> lcm(12, 8)\n    24\n    >>> lcm(8, 12)\n    24\n    >>> lcm(0, 12)\n\
    \    0\n    >>> lcm(12, 0)\n    0\n    >>> lcm(3, 5)\n    15\n    >>> lcm(5, 3)\n\
    \    15\n    >>> lcm(24, 60)\n    120\n    >>> lcm(60, 24)\n    120\n    >>> lcm(24,\
    \ 20)\n    120\n    >>> lcm(20, 24)\n    120\n    >>> lcm(2**100-1, 10**9+7)\n\
    \    9999999999999999948348340870997507\n*/\nlong lcm(long a, long\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpglrvsymv.d(88): Error: found `unittest` when expecting `)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpglrvsymv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * a) % p;\n        }\n        a = (a * a) % p;\n      \
    \  n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n\
    \    20\n*/\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else\n    {\n\
    \        long half = modp(n / 2, p);\n        long result = (half * half) % p;\n\
    \        if (n % 2 == 1)\n            result = (result * 2) % p;\n        return\
    \ result;\n    }\n}\n/*\nReturn the number of digits in n.\n    >>> num_digits(123L)\n\
    \    3\n    >>> num_digits(1L)\n    1\n    >>> num_digits(0L)\n    1\n    >>>\
    \ num_digits(12345678901234567890L)\n    20\n*/\nlong num_digits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    else\n        return cast(long) floor(log10(n))\
    \ + 1;\n}\n/*\nReturn the nth digit of n, where the rightmost digit is 0.\n  \
    \  >>> nth_digit(123L, 0)\n    3\n    >>> nth_digit(123L, 1)\n    2\n    >>> nth_digit(123L,\
    \ 2)\n    1\n    >>> nth_digit(123L, 3)\n    0\n    >>> nth_digit(12345678901234567890L,\
    \ 0)\n    0\n    >>> nth_digit(12345678901234567890L, 1)\n    0\n    >>> nth_digit(12345678901234567890L,\
    \ 2)\n    1\n    >>> nth_digit(12345678901234567890L, 3)\n    2\n    >>> nth_digit(12345678901234567890L,\
    \ 4)\n    3\n    >>> nth_digit(12345678901234567890L, 5)\n    4\n    >>> nth_digit(12345678901234567890L,\
    \ 6)\n    5\n    >>> nth_digit(12345678901234567890L, 7)\n    6\n    >>> nth_digit(123456789012345678\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5z8ud70u.d(50): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5z8ud70u.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n     \
    \   {\n            result = (result * power) % n;\n        }\n        power =\
    \ (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpighvh98j.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmpighvh98j.__unittest_L32_C1()\
    \ [0x427a7d]\\n??:? void tmpighvh98j.__modtest() [0x427b78]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b8b]\\\
    n??:? __libc_start_main [0x1f0d8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = n;\n    while (p > 0L) {\n        if (p % 2L == 1L) {\n        \
    \    result = (result * x) % n;\n        }\n        x = (x * x) % n;\n       \
    \ p = p / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjvksa1j2.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e15]\\n??:? void tmpjvksa1j2.__unittest_L30_C1()\
    \ [0x427a99]\\n??:? void tmpjvksa1j2.__modtest() [0x427b94]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb3b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb61]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430010]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9a5]\\n??:? runModuleUnitTests [0x42b911]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428264]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281eb]\\n??:? _d_run_main [0x428156]\\n??:? main [0x427ba7]\\\
    n??:? __libc_start_main [0x53f8f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n  \
    \      {\n            result = (result * a) % p;\n        }\n        a = (a *\
    \ a) % p;\n        n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>>\
    \ digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(1234567890123456789L)\n\
    \    19\n    \n*/\nlong digits(long n) \n{\n    long result = 1L;\n    while (n\
    \ >= 10L) \n    {\n        n = n / 10L;\n        result = result + 1L;\n    }\n\
    \    return result;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n\
    \    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n\
    \    5\n    >>> digits(1234567890123456789L)\n    19\n    \n*/\nlong digits(long\
    \ n) \n{\n    long result = 1L;\n    while (n >= 10L) \n    {\n        n = n /\
    \ 10L;\n        result = result + 1L;\n    }\n    return result;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(1234567890123456789L)\n\
    \    19\n    \n*/\nlong digits(long n) \n{\n    long result = 1L;\n    while (n\
    \ >= 10L) \n    {\n        n = n / 10L;\n        result = result + 1L;\n    }\n\
    \    return result;\n}\n/*\nReturn the\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc521cxjx.d(104): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc521cxjx.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long b = 2L;\n    while (n != 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * b) % p;\n        }\n        n >>= 1L;\n\
    \        b = (b * b) % p;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> len_digits(0L)\n    1\n    >>> len_digits(1L)\n   \
    \ 1\n    >>> len_digits(2L)\n    1\n    >>> len_digits(10L)\n    2\n    >>> len_digits(123456789L)\n\
    \    9\n    >>> len_digits(12345678901234567890L)\n    19\n*/\nlong len_digits(long\
    \ n) \n{\n    long result = 1L;\n    while (n >= 10L) \n    {\n        n /= 10L;\n\
    \        result += 1L;\n    }\n    return result;\n}\n/*\nReturn the nth digit\
    \ of n, where the least significant digit is 0.\n    >>> nth_digit(123456789L,\
    \ 0L)\n    9L\n    >>> nth_digit(123456789L, 1L)\n    8L\n    >>> nth_digit(123456789L,\
    \ 2L)\n    7L\n    >>> nth_digit(123456789L, 3L)\n    6L\n    >>> nth_digit(123456789L,\
    \ 4L)\n    5L\n    >>> nth_digit(123456789L, 5L)\n    4L\n    >>> nth_digit(123456789L,\
    \ 6L)\n    3L\n    >>> nth_digit(123456789L, 7L)\n    2L\n    >>> nth_digit(123456789L,\
    \ 8L)\n    1L\n    >>> nth_digit(123456789L, 9L)\n    0L\n    >>> nth_digit(123456789L,\
    \ 10L)\n    Traceback (most\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3p1_ujjl.d(57): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3p1_ujjl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       r = (r * b) % p;\n        }\n        n >>= 1L;\n        b = (b * b) %\
    \ p;\n    }\n    return r;\n}\n/*\nReturn the number of digits in the decimal\
    \ representation of n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n\
    \    >>> digits(10L)\n    2\n    >>> digits(100L)\n    3\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    long d = 1L;\n    while (n >= 10L) {\n        n /= 10L;\n        d\
    \ += 1L;\n    }\n    return d;\n}\n/*\nReturn the number of digits in the decimal\
    \ representation of n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n\
    \    >>> digits(10L)\n    2\n    >>> digits(100L)\n    3\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    long d = 1L;\n    while (n >= 10L) {\n        n /= 10L;\n        d\
    \ += 1L;\n    }\n    return d;\n}\n/*\nReturn the number of digits in the decimal\
    \ representation of n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n\
    \    >>> digits(10L)\n    2\n    >>> digits(100L)\n    3\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    long d = 1L;\n    while (n >= 10L) {\n        n /= 10L;\n\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8njk1zfo.d(99): Error: found `unittest` instead of statement\\\
    n/tmp/tmp8njk1zfo.d(111): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8njk1zfo.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) {\n        if (p & 1L) {\n          \
    \  result = (result * power) % n;\n        }\n        power = (power * power)\
    \ % n;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp21rni7x5.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmp21rni7x5.__unittest_L30_C1()\
    \ [0x427a7d]\\n??:? void tmp21rni7x5.__modtest() [0x427b78]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b8b]\\\
    n??:? __libc_start_main [0x9a1dc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            res = (res * a) % p;\n        }\n        a = (a * a) %\
    \ p;\n        n >>= 1L;\n    }\n    return res;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> ndigits(0L)\n    1\n    >>> ndigits(1L)\n    1\n    >>> ndigits(10L)\n\
    \    2\n    >>> ndigits(12345L)\n    5\n    >>> ndigits(123456789012345L)\n  \
    \  15\n*/\nlong ndigits(long n) \n{\n    long res = 0L;\n    while (n > 0L) \n\
    \    {\n        res += 1L;\n        n /= 10L;\n    }\n    return res;\n}\n/*\n\
    Return the number of digits in n.\n    >>> ndigits(0L)\n    1\n    >>> ndigits(1L)\n\
    \    1\n    >>> ndigits(10L)\n    2\n    >>> ndigits(12345L)\n    5\n    >>> ndigits(123456789012345L)\n\
    \    15\n*/\nlong ndigits(long n) \n{\n    long res = 0L;\n    while (n > 0L)\
    \ \n    {\n        res += 1L;\n        n /= 10L;\n    }\n    return res;\n}\n\
    /*\nReturn the number of digits in n.\n    >>> ndigits(0L)\n    1\n    >>> ndigits(1L)\n\
    \    1\n    >>> ndigits(10L)\n    2\n    >>> ndigits(12345L)\n    5\n    >>> ndigits(123456789012345L)\n\
    \    15\n*/\nlong ndigits(long n) \n{\n    long res = 0L;\n    while (n > 0L)\
    \ \n    {\n        res += 1L;\n        n /= 10L;\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpll7vc033.d(98): Error: found `unittest` instead of statement\\\
    n/tmp/tmpll7vc033.d(110): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpll7vc033.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n  \
    \          result = (result * base) % p;\n        }\n        base = (base * base)\
    \ % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * a) % p;\n        }\n        a = (a * a) % p;\n      \
    \  n = n / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        n\
    \ >>= 1L;\n        base = (base * base) % p;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else\n    {\n        long x = modp(n / 2, p);\n        if\
    \ (n % 2 == 0)\n            return (x * x) % p;\n        else\n            return\
    \ (x * x * 2) % p;\n    }\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n*/\nlong numdigits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    else\n        return (long)log10(n) +\
    \ 1;\n}\n/*\nReturn the nth digit of n.\n    >>> nthdigit(12345L, 0)\n    5\n\
    \    >>> nthdigit(12345L, 1)\n    4\n    >>> nthdigit(12345L, 2)\n    3\n    >>>\
    \ nthdigit(12345L, 3)\n    2\n    >>> nthdigit(12345L, 4)\n    1\n    >>> nthdigit(12345L,\
    \ 5)\n    0\n*/\nlong nthdigit(long n, long d) \n{\n    return (n / (long)pow(10,\
    \ d)) % 10;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n*/\nlong numdigits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    else\n        return (long)log10(n) +\
    \ 1;\n}\n/*\nReturn the nth digit of n.\n    >>> nthdigit(12345L, 0)\n    5\n\
    \    >>> nthdigit(12345L,\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgmw0mrzu.d(48): Error: C style cast illegal, use `cast(long)log10(n)`\\\
    n/tmp/tmpgmw0mrzu.d(67): Error: C style cast illegal, use `cast(long)pow(10, d)`\\\
    n/tmp/tmpgmw0mrzu.d(87): Error: C style cast illegal, use `cast(long)log10(n)`\\\
    n/tmp/tmpgmw0mrzu.d(89): Error: unterminated /* */ comment\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgmw0mrzu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * a) % p;\n        }\n        a = (a * a) % p;\n      \
    \  n = n / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n  \
    \      {\n            result = (result * a) % p;\n        }\n        a = (a *\
    \ a) % p;\n        n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn a list\
    \ of the first n primes.\n    >>> primes(0)\n    []\n    >>> primes(1)\n    [2]\n\
    \    >>> primes(2)\n    [2, 3]\n    >>> primes(3)\n    [2, 3, 5]\n    >>> primes(10)\n\
    \    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n*/\nlong[] primes(long n) \n{\n   \
    \ long[] result = new long[n];\n    long i = 0L;\n    long p = 2L;\n    while\
    \ (i < n) \n    {\n        long j = 0L;\n        while (j < i && p % result[j]\
    \ != 0L) \n        {\n            j = j + 1L;\n        }\n        if (j == i)\
    \ \n        {\n            result[i] = p;\n            i = i + 1L;\n        }\n\
    \        p = p + 1L;\n    }\n    return result;\n}\n/*\nReturn the nth prime.\n\
    \    >>> prime(0)\n    2\n    >>> prime(1)\n    3\n    >>> prime(2)\n    5\n \
    \   >>> prime(3)\n    7\n    >>> prime(10)\n    29\n*/\nlong prime(long n) \n\
    {\n    return primes(n + 1L)[n];\n}\n/*\nReturn the nth prime.\n    >>> prime(0)\n\
    \    2\n    >>> prime(1)\n    3\n    >>> prime(2)\n    5\n    >>> prime(3)\n \
    \   7\n    >>> prime(10)\n    29\n*/\nlong prime(long n) \n{\n    return primes(n\
    \ + 1L)[n];\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n /= 2L;\n        if (n > 0L) \n    \
    \    {\n            r = (r * r) % p;\n        }\n    }\n    return r;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpiqjrrq2k.d(39): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e15]\\n??:? void tmpiqjrrq2k.__unittest_L34_C1()\
    \ [0x427abf]\\n??:? void tmpiqjrrq2k.__modtest() [0x427b94]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb3b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb61]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430010]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9a5]\\n??:? runModuleUnitTests [0x42b911]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428264]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281eb]\\n??:? _d_run_main [0x428156]\\n??:? main [0x427ba7]\\\
    n??:? __libc_start_main [0xf0e29554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long r = modp(n >>\
    \ 1, p);\n        r = (r * r) % p;\n        if (n & 1) \n        {\n         \
    \   r = (r * 2) % p;\n        }\n        return r;\n    }\n}\n/*\nReturn the number\
    \ of digits in the decimal representation of n.\n    >>> num_digits(0)\n    1\n\
    \    >>> num_digits(1)\n    1\n    >>> num_digits(10)\n    2\n    >>> num_digits(12345)\n\
    \    5\n    >>> num_digits(10**1000)\n    1001\n*/\nlong num_digits(long n) \n\
    {\n    long num = 1;\n    while (n >= 10) \n    {\n        n /= 10;\n        num++;\n\
    \    }\n    return num;\n}\n/*\nReturn the sum of the digits of n.\n    >>> sum_digits(0)\n\
    \    0\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(10)\n    1\n    >>> sum_digits(12345)\n\
    \    15\n    >>> sum_digits(10**1000)\n    1\n*/\nlong sum_digits(long n) \n{\n\
    \    long sum = 0;\n    while (n > 0) \n    {\n        sum += n % 10;\n      \
    \  n /= 10;\n    }\n    return sum;\n}\n/*\nReturn the sum of the digits of 2^n.\n\
    \    >>> sum_digits_2_to_the(0)\n    2\n    >>> sum_digits_2_to_the(1)\n    4\n\
    \    >>> sum_digits_2_to_the(2)\n    8\n    >>> sum_digits_2_to_the(1000)\n  \
    \  1366\n*/\nlong sum_digits_2_to_the(long n) \n{\n    return sum_digits(modp(n,\
    \ 10000000000L));\n}\n/*\nReturn the sum of the digits of 2\nunittest\n{\n   \
    \ alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp26cjdmnw.d(95): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp26cjdmnw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n     \
    \   {\n            result = (result * power) % 101L;\n        }\n        power\
    \ = (power * power) % 101L;\n        p >>= 1L;\n    }\n    return result;\n}\n\
    /*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(100L)\n    3\n    >>>\
    \ numdigits(123456789L)\n    9\n*/\nlong numdigits(long n) \n{\n    return n ==\
    \ 0L ? 1L : (long) floor(log10(n)) + 1L;\n}\n/*\nReturn the nth digit of n, where\
    \ the rightmost digit is 0.\n    >>> nthdigit(0L, 0L)\n    0\n    >>> nthdigit(0L,\
    \ 1L)\n    0\n    >>> nthdigit(123456789L, 0L)\n    9\n    >>> nthdigit(123456789L,\
    \ 1L)\n    8\n    >>> nthdigit(123456789L, 2L)\n    7\n    >>> nthdigit(123456789L,\
    \ 3L)\n    6\n    >>> nthdigit(123456789L, 4L)\n    5\n    >>> nthdigit(123456789L,\
    \ 5L)\n    4\n    >>> nthdigit(123456789L, 6L)\n    3\n    >>> nthdigit(123456789L,\
    \ 7L)\n    2\n    >>> nthdigit(123456789L, 8L)\n    1\n    >>> nthdigit(123456789L,\
    \ 9L)\n    0\n*/\nlong nthdigit(long n, long d) \n{\n    return (n / (long) pow(10L,\
    \ d)) % 10L;\n}\n/*\nReturn the sum of the digits of n.\n    >>> sumdigits(0L)\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7wtqbupu.d(47): Error: C style cast illegal, use `cast(long)floor(log10(n))`\\\
    n/tmp/tmp7wtqbupu.d(78): Error: C style cast illegal, use `cast(long)pow(10L,\
    \ d)`\\n/tmp/tmp7wtqbupu.d(80): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7wtqbupu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long factor = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L)\
    \ \n        {\n            result = (result * factor) % p;\n        }\n      \
    \  factor = (factor * factor) % p;\n        n /= 2L;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn a list of the digits of n in base b.\n    >>> digits(12345,\
    \ 10)\n    [1, 2, 3, 4, 5]\n    >>> digits(12345, 16)\n    [1, 2, 3, 4, 5]\n \
    \   >>> digits(12345, 8)\n    [1, 2, 3, 4, 5]\n    >>> digits(12345, 2)\n    [1,\
    \ 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1]\n    >>> digits(12345, 3)\n   \
    \ [1, 0, 1, 2, 0, 2, 2]\n    >>> digits(12345, 11)\n    [1, 2, 3, 4, 5]\n    >>>\
    \ digits(12345, 12)\n    [1, 2, 3, 4, 5]\n    >>> digits(12345, 13)\n    [1, 2,\
    \ 3, 4, 5]\n    >>> digits(12345, 14)\n    [1, 2, 3, 4, 5]\n    >>> digits(12345,\
    \ 15)\n    [1, 2, 3, 4, 5]\n    >>> digits(12345, 17)\n    [1, 2, 3, 4, 5]\n \
    \   >>> digits(12345, 18)\n    [1, 2, 3, 4, 5]\n    >>> digits(12345, 19)\n  \
    \  [1, 2, 3, 4, 5]\n    >>> digits(12345, 20)\n    [1, 2, 3, 4, 5]\n    >>> digits(12345,\
    \ 21)\n    [1, 2, 3, 4, 5]\n    >>> digits(12345, 22)\n    [1, 2, 3, 4, 5]\n \
    \   >>> digits(12345, 23)\n    [1, 2, 3, 4\nunittest\n{\n    alias candidate =\
    \ modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L)\
    \ == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L)\
    \ == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppfdhfamc.d(26): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfdhfamc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
